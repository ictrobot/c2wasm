(()=>{var n={428:(n,e,t)=>{"use strict";t.r(e),t.d(e,{AbstractArrayDeclarator:()=>AbstractArrayDeclarator,AbstractFunctionDeclarator:()=>AbstractFunctionDeclarator,AbstractPointerDeclarator:()=>AbstractPointerDeclarator,ArrayDeclarator:()=>ArrayDeclarator,AssignmentExpression:()=>AssignmentExpression,BinaryExpression:()=>BinaryExpression,BinaryOperations:()=>s,BreakStatement:()=>BreakStatement,CaseStatement:()=>CaseStatement,CastExpression:()=>CastExpression,CompoundStatement:()=>CompoundStatement,ConditionalExpression:()=>ConditionalExpression,Constant:()=>Constant,ConstantExpression:()=>ConstantExpression,ContinueStatement:()=>ContinueStatement,CustomTypeSpecifier:()=>CustomTypeSpecifier,Declaration:()=>Declaration,DeclarationSpecifiers:()=>DeclarationSpecifiers,DefaultStatement:()=>DefaultStatement,DoWhileLoop:()=>DoWhileLoop,EnumSpecifier:()=>EnumSpecifier,Enumerator:()=>Enumerator,Expression:()=>Expression,ExpressionStatement:()=>ExpressionStatement,ForLoop:()=>ForLoop,FunctionCallExpression:()=>FunctionCallExpression,FunctionDeclarator:()=>FunctionDeclarator,FunctionDefinition:()=>FunctionDefinition,GotoStatement:()=>GotoStatement,Identifier:()=>Identifier,IdentifierDeclarator:()=>IdentifierDeclarator,IfStatement:()=>IfStatement,InitDeclarator:()=>InitDeclarator,MemberAccessExpression:()=>MemberAccessExpression,NoOp:()=>NoOp,ParameterDeclaration:()=>ParameterDeclaration,ParseNode:()=>ParseNode,Pointer:()=>Pointer,PointerDeclarator:()=>PointerDeclarator,ReturnStatement:()=>ReturnStatement,SizeofExpression:()=>SizeofExpression,SpecifierQualifiers:()=>SpecifierQualifiers,Statement:()=>Statement,StringLiteral:()=>StringLiteral,StructDeclaration:()=>StructDeclaration,StructUnionSpecifier:()=>StructUnionSpecifier,SwitchStatement:()=>SwitchStatement,TypeName:()=>TypeName,UnaryExpression:()=>UnaryExpression,UnaryOperations:()=>i,WhileLoop:()=>WhileLoop});class ParseNode{constructor(n){this.loc=n}*children(){}}class Expression extends ParseNode{constructor(){super(...arguments),this._expression=!0}}class Identifier extends Expression{constructor(n,e){super(n),this.name=e,this.type="identifier"}}class Constant extends Expression{constructor(n,e,t){super(n),this.value=e,this.valueType=t,this.type="constant"}}class StringLiteral extends Expression{constructor(n,e){super(n),this.value=e,this.type="stringLiteral"}}const i=["postfixIncrement","postfixDecrement","prefixIncrement","prefixDecrement","addressOf","dereference","unaryPlus","unaryMinus","bitwiseNot","logicalNot"];class UnaryExpression extends Expression{constructor(n,e,t){super(n),this.type=e,this.body=t,this._unaryExpr=!0}*children(){yield this.body}}const s=["arraySubscript","comma","mul","div","mod","add","sub","bitwiseShiftLeft","bitwiseShiftRight","relationalLT","relationalGT","relationalLEq","relationalGEq","relationalEq","relationalNEq","bitwiseAnd","bitwiseXor","bitwiseOr","logicalAnd","logicalOr"];class BinaryExpression extends Expression{constructor(n,e,t,i){super(n),this.type=e,this.lhs=t,this.rhs=i,this._binaryExpr=!0}*children(){yield this.lhs,yield this.rhs}}class SizeofExpression extends Expression{constructor(n,e){super(n),this.body=e,this.type="sizeof"}*children(){yield this.body}}class CastExpression extends Expression{constructor(n,e,t){super(n),this.targetType=e,this.body=t,this.type="cast"}*children(){yield this.targetType,yield this.body}}class FunctionCallExpression extends Expression{constructor(n,e,t=[]){super(n),this.fn=e,this.args=t,this.type="functionCall"}*children(){yield this.fn,yield*this.args}}class MemberAccessExpression extends Expression{constructor(n,e,t,i){super(n),this.pointer=e,this.lhs=t,this.rhs=i,this.type="access"}*children(){yield this.lhs}}class ConditionalExpression extends Expression{constructor(n,e,t,i){super(n),this.condition=e,this.trueValue=t,this.falseValue=i,this.type="conditional"}*children(){yield this.condition,yield this.trueValue,yield this.falseValue}}class AssignmentExpression extends Expression{constructor(n,e,t,i){super(n),this.assignType=e,this.lhs=t,this.rhs=i,this.type="assign"}*children(){yield this.lhs,yield this.rhs}}class ConstantExpression extends Expression{constructor(n,e){super(n),this.expr=e,this.type="constantExpr"}*children(){yield this.expr}}class CustomTypeSpecifier extends ParseNode{constructor(n,e){super(n),this.name=e,this.type="customType"}}class SpecifierQualifiers extends ParseNode{constructor(n,e,t){super(n),this.specifierList=e,this.qualifierList=t,this.type="specifiersAndQualifiers"}*children(){for(const n of this.specifierList)n instanceof ParseNode&&(yield n)}}class DeclarationSpecifiers extends ParseNode{constructor(n,e,t,i,s){super(n),this.specifierList=e,this.qualifierList=t,this.storageList=i,this.fnSpecifierList=s,this.type="declarationSpecifiers"}*children(){for(const n of this.specifierList)n instanceof ParseNode&&(yield n)}}class EnumSpecifier extends ParseNode{constructor(n,e,t){super(n),this.id=e,this.body=t,this.type="enum"}*children(){this.body&&(yield*this.body)}}class Enumerator extends ParseNode{constructor(n,e,t){super(n),this.id=e,this.value=t,this.type="enumerator"}*children(){this.value&&(yield this.value)}}class Declaration extends ParseNode{constructor(n,e,t=[]){super(n),this.typeInfo=e,this.list=t,this.type="declaration"}*children(){yield this.typeInfo,yield*this.list}}class InitDeclarator extends ParseNode{constructor(n,e,t){super(n),this.body=e,this.initializer=t,this.type="initDeclarator"}*children(){yield this.body,yield*this.exploreInitializer()}*exploreInitializer(n=this.initializer){if(n instanceof AssignmentExpression)yield n;else if(Array.isArray(n))for(const e of n)yield*this.exploreInitializer(e)}}class StructUnionSpecifier extends ParseNode{constructor(n,e,t,i){super(n),this.structure=e,this.id=t,this.declarations=i,this.type="structUnionSpecifier"}*children(){this.declarations&&(yield*this.declarations)}}class StructDeclaration extends ParseNode{constructor(n,e,t=[]){super(n),this.typeInfo=e,this.list=t,this.type="structDeclaration"}*children(){yield this.typeInfo,yield*this.list}}class PointerDeclarator extends ParseNode{constructor(n,e,t){super(n),this.pointer=e,this.body=t,this.type="pointerDeclarator",this.abstractDeclarator=!1}*children(){yield this.pointer,yield this.body}}class IdentifierDeclarator extends ParseNode{constructor(n,e){super(n),this.id=e,this.type="identifierDeclarator",this.abstractDeclarator=!1}}class ArrayDeclarator extends ParseNode{constructor(n,e,t){super(n),this.body=e,this.length=t,this.type="arrayDeclarator",this.abstractDeclarator=!1}*children(){yield this.body,this.length&&(yield this.length)}}class FunctionDeclarator extends ParseNode{constructor(n,e,t,i=!1){super(n),this.body=e,this.args=t,this.variadic=i,this.type="functionDeclarator",this.abstractDeclarator=!1}*children(){yield this.body;for(const n of this.args??[])n instanceof ParseNode&&(yield n)}}class ParameterDeclaration extends ParseNode{constructor(n,e,t){super(n),this.typeInfo=e,this.declarator=t,this.type="parameterDeclaration"}*children(){yield this.typeInfo,this.declarator&&(yield this.declarator)}}class Pointer extends ParseNode{constructor(n,e,t){super(n),this.qualifierList=e,this.body=t,this.type="pointer"}*children(){this.body&&(yield this.body)}}class TypeName extends ParseNode{constructor(n,e,t){super(n),this.typeInfo=e,this.declarator=t,this.type="typeName"}*children(){yield this.typeInfo,this.declarator&&(yield this.declarator)}}class AbstractPointerDeclarator extends ParseNode{constructor(n,e,t){super(n),this.pointer=e,this.body=t,this.type="abstractPointerDeclarator",this.abstractDeclarator=!0}*children(){yield this.pointer,this.body&&(yield this.body)}}class AbstractArrayDeclarator extends ParseNode{constructor(n,e,t){super(n),this.body=e,this.length=t,this.type="abstractArrayDeclarator",this.abstractDeclarator=!0}*children(){this.body&&(yield this.body),this.length&&(yield this.length)}}class AbstractFunctionDeclarator extends ParseNode{constructor(n,e,t,i=!1){super(n),this.body=e,this.args=t,this.variadic=i,this.type="abstractFunctionDeclarator",this.abstractDeclarator=!0}*children(){this.body&&(yield this.body),this.args&&(yield*this.args)}}class Statement extends ParseNode{constructor(){super(...arguments),this._statement=!0}setLabel(n){return this.label=n,this}}class IfStatement extends Statement{constructor(n,e,t,i){super(n),this.expression=e,this.ifBody=t,this.elseBody=i,this.type="ifStatement"}*children(){yield this.expression,yield this.ifBody,this.elseBody&&(yield this.elseBody)}}class SwitchStatement extends Statement{constructor(n,e,t){super(n),this.expression=e,this.body=t,this.type="switchStatement"}*children(){yield this.expression,yield this.body}}class CaseStatement extends Statement{constructor(n,e,t){super(n),this.value=e,this.body=t,this.type="caseStatement"}*children(){yield this.value,yield this.body}}class DefaultStatement extends Statement{constructor(n,e){super(n),this.body=e,this.type="defaultStatement"}*children(){yield this.body}}class CompoundStatement extends Statement{constructor(n,e){super(n),this.body=e,this.type="compoundStatement"}*children(){yield*this.body}}class ExpressionStatement extends Statement{constructor(n,e){super(n),this.expression=e,this.type="expressionStatement"}*children(){yield this.expression}}class NoOp extends Statement{constructor(n){super(n),this.type="nopStatement"}}class ForLoop extends Statement{constructor(n,e,t,i,s){super(n),this.init=e,this.test=t,this.update=i,this.body=s,this.type="forStatement"}*children(){yield this.init,yield this.test,this.update&&(yield this.update),yield this.body}}class WhileLoop extends Statement{constructor(n,e,t){super(n),this.test=e,this.body=t,this.type="whileStatement"}*children(){yield this.test,yield this.body}}class DoWhileLoop extends Statement{constructor(n,e,t){super(n),this.body=e,this.test=t,this.type="doWhileStatement"}*children(){yield this.body,yield this.test}}class GotoStatement extends Statement{constructor(n,e){super(n),this.target=e,this.type="gotoStatement"}}class ContinueStatement extends Statement{constructor(){super(...arguments),this.type="continueStatement"}}class BreakStatement extends Statement{constructor(){super(...arguments),this.type="breakStatement"}}class ReturnStatement extends Statement{constructor(n,e){super(n),this.value=e,this.type="returnStatement"}*children(){this.value&&(yield this.value)}}class FunctionDefinition extends ParseNode{constructor(n,e,t,i){super(n),this.typeInfo=e,this.declarator=t,this.body=i,this.type="functionDefinition"}*children(){yield this.typeInfo,yield this.declarator,yield this.body}}},347:(n,e,t)=>{var i=function(){function n(n,e){var t;if(Object.defineProperty(this,"name",{enumerable:!1,writable:!1,value:"JisonParserError"}),null==n&&(n="???"),Object.defineProperty(this,"message",{enumerable:!1,writable:!0,value:n}),this.hash=e,e&&e.exception instanceof Error){var i=e.exception;this.message=i.message||n,t=i.stack}t||(Error.hasOwnProperty("captureStackTrace")?Error.captureStackTrace(this,this.constructor):t=new Error(n).stack),t&&Object.defineProperty(this,"stack",{enumerable:!1,writable:!1,value:t})}function e(n,e,t){t=t||0;for(var i=0;i<e;i++)this.push(n),n+=t}function i(n,e){for(e+=n=this.length-n;n<e;n++)this.push(this[n])}function s(n){for(var e=[],t=0,i=n.length;t<i;t++){var s=n[t];"function"==typeof s?(t++,s.apply(e,n[t])):e.push(s)}return e}"function"==typeof Object.setPrototypeOf?Object.setPrototypeOf(n.prototype,Error.prototype):n.prototype=Object.create(Error.prototype),n.prototype.constructor=n,n.prototype.name="JisonParserError";var r={trace:function(){},JisonParserError:n,yy:{},options:{type:"lalr",hasPartialLrUpgradeOnConflict:!0,errorRecoveryTokenDiscardCount:3},symbols_:{"!":14,"!=":43,$accept:0,$end:1,"%":16,"%=":48,"&":9,"&&":44,"&=":53,"(":3,")":4,"*":10,"*=":46,"+":11,"++":35,"+=":49,",":8,"-":12,"--":36,"-=":50,"->":34,".":7,"...":76,"/":15,"/=":47,":":22,";":24,"<":17,"<<":38,"<<=":51,"<=":40,"=":23,"==":42,">":18,">=":41,">>":39,">>=":52,"?":21,BREAK:87,CASE:77,CHAR:60,CONST:73,CONSTANT_CHAR:32,CONSTANT_FLOAT:28,CONSTANT_HEX:29,CONSTANT_INT:31,CONSTANT_OCTAL:30,CONTINUE:86,DEFAULT:78,DO:83,DOUBLE:65,ELSE:80,ENUM:72,EOF:1,EXTERN:57,FLOAT:64,FOR:84,GOTO:85,IDENTIFIER:27,IF:79,IMPORT:75,INLINE:74,INT:62,LONG:63,RETURN:88,SHORT:61,SIGNED:66,SIZEOF:37,STATIC:58,STRING_LITERAL:33,STRUCT:70,SWITCH:81,TYPEDEF:56,TYPE_NAME:69,UNION:71,UNSIGNED:67,VOID:59,WHILE:82,"[":5,"]":6,"^":19,"^=":54,_BOOL:68,abstract_declarator:141,additive_expression:101,and_expression:105,argument_expression_list:96,assignment_expression:111,assignment_operator:112,ast_tree:89,block_item:149,block_item_list:148,cast_expression:99,compound_statement:147,concat_string_literals:93,conditional_expression:110,constant:91,constant_expression:114,declaration:115,declaration_specifiers:116,declarator:133,direct_abstract_declarator:142,direct_declarator:134,enum_specifier:128,enumerator:130,enumerator_list:129,equality_expression:104,error:2,exclusive_or_expression:106,expression:113,expression_statement:150,external_declaration:155,function_definition:156,function_specifier:132,identifier:90,inclusive_or_expression:107,init_declarator:118,init_declarator_list:117,initializer:143,initializer_list:144,iteration_statement:152,jump_statement:153,labeled_statement:146,logical_and_expression:108,logical_or_expression:109,multiplicative_expression:100,parameter_declaration:139,parameter_list:138,parameter_type_list:137,pointer:135,postfix_expression:95,primary_expression:94,relational_expression:103,selection_statement:151,shift_expression:102,specifier_qualifier_list:125,statement:145,storage_class_specifier:119,string_literal:92,struct_declaration:124,struct_declaration_list:123,struct_declarator:127,struct_declarator_list:126,struct_or_union:122,struct_or_union_specifier:121,translation_unit:154,type_name:140,type_qualifier:131,type_qualifier_list:136,type_specifier:120,unary_expression:97,unary_operator:98,"{":25,"|":20,"|=":55,"||":45,"}":26,"~":13},terminals_:{1:"EOF",2:"error",3:"(",4:")",5:"[",6:"]",7:".",8:",",9:"&",10:"*",11:"+",12:"-",13:"~",14:"!",15:"/",16:"%",17:"<",18:">",19:"^",20:"|",21:"?",22:":",23:"=",24:";",25:"{",26:"}",27:"IDENTIFIER",28:"CONSTANT_FLOAT",29:"CONSTANT_HEX",30:"CONSTANT_OCTAL",31:"CONSTANT_INT",32:"CONSTANT_CHAR",33:"STRING_LITERAL",34:"->",35:"++",36:"--",37:"SIZEOF",38:"<<",39:">>",40:"<=",41:">=",42:"==",43:"!=",44:"&&",45:"||",46:"*=",47:"/=",48:"%=",49:"+=",50:"-=",51:"<<=",52:">>=",53:"&=",54:"^=",55:"|=",56:"TYPEDEF",57:"EXTERN",58:"STATIC",59:"VOID",60:"CHAR",61:"SHORT",62:"INT",63:"LONG",64:"FLOAT",65:"DOUBLE",66:"SIGNED",67:"UNSIGNED",68:"_BOOL",69:"TYPE_NAME",70:"STRUCT",71:"UNION",72:"ENUM",73:"CONST",74:"INLINE",75:"IMPORT",76:"...",77:"CASE",78:"DEFAULT",79:"IF",80:"ELSE",81:"SWITCH",82:"WHILE",83:"DO",84:"FOR",85:"GOTO",86:"CONTINUE",87:"BREAK",88:"RETURN"},TERROR:2,EOF:1,originalQuoteName:null,originalParseError:null,cleanupAfterParse:null,constructParseErrorInfo:null,yyMergeLocationInfo:null,__reentrant_call_depth:0,__error_infos:[],__error_recovery_infos:[],quoteName:function(n){return'"'+n+'"'},getSymbolName:function(n){if(this.terminals_[n])return this.terminals_[n];var e=this.symbols_;for(var t in e)if(e[t]===n)return t;return null},describeSymbol:function(n){if(n!==this.EOF&&this.terminal_descriptions_&&this.terminal_descriptions_[n])return this.terminal_descriptions_[n];if(n===this.EOF)return"end of input";var e=this.getSymbolName(n);return e?this.quoteName(e):null},collect_expected_token_set:function(n,e){var t=this.TERROR,i=[],s={};if(!e&&this.state_descriptions_&&this.state_descriptions_[n])return[this.state_descriptions_[n]];for(var r in this.table[n])if((r=+r)!==t){var a=e?r:this.describeSymbol(r);a&&!s[a]&&(i.push(a),s[a]=!0)}return i},productions_:function(n){for(var e=[],t=n.pop,i=n.rule,s=0,r=t.length;s<r;s++)e.push([t[s],i[s]]);return e}({pop:s([89,89,90,e,[91,5],92,93,93,e,[94,4],e,[95,8],96,96,e,[97,6],e,[98,6],99,99,e,[100,4],e,[101,3],e,[102,3],e,[103,5],e,[104,3],105,105,106,106,107,107,108,108,109,109,110,110,111,111,e,[112,11],113,113,114,115,115,e,[116,8],117,117,118,118,e,[119,3],e,[120,13],e,[121,3],122,122,123,123,124,e,[125,4],126,126,127,e,[128,5],129,129,130,130,131,132,132,133,133,e,[134,6],e,[135,4],136,136,137,137,138,138,e,[139,3],140,140,e,[141,3],e,[142,9],e,[143,3],144,144,e,[145,6],e,[146,3],147,147,148,148,149,149,150,150,e,[151,3],e,[152,6],e,[153,5],154,154,155,155,156]),rule:s([2,e,[1,9],i,[10,4],3,1,4,3,4,3,3,2,2,i,[10,3],e,[2,4],4,e,[1,7],4,1,e,[3,3],i,[4,3],i,[3,6],i,[8,7],i,[36,3],i,[4,6],5,i,[4,3],e,[1,11],i,[59,3],i,[3,3],i,[80,3],i,[4,4],i,[32,4],e,[1,15],5,4,i,[107,4],2,3,i,[31,4],i,[114,4],5,5,6,i,[40,8],i,[17,4],i,[130,4],i,[125,3],i,[67,4],i,[21,3],i,[139,3],i,[22,4],i,[46,3],3,3,4,i,[4,4],i,[33,3],i,[83,8],i,[41,3],i,[39,5],i,[31,3],5,7,5,5,7,6,7,6,7,i,[49,3],i,[20,6],3])}),performAction:function(n,e,t,i,s,r){var o=this.yy,c=o.parser,f=o.lexer;switch(t){case 0:this.$=void 0,this._$=r[i-1];break;case 1:return this.$=void 0,this._$=c.yyMergeLocationInfo(i-1,i),s[i-1];case 2:return this.$=void 0,this._$=r[i],[];case 3:case 9:case 100:case 101:case 102:case 103:case 104:case 105:case 106:case 107:case 108:case 109:case 110:case 111:case 142:this._$=r[i],this.$=n;break;case 4:this._$=r[i],this.$=new a.Constant(this._$,n,"float");break;case 5:this._$=r[i],this.$=new a.Constant(this._$,n,"hex");break;case 6:this._$=r[i],this.$=new a.Constant(this._$,n,"oct");break;case 7:this._$=r[i],this.$=new a.Constant(this._$,n,"int");break;case 8:this._$=r[i],this.$=new a.Constant(this._$,n,"char");break;case 10:case 13:case 16:case 26:case 38:case 40:case 44:case 47:case 50:case 55:case 58:case 60:case 62:case 64:case 66:case 68:case 70:case 83:case 98:case 113:case 114:case 130:case 144:case 167:case 178:case 183:case 184:case 185:case 186:case 187:case 188:case 196:case 197:case 216:this._$=r[i],this.$=s[i];break;case 11:this._$=c.yyMergeLocationInfo(i-1,i),this.$=s[i-1]+s[i];break;case 12:this._$=r[i],this.$=new a.Identifier(this._$,n);break;case 14:this._$=r[i],this.$=new a.StringLiteral(this._$,s[i]);break;case 15:case 146:case 169:case 179:this._$=c.yyMergeLocationInfo(i-2,i),this.$=s[i-1];break;case 17:this._$=c.yyMergeLocationInfo(i-3,i),this.$=new a.BinaryExpression(this._$,"arraySubscript",s[i-3],s[i-1]);break;case 18:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.FunctionCallExpression(this._$,s[i-2]);break;case 19:this._$=c.yyMergeLocationInfo(i-3,i),this.$=new a.FunctionCallExpression(this._$,s[i-3],s[i-1]);break;case 20:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.MemberAccessExpression(this._$,!1,s[i-2],s[i]);break;case 21:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.MemberAccessExpression(this._$,!0,s[i-2],s[i]);break;case 22:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new a.UnaryExpression(this._$,"postfixIncrement",s[i-1]);break;case 23:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new a.UnaryExpression(this._$,"postfixDecrement",s[i-1]);break;case 24:case 96:case 121:case 128:case 136:case 155:case 159:case 181:case 194:case 214:this._$=r[i],this.$=[s[i]];break;case 25:case 97:case 129:case 137:case 160:case 182:this._$=c.yyMergeLocationInfo(i-2,i),this.$=(s[i-2].push(s[i]),s[i-2]);break;case 27:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new a.UnaryExpression(this._$,"prefixIncrement",s[i]);break;case 28:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new a.UnaryExpression(this._$,"prefixDecrement",s[i]);break;case 29:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new a.UnaryExpression(this._$,s[i-1],s[i]);break;case 30:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new a.SizeofExpression(this._$,s[i]);break;case 31:this._$=c.yyMergeLocationInfo(i-3,i),this.$=new a.SizeofExpression(this._$,s[i-1]);break;case 32:this._$=r[i],this.$="addressOf";break;case 33:this._$=r[i],this.$="dereference";break;case 34:this._$=r[i],this.$="unaryPlus";break;case 35:this._$=r[i],this.$="unaryMinus";break;case 36:this._$=r[i],this.$="bitwiseNot";break;case 37:this._$=r[i],this.$="logicalNot";break;case 39:this._$=c.yyMergeLocationInfo(i-3,i),this.$=new a.CastExpression(this._$,s[i-2],s[i]);break;case 41:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.BinaryExpression(this._$,"mul",s[i-2],s[i]);break;case 42:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.BinaryExpression(this._$,"div",s[i-2],s[i]);break;case 43:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.BinaryExpression(this._$,"mod",s[i-2],s[i]);break;case 45:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.BinaryExpression(this._$,"add",s[i-2],s[i]);break;case 46:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.BinaryExpression(this._$,"sub",s[i-2],s[i]);break;case 48:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.BinaryExpression(this._$,"bitwiseShiftLeft",s[i-2],s[i]);break;case 49:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.BinaryExpression(this._$,"bitwiseShiftRight",s[i-2],s[i]);break;case 51:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.BinaryExpression(this._$,"relationalLT",s[i-2],s[i]);break;case 52:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.BinaryExpression(this._$,"relationalGT",s[i-2],s[i]);break;case 53:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.BinaryExpression(this._$,"relationalLEq",s[i-2],s[i]);break;case 54:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.BinaryExpression(this._$,"relationalGEq",s[i-2],s[i]);break;case 56:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.BinaryExpression(this._$,"relationalEq",s[i-2],s[i]);break;case 57:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.BinaryExpression(this._$,"relationalNEq",s[i-2],s[i]);break;case 59:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.BinaryExpression(this._$,"bitwiseAnd",s[i-2],s[i]);break;case 61:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.BinaryExpression(this._$,"bitwiseXor",s[i-2],s[i]);break;case 63:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.BinaryExpression(this._$,"bitwiseOr",s[i-2],s[i]);break;case 65:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.BinaryExpression(this._$,"logicalAnd",s[i-2],s[i]);break;case 67:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.BinaryExpression(this._$,"logicalOr",s[i-2],s[i]);break;case 69:this._$=c.yyMergeLocationInfo(i-4,i),this.$=new a.ConditionalExpression(this._$,s[i-4],s[i-2],s[i]);break;case 71:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.AssignmentExpression(this._$,s[i-1],s[i-2],s[i]);break;case 72:this._$=r[i],this.$=void 0;break;case 73:this._$=r[i],this.$="mul";break;case 74:this._$=r[i],this.$="div";break;case 75:this._$=r[i],this.$="mod";break;case 76:this._$=r[i],this.$="add";break;case 77:this._$=r[i],this.$="sub";break;case 78:this._$=r[i],this.$="leftShift";break;case 79:this._$=r[i],this.$="rightShift";break;case 80:this._$=r[i],this.$="bitwiseAnd";break;case 81:this._$=r[i],this.$="bitwiseXor";break;case 82:this._$=r[i],this.$="bitwiseOr";break;case 84:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.BinaryExpression(this._$,"comma",s[i-2],s[i]);break;case 85:this._$=r[i],this.$=new a.ConstantExpression(this._$,s[i]);break;case 86:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new a.Declaration(this._$,s[i-1]);break;case 87:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.Declaration(this._$,s[i-2],s[i-1]);break;case 88:this._$=r[i],this.$=new a.DeclarationSpecifiers(this._$,[],[],[s[i]],[]);break;case 89:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new a.DeclarationSpecifiers(this._$,s[i].specifierList,s[i].qualifierList,[s[i-1],...s[i].storageList],s[i].fnSpecifierList);break;case 90:this._$=r[i],this.$=new a.DeclarationSpecifiers(this._$,[s[i]],[],[],[]);break;case 91:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new a.DeclarationSpecifiers(this._$,[s[i-1],...s[i].specifierList],s[i].qualifierList,s[i].storageList,s[i].fnSpecifierList);break;case 92:this._$=r[i],this.$=new a.DeclarationSpecifiers(this._$,[],[s[i]],[],[]);break;case 93:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new a.DeclarationSpecifiers(this._$,s[i].specifierList,[s[i-1],...s[i].qualifierList],s[i].storageList,s[i].fnSpecifierList);break;case 94:this._$=r[i],this.$=new a.DeclarationSpecifiers(this._$,[],[],[],[s[i]]);break;case 95:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new a.DeclarationSpecifiers(this._$,s[i].specifierList,s[i].qualifierList,s[i].storageList,[s[i-1],...s[i].fnSpecifierList]);break;case 99:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.InitDeclarator(this._$,s[i-2],s[i]);break;case 112:this._$=r[i],this.$="bool";break;case 115:this._$=r[i],this.$=new a.CustomTypeSpecifier(this._$,s[i]);break;case 116:this._$=c.yyMergeLocationInfo(i-4,i),this.$=new a.StructUnionSpecifier(this._$,s[i-4],s[i-3],s[i-1]);break;case 117:this._$=c.yyMergeLocationInfo(i-3,i),this.$=new a.StructUnionSpecifier(this._$,s[i-3],void 0,s[i-1]);break;case 118:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new a.StructUnionSpecifier(this._$,s[i-1],s[i]);break;case 119:this._$=r[i],this.$="struct";break;case 120:this._$=r[i],this.$="union";break;case 122:case 156:case 195:case 215:this._$=c.yyMergeLocationInfo(i-1,i),this.$=(s[i-1].push(s[i]),s[i-1]);break;case 123:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.StructDeclaration(this._$,s[i-2],s[i-1]);break;case 124:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new a.SpecifierQualifiers(this._$,[s[i-1],...s[i].specifierList],s[i].qualifierList);break;case 125:this._$=r[i],this.$=new a.SpecifierQualifiers(this._$,[s[i]],[]);break;case 126:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new a.SpecifierQualifiers(this._$,s[i].specifierList,[s[i-1],...s[i].qualifierList]);break;case 127:this._$=r[i],this.$=new a.SpecifierQualifiers(this._$,[],[s[i]]);break;case 131:this._$=c.yyMergeLocationInfo(i-3,i),this.$=new a.EnumSpecifier(this._$,void 0,s[i-1]);break;case 132:this._$=c.yyMergeLocationInfo(i-4,i),this.$=new a.EnumSpecifier(this._$,s[i-3],s[i-1]);break;case 133:this._$=c.yyMergeLocationInfo(i-4,i),this.$=new a.EnumSpecifier(this._$,void 0,s[i-2]);break;case 134:this._$=c.yyMergeLocationInfo(i-5,i),this.$=new a.EnumSpecifier(this._$,s[i-4],s[i-2]);break;case 135:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new a.EnumSpecifier(this._$,s[i]);break;case 138:this._$=r[i],this.$=new a.Enumerator(this._$,s[i]);break;case 139:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.Enumerator(this._$,s[i-2],s[i]);break;case 140:this._$=r[i],this.$="const";break;case 141:this._$=r[i],this.$="inline";break;case 143:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new a.PointerDeclarator(this._$,s[i-1],s[i]);break;case 145:this._$=r[i],this.$=new a.IdentifierDeclarator(this._$,s[i]);break;case 147:this._$=c.yyMergeLocationInfo(i-3,i),this.$=new a.ArrayDeclarator(this._$,s[i-3],s[i-1]);break;case 148:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.ArrayDeclarator(this._$,s[i-2]);break;case 149:this._$=c.yyMergeLocationInfo(i-3,i),this.$=new a.FunctionDeclarator(this._$,s[i-3],s[i-1],s[i-1].variadic);break;case 150:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.FunctionDeclarator(this._$,s[i-2]);break;case 151:this._$=r[i],this.$=new a.Pointer(this._$);break;case 152:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new a.Pointer(this._$,s[i]);break;case 153:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new a.Pointer(this._$,void 0,s[i]);break;case 154:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.Pointer(this._$,s[i-1],s[i]);break;case 157:this._$=r[i],this.$=(s[i].variadic=!1,s[i]);break;case 158:this._$=c.yyMergeLocationInfo(i-2,i),this.$=(s[i-2].variadic=!0,s[i-2]);break;case 161:case 162:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new a.ParameterDeclaration(this._$,s[i-1],s[i]);break;case 163:this._$=r[i],this.$=new a.ParameterDeclaration(this._$,s[i]);break;case 164:this._$=r[i],this.$=new a.TypeName(this._$,s[i]);break;case 165:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new a.TypeName(this._$,s[i-1],s[i]);break;case 166:this._$=r[i],this.$=new a.AbstractPointerDeclarator(this._$,s[i]);break;case 168:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new a.AbstractPointerDeclarator(this._$,s[i-1],s[i]);break;case 170:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new a.AbstractArrayDeclarator(this._$);break;case 171:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.AbstractArrayDeclarator(this._$,void 0,s[i-1]);break;case 172:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.AbstractArrayDeclarator(this._$,s[i-2]);break;case 173:this._$=c.yyMergeLocationInfo(i-3,i),this.$=new a.AbstractArrayDeclarator(this._$,s[i-3],s[i-1]);break;case 174:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new a.AbstractFunctionDeclarator(this._$);break;case 175:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.AbstractFunctionDeclarator(this._$,void 0,s[i-1],s[i-1].variadic);break;case 176:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.AbstractFunctionDeclarator(this._$,s[i-2]);break;case 177:this._$=c.yyMergeLocationInfo(i-3,i),this.$=new a.AbstractFunctionDeclarator(this._$,s[i-3],s[i-1],s[i-1].variadic);break;case 180:this._$=c.yyMergeLocationInfo(i-3,i),this.$=s[i-2];break;case 189:this._$=c.yyMergeLocationInfo(i-2,i),this.$=s[i].setLabel(s[i-2]);break;case 190:this._$=c.yyMergeLocationInfo(i-3,i),this.$=new a.CaseStatement(this._$,s[i-2],s[i]);break;case 191:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.DefaultStatement(this._$,s[i]);break;case 192:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new a.CompoundStatement(this._$,[]);break;case 193:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.CompoundStatement(this._$,s[i-1]);break;case 198:this._$=r[i],this.$=new a.NoOp(this._$);break;case 199:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new a.ExpressionStatement(this._$,s[i-1]);break;case 200:this._$=c.yyMergeLocationInfo(i-4,i),this.$=new a.IfStatement(this._$,s[i-2],s[i]);break;case 201:this._$=c.yyMergeLocationInfo(i-6,i),this.$=new a.IfStatement(this._$,s[i-4],s[i-2],s[i]);break;case 202:this._$=c.yyMergeLocationInfo(i-4,i),this.$=new a.SwitchStatement(this._$,s[i-2],s[i]);break;case 203:this._$=c.yyMergeLocationInfo(i-4,i),this.$=new a.WhileLoop(this._$,s[i-2],s[i]);break;case 204:this._$=c.yyMergeLocationInfo(i-6,i),this.$=new a.DoWhileLoop(this._$,s[i-5],s[i-2]);break;case 205:case 207:this._$=c.yyMergeLocationInfo(i-5,i),this.$=new a.ForLoop(this._$,s[i-3],s[i-2],void 0,s[i]);break;case 206:case 208:this._$=c.yyMergeLocationInfo(i-6,i),this.$=new a.ForLoop(this._$,s[i-4],s[i-3],s[i-2],s[i]);break;case 209:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.GotoStatement(this._$,s[i-1]);break;case 210:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new a.ContinueStatement(this._$);break;case 211:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new a.BreakStatement(this._$);break;case 212:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new a.ReturnStatement(this._$);break;case 213:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.ReturnStatement(this._$,s[i-1]);break;case 217:this._$=r[i],this.$=(f.externalDeclaration(s[i]),s[i]);break;case 218:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.FunctionDefinition(this._$,s[i-2],s[i-1],s[i])}},table:function(n){for(var e=[],t=n.len,i=n.symbol,s=n.type,r=n.state,a=n.mode,o=n.goto,c=0,f=t.length;c<f;c++){for(var l=t[c],h={},d=0;d<l;d++){var _=i.shift();switch(s.shift()){case 2:h[_]=[a.shift(),o.shift()];break;case 0:h[_]=r.shift();break;default:h[_]=[3]}}e.push(h)}return e}({len:s([34,1,32,e,[0,4],10,e,[35,4],e,[0,19],3,3,e,[0,4],5,0,2,4,7,0,10,0,7,e,[0,5],28,23,4,28,0,40,91,0,8,7,39,32,9,0,0,1,23,23,0,9,26,26,2,0,3,4,0,0,41,0,37,8,42,25,25,26,25,i,[25,3],e,[0,5],10,0,0,44,61,11,e,[0,6],12,0,14,18,20,22,25,0,0,90,i,[25,6],e,[0,4],39,38,1,0,2,e,[1,3],59,1,i,[6,3],40,i,[113,3],1,e,[0,3],i,[19,3],i,[45,3],0,0,23,0,i,[9,3],e,[0,4],4,38,2,2,0,38,e,[0,11],39,35,39,40,i,[19,3],i,[9,3],e,[0,3],61,34,33,i,[68,3],7,32,31,30,30,e,[29,4],28,28,27,27,e,[26,3],0,0,59,1,59,0,38,e,[39,3],1,70,i,[85,4],i,[46,3],30,0,0,8,4,42,i,[51,3],8,i,[85,5],i,[174,3],2,9,2,i,[99,5],1,10,11,0,26,i,[103,3],12,14,18,18,e,[20,4],22,22,25,i,[168,3],i,[67,3],i,[56,3],2,2,1,41,41,i,[49,5],39,32,1,i,[156,3],i,[77,4],0,37,0,i,[144,5],e,[59,3],39,40,40,i,[21,8],0,52,i,[47,3],59,2,59,i,[82,3],59,1,i,[60,3],i,[62,3],0,0]),symbol:s([1,e,[56,20,1],89,115,116,e,[119,4,1],128,131,132,154,155,156,1,i,[35,21],i,[34,9],155,156,3,10,24,27,90,117,118,133,134,135,3,4,5,8,i,[13,3],i,[48,20],i,[47,8],i,[35,105],25,27,90,i,[3,3],8,23,24,25,147,8,24,3,27,90,134,i,[52,4],i,[14,3],i,[59,5],27,73,131,135,136,3,10,27,90,i,[181,9],25,i,[77,21],i,[17,15],e,[120,6,1],128,131,27,90,129,130,i,[55,28],3,e,[9,6,1],25,e,[27,7,1],35,36,37,e,[90,6,1],e,[97,15,1],143,i,[40,7],e,[24,10,1],i,[42,3],i,[80,20],77,78,79,e,[81,8,1],i,[73,21],113,i,[398,9],e,[145,9,1],i,[221,4],i,[403,8],i,[246,4],6,i,[107,6],i,[146,30],114,4,i,[338,28],137,138,139,i,[317,9],4,i,[282,23],26,i,[24,18],i,[23,4],i,[142,4],126,127,i,[143,6],10,27,i,[36,18],i,[35,4],i,[26,25],8,26,8,23,26,i,[371,5],i,[343,39],144,4,6,e,[8,5,1],e,[15,10,1],26,e,[38,18,1],112,i,[37,3],21,22,24,26,45,e,[3,10,1],i,[48,11],34,35,36,i,[51,18],i,[128,7],i,[127,18],i,[25,50],99,i,[26,25],i,[151,7],44,45,i,[9,3],i,[140,3],i,[10,4],i,[162,21],e,[33,4,1],i,[163,18],92,i,[88,17],i,[339,15],i,[576,22],i,[361,6],140,i,[115,3],i,[94,4],i,[126,7],9,i,[12,18],i,[109,4],i,[14,4],i,[134,6],24,26,i,[127,6],i,[18,12],i,[147,8],i,[20,4],11,12,i,[22,20],i,[199,11],i,[25,10],i,[778,85],i,[777,7],i,[1182,9],5,i,[325,16],i,[486,46],i,[810,13],22,i,[1109,3],e,[3,3],i,[183,8],i,[46,10],i,[162,33],i,[153,3],i,[152,5],27,90,24,24,i,[64,8],i,[722,31],113,i,[963,3],6,4,4,8,i,[895,6],i,[1205,4],141,142,i,[874,23],8,24,i,[811,3],i,[810,8],i,[196,31],i,[857,3],26,i,[42,37],111,i,[38,38],113,i,[39,35],i,[74,40],4,i,[40,22],e,[96,16,1],27,90,27,90,i,[157,56],i,[794,44],i,[100,34],i,[34,33],4,8,4,i,[1252,4],i,[443,3],i,[43,32],i,[32,31],i,[31,30],i,[30,59],i,[29,115],i,[28,55],i,[27,53],i,[26,59],i,[993,52],22,i,[1053,60],i,[918,111],i,[39,43],82,i,[1204,18],i,[1449,20],i,[1438,31],150,24,8,24,e,[56,21,1],i,[33,8],i,[2155,5],i,[2486,3],142,i,[8,4],i,[2076,5],i,[102,21],i,[47,8],i,[1299,3],i,[2207,3],i,[859,3],i,[2280,38],i,[2192,4],i,[2191,4],i,[1324,11],i,[1658,12],i,[2135,22],8,22,i,[1948,9],6,8,i,[974,3],i,[1953,10],i,[1848,11],i,[587,27],4,5,i,[205,4],10,i,[2403,28],i,[197,6],i,[1916,56],i,[1934,30],i,[20,60],i,[1994,22],i,[2016,43],i,[2041,34],i,[805,50],i,[387,3],i,[391,3],i,[1924,9],i,[697,32],150,i,[41,42],i,[627,4],i,[2865,70],i,[549,3],i,[856,37],i,[1009,45],i,[1106,59],i,[59,118],i,[2030,56],i,[40,56],6,4,i,[2640,43],e,[80,9,1],i,[588,3],i,[653,60],i,[61,120],i,[2629,9],i,[475,110]]),type:s([e,[2,21],e,[0,13],1,i,[35,32],i,[15,10],e,[2,27],i,[45,12],i,[35,103],i,[3,6],i,[5,8],i,[52,15],i,[69,6],i,[76,31],i,[92,25],i,[55,46],i,[338,16],i,[314,13],e,[2,47],e,[0,40],i,[43,8],i,[73,46],i,[491,36],i,[333,19],i,[409,26],i,[142,15],i,[97,21],i,[26,38],i,[35,21],i,[253,26],i,[329,34],e,[2,67],i,[112,25],i,[25,33],i,[51,43],i,[146,46],i,[576,61],e,[2,173],i,[777,42],i,[1182,34],i,[105,50],i,[162,65],i,[428,23],i,[409,35],i,[874,32],i,[927,19],i,[1006,54],i,[42,27],i,[576,39],i,[74,74],i,[40,24],i,[1420,3],i,[1389,71],i,[794,46],i,[34,50],i,[1657,13],i,[43,29],i,[32,31],i,[31,30],i,[30,59],i,[29,115],i,[28,55],i,[27,53],i,[26,69],i,[1357,73],i,[623,63],i,[918,78],i,[922,61],i,[1438,53],i,[56,33],i,[2037,26],i,[902,45],i,[314,25],i,[1413,8],i,[97,20],i,[1822,76],i,[116,13],i,[200,38],e,[2,266],i,[865,54],i,[48,41],i,[89,45],i,[2865,60],i,[73,33],i,[2165,68],i,[1166,59],i,[59,105],i,[2030,63],i,[938,93],i,[2875,93],i,[61,121],i,[475,88]]),state:s([1,e,[6,4,1],25,31,26,10,11,2,e,[4,6,1],i,[12,5],36,5,44,39,42,37,41,40,47,i,[16,7],48,i,[8,7],49,i,[8,7],50,i,[8,7],51,54,55,44,60,65,64,63,44,66,41,40,71,25,31,68,69,70,26,72,75,73,74,97,98,107,99,89,83,81,86,e,[115,6,-1],108,101,96,88,82,80,78,77,128,i,[22,19],142,132,119,121,i,[76,7],120,122,123,117,118,e,[124,4,1],44,143,144,41,40,i,[67,6],148,i,[45,12],147,145,153,i,[43,7],149,151,152,155,154,i,[112,3],157,i,[112,4],i,[8,3],159,i,[7,3],44,160,161,162,i,[133,5],163,i,[19,5],164,i,[137,3],168,i,[137,22],170,169,171,i,[24,6],191,86,i,[8,6],193,i,[8,7],148,86,194,i,[9,6],195,86,199,i,[58,20],142,200,i,[89,3],202,26,72,201,i,[202,34],219,i,[201,5],39,42,i,[202,23],221,i,[66,22],228,e,[122,6,1],230,i,[125,21],234,44,238,41,240,239,241,i,[239,7],75,248,i,[88,20],249,i,[58,20],254,i,[79,21],255,i,[64,17],256,i,[40,21],257,i,[22,6],259,i,[23,14],260,261,262,i,[290,22],i,[312,28],263,i,[115,16],264,i,[17,15],265,269,268,241,i,[19,14],271,i,[15,13],272,i,[14,12],273,i,[13,12],274,i,[13,11],275,i,[12,11],276,i,[12,11],277,i,[12,11],278,i,[12,10],279,i,[11,10],280,i,[11,9],281,i,[10,9],282,i,[10,8],283,i,[9,8],284,i,[9,8],285,i,[454,22],286,e,[122,7,1],i,[29,21],288,i,[29,6],i,[295,20],289,i,[316,21],290,i,[22,21],291,i,[22,21],292,i,[22,21],132,295,i,[665,8],294,i,[833,8],299,44,60,300,44,i,[13,8],66,41,240,305,151,152,303,i,[378,15],i,[593,6],307,44,308,i,[854,3],i,[621,8],i,[841,15],311,i,[50,8],317,300,i,[76,8],269,i,[74,5],i,[251,22],318,i,[251,26],142,132,323,i,[23,22],324,i,[149,20],326,i,[110,8],328,151,152,i,[32,19],332,i,[75,20],333,i,[148,22],334,i,[428,28],335,i,[29,28],336,i,[206,27],337,i,[22,21],339,i,[22,21],341,i,[95,22],346,i,[124,28],348,i,[29,28],350,i,[29,28],352,i,[29,28],353,i,[29,6]]),mode:s([e,[1,46],e,[2,7],i,[27,101],i,[31,5],1,i,[27,7],i,[9,3],i,[43,8],i,[18,5],i,[12,8],e,[2,20],i,[100,22],i,[44,38],e,[1,57],i,[96,6],i,[327,43],i,[218,8],i,[369,35],i,[20,35],i,[299,11],i,[352,20],i,[317,10],i,[250,19],i,[24,7],i,[67,6],i,[289,19],i,[310,86],i,[146,12],i,[412,22],i,[440,60],i,[236,15],i,[65,20],i,[8,22],i,[34,18],i,[30,22],i,[87,7],i,[55,20],i,[271,60],i,[246,30],i,[688,75],i,[561,7],i,[502,7],e,[1,217],i,[219,219],e,[1,232],i,[680,7],i,[458,70],i,[1605,13],i,[1062,14],i,[1676,26],i,[123,26],i,[1116,48],i,[1134,38],i,[20,60],i,[1194,23],i,[1216,42],i,[1241,80],i,[2006,28],i,[690,216],e,[2,42],i,[538,11],e,[1,155]]),goto:s([3,e,[12,13,1],27,33,34,32,28,29,30,35,i,[21,20],45,43,38,46,e,[88,7],i,[31,20],e,[90,7],i,[27,20],e,[92,7],i,[27,20],e,[94,7],i,[27,20],52,46,53,46,98,56,98,57,59,58,45,46,62,144,61,e,[144,4],e,[151,4],43,151,28,45,43,46,e,[118,6],67,e,[118,21],i,[74,15],46,e,[135,6],76,e,[135,21],100,e,[90,6,1],79,46,e,[102,5,1],109,84,85,87,i,[18,7],131,57,116,i,[20,10],i,[159,20],129,130,e,[133,9,1],i,[144,3],62,143,61,e,[143,4],100,146,i,[62,6],i,[59,10],150,i,[60,20],e,[152,4],43,152,28,156,i,[25,15],158,i,[16,15],i,[88,3],e,[125,5],i,[23,15],e,[127,5],i,[20,15],166,165,138,167,138,46,i,[206,18],e,[38,15],172,e,[38,10],e,[173,10,1],e,[68,3],183,e,[68,3],184,186,26,185,26,187,e,[26,16],188,189,190,e,[26,18],192,i,[230,16],i,[17,17],i,[138,7],i,[17,10],196,i,[17,16],e,[66,7],197,66,e,[64,3],198,e,[64,6],e,[14,21],109,e,[14,21],i,[96,17],i,[272,15],e,[62,3],203,e,[62,7],e,[60,3],204,e,[60,8],e,[58,10],205,206,58,58,e,[55,4],207,208,e,[55,6],209,210,e,[55,4],e,[50,12],211,212,e,[50,6],e,[47,4],213,214,e,[47,16],e,[44,4],215,44,44,216,217,e,[44,16],i,[576,9],218,i,[576,43],38,46,e,[12,15],220,e,[12,23],i,[248,17],222,224,223,225,226,227,i,[117,9],i,[25,10],i,[96,11],229,46,231,232,i,[34,7],233,i,[33,10],i,[860,3],235,236,157,237,242,163,243,163,43,46,244,i,[160,15],246,245,247,i,[590,8],i,[50,10],251,250,253,252,i,[21,17],i,[17,52],258,i,[18,16],46,i,[109,18],i,[482,32],i,[49,34],266,224,267,270,164,243,43,i,[178,69],i,[17,193],i,[539,23],287,i,[31,30],i,[129,68],293,i,[99,8],i,[784,30],296,224,297,i,[23,20],298,242,166,243,166,46,302,167,301,167,242,304,243,43,46,i,[35,20],100,306,i,[115,16],i,[1337,3],309,i,[1293,9],310,i,[24,10],224,312,e,[67,7],197,67,313,224,314,315,316,e,[65,3],198,e,[65,6],e,[63,3],203,e,[63,7],i,[193,17],270,166,243,270,i,[124,3],i,[123,20],e,[61,3],204,e,[61,8],e,[59,10],205,206,59,59,e,[56,4],207,208,e,[56,6],209,210,e,[56,4],e,[57,4],207,208,e,[57,6],209,210,e,[57,4],e,[51,12],211,212,e,[51,6],e,[52,12],211,212,e,[52,6],e,[53,12],211,212,e,[53,6],e,[54,12],211,212,e,[54,6],e,[48,4],213,214,e,[48,16],e,[49,4],213,214,e,[49,16],e,[45,4],215,45,45,216,217,e,[45,16],e,[46,4],215,46,46,216,217,e,[46,16],i,[554,30],319,224,320,224,321,224,322,i,[492,18],i,[18,18],302,168,301,168,100,325,i,[358,16],327,i,[352,20],329,330,331,i,[738,64],i,[30,67],i,[107,11],338,i,[18,17],340,i,[18,16],342,343,e,[200,43],344,e,[200,8],345,224,i,[139,30],347,i,[32,31],349,i,[32,31],351,i,[264,60]])}),defaultActions:function(n){for(var e={},t=n.idx,i=n.goto,s=0,r=t.length;s<r;s++){e[t[s]]=i[s]}return e}({idx:s([e,[3,4,1],e,[12,19,1],e,[33,4,1],38,42,44,e,[46,5,1],55,58,64,65,69,74,77,78,80,e,[89,7,1],97,98,e,[102,6,1],109,115,116,118,119,120,e,[122,6,1],131,142,143,146,147,e,[148,4,2],155,156,158,159,e,[161,5,1],170,e,[172,11,1],189,190,191,193,194,195,199,218,219,223,231,232,233,235,236,238,239,244,245,e,[247,4,1],252,254,258,260,261,262,266,268,e,[283,4,1],288,289,e,[296,4,1],304,306,e,[308,4,1],313,314,316,317,318,325,327,e,[329,5,1],335,336,342,343,346,348,e,[350,4,1]]),goto:s([2,214,216,217,e,[100,16,1],140,141,142,119,120,1,215,86,96,145,3,e,[89,4,2],218,87,153,155,121,136,99,178,70,16,e,[32,6,1],12,13,e,[4,5,1],10,9,40,192,194,196,197,e,[183,6,1],198,83,97,148,85,38,150,159,154,156,146,117,122,128,130,124,126,131,181,e,[72,11,1],22,23,e,[27,4,1],11,193,195,199,210,211,212,147,149,161,162,116,123,133,137,139,132,179,71,18,24,20,21,15,165,41,42,43,189,191,84,209,213,158,160,174,170,129,134,180,182,17,19,31,39,190,172,176,169,175,171,69,25,202,203,173,177,205,207,201,204,206,208])}),parseError:function(n,e,t){if(!e.recoverable)throw"function"==typeof this.trace&&this.trace(n),t||(t=this.JisonParserError),new t(n,e);"function"==typeof this.trace&&this.trace(n),e.destroy()},parse:function(n){var e,t,i,s=this,r=new Array(128),a=new Array(128),o=new Array(128),c=new Array(128),f=this.table,l=0,h=0,d=(this.TERROR,this.EOF),_=(this.options.errorRecoveryTokenDiscardCount,[0,354]);i=this.__lexer__?this.__lexer__:this.__lexer__=Object.create(this.lexer);var u={parseError:void 0,quoteName:void 0,lexer:void 0,parser:void 0,pre_parse:void 0,post_parse:void 0,pre_lex:void 0,post_lex:void 0};function p(n){if("object"==typeof n){var e={};for(var t in n)Object.prototype.hasOwnProperty.call(n,t)&&(e[t]=n[t]);return e}return n}function m(n,e){for(var t in e)void 0===n[t]&&Object.prototype.hasOwnProperty.call(e,t)&&(n[t]=e[t])}function g(n){var e=p(n);return e&&e.range&&(e.range=e.range.slice(0)),e}function y(){var n=i.fastLex();return"number"!=typeof n&&(n=s.symbols_[n]||n),n||d}"function"!=typeof assert||assert,this.yyGetSharedState=function(){return u},m(u,this.yy),u.lexer=i,u.parser=this,"function"==typeof u.parseError?this.parseError=function(n,e,t){return t||(t=this.JisonParserError),u.parseError.call(this,n,e,t)}:this.parseError=this.originalParseError,"function"==typeof u.quoteName?this.quoteName=function(n){return u.quoteName.call(this,n)}:this.quoteName=this.originalQuoteName,this.cleanupAfterParse=function(n,e,t){var s,f;e&&((u.post_parse||this.post_parse)&&(f=this.constructParseErrorInfo(null,null,null,!1)),u.post_parse&&void 0!==(s=u.post_parse.call(this,u,n,f))&&(n=s),this.post_parse&&void 0!==(s=this.post_parse.call(this,u,n,f))&&(n=s),f&&f.destroy&&f.destroy());if(this.__reentrant_call_depth>1)return n;if(i.cleanupAfterLex&&i.cleanupAfterLex(t),u&&(u.lexer=void 0,u.parser=void 0,i.yy===u&&(i.yy=void 0)),u=void 0,this.parseError=this.originalParseError,this.quoteName=this.originalQuoteName,r.length=0,a.length=0,c.length=0,o.length=0,l=0,!t){for(var h=this.__error_infos.length-1;h>=0;h--){var d=this.__error_infos[h];d&&"function"==typeof d.destroy&&d.destroy()}this.__error_infos.length=0}return n},this.yyMergeLocationInfo=function(n,e,t,i,s){var r,a=0|n,o=0|e,f=t,h=i;if(!f&&null!=n)for(var d=a;d<=o&&!(f=c[d]);d++);if(!h&&null!=e)for(d=o;d>=a&&!(h=c[d]);d--);if(!f&&null==n){if(!s)for(d=(a||l)-1;d>=0&&!(f=c[d]);d--);return f?((r=p(f)).first_line=r.last_line,r.first_column=r.last_column,r.range&&(r.range=r.range.slice(0),r.range[0]=r.range[1]),h&&(m(r,h),r.last_line=h.last_line,r.last_column=h.last_column,r.range&&h.range&&(r.range[1]=h.range[1])),r):h?((r=p(h)).range&&(r.range=r.range.slice(0)),r):void 0}if(f||(f=h,h=null),f)return(r=p(f)).range&&(r.range=r.range.slice(0)),h&&(m(r,h),r.last_line=h.last_line,r.last_column=h.last_column,r.range&&h.range&&(r.range[1]=h.range[1])),r},this.constructParseErrorInfo=function(n,e,t,s){var f={errStr:n,exception:e,text:i.match,value:i.yytext,token:this.describeSymbol(h)||h,token_id:h,line:i.yylineno,loc:g(i.yylloc),expected:t,recoverable:s,state:b,action:L,new_state:w,symbol_stack:r,state_stack:a,value_stack:o,location_stack:c,stack_pointer:l,yy:u,lexer:i,parser:this,destroy:function(){var n=!!this.recoverable;for(var e in this)this.hasOwnProperty(e)&&"object"==typeof e&&(this[e]=void 0);this.recoverable=n}};return this.__error_infos.push(f),f};var b,L,v,x,E,I,A,w,S=function(){var n=i.lex();return"number"!=typeof n&&(n=s.symbols_[n]||n),n||d},F={$:!0,_$:void 0,yy:u},T=!1;try{if(this.__reentrant_call_depth++,i.setInput(n,u),"function"==typeof i.canIUse)i.canIUse().fastLex&&(S=y);for(e=i.yylloc,c[l]=e,o[l]=null,a[l]=0,r[l]=0,++l,t=i.yytext,this.pre_parse&&this.pre_parse.call(this,u),u.pre_parse&&u.pre_parse.call(this,u),w=a[l-1];;){if(b=w,this.defaultActions[b])L=2,w=this.defaultActions[b];else if(h||(h=S()),x=f[b]&&f[b][h]||_,w=x[1],!(L=x[0])){var N,O=this.describeSymbol(h)||h,$=this.collect_expected_token_set(b);N="number"==typeof i.yylineno?"Parse error on line "+(i.yylineno+1)+": ":"Parse error: ","function"==typeof i.showPosition&&(N+="\n"+i.showPosition(69,10)+"\n"),$.length?N+="Expecting "+$.join(", ")+", got unexpected "+O:N+="Unexpected "+O,E=this.constructParseErrorInfo(N,null,$,!1),void 0!==(v=this.parseError(E.errStr,E,this.JisonParserError))&&(T=v);break}switch(L){default:if(L instanceof Array){E=this.constructParseErrorInfo("Parse Error: multiple actions possible at state: "+b+", token: "+h,null,null,!1),void 0!==(v=this.parseError(E.errStr,E,this.JisonParserError))&&(T=v);break}E=this.constructParseErrorInfo("Parsing halted. No viable error recovery approach available due to internal system failure.",null,null,!1),void 0!==(v=this.parseError(E.errStr,E,this.JisonParserError))&&(T=v);break;case 1:r[l]=h,o[l]=i.yytext,c[l]=g(i.yylloc),a[l]=w,++l,h=0,t=i.yytext,e=i.yylloc;continue;case 2:if(I=(A=this.productions_[w-1])[1],void 0!==(v=this.performAction.call(F,t,e,w,l-1,o,c))){T=v;break}l-=I;var k=A[0];r[l]=k,o[l]=F.$,c[l]=F._$,w=f[a[l-1]][k],a[l]=w,++l;continue;case 3:-2!==l&&(T=!0,l--,void 0!==o[l]&&(T=o[l]))}break}}catch(n){if(n instanceof this.JisonParserError)throw n;if(i&&"function"==typeof i.JisonLexerError&&n instanceof i.JisonLexerError)throw n;E=this.constructParseErrorInfo("Parsing aborted due to exception.",n,null,!1),T=!1,void 0!==(v=this.parseError(E.errStr,E,this.JisonParserError))&&(T=v)}finally{T=this.cleanupAfterParse(T,!0,!0),this.__reentrant_call_depth--}return T}};r.originalParseError=r.parseError,r.originalQuoteName=r.quoteName;const a=t(428);function o(){this.yy={}}return o.prototype=r,r.Parser=o,new o}();e.parser=i,e.Parser=i.Parser,e.parse=function(){return i.parse.apply(i,arguments)}}},e={};function t(i){var s=e[i];if(void 0!==s)return s.exports;var r=e[i]={exports:{}};return n[i](r,r.exports,t),r.exports}t.d=(n,e)=>{for(var i in e)t.o(e,i)&&!t.o(n,i)&&Object.defineProperty(n,i,{enumerable:!0,get:e[i]})},t.o=(n,e)=>Object.prototype.hasOwnProperty.call(n,e),t.r=n=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},(()=>{"use strict";const n=JSON.parse("{\"ctype.h\":\"#pragma once\\nint isalnum(int chr);\\nint isalpha(int chr);\\nint iscntrl(int chr);\\nint isdigit(int chr);\\nint islower(int chr);\\nint isupper(int chr);\\nint isgraph(int chr);\\nint isprint(int chr);\\nint ispunct(int chr);\\nint isspace(int chr);\\nint isxdigit(int chr);\\nint tolower(int chr);\\nint toupper(int chr);\\n\",\"custom/alloc.c\":\"#include <stdlib.h>\\n#define PAGE_SIZE 65536\\n#define ALLOC_OFFSET (sizeof(struct node))\\n#define BLOCK_START(b) ((char*) (b) + ALLOC_OFFSET)\\nstatic struct node {\\nstruct node *prev;\\nstruct node *next;\\nsize_t size;\\nint padding;  \\n} alloc_list;\\nstatic void merge_blocks(struct node* node) {\\nstruct node* last = NULL;\\nwhile(node && node->next) {\\nsize_t end = (size_t) node + ALLOC_OFFSET + node->size;\\nstruct node* next = node->next;\\nif (end == (size_t) next) {\\nnode->size += ALLOC_OFFSET + next->size;\\nnode->next = next->next;\\nif (node->next->prev) node->next->prev = node;\\nnext->prev = NULL;\\nnext->next = NULL;\\nnext->size = 0;\\n} else {\\nnode = next;\\n}\\n}\\n}\\nvoid* malloc(size_t size) {\\nif(size > 0) {\\nsize = (size + 31) & ~31;  \\nstruct node *block = &alloc_list, *last = block;\\nwhile (block) {\\nif (block->size >= size) {\\nif (block->size - size >= 48) {\\nstruct node *new_block = (struct node*) (BLOCK_START(block) + size);\\nnew_block->size = block->size - size - ALLOC_OFFSET;\\nnew_block->prev = block;\\nnew_block->next = block->next;\\nblock->size = size;\\nif (block->next) block->next->prev = new_block;\\nblock->next = new_block;\\n}\\nstruct node *prev = block->prev, *next = block->next;\\nif (prev) prev->next = next;\\nif (next) next->prev = prev;\\nblock->next = (struct node *) -1;\\nblock->prev = (struct node *) 7;\\nreturn BLOCK_START(block);\\n}\\nlast = block;\\nblock = block->next;\\n}\\nint pages = 1 + ((size + ALLOC_OFFSET) / PAGE_SIZE);\\nint result = __wasm_i32__(1, pages, 0x40, 0);  \\nif (result < 0) {\\nreturn NULL;\\n} else {\\nlast->next = (struct node*) (result * PAGE_SIZE);\\nlast->next->size = (pages * PAGE_SIZE) - ALLOC_OFFSET;\\nlast->next->prev = last;\\nmerge_blocks(last);\\nreturn malloc(size);\\n}\\n}\\nreturn NULL;\\n}\\nvoid free(void* ptr) {\\nif (ptr) {\\nstruct node* block = (struct node*) ((char*)ptr - ALLOC_OFFSET);\\nif ((int) block->next != -1 || (int) block->prev != 7) {\\nreturn;\\n}\\n__wasm__(3, ptr, 0, block->size, 0xFC, 0x0B, 0x00);  \\nstruct node* list = &alloc_list;\\nwhile (list->next && list->next < block) {\\nlist = list->next;\\n}\\nblock->prev = list;\\nblock->next = list->next;\\nif (list->next && list->next->prev) list->next->prev = block;\\nlist->next = block;\\nmerge_blocks(&alloc_list);\\n}\\n}\\nvoid* realloc(void* ptr, size_t size) {\\nif (ptr) {\\nstruct node* block = (struct node*) ((char*)ptr - ALLOC_OFFSET);\\nif ((int) block->next != -1 || (int) block->prev != 7) {\\nreturn NULL;\\n}\\nif (block->size > size) {\\nreturn ptr;\\n}\\nvoid* new_ptr = malloc(size);\\n__wasm__(3, new_ptr, ptr, block->size, 0xFC, 0x0A, 0x00, 0x00);  \\nfree(ptr);\\nreturn new_ptr;\\n}\\nreturn NULL;\\n}\\nvoid* calloc(size_t nobj, size_t size) {\\nif (nobj && size) {\\nsize *= nobj;\\nvoid* ptr = malloc(size);\\nif (ptr) {\\n__wasm__(3, ptr, 0, size, 0xFC, 0x0B, 0x00);  \\n}\\nreturn ptr;\\n}\\nreturn NULL;\\n}\\n\",\"custom/ctype.c\":\"#include <ctype.h>\\nint isalnum(int chr) {\\nreturn isalpha(chr) || isdigit(chr);\\n}\\nint isalpha(int chr) {\\nreturn islower(chr) || isupper(chr);\\n}\\nint iscntrl(int chr) {\\nreturn chr < 0x20 || chr == 0x7f;\\n}\\nint isdigit(int chr) {\\nreturn chr >= '0' && chr <= '9';\\n}\\nint islower(int chr) {\\nreturn chr >= 'a' && chr <= 'z';\\n}\\nint isupper(int chr) {\\nreturn chr >= 'A' && chr <= 'Z';\\n}\\nint isgraph(int chr) {\\nreturn chr >= ' ' && chr <= '~';\\n}\\nint isprint(int chr) {\\nreturn chr > ' ' && chr <= '~';\\n}\\nint ispunct(int chr) {\\nreturn chr >= 'a' && chr <= 'z';\\n}\\nint isspace(int chr) {\\nreturn chr == ' ' || (chr >= '\\\\t' && chr <= '\\\\r');\\n}\\nint isxdigit(int chr) {\\nreturn isdigit(chr) || (chr >= 'a' && chr <= 'f') || (chr >= 'A' && chr <= 'F');\\n}\\nint tolower(int chr) {\\nreturn isupper(chr) ? chr + 32 : chr;\\n}\\nint toupper(int chr) {\\nreturn islower(chr) ? chr - 32 : chr;\\n}\\n\",\"custom/math.c\":\"#include <math.h>\\n#include <wasm/f64.h>\\ndouble sqrt(double d) {\\nreturn f64_sqrt(d);\\n}\\ndouble ceil(double d) {\\nreturn f64_ceil(d);\\n}\\ndouble fabs(double d) {\\nreturn f64_abs(d);\\n}\\ndouble floor(double d) {\\nreturn f64_floor(d);\\n}\\ndouble fmax(double d1, double d2) {\\nreturn f64_max(d1, d2);\\n}\\ndouble fmin(double d1, double d2) {\\nreturn f64_min(d1, d2);\\n}\\ndouble trunc(double d) {\\nreturn f64_trunc(d);\\n}\\ndouble copysign(double d1, double d2) {\\nreturn f64_copysign(d1, d2);\\n}\\ndouble round(double d) {\\nreturn f64_nearest(d);\\n}\\ndouble exp(double d) {\\ndouble sum = 1 + d, factorial = 1, power = d;\\nfor (int k = 2; k <= 5; k++) {\\npower *= d;\\nfactorial *= k;\\nsum += power / factorial;\\n}\\nreturn sum;\\n}\\n\",\"custom/stdio.c\":\"#include <stdio.h>\\n#ifndef FILES\\nint putchar(int chr) {\\n__put_char(chr);\\nreturn chr;\\n}\\nint puts(const char *s) {\\nchar *x = s;\\nwhile (*x) {\\n__put_char(*x);\\nx++;\\n}\\n__put_char('\\\\n');\\nreturn 0;\\n}\\n#else\\n#include <stdlib.h>\\n#include <string.h>\\n#include <stdbool.h>\\n#define __fhandle_stdin 0\\n#define __fhandle_stdout 1\\n#define __fhandle_stderr 2\\n#define __fhandle_fname 3\\nstatic FILE __stdin = {__fhandle_stdin, -1, false, false};\\nFILE* stdin = &__stdin;\\nstatic FILE __stdout = {__fhandle_stdout, -1, false, false};\\nFILE* stdout = &__stdout;\\nstatic FILE __stderr = {__fhandle_stderr, -1, false, false};\\nFILE* stderr = &__stderr;\\n#define __fhandle_flag_str 1\\nstatic void store_fname(const char *s) {\\nchar *x = s;\\nwhile (*x) {\\n__put_char(__fhandle_fname, *x);\\nx++;\\n}\\n__put_char(__fhandle_fname, 0);\\n}\\nFILE *fopen(const char *filename, const char *mode) {\\nreturn freopen(filename, mode, NULL);\\n}\\nFILE *freopen(const char *filename, const char *mode, FILE* stream) {\\nstore_fname(filename);\\nif (!__exists() && strchr(mode, 'r')) {\\nreturn NULL;\\n}\\nif (stream == NULL) {\\nstream = malloc(sizeof(struct __stdio_file));\\n}\\nstore_fname(filename);\\nstream->handle = __get_fhandle();\\nstream->unget = -1;\\nstream->len = 0;\\nstream->flags = 0;\\nstream->error = false;\\nstream->eof = false;\\nif (strchr(mode, 'a')) {\\nfseek(stream, 0, SEEK_END);\\n}\\nreturn stream;\\n}\\nvoid __str2file(FILE *stream, const char *data) {\\nstream->handle = (int) data;\\nstream->unget = -1;\\nstream->len = 0;\\nstream->flags = __fhandle_flag_str;\\nstream->error = false;\\nstream->eof = false;\\n}\\nint fflush(FILE* stream) {\\nreturn 0;  \\n}\\nint fclose(FILE* stream) {\\nfree(stream);\\nreturn 0;\\n}\\nint remove(const char *filename) {\\nreturn rename(filename, \\\"\\\");\\n}\\nint rename(const char *oldname, const char *newname) {\\nstore_fname(oldname);\\nstore_fname(newname);\\nreturn __move();\\n}\\nstatic char __tmpnam[L_tmpnam];\\nstatic int __tmpcount;\\nchar *tmpnam(char *s) {\\nif (s == NULL) s = __tmpnam;\\nsnprintf(s, L_tmpnam, \\\"$tmp/%d\\\", ++__tmpcount);\\nreturn s;\\n}\\nFILE *tmpfile(void) {\\nreturn fopen(tmpnam(NULL), \\\"wb+\\\");\\n}\\nint setvbuf(FILE *stream, char *buf, int mode, size_t size) {\\nreturn -1;  \\n}\\nvoid setbuf(FILE *stream, char *buf) {\\n}\\nint fgetc(FILE *stream) {\\nint c;\\nif (stream->unget >= 0) {\\nc = (unsigned char) stream->unget;\\nstream->unget = -1;\\n} else if (stream->flags & __fhandle_flag_str) {\\nchar* s = (char*) stream->handle;\\nc = *(s++);\\nif (c) {\\nstream->handle = (int) s;\\n} else {\\nstream->eof = true;\\nc = EOF;\\n}\\nstream->error = false;\\nstream->len++;\\n} else {\\nc = __get_char(stream->handle);\\nstream->eof = c == EOF;\\nstream->error = c < 0 && c != EOF;\\nstream->len++;\\n}\\nreturn c;\\n}\\nchar *fgets(char *s, int n, FILE *stream) {\\nint i = 0;\\nwhile (i < n - 1) {\\nint c = fgetc(stream);\\nif (c < 0) return NULL;\\ns[i++] = c;\\nif (c == '\\\\n') break;\\n}\\ns[i] = 0;\\nreturn s;\\n}\\nint fputc(int c, FILE *stream) {\\nif (stream->flags & __fhandle_flag_str) return EOF;\\nint result = __put_char(stream->handle, c);\\nif (result >= 0) return c;\\nreturn result;\\n}\\nint fputs(const char *s, FILE *stream) {\\nif (stream->flags & __fhandle_flag_str) return EOF;\\nchar *x = s;\\nwhile (*x) {\\nif (__put_char(stream->handle, *x) < 0) return EOF;\\nx++;\\n}\\nreturn 0;\\n}\\nint getchar(void) {\\nreturn fgetc(stdin);\\n}\\nchar *gets(char *s) {\\nwhile (true) {\\nint c = fgetc(stdin);\\nif (c == '\\\\n') {\\n*s = 0;\\nreturn s;\\n} else if (c < 0) {\\nbreak;\\n} else {\\n*s = c;\\n}\\ns++;\\n}\\nreturn NULL;\\n}\\nint putchar(int c) {\\nreturn fputc(c, stdout);\\n}\\nint puts(const char *s) {\\nif (fputs(s, stdout) < 0) return EOF;\\nif (fputc('\\\\n', stdout) < 0) return EOF;\\nreturn 0;\\n}\\nint ungetc(int c, FILE *stream) {\\nif (c < 0 || stream->unget >= 0) return EOF;\\nstream->unget = c;\\nreturn c;\\n}\\nsize_t fread(void *ptr, size_t size, size_t nobj, FILE *stream) {\\nint n;\\nfor (n = 0; n < nobj; n++) {\\nfor (int i = 0; i < size; i++) {\\nint c = fgetc(stream);\\nif (c < 0) return n;\\n((char*) ptr)[(n * size) + i] = c;\\n}\\n}\\nreturn n;\\n}\\nsize_t fwrite(const void *ptr, size_t size, size_t nobj, FILE* stream) {\\nint n;\\nfor (n = 0; n < nobj; n++) {\\nfor (int i = 0; i < size; i++) {\\nif (fputc(((char*) ptr)[(n * size) + i], stream) < 0) {\\nreturn n;\\n}\\n}\\n}\\nreturn n;\\n}\\nint fseek(FILE *stream, long offset, int origin) {\\nif (stream->flags & __fhandle_flag_str) return -1;\\nlong pos;\\nif (origin == SEEK_SET) {\\npos = offset;\\n} else if (origin == SEEK_CUR) {\\npos = __get_pos(stream->handle) + offset;\\n} else if (origin == SEEK_END) {\\npos = __get_len(stream->handle) + offset;\\n} else {\\nreturn -1;\\n}\\nreturn fsetpos(stream, &pos);\\n}\\nlong ftell(FILE *stream) {\\nif (stream->flags & __fhandle_flag_str) return -1;\\nlong pos = __get_pos(stream->handle);\\nif (pos < 0) return -1;\\nreturn pos;\\n}\\nvoid rewind(FILE *stream) {\\nfseek(stream, 0L, SEEK_SET);\\nclearerr(stream);\\n}\\nint fgetpos(FILE *stream, fpos_t *ptr) {\\nif (stream->flags & __fhandle_flag_str) return -1;\\nlong pos = __get_pos(stream->handle);\\nif (pos < 0) return -1;\\n*ptr = pos;\\nreturn 0;\\n}\\nint fsetpos(FILE *stream, const fpos_t *ptr) {\\nif (stream->flags & __fhandle_flag_str || __set_pos(stream->handle, *ptr) != 0) {\\nreturn -1;\\n}\\nreturn 0;\\n}\\nvoid clearerr(FILE *stream) {\\nstream->eof = false;\\nstream->error = false;\\n}\\nint feof(FILE *stream) {\\nreturn stream->eof;\\n}\\nint ferror(FILE *stream) {\\nreturn stream->error;\\n}\\nvoid perror(const char *s) {\\nfputs(s, stderr);\\nfputs(\\\": error\\\\n\\\", stderr);\\n}\\nint fscanf(FILE *stream, const char *fmt, ...) {\\nva_list va;\\nva_start(va, fmt);\\nint result = vfscanf(stream, fmt, va);\\nva_end(va);\\nreturn result;\\n}\\nint scanf(const char *fmt, ...) {\\nva_list va;\\nva_start(va, fmt);\\nint result = vfscanf(stdin, fmt, va);\\nva_end(va);\\nreturn result;\\n}\\nint sscanf(char *s, const char *fmt, ...) {\\nFILE f;\\n__str2file(&f, s);\\nva_list va;\\nva_start(va, fmt);\\nint result = vfscanf(&f, fmt, va);\\nva_end(va);\\nreturn result;\\n}\\n#endif\\n\",\"custom/stdlib.c\":\"#include <stdlib.h>\\nvoid abort() {\\n__wasm__(0, 0x00);\\n}\\nvoid exit(int code) {\\n__wasm__(0, 0x00);\\n}\\nint atexit(void (*fcn)(void)) {\\nreturn 1;\\n}\\nint system(const char *s) {\\nreturn s == NULL ? 0 : 1;\\n}\\nchar *getenv(const char *name) {\\nreturn NULL;\\n}\\ndouble atof(const char *s) {\\nreturn strtod(s, (char**) NULL);\\n}\\nint atoi(const char *s) {\\nreturn (int) strtol(s, (char**) NULL, 10);\\n}\\nint atol(const char *s) {\\nreturn strtol(s, (char**) NULL, 10);\\n}\\nint abs(int n) {\\nreturn n >= 0 ? n : -n;\\n}\\nint labs(long n) {\\nreturn n >= 0 ? n : -n;\\n}\\ndiv_t div(int num, int denom) {\\ndiv_t result;\\nresult.quot = num / denom;\\nresult.rem = num % denom;\\nreturn result;\\n}\\nldiv_t ldiv(long num, long denom) {\\nldiv_t result;\\nresult.quot = num / denom;\\nresult.rem = num % denom;\\nreturn result;\\n}\\n\",\"custom/string.c\":\"#include <string.h>\\nchar* strcpy(char* destination, const char* source) {\\nmemcpy(destination, source, strlen(source) + 1);  \\nreturn destination;\\n}\\nchar* strncpy(char* destination, const char* source, size_t n) {\\nconst size_t len = strnlen(source, n);\\nif (len < n) {\\nmemcpy(destination, source, len);\\nmemset(destination + len, 0, n - len);\\n} else {\\nmemcpy(destination, source, n);\\n}\\nreturn destination;\\n}\\nvoid* memcpy(void* destination, const void* source, size_t n) {\\n__wasm__(3, destination, source, n, 0xFC, 0x0A, 0, 0);  \\nreturn destination;\\n}\\nvoid* memset(void* destination, int c, size_t n) {\\n__wasm__(3, destination, c, n, 0xFC, 0x0B, 0);  \\nreturn destination;\\n}\\n\",\"custom/time.c\":\"#include <time.h>\\nclock_t clock() {\\nreturn __time();\\n}\\n\",\"errno.h\":\"extern int errno;\\n#define EDOM 10\\n#define ERANGE 11\\n#define EILSEQ 12\\n\",\"float.h\":\"#pragma once\\n#define FLT_RADIX 2\\n#define FLT_ROUNDS 1\\n#define FLT_DIG 6\\n#define FLT_EPSILON 1.192092896e-07F\\n#define FLT_MANT_DIG 24\\n#define FLT_MAX 3.402823466e+38F\\n#define FLT_MAX_EXP 128\\n#define FLT_MIN 1.175494351e-38F\\n#define FLT_MIN_EXP (-125)\\n#define DBL_DIG 15\\n#define DBL_EPSILON 2.2204460492503131e-016\\n#define DBL_MANT_DIG 53\\n#define DBL_MAX 1.7976931348623158e+308\\n#define DBL_MAX_EXP 1024\\n#define DBL_MIN 2.2250738585072014e-308\\n#define DBL_MIN_EXP (-1021)\\n#define LDBL_DIG 15\\n#define LDBL_EPSILON 2.2204460492503131e-016\\n#define LDBL_MANT_DIG 53\\n#define LDBL_MAX 1.7976931348623158e+308\\n#define LDBL_MAX_EXP 1024\\n#define LDBL_MIN 2.2250738585072014e-308\\n#define LDBL_MIN_EXP (-1021)\\n\",\"libraries/avrlibc/LICENSE\":\"The contents of avr-libc are licensed with a Modified BSD License.\\n\\nAll of this is supposed to be Free Software, Open Source, DFSG-free,\\nGPL-compatible, and OK to use in both free and proprietary applications.\\n\\nSee the license information in the individual source files for details.\\n\\nAdditions and corrections to this file are welcome.\\n\\n*******************************************************************************\\nPortions of avr-libc are Copyright (c) 1999-2010\\nKeith Gudger,\\nBjoern Haase,\\nSteinar Haugen,\\nPeter Jansen,\\nReinhard Jessich,\\nMagnus Johansson,\\nArtur Lipowski,\\nMarek Michalkiewicz,\\nColin O'Flynn,\\nBob Paddock,\\nReiner Patommel,\\nMichael Rickman,\\nTheodore A. Roth,\\nJuergen Schilling,\\nPhilip Soeberg,\\nAnatoly Sokolov,\\nNils Kristian Strom,\\nMichael Stumpf,\\nStefan Swanepoel,\\nEric B. Weddington,\\nJoerg Wunsch,\\nDmitry Xmelkov,\\nThe Regents of the University of California.\\nAll rights reserved.\\n\\n   Redistribution and use in source and binary forms, with or without\\n   modification, are permitted provided that the following conditions are met:\\n\\n   * Redistributions of source code must retain the above copyright\\n     notice, this list of conditions and the following disclaimer.\\n\\n   * Redistributions in binary form must reproduce the above copyright\\n     notice, this list of conditions and the following disclaimer in\\n     the documentation and/or other materials provided with the\\n     distribution.\\n\\n   * Neither the name of the copyright holders nor the names of\\n     contributors may be used to endorse or promote products derived\\n     from this software without specific prior written permission.\\n\\n   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \\\"AS IS\\\"\\n   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\\n   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\\n   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\\n   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\\n   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\\n   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\\n   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\\n   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\\n   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\\n   POSSIBILITY OF SUCH DAMAGE.\\n\\n*******************************************************************************\\n\",\"libraries/avrlibc/src/bsearch.c\":\"#include <stddef.h>\\n#include <stdlib.h>\\nvoid *\\nbsearch(const void *key, const void *base0, size_t nmemb,\\nsize_t size, int (*compar)(const void *, const void *))\\n{\\nconst char *base = base0;\\nsize_t lim;\\nint cmp;\\nconst void *p;\\nfor (lim = nmemb; lim != 0; lim >>= 1) {\\np = base + (lim >> 1) * size;\\ncmp = (*compar)(key, p);\\nif (cmp == 0)\\nreturn ((void *)p);\\nif (cmp > 0) {\\t \\nbase = (char *)p + size;\\nlim--;\\n}\\t\\t \\n}\\nreturn (NULL);\\n}\",\"libraries/avrlibc/src/qsort.c\":\"#include <stdlib.h>\\ntypedef int cmp_t(const void *, const void *);\\nstatic char *med3(char *, char *, char *, cmp_t *);\\nstatic void swapfunc(char *, char *, int);\\n#define min(a, b)\\t((a) < (b) ? (a) : (b))\\n#define swapcode(TYPE, parmi, parmj, n) { \\t\\t\\\\\\nint i = (n) / sizeof (TYPE); \\t\\t\\t\\\\\\nTYPE *pi = (TYPE *) (parmi); \\t\\t\\t\\\\\\nTYPE *pj = (TYPE *) (parmj); \\t\\t\\t\\\\\\ndo { \\t\\t\\t\\t  \\t\\t\\\\\\nTYPE\\tt = *pi;\\t\\t\\t\\\\\\n*pi++ = *pj;\\t\\t\\t\\t\\\\\\n*pj++ = t;\\t\\t\\t\\t\\\\\\n} while (--i > 0);\\t\\t\\t\\t\\\\\\n}\\nstatic void\\nswapfunc(char *a, char *b, int n)\\n{\\nswapcode(char, a, b, n)\\n}\\n#define swap(a, b) swapfunc(a, b, es)\\n#define vecswap(a, b, n) \\tif ((n) > 0) swapfunc(a, b, n)\\nstatic char *\\nmed3(char *a, char *b, char *c, cmp_t *cmp)\\n{\\nreturn cmp(a, b) < 0 ?\\n(cmp(b, c) < 0 ? b : (cmp(a, c) < 0 ? c : a ))\\n:(cmp(b, c) > 0 ? b : (cmp(a, c) < 0 ? a : c ));\\n}\\nvoid\\nqsort(void *a, size_t n, size_t es, cmp_t *cmp)\\n{\\nchar *pa, *pb, *pc, *pd, *pl, *pm, *pn;\\nint d, r, swap_cnt;\\nloop:\\nswap_cnt = 0;\\nif (n < 7) {\\nfor (pm = (char *)a + es; pm < (char *)a + n * es; pm += es)\\nfor (pl = pm; pl > (char *)a && cmp(pl - es, pl) > 0;\\npl -= es)\\nswap(pl, pl - es);\\nreturn;\\n}\\npm = (char *)a + (n / 2) * es;\\nif (n > 7) {\\npl = a;\\npn = (char *)a + (n - 1) * es;\\nif (n > 40) {\\nd = (n / 8) * es;\\npl = med3(pl, pl + d, pl + 2 * d, cmp);\\npm = med3(pm - d, pm, pm + d, cmp);\\npn = med3(pn - 2 * d, pn - d, pn, cmp);\\n}\\npm = med3(pl, pm, pn, cmp);\\n}\\nswap(a, pm);\\npa = pb = (char *)a + es;\\npc = pd = (char *)a + (n - 1) * es;\\nfor (;;) {\\nwhile (pb <= pc && (r = cmp(pb, a)) <= 0) {\\nif (r == 0) {\\nswap_cnt = 1;\\nswap(pa, pb);\\npa += es;\\n}\\npb += es;\\n}\\nwhile (pb <= pc && (r = cmp(pc, a)) >= 0) {\\nif (r == 0) {\\nswap_cnt = 1;\\nswap(pc, pd);\\npd -= es;\\n}\\npc -= es;\\n}\\nif (pb > pc)\\nbreak;\\nswap(pb, pc);\\nswap_cnt = 1;\\npb += es;\\npc -= es;\\n}\\nif (swap_cnt == 0) {   \\nfor (pm = (char *)a + es; pm < (char *)a + n * es; pm += es)\\nfor (pl = pm; pl > (char *)a && cmp(pl - es, pl) > 0;\\npl -= es)\\nswap(pl, pl - es);\\nreturn;\\n}\\npn = (char *)a + n * es;\\nr = (int) min(pa - (char *)a, pb - pa);\\nvecswap(a, pb - r, r);\\nr = (int) min(pd - pc, pn - pd - es);\\nvecswap(pb, pn - r, r);\\nif ((r = (int) (pb - pa)) > es)\\nqsort(a, r / es, es, cmp);\\nif ((r = (int) (pd - pc)) > es) {\\na = pn - r;\\nn = r / es;\\ngoto loop;\\n}\\n}\\n\",\"libraries/avrlibc/src/strtod.c\":\"#include <ctype.h>\\n#include <limits.h>\\n#include <math.h>         \\n#include <stdlib.h>\\n#include <strings.h>\\nstatic const double pwr_p10 [6] = {\\n1e+1, 1e+2, 1e+4, 1e+8, 1e+16, 1e+32\\n};\\nstatic const double pwr_m10 [6] = {\\n1e-1, 1e-2, 1e-4, 1e-8, 1e-16, 1e-32\\n};\\ndouble\\nstrtod (const char * nptr, char ** endptr)\\n{\\nunion {\\nunsigned long u32;\\ndouble flt;\\n} x;\\nunsigned char c;\\nint exp;\\nunsigned char flag;\\n#define FL_MINUS    0x01     \\n#define FL_ANY      0x02     \\n#define FL_OVFL     0x04     \\n#define FL_DOT      0x08     \\n#define FL_MEXP     0x10     \\nif (endptr)\\n*endptr = (char *)nptr;\\ndo {\\nc = *nptr++;\\n} while (isspace (c));\\nflag = 0;\\nif (c == '-') {\\nflag = FL_MINUS;\\nc = *nptr++;\\n} else if (c == '+') {\\nc = *nptr++;\\n}\\nif (!strncasecmp (nptr - 1, \\\"inf\\\", 3)) {\\nnptr += 2;\\nif (!strncasecmp (nptr, \\\"inity\\\", 5))\\nnptr += 5;\\nif (endptr)\\n*endptr = (char *)nptr;\\nreturn flag & FL_MINUS ? -INFINITY : +INFINITY;\\n}\\nif (!strncasecmp (nptr - 1, \\\"nan\\\", 3)) {\\nif (endptr)\\n*endptr = (char *)nptr + 2;\\nreturn NAN;\\n}\\nx.u32 = 0;\\nexp = 0;\\nwhile (1) {\\nc -= '0';\\nif (c <= 9) {\\nflag |= FL_ANY;\\nif (flag & FL_OVFL) {\\nif (!(flag & FL_DOT))\\nexp += 1;\\n} else {\\nif (flag & FL_DOT)\\nexp -= 1;\\nx.u32 = x.u32 * 10 + c;\\nif (x.u32 >= (ULONG_MAX - 9) / 10)\\nflag |= FL_OVFL;\\n}\\n} else if (c == (('.'-'0') & 0xff)  &&  !(flag & FL_DOT)) {\\nflag |= FL_DOT;\\n} else {\\nbreak;\\n}\\nc = *nptr++;\\n}\\nif (c == (('e'-'0') & 0xff) || c == (('E'-'0') & 0xff)) {\\nint i;\\nc = *nptr++;\\ni = 2;\\nif (c == '-') {\\nflag |= FL_MEXP;\\nc = *nptr++;\\n} else if (c == '+') {\\nc = *nptr++;\\n} else {\\ni = 1;\\n}\\nc -= '0';\\nif (c > 9) {\\nnptr -= i;\\n} else {\\ni = 0;\\ndo {\\nif (i < 3200)\\ni = (((i << 2) + i) << 1) + c;     \\nc = *nptr++ - '0';\\n} while (c <= 9);\\nif (flag & FL_MEXP)\\ni = -i;\\nexp += i;\\n}\\n}\\nif ((flag & FL_ANY) && endptr)\\n*endptr = (char *)nptr - 1;\\nx.flt = (double) (x.u32);         \\nif ((flag & FL_MINUS) && (flag & FL_ANY))\\nx.flt = -x.flt;\\nif (x.flt != 0) {\\nint pwr;\\nif (exp < 0) {\\nnptr = (void *)(pwr_m10 + 5);\\nexp = -exp;\\n} else {\\nnptr = (void *)(pwr_p10 + 5);\\n}\\nfor (pwr = 32; pwr; pwr >>= 1) {\\nfor (; exp >= pwr; exp -= pwr) {\\nx.flt *= *((double *)nptr);\\n}\\nnptr -= sizeof(double);\\n}\\n}\\nreturn x.flt;\\n}\",\"libraries/avrlibc/src/strtol.c\":\"#include <limits.h>\\n#include <ctype.h>\\n#include <errno.h>\\n#include <stdlib.h>\\nlong\\nstrtol(const char *nptr, char **endptr, int base)\\n{\\nunsigned long acc;\\nunsigned char c;\\nunsigned long cutoff;\\nsigned char any;\\nunsigned char flag = 0;\\n#define FL_NEG\\t0x01\\t\\t \\n#define FL_0X\\t0x02\\t\\t \\nif (endptr)\\n*endptr = (char *)nptr;\\nif (base != 0 && (base < 2 || base > 36))\\nreturn 0;\\ndo {\\nc = *nptr++;\\n} while (isspace(c));\\nif (c == '-') {\\nflag = FL_NEG;\\nc = *nptr++;\\n} else if (c == '+')\\nc = *nptr++;\\nif ((base == 0 || base == 16) &&\\nc == '0' && (*nptr == 'x' || *nptr == 'X')) {\\nc = nptr[1];\\nnptr += 2;\\nbase = 16;\\nflag |= FL_0X;\\n}\\nif (base == 0)\\nbase = c == '0' ? 8 : 10;\\n#if  LONG_MIN != -LONG_MAX - 1\\n#  error \\\"This implementation of strtol() does not work on this platform.\\\"\\n#endif\\nswitch (base) {\\ncase 10:\\ncutoff = ((unsigned long)LONG_MAX + 1) / 10;\\nbreak;\\ncase 16:\\ncutoff = ((unsigned long)LONG_MAX + 1) / 16;\\nbreak;\\ncase 8:\\ncutoff = ((unsigned long)LONG_MAX + 1) / 8;\\nbreak;\\ncase 2:\\ncutoff = ((unsigned long)LONG_MAX + 1) / 2;\\nbreak;\\ndefault:\\ncutoff = ((unsigned long)LONG_MAX + 1) / base;\\n}\\nfor (acc = 0, any = 0;; c = *nptr++) {\\nif (c >= '0' && c <= '9')\\nc -= '0';\\nelse if (c >= 'A' && c <= 'Z')\\nc -= 'A' - 10;\\nelse if (c >= 'a' && c <= 'z')\\nc -= 'a' - 10;\\nelse\\nbreak;\\nif (c >= base)\\nbreak;\\nif (any < 0)\\ncontinue;\\nif (acc > cutoff) {\\nany = -1;\\ncontinue;\\n}\\nacc = acc * base + c;\\nif (acc > (unsigned long)LONG_MAX + 1)\\nany = -1;\\nelse\\nany = 1;\\n}\\nif (endptr) {\\nif (any)\\n*endptr = (char *)nptr - 1;\\nelse if (flag & FL_0X)\\n*endptr = (char *)nptr - 2;\\n}\\nif (any < 0) {\\nacc = (flag & FL_NEG) ? LONG_MIN : LONG_MAX;\\nerrno = ERANGE;\\n} else if (flag & FL_NEG) {\\nacc = -acc;\\n} else if ((signed long)acc < 0) {\\nacc = LONG_MAX;\\nerrno = ERANGE;\\n}\\nreturn (acc);\\n}\",\"libraries/avrlibc/src/strtoul.c\":\"#include <limits.h>\\n#include <ctype.h>\\n#include <errno.h>\\n#include <stdlib.h>\\nunsigned long\\nstrtoul(const char *nptr, char **endptr, int base)\\n{\\nunsigned long acc;\\nunsigned char c;\\nunsigned long cutoff;\\nsigned char any;\\nunsigned char flag = 0;\\n#define FL_NEG\\t0x01\\t\\t \\n#define FL_0X\\t0x02\\t\\t \\nif (endptr)\\n*endptr = (char *)nptr;\\nif (base != 0 && (base < 2 || base > 36))\\nreturn 0;\\ndo {\\nc = *nptr++;\\n} while (isspace(c));\\nif (c == '-') {\\nflag = FL_NEG;\\nc = *nptr++;\\n} else if (c == '+')\\nc = *nptr++;\\nif ((base == 0 || base == 16) &&\\nc == '0' && (*nptr == 'x' || *nptr == 'X')) {\\nc = nptr[1];\\nnptr += 2;\\nbase = 16;\\nflag |= FL_0X;\\n}\\nif (base == 0)\\nbase = c == '0' ? 8 : 10;\\nswitch (base) {\\ncase 16:    cutoff = ULONG_MAX / 16;  break;\\ncase 10:    cutoff = ULONG_MAX / 10;  break;\\ncase 8:     cutoff = ULONG_MAX / 8;   break;\\ndefault:    cutoff = ULONG_MAX / base;\\n}\\nfor (acc = 0, any = 0;; c = *nptr++) {\\nif (c >= '0' && c <= '9')\\nc -= '0';\\nelse if (c >= 'A' && c <= 'Z')\\nc -= 'A' - 10;\\nelse if (c >= 'a' && c <= 'z')\\nc -= 'a' - 10;\\nelse\\nbreak;\\nif (c >= base)\\nbreak;\\nif (any < 0)\\ncontinue;\\nif (acc > cutoff) {\\nany = -1;\\ncontinue;\\n}\\nacc = acc * base + c;\\nany = (c > acc) ? -1 : 1;\\n}\\nif (endptr) {\\nif (any)\\n*endptr = (char *)nptr - 1;\\nelse if (flag & FL_0X)\\n*endptr = (char *)nptr - 2;\\n}\\nif (flag & FL_NEG)\\nacc = -acc;\\nif (any < 0) {\\nacc = ULONG_MAX;\\nerrno = ERANGE;\\n}\\nreturn (acc);\\n}\",\"libraries/avrlibc/src/vfscanf.c\":\"#ifdef FILES\\n#include <ctype.h>\\n#include <limits.h>\\n#include <math.h>\\n#include <stdarg.h>\\n#include <stddef.h>\\n#include <stdio.h>\\n#include <stdlib.h>\\n#include <string.h>\\n#define FL_STAR        0x01     \\n#define FL_WIDTH       0x02     \\n#define FL_LONG        0x04     \\n#define FL_CHAR        0x08     \\n#define FL_OCT         0x10     \\n#define FL_DEC         0x20     \\n#define FL_HEX         0x40     \\n#define FL_MINUS       0x80     \\n#define FL_SHORT       0x100\\nstatic void putval(char *addr, long val, unsigned char flags) {\\nif (!(flags & FL_STAR)) {\\nif (flags & FL_CHAR)\\n*(char *) addr = (char) val;\\nelse if (flags & FL_LONG)\\n*(long *) addr = (long) val;\\nelse if (flags & FL_SHORT)\\n*(short *) addr = (short) val;\\nelse\\n*(int *) addr = (int) val;\\n}\\n}\\nstatic unsigned char conv_int(FILE *stream, int width, void *addr, unsigned char flags) {\\nunsigned long val;\\nint i;\\ni = getc(stream);             \\nswitch ((unsigned char) i) {\\ncase '-':\\nflags |= FL_MINUS;\\ncase '+':\\nif (!--width || (i = getc(stream)) < 0)\\ngoto err;\\n}\\n{\\nval = 0;\\nflags &= ~FL_WIDTH;\\nif (!(flags & (FL_DEC | FL_OCT)) && (unsigned char) i == '0') {\\nif (!--width || (i = getc(stream)) < 0)\\ngoto putval;\\nflags |= FL_WIDTH;\\nif ((unsigned char) (i) == 'x' || (unsigned char) (i) == 'X') {\\nflags |= FL_HEX;\\nif (!--width || (i = getc(stream)) < 0)\\ngoto putval;\\n} else {\\nif (!(flags & FL_HEX))\\nflags |= FL_OCT;\\n}\\n}\\ndo {\\nunsigned char c = i;\\nc -= '0';\\nif (flags & FL_OCT) {\\nif (c > 7) {\\nungetc(i, stream);\\nbreak;\\n}\\nval = val * 8 + c;\\n} else if (flags & FL_HEX) {\\nif (c > 9) {\\nc &= ~('A' ^ 'a');\\nc += '0' - 'A';\\nif (c > 5) {\\nungetc(i, stream);\\nbreak;\\n}\\nc += 10;\\n}\\nval = val * 16 + c;\\n} else {\\nif (c > 9) {\\nungetc(i, stream);\\nbreak;\\n}\\nval = val * 10 + c;\\n}\\nflags |= FL_WIDTH;\\nif (!--width) goto putval;\\n} while ((i = getc(stream)) >= 0);\\nif (!(flags & FL_WIDTH))\\ngoto err;\\nputval:\\nif (flags & FL_MINUS) val = -(long) val;\\nputval(addr, val, flags);\\nreturn 1;\\n}\\nerr:\\nreturn 0;\\n}\\nstatic const char *conv_brk(FILE *stream, int width, char *addr, const char *fmt) {\\nunsigned char msk[32];\\nunsigned char fnegate;\\nunsigned char frange;\\nunsigned char cabove;\\nint i;\\nmemset(msk, 0, sizeof(msk));\\nfnegate = 0;\\nfrange = 0;\\ncabove = 0;             \\nfor (i = 0;; i++) {\\nunsigned char c = *(fmt++);\\nif (c == 0) {\\nreturn 0;\\n} else if (c == '^' && !i) {\\nfnegate = 1;\\ncontinue;\\n} else if (i > fnegate) {\\nif (c == ']') break;\\nif (c == '-' && !frange) {\\nfrange = 1;\\ncontinue;\\n}\\n}\\nif (!frange) cabove = c;\\nfor (;;) {\\nmsk[c >> 3] |= 1 << (c & 7);\\nif (c == cabove) break;\\nif (c < cabove)\\nc++;\\nelse\\nc--;\\n}\\nfrange = 0;\\n}\\nif (frange)\\nmsk['-' / 8] |= 1 << ('-' & 7);\\nif (fnegate) {\\nunsigned char *p = msk;\\ndo {\\nunsigned char c = *p;\\n*p++ = ~c;\\n} while (p != msk + sizeof(msk));\\n}\\nfnegate = 1;\\ndo {\\ni = getc(stream);\\nif (i < 0) break;\\nif (!((msk[(unsigned char) i >> 3] >> (i & 7)) & 1)) {\\nungetc(i, stream);\\nbreak;\\n}\\nif (addr) *addr++ = i;\\nfnegate = 0;\\n} while (--width);\\nif (fnegate) {\\nreturn 0;\\n} else {\\nif (addr) *addr = 0;\\nreturn fmt;\\n}\\n}\\nstatic const double pwr_p10[6] = {\\n1e+1, 1e+2, 1e+4, 1e+8, 1e+16, 1e+32\\n};\\nstatic const double pwr_m10[6] = {\\n1e-1, 1e-2, 1e-4, 1e-8, 1e-16, 1e-32\\n};\\nstatic const char pstr_nfinity[] = \\\"nfinity\\\";\\nstatic const char pstr_an[] = \\\"an\\\";\\nstatic unsigned char conv_flt(FILE *stream, int width, double *addr) {\\nunion {\\nunsigned long u32;\\ndouble flt;\\n} x;\\nint i;\\nconst char *p = 0;\\nint exp;\\nunsigned char flag;\\n#define FL_MINUS   0x80     \\n#define FL_ANY     0x02     \\n#define FL_OVFL    0x04     \\n#define FL_DOT     0x08     \\n#define FL_MEXP    0x10     \\ni = getc(stream);         \\nflag = 0;\\nswitch ((unsigned char) i) {\\ncase '-':\\nflag = FL_MINUS;\\ncase '+':\\nif (!--width || (i = getc(stream)) < 0)\\ngoto err;\\n}\\nswitch (tolower(i)) {\\ncase 'n':\\np = pstr_an;\\ncase 'i':\\nif (!p) p = pstr_nfinity;\\nunsigned char c;\\nwhile ((c = *(p++)) != 0) {\\nif (!--width || (i = getc(stream)) < 0 || (!((unsigned char) tolower(i) == c || !(ungetc(i, stream), 1)))) {\\nif (p == pstr_nfinity + 3) break;\\ngoto err;\\n}\\n}\\nx.flt = (p == pstr_an + 3) ? NAN : INFINITY;\\nbreak;\\ndefault:\\nexp = 0;\\nx.u32 = 0;\\ndo {\\nunsigned char c = i - '0';\\nif (c <= 9) {\\nflag |= FL_ANY;\\nif (flag & FL_OVFL) {\\nif (!(flag & FL_DOT))\\nexp += 1;\\n} else {\\nif (flag & FL_DOT)\\nexp -= 1;\\nx.u32 = x.u32 * 10 + c;\\nif (x.u32 >= (ULONG_MAX - 9) / 10)\\nflag |= FL_OVFL;\\n}\\n} else if (c == (('.' - '0') & 0xff) && !(flag & FL_DOT)) {\\nflag |= FL_DOT;\\n} else {\\nbreak;\\n}\\n} while (--width && (i = getc(stream)) >= 0);\\nif (!(flag & FL_ANY))\\ngoto err;\\nif ((unsigned char) i == 'e' || (unsigned char) i == 'E') {\\nint expacc;\\nif (!--width || (i = getc(stream)) < 0) goto err;\\nswitch ((unsigned char) i) {\\ncase '-':\\nflag |= FL_MEXP;\\ncase '+':\\nif (!--width) goto err;\\ni = getc(stream);         \\n}\\nif (!isdigit(i)) goto err;\\nexpacc = 0;\\ndo {\\nexpacc = expacc * 10 + (i - '0');\\n} while (--width && isdigit(i = getc(stream)));\\nif (flag & FL_MEXP)\\nexpacc = -expacc;\\nexp += expacc;\\n}\\nif (width && i >= 0) ungetc(i, stream);\\nx.flt = (double) (x.u32);\\nif (exp < 0) {\\np = (void *) (pwr_m10 + 5);\\nexp = -exp;\\n} else {\\np = (void *) (pwr_p10 + 5);\\n}\\nfor (width = 32; width; width >>= 1) {\\nfor (; (unsigned) exp >= width; exp -= width) {\\nx.flt *= *((double *)p);\\n}\\np = p - sizeof(double);\\n}\\n}  \\nif (flag & FL_MINUS)\\nx.flt = -x.flt;\\nif (addr) *addr = x.flt;\\nreturn 1;\\nerr:\\nreturn 0;\\n}\\nstatic int skip_spaces(FILE *stream) {\\nint i;\\ndo {\\nif ((i = getc(stream)) < 0)\\nreturn i;\\n} while (isspace(i));\\nungetc(i, stream);\\nreturn i;\\n}\\nint vfscanf(FILE *stream, const char *fmt, va_list ap) {\\nint nconvs;\\nunsigned char c;\\nint width;\\nchar *addr;\\nunsigned char flags;\\nint i;\\nnconvs = 0;\\nstream->len = 0;\\nwhile ((c = *(fmt++)) != 0) {\\nif (isspace(c)) {\\nskip_spaces(stream);\\n} else if (c != '%' || (c = *(fmt++)) == '%') {\\nif ((i = getc(stream)) < 0)\\ngoto eof;\\nif ((unsigned char) i != c) {\\nungetc(i, stream);\\nbreak;\\n}\\n} else {\\nflags = 0;\\nif (c == '*') {\\nflags = FL_STAR;\\nc = *(fmt++);\\n}\\nwidth = 0;\\nwhile ((c -= '0') < 10) {\\nflags |= FL_WIDTH;\\nwidth = width * 10 + c;\\nc = *(fmt++);\\n}\\nc += '0';\\nif (flags & FL_WIDTH) {\\nif (!width) break;\\n} else {\\nwidth = ~0;\\n}\\nswitch (c) {\\ncase 'h':\\nflags |= FL_SHORT;\\nif ((c = *(fmt++)) != 'h')\\nbreak;\\nflags |= FL_CHAR;\\nc = *(fmt++);\\nbreak;\\ncase 'l':\\nflags |= FL_LONG;\\nif ((c = *fmt++) != 'l')\\nbreak;\\nc = *(fmt++);\\n}\\nif (!c || !strchr(\\\"cdinopsuxX[efgEFG\\\", c))\\nbreak;\\naddr = (flags & FL_STAR) ? 0 : va_arg (ap, char *);\\nif (c == 'n') {\\nputval(addr, (unsigned) (stream->len), flags);\\ncontinue;\\n}\\nif (c == 'c') {\\nif (!(flags & FL_WIDTH)) width = 1;\\ndo {\\nif ((i = getc(stream)) < 0)\\ngoto eof;\\nif (addr) *(addr++) = i;\\n} while (--width);\\nc = 1;             \\n} else if (c == '[') {\\nfmt = conv_brk(stream, width, addr, fmt);\\nc = (fmt != 0);\\n} else {\\nif (skip_spaces(stream) < 0)\\ngoto eof;\\nswitch (c) {\\ncase 's':\\ndo {\\nif ((i = getc(stream)) < 0)\\nbreak;\\nif (isspace(i)) {\\nungetc(i, stream);\\nbreak;\\n}\\nif (addr) *(addr++) = i;\\n} while (--width);\\nif (addr) *(addr) = 0;\\nc = 1;         \\nbreak;\\ncase 'p':\\ncase 'x':\\ncase 'X':\\nflags |= FL_HEX;\\nc = conv_int(stream, width, (void *) addr, flags);\\nbreak;\\ncase 'd':\\ncase 'u':\\nflags |= FL_DEC;\\nc = conv_int(stream, width, (void *) addr, flags);\\nbreak;\\ncase 'o':\\nflags |= FL_OCT;\\nc = conv_int(stream, width, (void *) addr, flags);\\nbreak;\\ncase 'i':\\nc = conv_int(stream, width, (void *) addr, flags);\\nbreak;\\ndefault:         \\nif (flags & FL_LONG) {\\nc = conv_flt(stream, width, (void *) addr);\\n} else if (addr) {\\ndouble d;\\nc = conv_flt(stream, width, &d);\\n*((float*) addr) = d;\\n} else {\\nc = conv_flt(stream, width, 0);\\n}\\n}\\n}  \\nif (!c) {\\nif (feof(stream) || ferror(stream))\\ngoto eof;\\nbreak;\\n}\\nif (!(flags & FL_STAR)) nconvs += 1;\\n}  \\n}  \\nreturn nconvs;\\neof:\\nreturn nconvs ? nconvs : EOF;\\n}\\n#endif\\n\",\"libraries/musl/README.md\":\"Original: https://musl.libc.org/\\n\\nVersion used: `v1.2.1`\\n\\nLicense (for files used): MIT\\n\\n\",\"libraries/musl/src/string/memchr.c\":\"#include <string.h>\\n#include <stdint.h>\\n#include <limits.h>\\n#define SS (sizeof(size_t))\\n#define ALIGN (sizeof(size_t)-1)\\n#define ONES ((size_t)-1/UCHAR_MAX)\\n#define HIGHS (ONES * (UCHAR_MAX/2+1))\\n#define HASZERO(x) ((x)-ONES & ~(x) & HIGHS)\\nvoid *memchr(const void *src, int c, size_t n)\\n{\\nconst unsigned char *s = src;\\nc = (unsigned char)c;\\nfor (; n && *s != c; s++, n--);\\nreturn n ? (void *)s : (void *)0;\\n}\\n\",\"libraries/musl/src/string/memcmp.c\":\"#include <string.h>\\nint memcmp(const void *vl, const void *vr, size_t n)\\n{\\nconst unsigned char *l=vl, *r=vr;\\nfor (; n && *l == *r; n--, l++, r++);\\nreturn n ? *l-*r : 0;\\n}\\n\",\"libraries/musl/src/string/memmove.c\":\"#include <string.h>\\n#include <stdint.h>\\nvoid *memmove(void *dest, const void *src, size_t n)\\n{\\nchar *d = dest;\\nconst char *s = src;\\nif (d==s) return d;\\nif ((uintptr_t)s-(uintptr_t)d-n <= -2*n) return memcpy(d, s, n);\\nif (d<s) {\\nfor (; n; n--) *d++ = *s++;\\n} else {\\nwhile (n) n--, d[n] = s[n];\\n}\\nreturn dest;\\n}\\n\",\"libraries/musl/src/string/strcasecmp.c\":\"#include <strings.h>\\n#include <ctype.h>\\nint strcasecmp(const char *_l, const char *_r)\\n{\\nconst unsigned char *l=(void *)_l, *r=(void *)_r;\\nfor (; *l && *r && (*l == *r || tolower(*l) == tolower(*r)); l++, r++);\\nreturn tolower(*l) - tolower(*r);\\n}\",\"libraries/musl/src/string/strcat.c\":\"#include <string.h>\\nchar *strcat(char *dest, const char *src)\\n{\\nstrcpy(dest + strlen(dest), src);\\nreturn dest;\\n}\\n\",\"libraries/musl/src/string/strchr.c\":\"#include <string.h>\\nchar *__strchrnul(const char *s, int c);\\nchar *strchr(const char *s, int c)\\n{\\nchar *r = __strchrnul(s, c);\\nreturn *(unsigned char *)r == (unsigned char)c ? r : (char *)0;\\n}\\n\",\"libraries/musl/src/string/strchrnul.c\":\"#include <string.h>\\n#include <stdint.h>\\n#include <limits.h>\\n#define ALIGN (sizeof(size_t))\\n#define ONES ((size_t)-1/UCHAR_MAX)\\n#define HIGHS (ONES * (UCHAR_MAX/2+1))\\n#define HASZERO(x) ((x)-ONES & ~(x) & HIGHS)\\nchar *__strchrnul(const char *s, int c)\\n{\\nc = (unsigned char)c;\\nif (!c) return (char *)s + strlen(s);\\nfor (; *s && *(unsigned char *)s != c; s++);\\nreturn (char *)s;\\n}\\n\",\"libraries/musl/src/string/strcmp.c\":\"#include <string.h>\\nint strcmp(const char *l, const char *r)\\n{\\nfor (; *l==*r && *l; l++, r++);\\nreturn *(unsigned char *)l - *(unsigned char *)r;\\n}\\n\",\"libraries/musl/src/string/strcspn.c\":\"#include <string.h>\\n#define BITOP(a,b,op) \\\\\\n((a)[(size_t)(b)/(8*sizeof *(a))] op (size_t)1<<((size_t)(b)%(8*sizeof *(a))))\\nchar *__strchrnul(const char *s, int c);\\nsize_t strcspn(const char *s, const char *c)\\n{\\nconst char *a = s;\\nsize_t byteset[8];  \\nif (!c[0] || !c[1]) return (size_t) (__strchrnul(s, *c)-a);\\nmemset(byteset, 0, sizeof byteset);\\nfor (; *c && BITOP(byteset, *(unsigned char *)c, |=); c++);\\nfor (; *s && !BITOP(byteset, *(unsigned char *)s, &); s++);\\nreturn (size_t) (s-a);\\n}\\n\",\"libraries/musl/src/string/strlen.c\":\"#include <string.h>\\n#include <stdint.h>\\n#include <limits.h>\\n#define ALIGN (sizeof(size_t))\\n#define ONES ((size_t)-1/UCHAR_MAX)\\n#define HIGHS (ONES * (UCHAR_MAX/2+1))\\n#define HASZERO(x) ((x)-ONES & ~(x) & HIGHS)\\nsize_t strlen(const char *s)\\n{\\nconst char *a = s;\\nfor (; *s; s++);\\nreturn (size_t) (s-a);\\n}\\n\",\"libraries/musl/src/string/strncasecmp.c\":\"#include <strings.h>\\n#include <ctype.h>\\nint strncasecmp(const char *_l, const char *_r, size_t n)\\n{\\nconst unsigned char *l=(void *)_l, *r=(void *)_r;\\nif (!n--) return 0;\\nfor (; *l && *r && n && (*l == *r || tolower(*l) == tolower(*r)); l++, r++, n--);\\nreturn tolower(*l) - tolower(*r);\\n}\",\"libraries/musl/src/string/strncat.c\":\"#include <string.h>\\nchar *strncat(char *d, const char *s, size_t n)\\n{\\nchar *a = d;\\nd += strlen(d);\\nwhile (n && *s) n--, *d++ = *s++;\\n*d++ = 0;\\nreturn a;\\n}\\n\",\"libraries/musl/src/string/strncmp.c\":\"#include <string.h>\\nint strncmp(const char *_l, const char *_r, size_t n)\\n{\\nconst unsigned char *l=(void *)_l, *r=(void *)_r;\\nif (!n--) return 0;\\nfor (; *l && *r && n && *l == *r ; l++, r++, n--);\\nreturn *l - *r;\\n}\\n\",\"libraries/musl/src/string/strnlen.c\":\"#include <string.h>\\nsize_t strnlen(const char *s, size_t n)\\n{\\nconst char *p = memchr(s, 0, n);\\nreturn p ? (size_t) (p-s) : n;\\n}\\n\",\"libraries/musl/src/string/strpbrk.c\":\"#include <string.h>\\nchar *strpbrk(const char *s, const char *b)\\n{\\ns += strcspn(s, b);\\nreturn *s ? (char *)s : (char *) 0;\\n}\\n\",\"libraries/musl/src/string/strrchr.c\":\"#include <string.h>\\nvoid *__memrchr(const void *m, int c, size_t n)\\n{\\nconst unsigned char *s = m;\\nc = (unsigned char)c;\\nwhile (n--) if (s[n]==c) return (void *)(s+n);\\nreturn 0;\\n}\\nchar *strrchr(const char *s, int c)\\n{\\nreturn __memrchr(s, c, strlen(s) + 1);\\n}\\n\",\"libraries/musl/src/string/strspn.c\":\"#include <string.h>\\n#define BITOP(a,b,op) \\\\\\n((a)[(size_t)(b)/(8*sizeof *(a))] op (size_t)1<<((size_t)(b)%(8*sizeof *(a))))\\nsize_t strspn(const char *s, const char *c)\\n{\\nconst char *a = s;\\nsize_t byteset[8] = { 0 };\\nif (!c[0]) return 0;\\nif (!c[1]) {\\nfor (; *s == *c; s++);\\nreturn (size_t) (s-a);\\n}\\nfor (; *c && BITOP(byteset, *(unsigned char *)c, |=); c++);\\nfor (; *s && BITOP(byteset, *(unsigned char *)s, &); s++);\\nreturn (size_t) (s-a);\\n}\\n\",\"libraries/musl/src/string/strstr.c\":\"#include <string.h>\\n#include <stdint.h>\\nstatic char *twobyte_strstr(const unsigned char *h, const unsigned char *n)\\n{\\nuint16_t nw = n[0]<<8 | n[1], hw = h[0]<<8 | h[1];\\nfor (h++; *h && hw != nw; hw = hw<<8 | *++h);\\nreturn *h ? (char *)h-1 : (char *) 0;\\n}\\nstatic char *threebyte_strstr(const unsigned char *h, const unsigned char *n)\\n{\\nuint32_t nw = (uint32_t)n[0]<<24 | n[1]<<16 | n[2]<<8;\\nuint32_t hw = (uint32_t)h[0]<<24 | h[1]<<16 | h[2]<<8;\\nfor (h+=2; *h && hw != nw; hw = (hw|*++h)<<8);\\nreturn *h ? (char *)h-2 : (char *) 0;\\n}\\nstatic char *fourbyte_strstr(const unsigned char *h, const unsigned char *n)\\n{\\nuint32_t nw = (uint32_t)n[0]<<24 | n[1]<<16 | n[2]<<8 | n[3];\\nuint32_t hw = (uint32_t)h[0]<<24 | h[1]<<16 | h[2]<<8 | h[3];\\nfor (h+=3; *h && hw != nw; hw = hw<<8 | *++h);\\nreturn *h ? (char *)h-3 : (char *) 0;\\n}\\n#define MAX(a,b) ((a)>(b)?(a):(b))\\n#define MIN(a,b) ((a)<(b)?(a):(b))\\n#define BITOP(a,b,op) \\\\\\n((a)[(size_t)(b)/(8*sizeof *(a))] op (size_t)1<<((size_t)(b)%(8*sizeof *(a))))\\nstatic char *twoway_strstr(const unsigned char *h, const unsigned char *n)\\n{\\nconst unsigned char *z;\\nsize_t l, ip, jp, k, p, ms, p0, mem, mem0;\\nsize_t byteset[8] = { 0 };\\nsize_t shift[256];\\nfor (l=0; n[l] && h[l]; l++)\\nBITOP(byteset, n[l], |=), shift[n[l]] = l+1;\\nif (n[l]) return 0;  \\nip = -1; jp = 0; k = p = 1;\\nwhile (jp+k<l) {\\nif (n[ip+k] == n[jp+k]) {\\nif (k == p) {\\njp += p;\\nk = 1;\\n} else k++;\\n} else if (n[ip+k] > n[jp+k]) {\\njp += k;\\nk = 1;\\np = jp - ip;\\n} else {\\nip = jp++;\\nk = p = 1;\\n}\\n}\\nms = ip;\\np0 = p;\\nip = -1; jp = 0; k = p = 1;\\nwhile (jp+k<l) {\\nif (n[ip+k] == n[jp+k]) {\\nif (k == p) {\\njp += p;\\nk = 1;\\n} else k++;\\n} else if (n[ip+k] < n[jp+k]) {\\njp += k;\\nk = 1;\\np = jp - ip;\\n} else {\\nip = jp++;\\nk = p = 1;\\n}\\n}\\nif (ip+1 > ms+1) ms = ip;\\nelse p = p0;\\nif (memcmp(n, n+p, ms+1)) {\\nmem0 = 0;\\np = MAX(ms, l-ms-1) + 1;\\n} else mem0 = l-p;\\nmem = 0;\\nz = h;\\nfor (;;) {\\nif (z-h < l) {\\nsize_t grow = l | 63;\\nconst unsigned char *z2 = memchr(z, 0, grow);\\nif (z2) {\\nz = z2;\\nif (z-h < l) return 0;\\n} else z += grow;\\n}\\nif (BITOP(byteset, h[l-1], &)) {\\nk = l-shift[h[l-1]];\\nif (k) {\\nif (k < mem) k = mem;\\nh += k;\\nmem = 0;\\ncontinue;\\n}\\n} else {\\nh += l;\\nmem = 0;\\ncontinue;\\n}\\nfor (k=MAX(ms+1,mem); n[k] && n[k] == h[k]; k++);\\nif (n[k]) {\\nh += k-ms;\\nmem = 0;\\ncontinue;\\n}\\nfor (k=ms+1; k>mem && n[k-1] == h[k-1]; k--);\\nif (k <= mem) return (char *)h;\\nh += p;\\nmem = mem0;\\n}\\nreturn 0;\\n}\\nchar *strstr(const char *h, const char *n)\\n{\\nif (!n[0]) return (char *)h;\\nh = strchr(h, *n);\\nif (!h || !n[1]) return (char *)h;\\nif (!h[1]) return 0;\\nif (!n[2]) return twobyte_strstr((void *)h, (void *)n);\\nif (!h[2]) return 0;\\nif (!n[3]) return threebyte_strstr((void *)h, (void *)n);\\nif (!h[3]) return 0;\\nif (!n[4]) return fourbyte_strstr((void *)h, (void *)n);\\nreturn twoway_strstr((void *)h, (void *)n);\\n}\\n\",\"libraries/musl/src/string/strtok.c\":\"#include <string.h>\\nchar *strtok(char *s, const char *sep)\\n{\\nstatic char *p;\\nif (!s && !(s = p)) return NULL;\\ns += strspn(s, sep);\\nif (!*s) return p = 0;\\np = s + strcspn(s, sep);\\nif (*p) *p++ = 0;\\nelse p = 0;\\nreturn s;\\n}\\n\",\"libraries/printf/LICENSE\":\"The MIT License (MIT)\\n\\nCopyright (c) 2014 Marco Paland\\n\\nPermission is hereby granted, free of charge, to any person obtaining a copy\\nof this software and associated documentation files (the \\\"Software\\\"), to deal\\nin the Software without restriction, including without limitation the rights\\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\ncopies of the Software, and to permit persons to whom the Software is\\nfurnished to do so, subject to the following conditions:\\n\\nThe above copyright notice and this permission notice shall be included in all\\ncopies or substantial portions of the Software.\\n\\nTHE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\nSOFTWARE.\\n\",\"libraries/printf/README.md\":\"Original: https://github.com/mpaland/printf\\n\\nCommit used: `d3b984684bb8a8bdc48cc7a1abecb93ce59bbe3e`\\n\\nLicense: MIT\\n\\nFiles:\\n- `printf.c` custom fprintf implementation added to the end of the file, but otherwise unmodified\\n- `printf.h` custom\\n\\n\",\"libraries/printf/printf.c\":\"#include <stdbool.h>\\n#include <stdint.h>\\n#include \\\"printf.h\\\"\\n#ifdef PRINTF_INCLUDE_CONFIG_H\\n#include \\\"printf_config.h\\\"\\n#endif\\n#ifndef PRINTF_NTOA_BUFFER_SIZE\\n#define PRINTF_NTOA_BUFFER_SIZE    32U\\n#endif\\n#ifndef PRINTF_FTOA_BUFFER_SIZE\\n#define PRINTF_FTOA_BUFFER_SIZE    32U\\n#endif\\n#ifndef PRINTF_DISABLE_SUPPORT_FLOAT\\n#define PRINTF_SUPPORT_FLOAT\\n#endif\\n#ifndef PRINTF_DISABLE_SUPPORT_EXPONENTIAL\\n#define PRINTF_SUPPORT_EXPONENTIAL\\n#endif\\n#ifndef PRINTF_DEFAULT_FLOAT_PRECISION\\n#define PRINTF_DEFAULT_FLOAT_PRECISION  6U\\n#endif\\n#ifndef PRINTF_MAX_FLOAT\\n#define PRINTF_MAX_FLOAT  1e9\\n#endif\\n#ifndef PRINTF_DISABLE_SUPPORT_LONG_LONG\\n#define PRINTF_SUPPORT_LONG_LONG\\n#endif\\n#ifndef PRINTF_DISABLE_SUPPORT_PTRDIFF_T\\n#define PRINTF_SUPPORT_PTRDIFF_T\\n#endif\\n#define FLAGS_ZEROPAD   (1U <<  0U)\\n#define FLAGS_LEFT      (1U <<  1U)\\n#define FLAGS_PLUS      (1U <<  2U)\\n#define FLAGS_SPACE     (1U <<  3U)\\n#define FLAGS_HASH      (1U <<  4U)\\n#define FLAGS_UPPERCASE (1U <<  5U)\\n#define FLAGS_CHAR      (1U <<  6U)\\n#define FLAGS_SHORT     (1U <<  7U)\\n#define FLAGS_LONG      (1U <<  8U)\\n#define FLAGS_LONG_LONG (1U <<  9U)\\n#define FLAGS_PRECISION (1U << 10U)\\n#define FLAGS_ADAPT_EXP (1U << 11U)\\n#if defined(PRINTF_SUPPORT_FLOAT)\\n#include <float.h>\\n#endif\\ntypedef void (*out_fct_type)(char character, void* buffer, size_t idx, size_t maxlen);\\ntypedef struct {\\nvoid  (*fct)(char character, void* arg);\\nvoid* arg;\\n} out_fct_wrap_type;\\nstatic inline void _out_buffer(char character, void* buffer, size_t idx, size_t maxlen)\\n{\\nif (idx < maxlen) {\\n((char*)buffer)[idx] = character;\\n}\\n}\\nstatic inline void _out_null(char character, void* buffer, size_t idx, size_t maxlen)\\n{\\n(void)character; (void)buffer; (void)idx; (void)maxlen;\\n}\\nstatic inline void _out_char(char character, void* buffer, size_t idx, size_t maxlen)\\n{\\n(void)buffer; (void)idx; (void)maxlen;\\nif (character) {\\n_putchar(character);\\n}\\n}\\nstatic inline void _out_fct(char character, void* buffer, size_t idx, size_t maxlen)\\n{\\n(void)idx; (void)maxlen;\\nif (character) {\\n((out_fct_wrap_type*)buffer)->fct(character, ((out_fct_wrap_type*)buffer)->arg);\\n}\\n}\\nstatic inline unsigned int _strnlen_s(const char* str, size_t maxsize)\\n{\\nconst char* s;\\nfor (s = str; *s && maxsize--; ++s);\\nreturn (unsigned int)(s - str);\\n}\\nstatic inline bool _is_digit(char ch)\\n{\\nreturn (ch >= '0') && (ch <= '9');\\n}\\nstatic unsigned int _atoi(const char** str)\\n{\\nunsigned int i = 0U;\\nwhile (_is_digit(**str)) {\\ni = i * 10U + (unsigned int)(*((*str)++) - '0');\\n}\\nreturn i;\\n}\\nstatic size_t _out_rev(out_fct_type out, char* buffer, size_t idx, size_t maxlen, const char* buf, size_t len, unsigned int width, unsigned int flags)\\n{\\nconst size_t start_idx = idx;\\nif (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {\\nfor (size_t i = len; i < width; i++) {\\nout(' ', buffer, idx++, maxlen);\\n}\\n}\\nwhile (len) {\\nout(buf[--len], buffer, idx++, maxlen);\\n}\\nif (flags & FLAGS_LEFT) {\\nwhile (idx - start_idx < width) {\\nout(' ', buffer, idx++, maxlen);\\n}\\n}\\nreturn idx;\\n}\\nstatic size_t _ntoa_format(out_fct_type out, char* buffer, size_t idx, size_t maxlen, char* buf, size_t len, bool negative, unsigned int base, unsigned int prec, unsigned int width, unsigned int flags)\\n{\\nif (!(flags & FLAGS_LEFT)) {\\nif (width && (flags & FLAGS_ZEROPAD) && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {\\nwidth--;\\n}\\nwhile ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {\\nbuf[len++] = '0';\\n}\\nwhile ((flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {\\nbuf[len++] = '0';\\n}\\n}\\nif (flags & FLAGS_HASH) {\\nif (!(flags & FLAGS_PRECISION) && len && ((len == prec) || (len == width))) {\\nlen--;\\nif (len && (base == 16U)) {\\nlen--;\\n}\\n}\\nif ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {\\nbuf[len++] = 'x';\\n}\\nelse if ((base == 16U) && (flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {\\nbuf[len++] = 'X';\\n}\\nelse if ((base == 2U) && (len < PRINTF_NTOA_BUFFER_SIZE)) {\\nbuf[len++] = 'b';\\n}\\nif (len < PRINTF_NTOA_BUFFER_SIZE) {\\nbuf[len++] = '0';\\n}\\n}\\nif (len < PRINTF_NTOA_BUFFER_SIZE) {\\nif (negative) {\\nbuf[len++] = '-';\\n}\\nelse if (flags & FLAGS_PLUS) {\\nbuf[len++] = '+';   \\n}\\nelse if (flags & FLAGS_SPACE) {\\nbuf[len++] = ' ';\\n}\\n}\\nreturn _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);\\n}\\nstatic size_t _ntoa_long(out_fct_type out, char* buffer, size_t idx, size_t maxlen, unsigned long value, bool negative, unsigned long base, unsigned int prec, unsigned int width, unsigned int flags)\\n{\\nchar buf[PRINTF_NTOA_BUFFER_SIZE];\\nsize_t len = 0U;\\nif (!value) {\\nflags &= ~FLAGS_HASH;\\n}\\nif (!(flags & FLAGS_PRECISION) || value) {\\ndo {\\nconst char digit = (char)(value % base);\\nbuf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;\\nvalue /= base;\\n} while (value && (len < PRINTF_NTOA_BUFFER_SIZE));\\n}\\nreturn _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int)base, prec, width, flags);\\n}\\n#if defined(PRINTF_SUPPORT_LONG_LONG)\\nstatic size_t _ntoa_long_long(out_fct_type out, char* buffer, size_t idx, size_t maxlen, unsigned long long value, bool negative, unsigned long long base, unsigned int prec, unsigned int width, unsigned int flags)\\n{\\nchar buf[PRINTF_NTOA_BUFFER_SIZE];\\nsize_t len = 0U;\\nif (!value) {\\nflags &= ~FLAGS_HASH;\\n}\\nif (!(flags & FLAGS_PRECISION) || value) {\\ndo {\\nconst char digit = (char)(value % base);\\nbuf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;\\nvalue /= base;\\n} while (value && (len < PRINTF_NTOA_BUFFER_SIZE));\\n}\\nreturn _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int)base, prec, width, flags);\\n}\\n#endif   \\n#if defined(PRINTF_SUPPORT_FLOAT)\\n#if defined(PRINTF_SUPPORT_EXPONENTIAL)\\nstatic size_t _etoa(out_fct_type out, char* buffer, size_t idx, size_t maxlen, double value, unsigned int prec, unsigned int width, unsigned int flags);\\n#endif\\nstatic size_t _ftoa(out_fct_type out, char* buffer, size_t idx, size_t maxlen, double value, unsigned int prec, unsigned int width, unsigned int flags)\\n{\\nchar buf[PRINTF_FTOA_BUFFER_SIZE];\\nsize_t len  = 0U;\\ndouble diff = 0.0;\\nstatic const double pow10[] = { 1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000 };\\nif (value != value)\\nreturn _out_rev(out, buffer, idx, maxlen, \\\"nan\\\", 3, width, flags);\\nif (value < -DBL_MAX)\\nreturn _out_rev(out, buffer, idx, maxlen, \\\"fni-\\\", 4, width, flags);\\nif (value > DBL_MAX)\\nreturn _out_rev(out, buffer, idx, maxlen, (flags & FLAGS_PLUS) ? \\\"fni+\\\" : \\\"fni\\\", (flags & FLAGS_PLUS) ? 4U : 3U, width, flags);\\nif ((value > PRINTF_MAX_FLOAT) || (value < -PRINTF_MAX_FLOAT)) {\\n#if defined(PRINTF_SUPPORT_EXPONENTIAL)\\nreturn _etoa(out, buffer, idx, maxlen, value, prec, width, flags);\\n#else\\nreturn 0U;\\n#endif\\n}\\nbool negative = false;\\nif (value < 0) {\\nnegative = true;\\nvalue = 0 - value;\\n}\\nif (!(flags & FLAGS_PRECISION)) {\\nprec = PRINTF_DEFAULT_FLOAT_PRECISION;\\n}\\nwhile ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {\\nbuf[len++] = '0';\\nprec--;\\n}\\nint whole = (int)value;\\ndouble tmp = (value - whole) * pow10[prec];\\nunsigned long frac = (unsigned long)tmp;\\ndiff = tmp - frac;\\nif (diff > 0.5) {\\n++frac;\\nif (frac >= pow10[prec]) {\\nfrac = 0;\\n++whole;\\n}\\n}\\nelse if (diff < 0.5) {\\n}\\nelse if ((frac == 0U) || (frac & 1U)) {\\n++frac;\\n}\\nif (prec == 0U) {\\ndiff = value - (double)whole;\\nif ((!(diff < 0.5) || (diff > 0.5)) && (whole & 1)) {\\n++whole;\\n}\\n}\\nelse {\\nunsigned int count = prec;\\nwhile (len < PRINTF_FTOA_BUFFER_SIZE) {\\n--count;\\nbuf[len++] = (char)(48U + (frac % 10U));\\nif (!(frac /= 10U)) {\\nbreak;\\n}\\n}\\nwhile ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {\\nbuf[len++] = '0';\\n}\\nif (len < PRINTF_FTOA_BUFFER_SIZE) {\\nbuf[len++] = '.';\\n}\\n}\\nwhile (len < PRINTF_FTOA_BUFFER_SIZE) {\\nbuf[len++] = (char)(48 + (whole % 10));\\nif (!(whole /= 10)) {\\nbreak;\\n}\\n}\\nif (!(flags & FLAGS_LEFT) && (flags & FLAGS_ZEROPAD)) {\\nif (width && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {\\nwidth--;\\n}\\nwhile ((len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {\\nbuf[len++] = '0';\\n}\\n}\\nif (len < PRINTF_FTOA_BUFFER_SIZE) {\\nif (negative) {\\nbuf[len++] = '-';\\n}\\nelse if (flags & FLAGS_PLUS) {\\nbuf[len++] = '+';   \\n}\\nelse if (flags & FLAGS_SPACE) {\\nbuf[len++] = ' ';\\n}\\n}\\nreturn _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);\\n}\\n#if defined(PRINTF_SUPPORT_EXPONENTIAL)\\nstatic size_t _etoa(out_fct_type out, char* buffer, size_t idx, size_t maxlen, double value, unsigned int prec, unsigned int width, unsigned int flags)\\n{\\nif ((value != value) || (value > DBL_MAX) || (value < -DBL_MAX)) {\\nreturn _ftoa(out, buffer, idx, maxlen, value, prec, width, flags);\\n}\\nconst bool negative = value < 0;\\nif (negative) {\\nvalue = -value;\\n}\\nif (!(flags & FLAGS_PRECISION)) {\\nprec = PRINTF_DEFAULT_FLOAT_PRECISION;\\n}\\nunion {\\nuint64_t U;\\ndouble   F;\\n} conv;\\nconv.F = value;\\nint exp2 = (int)((conv.U >> 52U) & 0x07FFU) - 1023;            \\nconv.U = (conv.U & ((1ULL << 52U) - 1U)) | (1023ULL << 52U);   \\nint expval = (int)(0.1760912590558 + exp2 * 0.301029995663981 + (conv.F - 1.5) * 0.289529654602168);\\nexp2 = (int)(expval * 3.321928094887362 + 0.5);\\nconst double z  = expval * 2.302585092994046 - exp2 * 0.6931471805599453;\\nconst double z2 = z * z;\\nconv.U = (uint64_t)(exp2 + 1023) << 52U;\\nconv.F *= 1 + 2 * z / (2 - z + (z2 / (6 + (z2 / (10 + z2 / 14)))));\\nif (value < conv.F) {\\nexpval--;\\nconv.F /= 10;\\n}\\nunsigned int minwidth = ((expval < 100) && (expval > -100)) ? 4U : 5U;\\nif (flags & FLAGS_ADAPT_EXP) {\\nif ((value >= 1e-4) && (value < 1e6)) {\\nif ((int)prec > expval) {\\nprec = (unsigned)((int)prec - expval - 1);\\n}\\nelse {\\nprec = 0;\\n}\\nflags |= FLAGS_PRECISION;    \\nminwidth = 0U;\\nexpval   = 0;\\n}\\nelse {\\nif ((prec > 0) && (flags & FLAGS_PRECISION)) {\\n--prec;\\n}\\n}\\n}\\nunsigned int fwidth = width;\\nif (width > minwidth) {\\nfwidth -= minwidth;\\n} else {\\nfwidth = 0U;\\n}\\nif ((flags & FLAGS_LEFT) && minwidth) {\\nfwidth = 0U;\\n}\\nif (expval) {\\nvalue /= conv.F;\\n}\\nconst size_t start_idx = idx;\\nidx = _ftoa(out, buffer, idx, maxlen, negative ? -value : value, prec, fwidth, flags & ~FLAGS_ADAPT_EXP);\\nif (minwidth) {\\nout((flags & FLAGS_UPPERCASE) ? 'E' : 'e', buffer, idx++, maxlen);\\nidx = _ntoa_long(out, buffer, idx, maxlen, (expval < 0) ? -expval : expval, expval < 0, 10, 0, minwidth-1, FLAGS_ZEROPAD | FLAGS_PLUS);\\nif (flags & FLAGS_LEFT) {\\nwhile (idx - start_idx < width) out(' ', buffer, idx++, maxlen);\\n}\\n}\\nreturn idx;\\n}\\n#endif   \\n#endif   \\nstatic int _vsnprintf(out_fct_type out, char* buffer, const size_t maxlen, const char* format, va_list va)\\n{\\nunsigned int flags, width, precision, n;\\nsize_t idx = 0U;\\nif (!buffer) {\\nout = _out_null;\\n}\\nwhile (*format)\\n{\\nif (*format != '%') {\\nout(*format, buffer, idx++, maxlen);\\nformat++;\\ncontinue;\\n}\\nelse {\\nformat++;\\n}\\nflags = 0U;\\ndo {\\nswitch (*format) {\\ncase '0': flags |= FLAGS_ZEROPAD; format++; n = 1U; break;\\ncase '-': flags |= FLAGS_LEFT;    format++; n = 1U; break;\\ncase '+': flags |= FLAGS_PLUS;    format++; n = 1U; break;\\ncase ' ': flags |= FLAGS_SPACE;   format++; n = 1U; break;\\ncase '#': flags |= FLAGS_HASH;    format++; n = 1U; break;\\ndefault :                                   n = 0U; break;\\n}\\n} while (n);\\nwidth = 0U;\\nif (_is_digit(*format)) {\\nwidth = _atoi(&format);\\n}\\nelse if (*format == '*') {\\nconst int w = va_arg(va, int);\\nif (w < 0) {\\nflags |= FLAGS_LEFT;     \\nwidth = (unsigned int)-w;\\n}\\nelse {\\nwidth = (unsigned int)w;\\n}\\nformat++;\\n}\\nprecision = 0U;\\nif (*format == '.') {\\nflags |= FLAGS_PRECISION;\\nformat++;\\nif (_is_digit(*format)) {\\nprecision = _atoi(&format);\\n}\\nelse if (*format == '*') {\\nconst int prec = (int)va_arg(va, int);\\nprecision = prec > 0 ? (unsigned int)prec : 0U;\\nformat++;\\n}\\n}\\nswitch (*format) {\\ncase 'l' :\\nflags |= FLAGS_LONG;\\nformat++;\\nif (*format == 'l') {\\nflags |= FLAGS_LONG_LONG;\\nformat++;\\n}\\nbreak;\\ncase 'h' :\\nflags |= FLAGS_SHORT;\\nformat++;\\nif (*format == 'h') {\\nflags |= FLAGS_CHAR;\\nformat++;\\n}\\nbreak;\\n#if defined(PRINTF_SUPPORT_PTRDIFF_T)\\ncase 't' :\\nflags |= (sizeof(ptrdiff_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);\\nformat++;\\nbreak;\\n#endif\\ncase 'j' :\\nflags |= (sizeof(intmax_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);\\nformat++;\\nbreak;\\ncase 'z' :\\nflags |= (sizeof(size_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);\\nformat++;\\nbreak;\\ndefault :\\nbreak;\\n}\\nswitch (*format) {\\ncase 'd' :\\ncase 'i' :\\ncase 'u' :\\ncase 'x' :\\ncase 'X' :\\ncase 'o' :\\ncase 'b' : {\\nunsigned int base;\\nif (*format == 'x' || *format == 'X') {\\nbase = 16U;\\n}\\nelse if (*format == 'o') {\\nbase =  8U;\\n}\\nelse if (*format == 'b') {\\nbase =  2U;\\n}\\nelse {\\nbase = 10U;\\nflags &= ~FLAGS_HASH;    \\n}\\nif (*format == 'X') {\\nflags |= FLAGS_UPPERCASE;\\n}\\nif ((*format != 'i') && (*format != 'd')) {\\nflags &= ~(FLAGS_PLUS | FLAGS_SPACE);\\n}\\nif (flags & FLAGS_PRECISION) {\\nflags &= ~FLAGS_ZEROPAD;\\n}\\nif ((*format == 'i') || (*format == 'd')) {\\nif (flags & FLAGS_LONG_LONG) {\\n#if defined(PRINTF_SUPPORT_LONG_LONG)\\nconst long long value = va_arg(va, long long);\\nidx = _ntoa_long_long(out, buffer, idx, maxlen, (unsigned long long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);\\n#endif\\n}\\nelse if (flags & FLAGS_LONG) {\\nconst long value = va_arg(va, long);\\nidx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);\\n}\\nelse {\\nconst int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);\\nidx = _ntoa_long(out, buffer, idx, maxlen, (unsigned int)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);\\n}\\n}\\nelse {\\nif (flags & FLAGS_LONG_LONG) {\\n#if defined(PRINTF_SUPPORT_LONG_LONG)\\nidx = _ntoa_long_long(out, buffer, idx, maxlen, va_arg(va, unsigned long long), false, base, precision, width, flags);\\n#endif\\n}\\nelse if (flags & FLAGS_LONG) {\\nidx = _ntoa_long(out, buffer, idx, maxlen, va_arg(va, unsigned long), false, base, precision, width, flags);\\n}\\nelse {\\nconst unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);\\nidx = _ntoa_long(out, buffer, idx, maxlen, value, false, base, precision, width, flags);\\n}\\n}\\nformat++;\\nbreak;\\n}\\n#if defined(PRINTF_SUPPORT_FLOAT)\\ncase 'f' :\\ncase 'F' :\\nif (*format == 'F') flags |= FLAGS_UPPERCASE;\\nidx = _ftoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);\\nformat++;\\nbreak;\\n#if defined(PRINTF_SUPPORT_EXPONENTIAL)\\ncase 'e':\\ncase 'E':\\ncase 'g':\\ncase 'G':\\nif ((*format == 'g')||(*format == 'G')) flags |= FLAGS_ADAPT_EXP;\\nif ((*format == 'E')||(*format == 'G')) flags |= FLAGS_UPPERCASE;\\nidx = _etoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);\\nformat++;\\nbreak;\\n#endif   \\n#endif   \\ncase 'c' : {\\nunsigned int l = 1U;\\nif (!(flags & FLAGS_LEFT)) {\\nwhile (l++ < width) {\\nout(' ', buffer, idx++, maxlen);\\n}\\n}\\nout((char)va_arg(va, int), buffer, idx++, maxlen);\\nif (flags & FLAGS_LEFT) {\\nwhile (l++ < width) {\\nout(' ', buffer, idx++, maxlen);\\n}\\n}\\nformat++;\\nbreak;\\n}\\ncase 's' : {\\nconst char* p = va_arg(va, char*);\\nunsigned int l = _strnlen_s(p, precision ? precision : (size_t)-1);\\nif (flags & FLAGS_PRECISION) {\\nl = (l < precision ? l : precision);\\n}\\nif (!(flags & FLAGS_LEFT)) {\\nwhile (l++ < width) {\\nout(' ', buffer, idx++, maxlen);\\n}\\n}\\nwhile ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {\\nout(*(p++), buffer, idx++, maxlen);\\n}\\nif (flags & FLAGS_LEFT) {\\nwhile (l++ < width) {\\nout(' ', buffer, idx++, maxlen);\\n}\\n}\\nformat++;\\nbreak;\\n}\\ncase 'p' : {\\nwidth = sizeof(void*) * 2U;\\nflags |= FLAGS_ZEROPAD | FLAGS_UPPERCASE;\\n#if defined(PRINTF_SUPPORT_LONG_LONG)\\nconst bool is_ll = sizeof(uintptr_t) == sizeof(long long);\\nif (is_ll) {\\nidx = _ntoa_long_long(out, buffer, idx, maxlen, (uintptr_t)va_arg(va, void*), false, 16U, precision, width, flags);\\n}\\nelse {\\n#endif\\nidx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)((uintptr_t)va_arg(va, void*)), false, 16U, precision, width, flags);\\n#if defined(PRINTF_SUPPORT_LONG_LONG)\\n}\\n#endif\\nformat++;\\nbreak;\\n}\\ncase '%' :\\nout('%', buffer, idx++, maxlen);\\nformat++;\\nbreak;\\ndefault :\\nout(*format, buffer, idx++, maxlen);\\nformat++;\\nbreak;\\n}\\n}\\nout((char)0, buffer, idx < maxlen ? idx : maxlen - 1U, maxlen);\\nreturn (int)idx;\\n}\\nint printf_(const char* format, ...)\\n{\\nva_list va;\\nva_start(va, format);\\nchar buffer[1];\\nconst int ret = _vsnprintf(_out_char, buffer, (size_t)-1, format, va);\\nva_end(va);\\nreturn ret;\\n}\\nint sprintf_(char* buffer, const char* format, ...)\\n{\\nva_list va;\\nva_start(va, format);\\nconst int ret = _vsnprintf(_out_buffer, buffer, (size_t)-1, format, va);\\nva_end(va);\\nreturn ret;\\n}\\nint snprintf_(char* buffer, size_t count, const char* format, ...)\\n{\\nva_list va;\\nva_start(va, format);\\nconst int ret = _vsnprintf(_out_buffer, buffer, count, format, va);\\nva_end(va);\\nreturn ret;\\n}\\nint vprintf_(const char* format, va_list va)\\n{\\nchar buffer[1];\\nreturn _vsnprintf(_out_char, buffer, (size_t)-1, format, va);\\n}\\nint vsnprintf_(char* buffer, size_t count, const char* format, va_list va)\\n{\\nreturn _vsnprintf(_out_buffer, buffer, count, format, va);\\n}\\nint fctprintf(void (*out)(char character, void* arg), void* arg, const char* format, ...)\\n{\\nva_list va;\\nva_start(va, format);\\nconst out_fct_wrap_type out_fct_wrap = { out, arg };\\nconst int ret = _vsnprintf(_out_fct, (char*)(uintptr_t)&out_fct_wrap, (size_t)-1, format, va);\\nva_end(va);\\nreturn ret;\\n}\\n#include <stdio.h>\\n#ifdef FILES\\nstatic void _fprintf_out(char character, void* arg) {\\nfputc(character, (FILE*) arg);\\n}\\nint fprintf(FILE *stream, const char *format, ...) {\\nva_list va;\\nva_start(va, format);\\nconst out_fct_wrap_type out_fct_wrap = { _fprintf_out, stream};\\nconst int ret = _vsnprintf(_out_fct, (char*)(uintptr_t)&out_fct_wrap, (size_t)-1, format, va);\\nva_end(va);\\nreturn ret;\\n}\\n#endif\\n\",\"libraries/printf/printf.h\":\"#include <stdio.h>\\n#define _putchar putchar\\n#define printf_ printf\\n#define sprintf_ sprintf\\n#define snprintf_ snprintf\\n#define vprintf_ vprintf\\n#define vsnprintf_ vsnprintf\\n\",\"limits.h\":\"#pragma once\\n#define CHAR_BIT 8\\n#define CHAR_MAX 255\\n#define CHAR_MIN 0\\n#define INT_MAX 2147483647\\n#define INT_MIN -2147483648\\n#define LONG_MAX 9223372036854775807\\n#define LONG_MIN -9223372036854775808\\n#define LLONG_MAX 9223372036854775807\\n#define LLONG_MIN -9223372036854775808\\n#define SCHAR_MAX 127\\n#define SCHAR_MIN -128\\n#define SHRT_MAX 32767\\n#define SHRT_MIN -32768\\n#define UCHAR_MAX 255\\n#define USHRT_MAX 65535\\n#define UINT_MAX 4294967295\\n#define ULONG_MAX 18446744073709551615\\n#define ULLONG_MAX 18446744073709551615\\n\",\"math.h\":\"#pragma once\\ndouble sqrt(double);\\ndouble ceil(double);\\ndouble fabs(double);\\ndouble floor(double);\\ndouble fmax(double, double);\\ndouble fmin(double, double);\\ndouble trunc(double);\\ndouble copysign(double, double);\\ndouble round(double);  \\ndouble exp(double);\\n#define INFINITY (1./0)\\n#define NAN (0./0)\\n\",\"stdarg.h\":\"#pragma once\\ntypedef char *va_list;\\n#define va_start(ap, parmN) ( ap = (char*) __wasm_ssp__() )\\n#define va_arg(ap, T) ( ap -= 8, *((T*) __wasm_rload__((T *) ap)) )\\n#define va_copy(dst, src) ( dst = src )\\n#define va_end(ap) \\\"va_end\\\"\\n\",\"stdbool.h\":\"#pragma once\\n#define __bool_true_false_are_defined 1\\n#define bool _Bool\\n#define false 0\\n#define true 1\\n\",\"stddef.h\":\"#pragma once\\n#define NULL ((void *) 0)\\n#define offsetof(st, m) ((size_t)&(((st *)0)->m))\\n#ifndef __type_size\\n#define __type_size\\ntypedef unsigned int size_t;\\n#endif\\n#ifndef __type_ptrdiff\\n#define __type_ptrdiff\\ntypedef signed long ptrdiff_t;\\n#endif\\n\",\"stdint.h\":\"#pragma once\\n#ifndef __type_int8\\n#define __type_int8\\ntypedef signed char int8_t;\\n#define INT8_MAX 127\\n#define INT8_MIN -128\\n#endif\\n#ifndef __type_uint8\\n#define __type_uint8\\ntypedef unsigned char uint8_t;\\n#define UINT8_MAX 255\\n#endif\\n#ifndef __type_int16\\n#define __type_int16\\ntypedef signed short int16_t;\\n#define INT16_MAX 32767\\n#define INT16_MIN -32768\\n#endif\\n#ifndef __type_uint16\\n#define __type_uint16\\ntypedef unsigned short uint16_t;\\n#define UINT16_MAX 65535\\n#endif\\n#ifndef __type_int32\\n#define __type_int32\\ntypedef signed int int32_t;\\n#define INT32_MAX 2147483647\\n#define INT32_MIN -2147483648\\n#endif\\n#ifndef __type_uint32\\n#define __type_uint32\\ntypedef unsigned int uint32_t;\\n#define UINT32_MAX 4294967295\\n#endif\\n#ifndef __type_int64\\n#define __type_int64\\ntypedef signed long int64_t;\\n#define INT64_MAX 9223372036854775807\\n#define INT64_MIN -9223372036854775808\\n#endif\\n#ifndef __type_uint64\\n#define __type_uint64\\ntypedef unsigned long uint64_t;\\n#define UINT64_MAX 18446744073709551615\\n#endif\\n#ifndef __type_int_least8\\n#define __type_int_least8\\ntypedef signed char int_least8_t;\\n#define INT_LEAST8_MAX 127\\n#define INT_LEAST8_MIN -128\\n#endif\\n#ifndef __type_uint_least8\\n#define __type_uint_least8\\ntypedef unsigned char uint_least8_t;\\n#define UINT_LEAST8_MAX 255\\n#endif\\n#ifndef __type_int_least16\\n#define __type_int_least16\\ntypedef signed short int_least16_t;\\n#define INT_LEAST16_MAX 32767\\n#define INT_LEAST16_MIN -32768\\n#endif\\n#ifndef __type_uint_least16\\n#define __type_uint_least16\\ntypedef unsigned short uint_least16_t;\\n#define UINT_LEAST16_MAX 65535\\n#endif\\n#ifndef __type_int_least32\\n#define __type_int_least32\\ntypedef signed int int_least32_t;\\n#define INT_LEAST32_MAX 2147483647\\n#define INT_LEAST32_MIN -2147483648\\n#endif\\n#ifndef __type_uint_least32\\n#define __type_uint_least32\\ntypedef unsigned int uint_least32_t;\\n#define UINT_LEAST32_MAX 4294967295\\n#endif\\n#ifndef __type_int_least64\\n#define __type_int_least64\\ntypedef signed long int_least64_t;\\n#define INT_LEAST64_MAX 9223372036854775807\\n#define INT_LEAST64_MIN -9223372036854775808\\n#endif\\n#ifndef __type_uint_least64\\n#define __type_uint_least64\\ntypedef unsigned long uint_least64_t;\\n#define UINT_LEAST64_MAX 18446744073709551615\\n#endif\\n#ifndef __type_int_fast8\\n#define __type_int_fast8\\ntypedef signed int int_fast8_t;\\n#define INT_FAST8_MAX 2147483647\\n#define INT_FAST8_MIN -2147483648\\n#endif\\n#ifndef __type_uint_fast8\\n#define __type_uint_fast8\\ntypedef unsigned int uint_fast8_t;\\n#define UINT_FAST8_MAX 4294967295\\n#endif\\n#ifndef __type_int_fast16\\n#define __type_int_fast16\\ntypedef signed int int_fast16_t;\\n#define INT_FAST16_MAX 2147483647\\n#define INT_FAST16_MIN -2147483648\\n#endif\\n#ifndef __type_uint_fast16\\n#define __type_uint_fast16\\ntypedef unsigned int uint_fast16_t;\\n#define UINT_FAST16_MAX 4294967295\\n#endif\\n#ifndef __type_int_fast32\\n#define __type_int_fast32\\ntypedef signed int int_fast32_t;\\n#define INT_FAST32_MAX 2147483647\\n#define INT_FAST32_MIN -2147483648\\n#endif\\n#ifndef __type_uint_fast32\\n#define __type_uint_fast32\\ntypedef unsigned int uint_fast32_t;\\n#define UINT_FAST32_MAX 4294967295\\n#endif\\n#ifndef __type_int_fast64\\n#define __type_int_fast64\\ntypedef signed long int_fast64_t;\\n#define INT_FAST64_MAX 9223372036854775807\\n#define INT_FAST64_MIN -9223372036854775808\\n#endif\\n#ifndef __type_uint_fast64\\n#define __type_uint_fast64\\ntypedef unsigned long uint_fast64_t;\\n#define UINT_FAST64_MAX 18446744073709551615\\n#endif\\n#ifndef __type_intptr\\n#define __type_intptr\\ntypedef signed int intptr_t;\\n#define INTPTR_MAX 2147483647\\n#define INTPTR_MIN -2147483648\\n#endif\\n#ifndef __type_uintptr\\n#define __type_uintptr\\ntypedef unsigned int uintptr_t;\\n#define UINTPTR_MAX 4294967295\\n#endif\\n#ifndef __type_intmax\\n#define __type_intmax\\ntypedef signed int intmax_t;\\n#define INTMAX_MAX 9223372036854775807\\n#define INTMAX_MIN -9223372036854775808\\n#endif\\n#ifndef __type_uintmax\\n#define __type_uintmax\\ntypedef unsigned int uintmax_t;\\n#define UINTMAX_MAX 18446744073709551615\\n#endif\\n\",\"stdio.h\":\"#pragma once\\n#include <stddef.h>\\n#include <stdarg.h>\\nint printf(const char* format, ...);\\nint sprintf(char* buffer, const char* format, ...);\\nint snprintf(char* buffer, size_t count, const char* format, ...);\\nint vsnprintf(char* buffer, size_t count, const char* format, va_list va);\\nint vprintf(const char* format, va_list va);\\nint fctprintf(void (*out)(char character, void* arg), void* arg, const char* format, ...);\\nint putchar(int chr);\\nint puts(const char *s);\\n#ifndef FILES\\nimport void __put_char(char);\\n#else\\nimport int __get_char(int handle);\\nimport int __put_char(int handle, int c);\\nimport long __get_pos(int handle);\\nimport long __get_len(int handle);\\nimport int __set_pos(int handle, long pos);\\nimport int __exists();\\nimport int __move();\\nimport int __get_fhandle();\\ntypedef struct __stdio_file {\\nint handle, unget, len, flags;\\n_Bool error, eof;\\n} FILE;\\ntypedef long fpos_t;\\nFILE *fopen(const char *filename, const char *mode);\\nFILE *freopen(const char *filename, const char *mode, FILE* stream);\\nint fflush(FILE* stream);\\nint fclose(FILE* stream);\\nint remove(const char *filename);\\nint rename(const char *oldname, const char *newname);\\nchar *tmpnam(char *s);\\nFILE *tmpfile(void);\\nint setvbuf(FILE *stream, char *buf, int mode, size_t size);\\nvoid setbuf(FILE *stream, char *buf);\\nint fprintf(FILE *stream, const char *format, ...);\\nint vfscanf(FILE *stream, const char *fmt, va_list ap);\\nint fscanf(FILE *stream, const char *fmt, ...);\\nint sscanf(char *s, const char *fmt, ...);\\nint scanf(const char *fmt, ...);\\nint fgetc(FILE *stream);\\nchar *fgets(char *s, int n, FILE *stream);\\nint fputc(int c, FILE *stream);\\nint fputs(const char *s, FILE *stream);\\n#define getc(s) fgetc(s)\\nint getchar(void);\\nchar *gets(char *s);\\n#define putc(c, s) fputc(c, s)\\nint putchar(int c);\\nint puts(const char *s);\\nint ungetc(int c, FILE *stream);\\nsize_t fread(void *ptr, size_t size, size_t nobj, FILE *stream);\\nsize_t fwrite(const void *ptr, size_t size, size_t nobj, FILE* stream);\\nint fseek(FILE *stream, long offset, int origin);\\nlong ftell(FILE *stream);\\nvoid rewind(FILE *stream);\\nint fgetpos(FILE *stream, fpos_t *ptr);\\nint fsetpos(FILE *stream, const fpos_t *ptr);\\nvoid clearerr(FILE *stream);\\nint feof(FILE *stream);\\nint ferror(FILE *stream);\\nvoid perror(const char *s);\\n#define EOF -1\\n#define BUFSIZ 16\\n#define FILENAME_MAX 2048\\n#define FOPEN_MAX 1073741824\\n#define _IONBF 0\\n#define _IOLBF 1\\n#define _IOFBF 2\\n#define L_tmpnam 32\\n#define SEEK_SET 0\\n#define SEEK_CUR 1\\n#define SEEK_END 2\\n#define TMP_MAX 1073741824\\nextern FILE *stdin, *stdout, *stderr;\\n#endif\\n\",\"stdlib.h\":\"#pragma once\\n#include <stddef.h>\\n#include <stdarg.h>\\nvoid* malloc(size_t size);\\nvoid free(void* ptr);\\nvoid* realloc(void* ptr, size_t size);\\nvoid* calloc(size_t nobj, size_t size);\\nvoid abort(void);\\nvoid exit(int code);\\nint atexit(void (*fcn)(void));\\nint system(const char *s);\\nchar *getenv(const char *name);\\ndouble strtod(const char *s, char **endp);\\nlong strtol(const char *s, char **endp, int base);\\nunsigned long strtoul(const char *s, char **endp, int base);\\nvoid *bsearch(const void * key, const void * base, size_t nmemb, size_t size, int (*cmp)(const void *, const void *));\\nvoid qsort(void * base, size_t nmemb, size_t size, int (*cmp)(const void *, const void *));\\ntypedef struct __sdiv_t{\\nint quot, rem;\\n} div_t;\\ntypedef struct __ldiv_t {\\nlong quot, rem;\\n} ldiv_t;\\ndouble atof(const char *s);\\nint atoi(const char *s);\\nint atol(const char *s);\\nint abs(int n);\\nint labs(long n);\\ndiv_t div(int num, int denom);\\nldiv_t ldiv(long num, long denom);\\n\",\"string.h\":\"#pragma once\\n#include <stddef.h>\\nchar* strcpy(char* s1, const char* s2);\\nchar* strncpy(char* s1, const char* s2, size_t n);\\nchar* strcat(char* s1, const char* s2);\\nchar* strncat(char* s1, const char* s2, size_t n);\\nint strcmp(const char* s1, const char* s2);\\nint strncmp(const char* s1, const char* s2, size_t n);\\nchar* strchr(const char* s, int c);\\nchar* strrchr(const char* s, int c);\\nsize_t strspn(const char* s1, const char* s2);\\nsize_t strcspn(const char* s1, const char* s2);\\nchar* strpbrk(const char* s1, const char* s2);\\nchar* strstr(const char* s1, const char* s2);\\nsize_t strlen(const char* s);\\nsize_t strnlen(const char* s, size_t n);\\nchar* strtok(char* s1, const char* s2);\\nvoid* memcpy(void* s1, const void* s2, size_t n);\\nvoid* memmove(void* s1, const void* s2, size_t n);\\nint memcmp(const void* s1, const void* s2, size_t n);\\nvoid* memchr(const void* s, int c, size_t n);\\nvoid* memset(void* s, int c, size_t n);\\n\",\"strings.h\":\"#pragma once\\n#include <stddef.h>\\n#include <string.h>\\nint strcasecmp(const char *l, const char *r);\\nint strncasecmp(const char *_l, const char *_r, size_t n);\",\"time.h\":\"#pragma once\\n#include <stddef.h>\\nimport double __time();\\ntypedef double clock_t;\\nclock_t clock();\\n#define CLOCKS_PER_SEC 1000\\n\",\"wasm/f32.h\":\"#pragma once\\n#define f32_abs(x)          (__wasm_f32__(1, (float) x, 0x8B))\\n#define f32_neg(x)          (__wasm_f32__(1, (float) x, 0x8C))\\n#define f32_ceil(x)         (__wasm_f32__(1, (float) x, 0x8D))\\n#define f32_floor(x)        (__wasm_f32__(1, (float) x, 0x8E))\\n#define f32_trunc(x)        (__wasm_f32__(1, (float) x, 0x8F))\\n#define f32_nearest(x)      (__wasm_f32__(1, (float) x, 0x90))\\n#define f32_sqrt(x)         (__wasm_f32__(1, (float) x, 0x91))\\n#define f32_min(x,y)        (__wasm_f32__(2, (float) x, (float) y, 0x96))\\n#define f32_max(x,y)        (__wasm_f32__(2, (float) x, (float) y, 0x97))\\n#define f32_copysign(x,y)   (__wasm_f32__(2, (float) x, (float) y, 0x98))\\n\",\"wasm/f64.h\":\"#pragma once\\n#define f64_abs(x)          (__wasm_f64__(1, (double) x, 0x99))\\n#define f64_neg(x)          (__wasm_f64__(1, (double) x, 0x9A))\\n#define f64_ceil(x)         (__wasm_f64__(1, (double) x, 0x9B))\\n#define f64_floor(x)        (__wasm_f64__(1, (double) x, 0x9C))\\n#define f64_trunc(x)        (__wasm_f64__(1, (double) x, 0x9D))\\n#define f64_nearest(x)      (__wasm_f64__(1, (double) x, 0x9E))\\n#define f64_sqrt(x)         (__wasm_f64__(1, (double) x, 0x9F))\\n#define f64_min(x,y)        (__wasm_f64__(2, (double) x, (double) y, 0xA4))\\n#define f64_max(x,y)        (__wasm_f64__(2, (double) x, (double) y, 0xA5))\\n#define f64_copysign(x,y)   (__wasm_f64__(2, (double) x, (double) y, 0xA6))\\n\"}"),e=new Map(Object.entries(n)),i=(()=>{const n=new Map;for(const[t,i]of e.entries())t.endsWith(".h")&&n.set(t,i);return n})();class c_error_CError extends Error{constructor(n,e,t){super(n),this.node=e,this.node2=t,this.name="CError",e?.loc&&(this.message+="\n\n"+s(e.loc),t?.loc&&(this.message+="\n\n"+s(t.loc,"Secondary location")))}}function s(n,e="Location"){const t=n.source.split("\n");if(n.first_line>=t.length)return`${e}: [UNKNOWN]`;let i=`${e}:\n`;const s=Math.ceil(Math.log10(n.last_line+4));function r(n){i+=`L${(n+1).toString().padStart(s,"0")}: ${t[n]}\n`}return n.first_line>1&&r(n.first_line-2),n.first_line>0&&r(n.first_line-1),r(n.first_line),i+=new Array(3+s+n.first_column).join(" "),n.first_line===n.last_line?i+=new Array(1+n.last_column-n.first_column).join("^"):i+="^",i+="\n",n.first_line+1<t.length&&r(n.first_line+1),n.first_line+2<t.length&&r(n.first_line+2),i}class types_CVoid{constructor(){this.typeName="void",this.bytes=0,this.alignment=1,this.incomplete=!0,this.node=void 0}equals(n){return n instanceof types_CVoid}get pointerGeneration(){return this}}class types_CArithmetic{constructor(n,e,t){this.typeName=n,this.bytes=e,this.type=t,this.incomplete=!1,this.node=void 0,this.alignment=e}equals(n){return n instanceof types_CArithmetic&&n.typeName===this.typeName&&n.type===this.type&&n.bytes===this.bytes}get minValue(){if(types_CArithmetic.BOOL.equals(this))return 0;switch(this.type){case"float":return-1/0;case"unsigned":return 0;case"signed":return-(2n**(BigInt(8*this.bytes)-1n))}}get maxValue(){if(types_CArithmetic.BOOL.equals(this))return 1;switch(this.type){case"float":return 1/0;case"unsigned":return 2n**BigInt(8*this.bytes)-1n;case"signed":return 2n**(BigInt(8*this.bytes)-1n)-1n}}get pointerGeneration(){return this}}types_CArithmetic.Fp32=new types_CArithmetic("float",4,"float"),types_CArithmetic.Fp64=new types_CArithmetic("double",8,"float"),types_CArithmetic.U8=new types_CArithmetic("char",1,"unsigned"),types_CArithmetic.S8=new types_CArithmetic("signed char",1,"signed"),types_CArithmetic.U16=new types_CArithmetic("unsigned short",2,"unsigned"),types_CArithmetic.S16=new types_CArithmetic("short",2,"signed"),types_CArithmetic.U32=new types_CArithmetic("unsigned int",4,"unsigned"),types_CArithmetic.S32=new types_CArithmetic("int",4,"signed"),types_CArithmetic.U64=new types_CArithmetic("unsigned long",8,"unsigned"),types_CArithmetic.S64=new types_CArithmetic("long",8,"signed"),types_CArithmetic.BOOL=new types_CArithmetic("bool",4,"signed");types_CArithmetic.U32,Symbol("const");var r=t(428);const a=new Map;function o(n,e=[]){for(const t of n){e.push(t),o(t.children(),e),e.pop();for(const n of a.get(Object.getPrototypeOf(t).constructor)??[])n(t,e)}return n}class validation_ParseTreeValidationError extends c_error_CError{constructor(n,e,t){super(n&&n.loc?`Line ${n.loc.first_line+1}: ${e}`:e,n,t),this.name="TreeValidationError"}}function c(n,e){const t=a.get(n);t?t.push(e):a.set(n,[e])}function f(n,e){if(n.every((n=>"string"==typeof n))&&!function(n){const e=n.slice();function t(n){const t=e.indexOf(n);return t>-1&&(e.splice(t,1),!0)}function i(n){if(!(e.length>0))return n}return t("void")?i(new types_CVoid):t("double")?(t("long"),i(types_CArithmetic.Fp64)):t("float")?i(types_CArithmetic.Fp32):t("char")?t("signed")?i(types_CArithmetic.S8):(t("unsigned"),i(types_CArithmetic.U8)):t("short")?(t("int"),t("unsigned")?i(types_CArithmetic.U16):(t("signed"),i(types_CArithmetic.S16))):t("long")?(t("long"),t("int"),t("unsigned")?i(types_CArithmetic.U64):(t("signed"),i(types_CArithmetic.S64))):t("int")?t("unsigned")?i(types_CArithmetic.U32):(t("signed"),i(types_CArithmetic.S32)):t("unsigned")?i(types_CArithmetic.U32):t("signed")?i(types_CArithmetic.S32):t("bool")?i(types_CArithmetic.BOOL):void 0}(n))throw new validation_ParseTreeValidationError(e,"Invalid specifiers - "+n.join(", "))}const l=n=>{if(n.qualifierList.length>1)throw new validation_ParseTreeValidationError(n,"Invalid qualifiers.");f(n.specifierList,n)};function h(n,e){for(let t=e.length-1;t>=0;t--){if(!(e[t]instanceof r.Expression)||"sizeof"===e[t].type)return;if("constantExpr"===e[t].type)throw new validation_ParseTreeValidationError(n,"Invalid constant expr.")}}c(r.SpecifierQualifiers,l),c(r.DeclarationSpecifiers,l),c(r.DeclarationSpecifiers,((n,e)=>{if(n.storageList.length>1)throw new validation_ParseTreeValidationError(n,"Invalid storage class list.");if(n.fnSpecifierList.length>1)throw new validation_ParseTreeValidationError(n,"Invalid fn specifier list.");if("typedef"===n.storageList[0]&&1!==e.length)throw new validation_ParseTreeValidationError(n,"Nested typedefs are not allowed")})),c(r.UnaryExpression,((n,e)=>{switch(n.type){case"postfixIncrement":case"postfixDecrement":case"prefixIncrement":case"prefixDecrement":case"addressOf":case"dereference":h(n,e)}})),c(r.BinaryExpression,((n,e)=>{switch(n.type){case"comma":case"arraySubscript":h(n,e)}})),c(r.FunctionCallExpression,h),c(r.MemberAccessExpression,h);var d=t(347);const _=Object.fromEntries(["if","break","case","char","const","continue","default","do","double","else","enum","extern","float","for","inline","int","long","return","short","signed","sizeof","static","struct","switch","typedef","union","unsigned","void","while","_Bool","goto","auto","register","volatile","import"].map((n=>[n,n.toUpperCase()]))),u=[{type:n=>_[n]??"IDENTIFIER",regex:/[a-zA-Z_][a-zA-Z0-9_]*/},{type:n=>n,regex:new RegExp(["...","<<=",">>=","!=","%=","&&","&=","*=","++","+=","--","-=","->","/=","<<","<=","==",">=",">>","^=","|=","||","!","%","&","(",")","*","+",",","-",".","/",":",";","<","=",">","?","[","]","^","{","|","}","~"].map((n=>n.replace(/[.*+?^${}()|[\]\\]/g,"\\$&"))).join("|"))},{type:"CONSTANT_FLOAT",regex:/(?:[0-9]+[Ee][+-]?[0-9]+|(?:[0-9]*\.[0-9]+|[0-9]+\.[0-9]*)(?:[Ee][+-]?[0-9]+)?)[fFlL]?|(?:[1-9][0-9]*|0)[fF]/},{type:"CONSTANT_HEX",regex:/0[xX][a-fA-F0-9]+(?:[uU][lL]{0,2}|[lL]{1,2}[uU]?|)/},{type:"CONSTANT_OCTAL",regex:/0[0-7]+(?:[uU][lL]{0,2}|[lL]{1,2}[uU]?|)/},{type:"CONSTANT_INT",regex:/(?:[1-9][0-9]*|0)(?:[uU][lL]{0,2}|[lL]{1,2}[uU]?|)/},{type:"CONSTANT_CHAR",regex:/'(?:[^\\\n']|\\(?:.|x[0-9a-fA-F]{1,2}|[0-7]{1,3}))'/,value:n=>n.slice(1,-1)},{type:"STRING_LITERAL",regex:/"(?:[^\\\n"]|\\(?:[^x0-7\n]|x[0-9a-fA-F]{1,2}|[0-7]{1,3}))*"/,value:n=>n.slice(1,-1)}];class Lexer{constructor(){this.source="",this.index=0,this.line=0,this.col=0}next(){for(;this.index<this.source.length&&(" "===this.source[this.index]||"\t"===this.source[this.index]||"\v"===this.source[this.index]||"\f"===this.source[this.index]||"\n"===this.source[this.index]);)"\n"===this.source[this.index]?(this.line++,this.col=1):this.col++,this.index++;const n={first_line:this.line,first_column:this.col,last_line:this.line,last_column:this.col+1,source:this.source};if(this.index===this.source.length)return{type:"EOF",value:"",text:"",loc:n};Lexer.regex.lastIndex=this.index;const e=Lexer.regex.exec(this.source);if(!e)throw new LexerError(n);const t=e[0];this.index+=t.length,this.col+=t.length,n.last_column=this.col;let i=0;for(;void 0===e[i+1];)i++;const s=u[i];return{type:"function"==typeof s.type?s.type(t):s.type,value:s.value?.(t)??t,text:t,loc:n}}reset(n){this.source=n,this.index=0,this.line=0,this.col=1}}Lexer.regex=new RegExp(u.map((n=>"("+n.regex.source+")")).join("|"),"ym");class LexerError extends c_error_CError{constructor(n){super("Unknown token",new class extends r.ParseNode{constructor(){super(...arguments),this.type="Unknown"}}(n)),this.name="LexerError"}}const p=new Lexer;const m=d;function g(n){try{return o(m.parse(n))}catch(n){throw n?.hash?.loc&&(n.message+="\n\n"+s(n.hash?.loc)),n}}m.parser.lexer=new class WrappedLexer{constructor(){this.types=new Map}lex(){const n=p.next();return this.yytext=n.value,this.yylloc=n.loc,this.yylineno=n.loc.first_line,"IDENTIFIER"===n.type&&this.types.get(n.text)?"TYPE_NAME":n.type}setInput(n){this.yytext=void 0,this.yylloc=void 0,this.yylineno=void 0,this.types.clear(),p.reset(n)}externalDeclaration(n){if("typedef"===n.typeInfo.storageList[0])for(let e of n.list){for(;!(e instanceof r.IdentifierDeclarator);)e=e.body;this.types.set(e.id,!0)}}};class type_checking_ExpressionTypeError extends c_error_CError{constructor(n,e,t){super(t?`Expected ${e} but got ${t} instead!`:`Expected ${e}`,n),this.wantedType=e,this.actualType=t,this.name="ExpressionTypeError"}}class expressions_CConstant{constructor(n,e,t){this.node=n,this.type=e,this.value=t,this.lvalue=!1}changeType(n){if(this.type.equals(n))return this;let e;if(n.equals(types_CArithmetic.BOOL))e=0==this.value?0:1;else if("float"===n.type)e=Number(this.value);else{if(this.value>n.maxValue||this.value<n.minValue)throw new type_checking_ExpressionTypeError(this.node,`value which fits in ${n.typeName}`,this.value.toString());e=BigInt(this.value)}return new expressions_CConstant(this.node,n,e)}*identifiers(){}}Symbol("constant");function y(n){let e,t=n.value;if("int"===n.valueType||"oct"===n.valueType||"hex"===n.valueType){let e,i,s=!1,r=!1;if(t=t.toLowerCase(),t.endsWith("u")&&(t=t.slice(0,-1),s=!0),t.endsWith("l")&&(t=t.slice(0,-1),r=!0,t.endsWith("l")&&(t=t.slice(0,-1))),!s&&t.endsWith("u")&&(t=t.slice(0,-1),s=!0),"oct"!==n.valueType)e=BigInt(t);else{e=0n;for(let n=0;n<t.length-1;n++)e+=BigInt(t[t.length-1-n])*8n**BigInt(n)}i="int"!==n.valueType||s||r?"int"===n.valueType||s||r?s&&r?[types_CArithmetic.U64]:r?[types_CArithmetic.S64,types_CArithmetic.U64]:[types_CArithmetic.U32,types_CArithmetic.U64]:[types_CArithmetic.S32,types_CArithmetic.U32,types_CArithmetic.S64,types_CArithmetic.U64]:[types_CArithmetic.S32,types_CArithmetic.S64,types_CArithmetic.U64];for(const t of i)if(e>=t.minValue&&e<=t.maxValue)return new expressions_CConstant(n,t,e);throw new validation_ParseTreeValidationError(n,"Integer constant too large for its type")}if("float"===n.valueType)return t.endsWith("f")?(t=t.slice(0,-1),e=types_CArithmetic.Fp32):e=types_CArithmetic.Fp64,new expressions_CConstant(n,e,parseFloat(t));if("char"===n.valueType)return t=b(t,n),new expressions_CConstant(n,types_CArithmetic.U8,BigInt(t.codePointAt(0)));throw new validation_ParseTreeValidationError(n,"Invalid constant type?")}function b(n,e){if(n.startsWith("\\")){if("\\n"===n)return"\n";if("\\t"===n)return"\t";if("\\v"===n)return"\v";if("\\b"===n)return"\b";if("\\r"===n)return"\r";if("\\f"===n)return"\f";if("\\a"===n)return"";if("\\\\"===n)return"\\";if("\\?"===n)return"?";if("\\'"===n)return"'";if('\\"'===n)return'"';let t;if(t=n.startsWith("\\x")?parseInt(n.slice(2),16):parseInt(n.slice(1),8),!isNaN(t)&&t>=0&&t<=255)return String.fromCharCode(t);throw new validation_ParseTreeValidationError(e,"Invalid character escape")}const t=n.codePointAt(0);if(1!==n.length||void 0===t||t>255)throw new validation_ParseTreeValidationError(e,"Invalid character");return n}function L(n,e){const t=g(`int x = ${n};`);if(1!==t.length||"declaration"!==t[0].type||1!==t[0].list.length||"initDeclarator"!==t[0].list[0].type||Array.isArray(t[0].list[0].initializer))throw e.error("Invalid #if conditional: `"+n+"`");return v(t[0].list[0].initializer,e)}function v(n,e){if(n instanceof r.Constant&&"float"!==n.valueType)return BigInt(y(n).value);if(n instanceof r.BinaryExpression)switch(n.type){case"add":return v(n.lhs,e)+v(n.rhs,e);case"sub":return v(n.lhs,e)-v(n.rhs,e);case"mul":return v(n.lhs,e)*v(n.rhs,e);case"div":return v(n.lhs,e)/v(n.rhs,e);case"bitwiseAnd":return v(n.lhs,e)&v(n.rhs,e);case"bitwiseOr":return v(n.lhs,e)|v(n.rhs,e);case"bitwiseXor":return v(n.lhs,e)^v(n.rhs,e);case"bitwiseShiftLeft":return v(n.lhs,e)<<v(n.rhs,e);case"bitwiseShiftRight":return v(n.lhs,e)>>v(n.rhs,e);case"relationalEq":return v(n.lhs,e)===v(n.rhs,e)?1n:0n;case"relationalNEq":return v(n.lhs,e)!==v(n.rhs,e)?1n:0n;case"relationalLT":return v(n.lhs,e)<v(n.rhs,e)?1n:0n;case"relationalLEq":return v(n.lhs,e)<=v(n.rhs,e)?1n:0n;case"relationalGT":return v(n.lhs,e)>v(n.rhs,e)?1n:0n;case"relationalGEq":return v(n.lhs,e)>=v(n.rhs,e)?1n:0n;case"logicalAnd":return 0n!==v(n.lhs,e)&&0n!==v(n.rhs,e)?1n:0n;case"logicalOr":return 0n!==v(n.lhs,e)||0n!==v(n.rhs,e)?1n:0n}else if(n instanceof r.UnaryExpression)switch(n.type){case"unaryPlus":return v(n.body,e);case"unaryMinus":return-v(n.body,e);case"logicalNot":return 0n===v(n.body,e)?1n:0n}else if(n instanceof r.Identifier)return 0n;throw e.error("Invalid preprocessor expression")}const x=/^[a-zA-Z_][a-zA-Z0-9_]*/,E=/^(?:"(?:\\"|[^\n"])*"|[^ \t\v\f\na-zA-Z_]+)/,I=/^[ \t\v\f]+/,A=/\/\*[^]*?\*\/|\/\/.*?$/gm,w=/defined(?:[ \t]*\([ \t]*([a-zA-Z_][a-zA-Z0-9_]*)[ \t]*\)|[ \t]+([a-zA-Z_][a-zA-Z0-9_]*))|(d?[^d]*)/gm;class Definition{constructor(n,e,t,i){this.preprocessor=n,this.identifier=e,this.replacement=t,this.parameters=i}expand(n){if(this.parameters.length>0)return this.expandWithParameters(n);return{output:this.replacement.map((n=>n.value)).join(""),line:n}}expandWithParameters(n){const e=n;if(0===(n=this.preprocessor.consume(n,I).remainingLine).length||"("!==n[0])return{output:this.identifier,line:e};n=this.preprocessor.mustConsume(n,"(").remainingLine;const t=[];for(let e=0;e<this.parameters.length;e++){const i=this.consumeArgument(n);t.push(i.value.trim()),n=e!==this.parameters.length-1?this.preprocessor.mustConsume(i.remainingLine,",").remainingLine:this.preprocessor.mustConsume(i.remainingLine,")").remainingLine}let i="";for(const n of this.replacement){if("identifier"===n.type){const e=this.parameters.indexOf(n.value);if(e>=0){i+=this.preprocessor.expandDefinitions(t[e]);continue}}i+=n.value}return{output:i,line:n}}consumeArgument(n){const e={value:"",remainingLine:n};let t=!1,i=0;for(;e.remainingLine.length>0&&(t||0!==i||","!==e.remainingLine[0]&&")"!==e.remainingLine[0]);){const n=e.remainingLine[0];let s=1;t&&"\\"===n&&'"'===e.remainingLine[1]?s=2:t||"'"!==n?'"'===n?t=!t:"("!==n||t?")"!==n||t||i--:i++:s+=Math.max(e.remainingLine.indexOf("'",1),0),e.value+=e.remainingLine.substring(0,s),e.remainingLine=e.remainingLine.substring(s)}return e}equals(n){return n.identifier===this.identifier&&n.replacement.length===this.replacement.length&&n.replacement.every(((n,e)=>n.value===this.replacement[e].value))&&n.parameters.length===this.parameters.length&&n.parameters.every(((n,e)=>n===this.parameters[e]))}}class Preprocessor extends class PreprocessorBase{consumeAny(n){let e;if((e=this.consume(n,x)).success)return e.type="identifier",e;if((e=this.consume(n,E)).success)return e;if((e=this.consume(n,I)).success)return e;throw this.error("Malformed input? Line does not match defined regular expressions.\n`"+n+"`")}mustConsume(n,e,t=e.toString()){const i=this.consume(n,e);if(i.success)return i;throw this.error(`Expected to find ${t} but found \`${n}\` instead`)}consume(n,e){if("string"==typeof e)return n.startsWith(e)?{success:!0,value:e,remainingLine:n.substring(e.length)}:{success:!1,remainingLine:n};const t=n.match(e);return null===t?{success:!1,remainingLine:n}:{success:!0,value:t[0],remainingLine:n.substring(t[0].length)}}}{constructor(n,e=!0,t){if(super(),this.filename=n,this.definitions=new Map,this.userFiles=new Map,this.libraryFiles=e?new Map(i):new Map,this.definitions.set("__FILE__",new Definition(this,"__FILE__",[{value:`"${n}"`}],[])),this.definitions.set("__c2wasm__",new Definition(this,"__c2wasm__",[{value:"1"}],[])),t)for(const[n,e]of Object.entries(t))this.definitions.set(n,new Definition(this,n,[{value:e}],[]))}process(n,e=this.filename){const t=(n=(n=n.replace(/\r\n/g,"\n")).replace(A," ")).replace(/\\\n/g,"").split("\n");let i="";for(;t.length>0;){let n=t.shift();if(n.startsWith("#")){let s;if(n=n.substring(1).trimStart(),(s=this.consume(n,"define")).success)this._define(s.remainingLine);else if((s=this.consume(n,"undef")).success)this._undef(s.remainingLine);else if((s=this.consume(n,"include")).success)i+=this._include(s.remainingLine)+"\n";else if((s=this.consume(n,"ifdef")).success)this._ifdef(s.remainingLine,!0,t);else if((s=this.consume(n,"ifndef")).success)this._ifdef(s.remainingLine,!1,t);else if((s=this.consume(n,"if")).success)i+=this._if(s.remainingLine,t);else if((s=this.consume(n,"pragma")).success){if("once"===this.mustConsume(s.remainingLine,I,"whitespace").remainingLine.trim()){const n=`__pragma_once_${e}__`;if(this.definitions.has(n))return i;this.definitions.set(n,new Definition(this,n,[],[]))}}else{if((s=this.consume(n,"error")).success)throw this.error("#"+n);if(n.trim().length>1)throw this.error(`Unknown preprocessor directive "#${n}"`)}}else i+=this.expandDefinitions(n)+"\n"}return i}expandDefinitions(n,e=this.definitions){let t="";for(;n.length>0;){const i=this.consumeAny(n);if("identifier"===i?.type){const s=e.get(i.value);if(void 0!==s){const r=s.expand(i.remainingLine),a=new Map(e);a.delete(i.value);let o=r.output,c="";for(;o!==c;)c=o,o=this.expandDefinitions(o,a);t+=o,n=r.line;continue}}t+=i?.value,n=i.remainingLine}return t}error(n){return new class extends Error{constructor(){super(...arguments),this.name="PreprocessorError"}}(`In file '${this.filename}': ${n}`)}_include(n){if((n=this.mustConsume(n,I,"whitespace").remainingLine.trim()).startsWith('"')&&n.endsWith('"'))return this._includeUser(n.substring(1,n.length-1));if(n.startsWith("<")&&n.endsWith(">"))return this._includeLib(n.substring(1,n.length-1));if((n=this.expandDefinitions(n)).startsWith('"')&&n.endsWith('"'))return this._includeUser(n.substring(1,n.length-1));if(n.startsWith("<")&&n.endsWith(">"))return this._includeLib(n.substring(1,n.length-1));throw this.error("Invalid #include")}_includeLib(n){const e=this.libraryFiles.get(n);if(void 0===e)throw this.error("Unknown path `"+n+"`");return this.process(e,`<${n}>`)}_includeUser(n){const e=this.filename.replace(/[^/\\]*$/,n);let t=this.userFiles.get(e);return void 0===t&&(t=this.userFiles.get(n),void 0===t)?this._includeLib(n):this.process(t,n)}_define(n){n=this.mustConsume(n,I,"whitespace").remainingLine;const e=this.mustConsume(n,x,"identifier"),t=[],i=[];if(e.remainingLine.trim().length>0){if("("===e.remainingLine[0]){for(n=this.mustConsume(e.remainingLine,"(").remainingLine;n.length>0;){n=this.consume(n,I).remainingLine;const e=this.mustConsume(n,x,"identifier");if(i.push(e.value),0===(n=this.consume(e.remainingLine,I).remainingLine).length)throw this.error("Unexpected end of line");if(","!==n[0]){if(")"===n[0])break;throw this.error("Unexpected")}n=this.mustConsume(n,",").remainingLine}(n=this.mustConsume(n,")").remainingLine).length>0&&(n=this.mustConsume(n,I,"whitespace").remainingLine)}else n=this.mustConsume(e.remainingLine,I,"whitespace").remainingLine;for(;n.length>0;){const e=this.consumeAny(n);"identifier"===e.type&&i.includes(e.value)||(e.value=this.expandDefinitions(e.value)),t.push(e),n=e.remainingLine}}const s=new Definition(this,e.value,t,i),r=this.definitions.get(e.value);if(void 0!==r&&!s.equals(r))throw this.error("Duplicate defines must be the same");this.definitions.set(e.value,s)}_undef(n){n=this.mustConsume(n,I,"whitespace").remainingLine;const e=this.mustConsume(n,x,"identifier");if(0!==e.remainingLine.trim().length)throw this.error("Unexpected extra characters in undef");this.definitions.delete(e.value)}_ifdef(n,e,t){n=this.mustConsume(n,I,"whitespace").remainingLine;const i=this.mustConsume(n,x,"identifier");t.unshift(`#if ${e?"":"!"} defined ${i.value}`)}_if(n,e){const t=this.mustConsume(n,I,"whitespace").remainingLine;let i=this._condition(t),s=i,r=1,a=!1;const o=[];for(let n=0;n<e.length;n++){const t=e[n].trimEnd();if(t.startsWith("#if"))r++;else if("#endif"===t){if(r--,0===r)return e.splice(0,n+1),this.process(o.join("\n"))}else{if("#else"===t&&1===r){if(a)throw this.error("more than one #else statement");a=!0,i=!s,s=!0;continue}if(t.startsWith("#elif")&&1===r){if(s)i=!1;else{const t=this.mustConsume(e[n].substring(5),I,"whitespace").remainingLine;i=this._condition(t),s||(s=i)}continue}}i&&o.push(e[n])}throw this.error("no matching #endif found")}_condition(n){let e="";for(const t of n.matchAll(w)){if(4!==t.length)throw this.error("invalid regex result when processing #if condition");const n=t[1]??t[2];e+=n?this.definitions.has(n)?" 1L ":" 0L ":t[3]}e=this.expandDefinitions(e);try{return 0n!==L(e,this)}catch(e){throw this.error("Invalid condition `"+n+"`")}}}const S="\nint factorial(int v) {\n  return v < 2 ? 1 : v * factorial(v - 1);\n}\n".trimStart();function F(n){try{const e=new Preprocessor("main.c");for(let n=0;n<5;n++)e.libraryFiles.set(`library${n}.h`,`void library${n}() {}`),e.userFiles.set(`user${n}.h`,`void user${n}() {}`);return e.process(n)}catch(n){return console.debug(n),n.stack}}if("undefined"!=typeof window&&window.document){window.document.write(`\n        <h1>c2wasm preprocessor</h1>\n        <div>\n            <textarea id="textInput" rows="20" style="width: 100%; resize: vertical">${S}</textarea>\n            <pre id="output">${F(S)}</pre>\n        </div>\n    `);const n=window.document.getElementById("textInput"),e=window.document.getElementById("output");n.addEventListener("input",(()=>{e.textContent=F(n.value)}))}else console.log(F(S))})()})();
//# sourceMappingURL=preprocessor.js.map