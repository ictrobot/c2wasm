{"c2wasm/core_portme.c":"/*\nCopyright 2018 Embedded Microprocessor Benchmark Consortium (EEMBC)\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\nOriginal Author: Shay Gal-on\n*/\n\n// MODIFIED\n\n#include <stdio.h>\n#include <stdlib.h>\n#include \"coremark.h\"\n\n#define ITERATIONS 0\n\n#if VALIDATION_RUN\nvolatile ee_s32 seed1_volatile = 0x3415;\nvolatile ee_s32 seed2_volatile = 0x3415;\nvolatile ee_s32 seed3_volatile = 0x66;\n#endif\n#if PERFORMANCE_RUN\nvolatile ee_s32 seed1_volatile = 0x0;\nvolatile ee_s32 seed2_volatile = 0x0;\nvolatile ee_s32 seed3_volatile = 0x66;\n#endif\n#if PROFILE_RUN\nvolatile ee_s32 seed1_volatile = 0x8;\nvolatile ee_s32 seed2_volatile = 0x8;\nvolatile ee_s32 seed3_volatile = 0x8;\n#endif\nvolatile ee_s32 seed4_volatile = ITERATIONS;\nvolatile ee_s32 seed5_volatile = 0;\n\n/* Porting : Timing functions\n        How to capture time and convert to seconds must be ported to whatever is\n   supported by the platform. e.g. Read value from on board RTC, read value from\n   cpu clock cycles performance counter etc. Sample implementation for standard\n   time.h and windows.h definitions included.\n*/\n\nstatic CORE_TICKS start_time_val, stop_time_val;\n\nimport double __time();\n\n/* Function : start_time\n        This function will be called right before starting the timed portion of\n   the benchmark.\n\n        Implementation may be capturing a system timer (as implemented in the\n   example code) or zeroing some system parameters - e.g. setting the cpu clocks\n   cycles to 0.\n*/\nvoid\nstart_time(void)\n{\n    start_time_val = __time();\n}\n/* Function : stop_time\n        This function will be called right after ending the timed portion of the\n   benchmark.\n\n        Implementation may be capturing a system timer (as implemented in the\n   example code) or other system parameters - e.g. reading the current value of\n   cpu cycles counter.\n*/\nvoid\nstop_time(void)\n{\n    stop_time_val = __time();\n}\n/* Function : get_time\n        Return an abstract \"ticks\" number that signifies time on the system.\n\n        Actual value returned may be cpu cycles, milliseconds or any other\n   value, as long as it can be converted to seconds by <time_in_secs>. This\n   methodology is taken to accomodate any hardware or simulated platform. The\n   sample implementation returns millisecs by default, and the resolution is\n   controlled by <TIMER_RES_DIVIDER>\n*/\nCORE_TICKS\nget_time(void)\n{\n    return stop_time_val - start_time_val;\n}\n/* Function : time_in_secs\n        Convert the value returned by get_time to seconds.\n\n        The <secs_ret> type is used to accomodate systems with no support for\n   floating point. Default implementation implemented by the EE_TICKS_PER_SEC\n   macro above.\n*/\ndouble\ntime_in_secs(CORE_TICKS ticks)\n{\n    return ticks / 1000.0;\n}\n\nee_u32 default_num_contexts = 1;\n\n/* Function : portable_init\n        Target specific initialization code\n        Test for some common mistakes.\n*/\nvoid\nportable_init(core_portable *p, int *argc, char **argv)\n{\n    if (sizeof(ee_ptr_int) != sizeof(ee_u8 *))\n    {\n        ee_printf(\n            \"ERROR! Please define ee_ptr_int to a type that holds a \"\n            \"pointer!\\n\");\n    }\n    if (sizeof(ee_u32) != 4)\n    {\n        ee_printf(\"ERROR! Please define ee_u32 to a 32b unsigned type!\\n\");\n    }\n    p->portable_id = 1;\n}\n/* Function : portable_fini\n        Target specific final code\n*/\nvoid\nportable_fini(core_portable *p)\n{\n    p->portable_id = 0;\n}\n\n#if (SEED_METHOD != SEED_ARG)\n// fix symbol missing\nee_s32 parseval(char *valstring){\n    return 0;\n}\n#endif\n","c2wasm/core_portme.h":"/*\nCopyright 2018 Embedded Microprocessor Benchmark Consortium (EEMBC)\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\nOriginal Author: Shay Gal-on\n*/\n\n// MODIFIED\n\n/* Topic : Description\n        This file contains configuration constants required to execute on\n   different platforms\n*/\n#ifndef CORE_PORTME_H\n#define CORE_PORTME_H\n\n// CUSTOM\n#define volatile\n#define COMPILER_REQUIRES_SORT_RETURN 1\n#define portable_malloc malloc\n#define portable_free free\n//#define CORE_DEBUG 1\n\n/************************/\n/* Data types and settings */\n/************************/\n/* Configuration : HAS_FLOAT\n        Define to 1 if the platform supports floating point.\n*/\n#define HAS_FLOAT 1\n/* Configuration : HAS_STDIO\n        Define to 1 if the platform has stdio.h.\n*/\n#define HAS_STDIO 1\n/* Configuration : HAS_PRINTF\n        Define to 1 if the platform has stdio.h and implements the printf\n   function.\n*/\n#define HAS_PRINTF 1\n\n/* Configuration : CORE_TICKS\n        Define type of return from the timing functions.\n */\ntypedef double CORE_TICKS;\n\n/* Definitions : COMPILER_VERSION, COMPILER_FLAGS, MEM_LOCATION\n        Initialize these strings per platform\n*/\n#define COMPILER_VERSION \"c2wasm - Ethan Jones\"\n\n#ifndef COMPILER_FLAGS\n#define COMPILER_FLAGS \"\" // Please put compiler flags here (e.g. -o3)\n#endif\n\n#ifndef MEM_LOCATION\n#define MEM_LOCATION \"Wasm\"\n#endif\n\n/* Data Types :\n        To avoid compiler issues, define the data types that need ot be used for\n   8b, 16b and 32b in <core_portme.h>.\n\n        *Imprtant* :\n        ee_ptr_int needs to be the data type used to hold pointers, otherwise\n   coremark may fail!!!\n*/\ntypedef signed short   ee_s16;\ntypedef unsigned short ee_u16;\ntypedef signed int     ee_s32;\ntypedef float          ee_f32;\ntypedef unsigned char  ee_u8;\ntypedef unsigned int   ee_u32;\ntypedef ee_u32         ee_ptr_int;\ntypedef unsigned int   ee_size_t;\n\n/* align_mem :\n        This macro is used to align an offset to point to a 32b value. It is\n   used in the Matrix algorithm to initialize the input memory blocks.\n*/\n#define align_mem(x) (void *)(4 + (((ee_ptr_int)(x)-1) & ~3))\n\n/* Configuration : SEED_METHOD\n        Defines method to get seed values that cannot be computed at compile\n   time.\n\n        Valid values :\n        SEED_ARG - from command line.\n        SEED_FUNC - from a system function.\n        SEED_VOLATILE - from volatile variables.\n*/\n#ifndef SEED_METHOD\n#define SEED_METHOD SEED_VOLATILE\n#endif\n\n/* Configuration : MEM_METHOD\n        Defines method to get a block of memry.\n\n        Valid values :\n        MEM_MALLOC - for platforms that implement malloc and have malloc.h.\n        MEM_STATIC - to use a static memory array.\n        MEM_STACK - to allocate the data block on the stack (NYI).\n*/\n#ifndef MEM_METHOD\n#define MEM_METHOD MEM_STACK\n#endif\n\n/* Configuration : MULTITHREAD\n        Define for parallel execution\n\n        Valid values :\n        1 - only one context (default).\n        N>1 - will execute N copies in parallel.\n\n        Note :\n        If this flag is defined to more then 1, an implementation for launching\n   parallel contexts must be defined.\n\n        Two sample implementations are provided. Use <USE_PTHREAD> or <USE_FORK>\n   to enable them.\n\n        It is valid to have a different implementation of <core_start_parallel>\n   and <core_end_parallel> in <core_portme.c>, to fit a particular architecture.\n*/\n#ifndef MULTITHREAD\n#define MULTITHREAD 1\n#define USE_PTHREAD 0\n#define USE_FORK    0\n#define USE_SOCKET  0\n#endif\n\n/* Configuration : MAIN_HAS_NOARGC\n        Needed if platform does not support getting arguments to main.\n\n        Valid values :\n        0 - argc/argv to main is supported\n        1 - argc/argv to main is not supported\n\n        Note :\n        This flag only matters if MULTITHREAD has been defined to a value\n   greater then 1.\n*/\n#define MAIN_HAS_NOARGC 1\n\n/* Configuration : MAIN_HAS_NORETURN\n        Needed if platform does not support returning a value from main.\n\n        Valid values :\n        0 - main returns an int, and return value will be 0.\n        1 - platform does not support returning a value from main\n*/\n#ifndef MAIN_HAS_NORETURN\n#define MAIN_HAS_NORETURN 0\n#endif\n\n/* Variable : default_num_contexts\n        Not used for this simple port, must cintain the value 1.\n*/\nextern ee_u32 default_num_contexts;\n\ntypedef struct CORE_PORTABLE_S\n{\n    ee_u8 portable_id;\n} core_portable;\n\n/* target specific init/fini */\nvoid portable_init(core_portable *p, int *argc, char **argv);\nvoid portable_fini(core_portable *p);\n\n#if !defined(PROFILE_RUN) && !defined(PERFORMANCE_RUN) \\\n    && !defined(VALIDATION_RUN)\n#if (TOTAL_DATA_SIZE == 1200)\n#define PROFILE_RUN 1\n#elif (TOTAL_DATA_SIZE == 2000)\n#define PERFORMANCE_RUN 1\n#else\n#define VALIDATION_RUN 1\n#endif\n#endif\n\n#endif /* CORE_PORTME_H */\n","core_list_join.c":"/*\nCopyright 2018 Embedded Microprocessor Benchmark Consortium (EEMBC)\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\nOriginal Author: Shay Gal-on\n*/\n\n#include \"coremark.h\"\n/*\nTopic: Description\n        Benchmark using a linked list.\n\n        Linked list is a common data structure used in many applications.\n\n        For our purposes, this will excercise the memory units of the processor.\n        In particular, usage of the list pointers to find and alter data.\n\n        We are not using Malloc since some platforms do not support this\nlibrary.\n\n        Instead, the memory block being passed in is used to create a list,\n        and the benchmark takes care not to add more items then can be\n        accomodated by the memory block. The porting layer will make sure\n        that we have a valid memory block.\n\n        All operations are done in place, without using any extra memory.\n\n        The list itself contains list pointers and pointers to data items.\n        Data items contain the following:\n\n        idx - An index that captures the initial order of the list.\n        data - Variable data initialized based on the input parameters. The 16b\nare divided as follows: o Upper 8b are backup of original data. o Bit 7\nindicates if the lower 7 bits are to be used as is or calculated. o Bits 0-2\nindicate type of operation to perform to get a 7b value. o Bits 3-6 provide\ninput for the operation.\n\n*/\n\n/* local functions */\n\nlist_head *core_list_find(list_head *list, list_data *info);\nlist_head *core_list_reverse(list_head *list);\nlist_head *core_list_remove(list_head *item);\nlist_head *core_list_undo_remove(list_head *item_removed,\n                                 list_head *item_modified);\nlist_head *core_list_insert_new(list_head * insert_point,\n                                list_data * info,\n                                list_head **memblock,\n                                list_data **datablock,\n                                list_head * memblock_end,\n                                list_data * datablock_end);\ntypedef ee_s32 (*list_cmp)(list_data *a, list_data *b, core_results *res);\nlist_head *core_list_mergesort(list_head *   list,\n                               list_cmp      cmp,\n                               core_results *res);\n\nee_s16\ncalc_func(ee_s16 *pdata, core_results *res)\n{\n    ee_s16 data = *pdata;\n    ee_s16 retval;\n    ee_u8  optype\n        = (data >> 7)\n          & 1;  /* bit 7 indicates if the function result has been cached */\n    if (optype) /* if cached, use cache */\n        return (data & 0x007f);\n    else\n    {                             /* otherwise calculate and cache the result */\n        ee_s16 flag = data & 0x7; /* bits 0-2 is type of function to perform */\n        ee_s16 dtype\n            = ((data >> 3)\n               & 0xf);       /* bits 3-6 is specific data for the operation */\n        dtype |= dtype << 4; /* replicate the lower 4 bits to get an 8b value */\n        switch (flag)\n        {\n            case 0:\n                if (dtype < 0x22) /* set min period for bit corruption */\n                    dtype = 0x22;\n                retval = core_bench_state(res->size,\n                                          res->memblock[3],\n                                          res->seed1,\n                                          res->seed2,\n                                          dtype,\n                                          res->crc);\n                if (res->crcstate == 0)\n                    res->crcstate = retval;\n                break;\n            case 1:\n                retval = core_bench_matrix(&(res->mat), dtype, res->crc);\n                if (res->crcmatrix == 0)\n                    res->crcmatrix = retval;\n                break;\n            default:\n                retval = data;\n                break;\n        }\n        res->crc = crcu16(retval, res->crc);\n        retval &= 0x007f;\n        *pdata = (data & 0xff00) | 0x0080 | retval; /* cache the result */\n        return retval;\n    }\n}\n/* Function: cmp_complex\n        Compare the data item in a list cell.\n\n        Can be used by mergesort.\n*/\nee_s32\ncmp_complex(list_data *a, list_data *b, core_results *res)\n{\n    ee_s16 val1 = calc_func(&(a->data16), res);\n    ee_s16 val2 = calc_func(&(b->data16), res);\n    return val1 - val2;\n}\n\n/* Function: cmp_idx\n        Compare the idx item in a list cell, and regen the data.\n\n        Can be used by mergesort.\n*/\nee_s32\ncmp_idx(list_data *a, list_data *b, core_results *res)\n{\n    if (res == NULL)\n    {\n        a->data16 = (a->data16 & 0xff00) | (0x00ff & (a->data16 >> 8));\n        b->data16 = (b->data16 & 0xff00) | (0x00ff & (b->data16 >> 8));\n    }\n    return a->idx - b->idx;\n}\n\nvoid\ncopy_info(list_data *to, list_data *from)\n{\n    to->data16 = from->data16;\n    to->idx    = from->idx;\n}\n\n/* Benchmark for linked list:\n        - Try to find multiple data items.\n        - List sort\n        - Operate on data from list (crc)\n        - Single remove/reinsert\n        * At the end of this function, the list is back to original state\n*/\nee_u16\ncore_bench_list(core_results *res, ee_s16 finder_idx)\n{\n    ee_u16     retval = 0;\n    ee_u16     found = 0, missed = 0;\n    list_head *list     = res->list;\n    ee_s16     find_num = res->seed3;\n    list_head *this_find;\n    list_head *finder, *remover;\n    list_data  info;\n    ee_s16     i;\n\n    info.idx = finder_idx;\n    /* find <find_num> values in the list, and change the list each time\n     * (reverse and cache if value found) */\n    for (i = 0; i < find_num; i++)\n    {\n        info.data16 = (i & 0xff);\n        this_find   = core_list_find(list, &info);\n        list        = core_list_reverse(list);\n        if (this_find == NULL)\n        {\n            missed++;\n            retval += (list->next->info->data16 >> 8) & 1;\n        }\n        else\n        {\n            found++;\n            if (this_find->info->data16 & 0x1) /* use found value */\n                retval += (this_find->info->data16 >> 9) & 1;\n            /* and cache next item at the head of the list (if any) */\n            if (this_find->next != NULL)\n            {\n                finder          = this_find->next;\n                this_find->next = finder->next;\n                finder->next    = list->next;\n                list->next      = finder;\n            }\n        }\n        if (info.idx >= 0)\n            info.idx++;\n#if CORE_DEBUG\n        ee_printf(\"List find %d: [%d,%d,%d]\\n\", i, retval, missed, found);\n#endif\n    }\n    retval += found * 4 - missed;\n    /* sort the list by data content and remove one item*/\n    if (finder_idx > 0)\n        list = core_list_mergesort(list, cmp_complex, res);\n    remover = core_list_remove(list->next);\n    /* CRC data content of list from location of index N forward, and then undo\n     * remove */\n    finder = core_list_find(list, &info);\n    if (!finder)\n        finder = list->next;\n    while (finder)\n    {\n        retval = crc16(list->info->data16, retval);\n        finder = finder->next;\n    }\n#if CORE_DEBUG\n    ee_printf(\"List sort 1: %04x\\n\", retval);\n#endif\n    remover = core_list_undo_remove(remover, list->next);\n    /* sort the list by index, in effect returning the list to original state */\n    list = core_list_mergesort(list, cmp_idx, NULL);\n    /* CRC data content of list */\n    finder = list->next;\n    while (finder)\n    {\n        retval = crc16(list->info->data16, retval);\n        finder = finder->next;\n    }\n#if CORE_DEBUG\n    ee_printf(\"List sort 2: %04x\\n\", retval);\n#endif\n    return retval;\n}\n/* Function: core_list_init\n        Initialize list with data.\n\n        Parameters:\n        blksize - Size of memory to be initialized.\n        memblock - Pointer to memory block.\n        seed - \tActual values chosen depend on the seed parameter.\n                The seed parameter MUST be supplied from a source that cannot be\n   determined at compile time\n\n        Returns:\n        Pointer to the head of the list.\n\n*/\nlist_head *\ncore_list_init(ee_u32 blksize, list_head *memblock, ee_s16 seed)\n{\n    /* calculated pointers for the list */\n    ee_u32 per_item = 16 + sizeof(struct list_data_s);\n    ee_u32 size     = (blksize / per_item)\n                  - 2; /* to accomodate systems with 64b pointers, and make sure\n                          same code is executed, set max list elements */\n    list_head *memblock_end  = memblock + size;\n    list_data *datablock     = (list_data *)(memblock_end);\n    list_data *datablock_end = datablock + size;\n    /* some useful variables */\n    ee_u32     i;\n    list_head *finder, *list = memblock;\n    list_data  info;\n\n    /* create a fake items for the list head and tail */\n    list->next         = NULL;\n    list->info         = datablock;\n    list->info->idx    = 0x0000;\n    list->info->data16 = (ee_s16)0x8080;\n    memblock++;\n    datablock++;\n    info.idx    = 0x7fff;\n    info.data16 = (ee_s16)0xffff;\n    core_list_insert_new(\n        list, &info, &memblock, &datablock, memblock_end, datablock_end);\n\n    /* then insert size items */\n    for (i = 0; i < size; i++)\n    {\n        ee_u16 datpat = ((ee_u16)(seed ^ i) & 0xf);\n        ee_u16 dat\n            = (datpat << 3) | (i & 0x7); /* alternate between algorithms */\n        info.data16 = (dat << 8) | dat;  /* fill the data with actual data and\n                                            upper bits with rebuild value */\n        core_list_insert_new(\n            list, &info, &memblock, &datablock, memblock_end, datablock_end);\n    }\n    /* and now index the list so we know initial seed order of the list */\n    finder = list->next;\n    i      = 1;\n    while (finder->next != NULL)\n    {\n        if (i < size / 5) /* first 20% of the list in order */\n            finder->info->idx = i++;\n        else\n        {\n            ee_u16 pat = (ee_u16)(i++ ^ seed); /* get a pseudo random number */\n            finder->info->idx = 0x3fff\n                                & (((i & 0x07) << 8)\n                                   | pat); /* make sure the mixed items end up\n                                              after the ones in sequence */\n        }\n        finder = finder->next;\n    }\n    list = core_list_mergesort(list, cmp_idx, NULL);\n#if CORE_DEBUG\n    ee_printf(\"Initialized list:\\n\");\n    finder = list;\n    while (finder)\n    {\n        ee_printf(\n            \"[%04x,%04x]\", finder->info->idx, (ee_u16)finder->info->data16);\n        finder = finder->next;\n    }\n    ee_printf(\"\\n\");\n#endif\n    return list;\n}\n\n/* Function: core_list_insert\n        Insert an item to the list\n\n        Parameters:\n        insert_point - where to insert the item.\n        info - data for the cell.\n        memblock - pointer for the list header\n        datablock - pointer for the list data\n        memblock_end - end of region for list headers\n        datablock_end - end of region for list data\n\n        Returns:\n        Pointer to new item.\n*/\nlist_head *\ncore_list_insert_new(list_head * insert_point,\n                     list_data * info,\n                     list_head **memblock,\n                     list_data **datablock,\n                     list_head * memblock_end,\n                     list_data * datablock_end)\n{\n    list_head *newitem;\n\n    if ((*memblock + 1) >= memblock_end)\n        return NULL;\n    if ((*datablock + 1) >= datablock_end)\n        return NULL;\n\n    newitem = *memblock;\n    (*memblock)++;\n    newitem->next      = insert_point->next;\n    insert_point->next = newitem;\n\n    newitem->info = *datablock;\n    (*datablock)++;\n    copy_info(newitem->info, info);\n\n    return newitem;\n}\n\n/* Function: core_list_remove\n        Remove an item from the list.\n\n        Operation:\n        For a singly linked list, remove by copying the data from the next item\n        over to the current cell, and unlinking the next item.\n\n        Note:\n        since there is always a fake item at the end of the list, no need to\n   check for NULL.\n\n        Returns:\n        Removed item.\n*/\nlist_head *\ncore_list_remove(list_head *item)\n{\n    list_data *tmp;\n    list_head *ret = item->next;\n    /* swap data pointers */\n    tmp        = item->info;\n    item->info = ret->info;\n    ret->info  = tmp;\n    /* and eliminate item */\n    item->next = item->next->next;\n    ret->next  = NULL;\n    return ret;\n}\n\n/* Function: core_list_undo_remove\n        Undo a remove operation.\n\n        Operation:\n        Since we want each iteration of the benchmark to be exactly the same,\n        we need to be able to undo a remove.\n        Link the removed item back into the list, and switch the info items.\n\n        Parameters:\n        item_removed - Return value from the <core_list_remove>\n        item_modified - List item that was modified during <core_list_remove>\n\n        Returns:\n        The item that was linked back to the list.\n\n*/\nlist_head *\ncore_list_undo_remove(list_head *item_removed, list_head *item_modified)\n{\n    list_data *tmp;\n    /* swap data pointers */\n    tmp                 = item_removed->info;\n    item_removed->info  = item_modified->info;\n    item_modified->info = tmp;\n    /* and insert item */\n    item_removed->next  = item_modified->next;\n    item_modified->next = item_removed;\n    return item_removed;\n}\n\n/* Function: core_list_find\n        Find an item in the list\n\n        Operation:\n        Find an item by idx (if not 0) or specific data value\n\n        Parameters:\n        list - list head\n        info - idx or data to find\n\n        Returns:\n        Found item, or NULL if not found.\n*/\nlist_head *\ncore_list_find(list_head *list, list_data *info)\n{\n    if (info->idx >= 0)\n    {\n        while (list && (list->info->idx != info->idx))\n            list = list->next;\n        return list;\n    }\n    else\n    {\n        while (list && ((list->info->data16 & 0xff) != info->data16))\n            list = list->next;\n        return list;\n    }\n}\n/* Function: core_list_reverse\n        Reverse a list\n\n        Operation:\n        Rearrange the pointers so the list is reversed.\n\n        Parameters:\n        list - list head\n        info - idx or data to find\n\n        Returns:\n        Found item, or NULL if not found.\n*/\n\nlist_head *\ncore_list_reverse(list_head *list)\n{\n    list_head *next = NULL, *tmp;\n    while (list)\n    {\n        tmp        = list->next;\n        list->next = next;\n        next       = list;\n        list       = tmp;\n    }\n    return next;\n}\n/* Function: core_list_mergesort\n        Sort the list in place without recursion.\n\n        Description:\n        Use mergesort, as for linked list this is a realistic solution.\n        Also, since this is aimed at embedded, care was taken to use iterative\n   rather then recursive algorithm. The sort can either return the list to\n   original order (by idx) , or use the data item to invoke other other\n   algorithms and change the order of the list.\n\n        Parameters:\n        list - list to be sorted.\n        cmp - cmp function to use\n\n        Returns:\n        New head of the list.\n\n        Note:\n        We have a special header for the list that will always be first,\n        but the algorithm could theoretically modify where the list starts.\n\n */\nlist_head *\ncore_list_mergesort(list_head *list, list_cmp cmp, core_results *res)\n{\n    list_head *p, *q, *e, *tail;\n    ee_s32     insize, nmerges, psize, qsize, i;\n\n    insize = 1;\n\n    while (1)\n    {\n        p    = list;\n        list = NULL;\n        tail = NULL;\n\n        nmerges = 0; /* count number of merges we do in this pass */\n\n        while (p)\n        {\n            nmerges++; /* there exists a merge to be done */\n            /* step `insize' places along from p */\n            q     = p;\n            psize = 0;\n            for (i = 0; i < insize; i++)\n            {\n                psize++;\n                q = q->next;\n                if (!q)\n                    break;\n            }\n\n            /* if q hasn't fallen off end, we have two lists to merge */\n            qsize = insize;\n\n            /* now we have two lists; merge them */\n            while (psize > 0 || (qsize > 0 && q))\n            {\n\n                /* decide whether next element of merge comes from p or q */\n                if (psize == 0)\n                {\n                    /* p is empty; e must come from q. */\n                    e = q;\n                    q = q->next;\n                    qsize--;\n                }\n                else if (qsize == 0 || !q)\n                {\n                    /* q is empty; e must come from p. */\n                    e = p;\n                    p = p->next;\n                    psize--;\n                }\n                else if (cmp(p->info, q->info, res) <= 0)\n                {\n                    /* First element of p is lower (or same); e must come from\n                     * p. */\n                    e = p;\n                    p = p->next;\n                    psize--;\n                }\n                else\n                {\n                    /* First element of q is lower; e must come from q. */\n                    e = q;\n                    q = q->next;\n                    qsize--;\n                }\n\n                /* add the next element to the merged list */\n                if (tail)\n                {\n                    tail->next = e;\n                }\n                else\n                {\n                    list = e;\n                }\n                tail = e;\n            }\n\n            /* now p has stepped `insize' places along, and q has too */\n            p = q;\n        }\n\n        tail->next = NULL;\n\n        /* If we have done only one merge, we're finished. */\n        if (nmerges <= 1) /* allow for nmerges==0, the empty list case */\n            return list;\n\n        /* Otherwise repeat, merging lists twice the size */\n        insize *= 2;\n    }\n#if COMPILER_REQUIRES_SORT_RETURN\n    return list;\n#endif\n}\n","core_main.c":"/*\nCopyright 2018 Embedded Microprocessor Benchmark Consortium (EEMBC)\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\nOriginal Author: Shay Gal-on\n*/\n\n/* File: core_main.c\n        This file contains the framework to acquire a block of memory, seed\n   initial parameters, tun t he benchmark and report the results.\n*/\n#include \"coremark.h\"\n\n/* Function: iterate\n        Run the benchmark for a specified number of iterations.\n\n        Operation:\n        For each type of benchmarked algorithm:\n                a - Initialize the data block for the algorithm.\n                b - Execute the algorithm N times.\n\n        Returns:\n        NULL.\n*/\nstatic ee_u16 list_known_crc[]   = { (ee_u16)0xd4b0,\n                                   (ee_u16)0x3340,\n                                   (ee_u16)0x6a79,\n                                   (ee_u16)0xe714,\n                                   (ee_u16)0xe3c1 };\nstatic ee_u16 matrix_known_crc[] = { (ee_u16)0xbe52,\n                                     (ee_u16)0x1199,\n                                     (ee_u16)0x5608,\n                                     (ee_u16)0x1fd7,\n                                     (ee_u16)0x0747 };\nstatic ee_u16 state_known_crc[]  = { (ee_u16)0x5e47,\n                                    (ee_u16)0x39bf,\n                                    (ee_u16)0xe5a4,\n                                    (ee_u16)0x8e3a,\n                                    (ee_u16)0x8d84 };\nvoid *\niterate(void *pres)\n{\n    ee_u32        i;\n    ee_u16        crc;\n    core_results *res        = (core_results *)pres;\n    ee_u32        iterations = res->iterations;\n    res->crc                 = 0;\n    res->crclist             = 0;\n    res->crcmatrix           = 0;\n    res->crcstate            = 0;\n\n    for (i = 0; i < iterations; i++)\n    {\n        crc      = core_bench_list(res, 1);\n        res->crc = crcu16(crc, res->crc);\n        crc      = core_bench_list(res, -1);\n        res->crc = crcu16(crc, res->crc);\n        if (i == 0)\n            res->crclist = res->crc;\n    }\n    return NULL;\n}\n\n#if (SEED_METHOD == SEED_ARG)\nee_s32 get_seed_args(int i, int argc, char *argv[]);\n#define get_seed(x)    (ee_s16) get_seed_args(x, argc, argv)\n#define get_seed_32(x) get_seed_args(x, argc, argv)\n#else /* via function or volatile */\nee_s32 get_seed_32(int i);\n#define get_seed(x) (ee_s16) get_seed_32(x)\n#endif\n\n#if (MEM_METHOD == MEM_STATIC)\nee_u8 static_memblk[TOTAL_DATA_SIZE];\n#endif\nchar *mem_name[3] = { \"Static\", \"Heap\", \"Stack\" };\n/* Function: main\n        Main entry routine for the benchmark.\n        This function is responsible for the following steps:\n\n        1 - Initialize input seeds from a source that cannot be determined at\n   compile time. 2 - Initialize memory block for use. 3 - Run and time the\n   benchmark. 4 - Report results, testing the validity of the output if the\n   seeds are known.\n\n        Arguments:\n        1 - first seed  : Any value\n        2 - second seed : Must be identical to first for iterations to be\n   identical 3 - third seed  : Any value, should be at least an order of\n   magnitude less then the input size, but bigger then 32. 4 - Iterations  :\n   Special, if set to 0, iterations will be automatically determined such that\n   the benchmark will run between 10 to 100 secs\n\n*/\n\n#if MAIN_HAS_NOARGC\nMAIN_RETURN_TYPE\nmain(void)\n{\n    int   argc = 0;\n    char *argv[1];\n#else\nMAIN_RETURN_TYPE\nmain(int argc, char *argv[])\n{\n#endif\n    ee_u16       i, j = 0, num_algorithms = 0;\n    ee_s16       known_id = -1, total_errors = 0;\n    ee_u16       seedcrc = 0;\n    CORE_TICKS   total_time;\n    core_results results[MULTITHREAD];\n#if (MEM_METHOD == MEM_STACK)\n    ee_u8 stack_memblock[TOTAL_DATA_SIZE * MULTITHREAD];\n#endif\n    /* first call any initializations needed */\n    portable_init(&(results[0].port), &argc, argv);\n    /* First some checks to make sure benchmark will run ok */\n    if (sizeof(struct list_head_s) > 128)\n    {\n        ee_printf(\"list_head structure too big for comparable data!\\n\");\n        return MAIN_RETURN_VAL;\n    }\n    results[0].seed1      = get_seed(1);\n    results[0].seed2      = get_seed(2);\n    results[0].seed3      = get_seed(3);\n    results[0].iterations = get_seed_32(4);\n#if CORE_DEBUG\n    results[0].iterations = 1;\n#endif\n    results[0].execs = get_seed_32(5);\n    if (results[0].execs == 0)\n    { /* if not supplied, execute all algorithms */\n        results[0].execs = ALL_ALGORITHMS_MASK;\n    }\n    /* put in some default values based on one seed only for easy testing */\n    if ((results[0].seed1 == 0) && (results[0].seed2 == 0)\n        && (results[0].seed3 == 0))\n    { /* perfromance run */\n        results[0].seed1 = 0;\n        results[0].seed2 = 0;\n        results[0].seed3 = 0x66;\n    }\n    if ((results[0].seed1 == 1) && (results[0].seed2 == 0)\n        && (results[0].seed3 == 0))\n    { /* validation run */\n        results[0].seed1 = 0x3415;\n        results[0].seed2 = 0x3415;\n        results[0].seed3 = 0x66;\n    }\n#if (MEM_METHOD == MEM_STATIC)\n    results[0].memblock[0] = (void *)static_memblk;\n    results[0].size        = TOTAL_DATA_SIZE;\n    results[0].err         = 0;\n#if (MULTITHREAD > 1)\n#error \"Cannot use a static data area with multiple contexts!\"\n#endif\n#elif (MEM_METHOD == MEM_MALLOC)\n    for (i = 0; i < MULTITHREAD; i++)\n    {\n        ee_s32 malloc_override = get_seed(7);\n        if (malloc_override != 0)\n            results[i].size = malloc_override;\n        else\n            results[i].size = TOTAL_DATA_SIZE;\n        results[i].memblock[0] = portable_malloc(results[i].size);\n        results[i].seed1       = results[0].seed1;\n        results[i].seed2       = results[0].seed2;\n        results[i].seed3       = results[0].seed3;\n        results[i].err         = 0;\n        results[i].execs       = results[0].execs;\n    }\n#elif (MEM_METHOD == MEM_STACK)\nfor (i = 0; i < MULTITHREAD; i++)\n{\n    results[i].memblock[0] = stack_memblock + i * TOTAL_DATA_SIZE;\n    results[i].size        = TOTAL_DATA_SIZE;\n    results[i].seed1       = results[0].seed1;\n    results[i].seed2       = results[0].seed2;\n    results[i].seed3       = results[0].seed3;\n    results[i].err         = 0;\n    results[i].execs       = results[0].execs;\n}\n#else\n#error \"Please define a way to initialize a memory block.\"\n#endif\n    /* Data init */\n    /* Find out how space much we have based on number of algorithms */\n    for (i = 0; i < NUM_ALGORITHMS; i++)\n    {\n        if ((1 << (ee_u32)i) & results[0].execs)\n            num_algorithms++;\n    }\n    for (i = 0; i < MULTITHREAD; i++)\n        results[i].size = results[i].size / num_algorithms;\n    /* Assign pointers */\n    for (i = 0; i < NUM_ALGORITHMS; i++)\n    {\n        ee_u32 ctx;\n        if ((1 << (ee_u32)i) & results[0].execs)\n        {\n            for (ctx = 0; ctx < MULTITHREAD; ctx++)\n                results[ctx].memblock[i + 1]\n                    = (char *)(results[ctx].memblock[0]) + results[0].size * j;\n            j++;\n        }\n    }\n    /* call inits */\n    for (i = 0; i < MULTITHREAD; i++)\n    {\n        if (results[i].execs & ID_LIST)\n        {\n            results[i].list = core_list_init(\n                results[0].size, results[i].memblock[1], results[i].seed1);\n        }\n        if (results[i].execs & ID_MATRIX)\n        {\n            core_init_matrix(results[0].size,\n                             results[i].memblock[2],\n                             (ee_s32)results[i].seed1\n                                 | (((ee_s32)results[i].seed2) << 16),\n                             &(results[i].mat));\n        }\n        if (results[i].execs & ID_STATE)\n        {\n            core_init_state(\n                results[0].size, results[i].seed1, results[i].memblock[3]);\n        }\n    }\n\n    /* automatically determine number of iterations if not set */\n    if (results[0].iterations == 0)\n    {\n        secs_ret secs_passed = 0;\n        ee_u32   divisor;\n        results[0].iterations = 1;\n        while (secs_passed < (secs_ret)1)\n        {\n            results[0].iterations *= 10;\n            start_time();\n            iterate(&results[0]);\n            stop_time();\n            secs_passed = time_in_secs(get_time());\n        }\n        /* now we know it executes for at least 1 sec, set actual run time at\n         * about 10 secs */\n        divisor = (ee_u32)secs_passed;\n        if (divisor == 0) /* some machines cast float to int as 0 since this\n                             conversion is not defined by ANSI, but we know at\n                             least one second passed */\n            divisor = 1;\n        results[0].iterations *= 1 + 10 / divisor;\n    }\n    /* perform actual benchmark */\n    start_time();\n#if (MULTITHREAD > 1)\n    if (default_num_contexts > MULTITHREAD)\n    {\n        default_num_contexts = MULTITHREAD;\n    }\n    for (i = 0; i < default_num_contexts; i++)\n    {\n        results[i].iterations = results[0].iterations;\n        results[i].execs      = results[0].execs;\n        core_start_parallel(&results[i]);\n    }\n    for (i = 0; i < default_num_contexts; i++)\n    {\n        core_stop_parallel(&results[i]);\n    }\n#else\n    iterate(&results[0]);\n#endif\n    stop_time();\n    total_time = get_time();\n    /* get a function of the input to report */\n    seedcrc = crc16(results[0].seed1, seedcrc);\n    seedcrc = crc16(results[0].seed2, seedcrc);\n    seedcrc = crc16(results[0].seed3, seedcrc);\n    seedcrc = crc16(results[0].size, seedcrc);\n\n    switch (seedcrc)\n    {                /* test known output for common seeds */\n        case 0x8a02: /* seed1=0, seed2=0, seed3=0x66, size 2000 per algorithm */\n            known_id = 0;\n            ee_printf(\"6k performance run parameters for coremark.\\n\");\n            break;\n        case 0x7b05: /*  seed1=0x3415, seed2=0x3415, seed3=0x66, size 2000 per\n                        algorithm */\n            known_id = 1;\n            ee_printf(\"6k validation run parameters for coremark.\\n\");\n            break;\n        case 0x4eaf: /* seed1=0x8, seed2=0x8, seed3=0x8, size 400 per algorithm\n                      */\n            known_id = 2;\n            ee_printf(\"Profile generation run parameters for coremark.\\n\");\n            break;\n        case 0xe9f5: /* seed1=0, seed2=0, seed3=0x66, size 666 per algorithm */\n            known_id = 3;\n            ee_printf(\"2K performance run parameters for coremark.\\n\");\n            break;\n        case 0x18f2: /*  seed1=0x3415, seed2=0x3415, seed3=0x66, size 666 per\n                        algorithm */\n            known_id = 4;\n            ee_printf(\"2K validation run parameters for coremark.\\n\");\n            break;\n        default:\n            total_errors = -1;\n            break;\n    }\n    if (known_id >= 0)\n    {\n        for (i = 0; i < default_num_contexts; i++)\n        {\n            results[i].err = 0;\n            if ((results[i].execs & ID_LIST)\n                && (results[i].crclist != list_known_crc[known_id]))\n            {\n                ee_printf(\"[%u]ERROR! list crc 0x%04x - should be 0x%04x\\n\",\n                          i,\n                          results[i].crclist,\n                          list_known_crc[known_id]);\n                results[i].err++;\n            }\n            if ((results[i].execs & ID_MATRIX)\n                && (results[i].crcmatrix != matrix_known_crc[known_id]))\n            {\n                ee_printf(\"[%u]ERROR! matrix crc 0x%04x - should be 0x%04x\\n\",\n                          i,\n                          results[i].crcmatrix,\n                          matrix_known_crc[known_id]);\n                results[i].err++;\n            }\n            if ((results[i].execs & ID_STATE)\n                && (results[i].crcstate != state_known_crc[known_id]))\n            {\n                ee_printf(\"[%u]ERROR! state crc 0x%04x - should be 0x%04x\\n\",\n                          i,\n                          results[i].crcstate,\n                          state_known_crc[known_id]);\n                results[i].err++;\n            }\n            total_errors += results[i].err;\n        }\n    }\n    total_errors += check_data_types();\n    /* and report results */\n    ee_printf(\"CoreMark Size    : %lu\\n\", (long unsigned)results[0].size);\n    ee_printf(\"Total ticks      : %lu\\n\", (long unsigned)total_time);\n#if HAS_FLOAT\n    ee_printf(\"Total time (secs): %f\\n\", time_in_secs(total_time));\n    if (time_in_secs(total_time) > 0)\n        ee_printf(\"Iterations/Sec   : %f\\n\",\n                  default_num_contexts * results[0].iterations\n                      / time_in_secs(total_time));\n#else\n    ee_printf(\"Total time (secs): %d\\n\", time_in_secs(total_time));\n    if (time_in_secs(total_time) > 0)\n        ee_printf(\"Iterations/Sec   : %d\\n\",\n                  default_num_contexts * results[0].iterations\n                      / time_in_secs(total_time));\n#endif\n    if (time_in_secs(total_time) < 10)\n    {\n        ee_printf(\n            \"ERROR! Must execute for at least 10 secs for a valid result!\\n\");\n        total_errors++;\n    }\n\n    ee_printf(\"Iterations       : %lu\\n\",\n              (long unsigned)default_num_contexts * results[0].iterations);\n    ee_printf(\"Compiler version : %s\\n\", COMPILER_VERSION);\n    ee_printf(\"Compiler flags   : %s\\n\", COMPILER_FLAGS);\n#if (MULTITHREAD > 1)\n    ee_printf(\"Parallel %s : %d\\n\", PARALLEL_METHOD, default_num_contexts);\n#endif\n    ee_printf(\"Memory location  : %s\\n\", MEM_LOCATION);\n    /* output for verification */\n    ee_printf(\"seedcrc          : 0x%04x\\n\", seedcrc);\n    if (results[0].execs & ID_LIST)\n        for (i = 0; i < default_num_contexts; i++)\n            ee_printf(\"[%d]crclist       : 0x%04x\\n\", i, results[i].crclist);\n    if (results[0].execs & ID_MATRIX)\n        for (i = 0; i < default_num_contexts; i++)\n            ee_printf(\"[%d]crcmatrix     : 0x%04x\\n\", i, results[i].crcmatrix);\n    if (results[0].execs & ID_STATE)\n        for (i = 0; i < default_num_contexts; i++)\n            ee_printf(\"[%d]crcstate      : 0x%04x\\n\", i, results[i].crcstate);\n    for (i = 0; i < default_num_contexts; i++)\n        ee_printf(\"[%d]crcfinal      : 0x%04x\\n\", i, results[i].crc);\n    if (total_errors == 0)\n    {\n        ee_printf(\n            \"Correct operation validated. See README.md for run and reporting \"\n            \"rules.\\n\");\n#if HAS_FLOAT\n        if (known_id == 3)\n        {\n            ee_printf(\"CoreMark 1.0 : %f / %s %s\",\n                      default_num_contexts * results[0].iterations\n                          / time_in_secs(total_time),\n                      COMPILER_VERSION,\n                      COMPILER_FLAGS);\n#if defined(MEM_LOCATION) && !defined(MEM_LOCATION_UNSPEC)\n            ee_printf(\" / %s\", MEM_LOCATION);\n#else\n            ee_printf(\" / %s\", mem_name[MEM_METHOD]);\n#endif\n\n#if (MULTITHREAD > 1)\n            ee_printf(\" / %d:%s\", default_num_contexts, PARALLEL_METHOD);\n#endif\n            ee_printf(\"\\n\");\n        }\n#endif\n    }\n    if (total_errors > 0)\n        ee_printf(\"Errors detected\\n\");\n    if (total_errors < 0)\n        ee_printf(\n            \"Cannot validate operation for these seed values, please compare \"\n            \"with results on a known platform.\\n\");\n\n#if (MEM_METHOD == MEM_MALLOC)\n    for (i = 0; i < MULTITHREAD; i++)\n        portable_free(results[i].memblock[0]);\n#endif\n    /* And last call any target specific code for finalizing */\n    portable_fini(&(results[0].port));\n\n    return MAIN_RETURN_VAL;\n}\n","core_matrix.c":"/*\nCopyright 2018 Embedded Microprocessor Benchmark Consortium (EEMBC)\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\nOriginal Author: Shay Gal-on\n*/\n\n#include \"coremark.h\"\n/*\nTopic: Description\n        Matrix manipulation benchmark\n\n        This very simple algorithm forms the basis of many more complex\nalgorithms.\n\n        The tight inner loop is the focus of many optimizations (compiler as\nwell as hardware based) and is thus relevant for embedded processing.\n\n        The total available data space will be divided to 3 parts:\n        NxN Matrix A - initialized with small values (upper 3/4 of the bits all\nzero). NxN Matrix B - initialized with medium values (upper half of the bits all\nzero). NxN Matrix C - used for the result.\n\n        The actual values for A and B must be derived based on input that is not\navailable at compile time.\n*/\nee_s16 matrix_test(ee_u32 N, MATRES *C, MATDAT *A, MATDAT *B, MATDAT val);\nee_s16 matrix_sum(ee_u32 N, MATRES *C, MATDAT clipval);\nvoid   matrix_mul_const(ee_u32 N, MATRES *C, MATDAT *A, MATDAT val);\nvoid   matrix_mul_vect(ee_u32 N, MATRES *C, MATDAT *A, MATDAT *B);\nvoid   matrix_mul_matrix(ee_u32 N, MATRES *C, MATDAT *A, MATDAT *B);\nvoid   matrix_mul_matrix_bitextract(ee_u32 N, MATRES *C, MATDAT *A, MATDAT *B);\nvoid   matrix_add_const(ee_u32 N, MATDAT *A, MATDAT val);\n\n#define matrix_test_next(x)      (x + 1)\n#define matrix_clip(x, y)        ((y) ? (x)&0x0ff : (x)&0x0ffff)\n#define matrix_big(x)            (0xf000 | (x))\n#define bit_extract(x, from, to) (((x) >> (from)) & (~(0xffffffff << (to))))\n\n#if CORE_DEBUG\nvoid\nprintmat(MATDAT *A, ee_u32 N, char *name)\n{\n    ee_u32 i, j;\n    ee_printf(\"Matrix %s [%dx%d]:\\n\", name, N, N);\n    for (i = 0; i < N; i++)\n    {\n        for (j = 0; j < N; j++)\n        {\n            if (j != 0)\n                ee_printf(\",\");\n            ee_printf(\"%d\", A[i * N + j]);\n        }\n        ee_printf(\"\\n\");\n    }\n}\nvoid\nprintmatC(MATRES *C, ee_u32 N, char *name)\n{\n    ee_u32 i, j;\n    ee_printf(\"Matrix %s [%dx%d]:\\n\", name, N, N);\n    for (i = 0; i < N; i++)\n    {\n        for (j = 0; j < N; j++)\n        {\n            if (j != 0)\n                ee_printf(\",\");\n            ee_printf(\"%d\", C[i * N + j]);\n        }\n        ee_printf(\"\\n\");\n    }\n}\n#endif\n/* Function: core_bench_matrix\n        Benchmark function\n\n        Iterate <matrix_test> N times,\n        changing the matrix values slightly by a constant amount each time.\n*/\nee_u16\ncore_bench_matrix(mat_params *p, ee_s16 seed, ee_u16 crc)\n{\n    ee_u32  N   = p->N;\n    MATRES *C   = p->C;\n    MATDAT *A   = p->A;\n    MATDAT *B   = p->B;\n    MATDAT  val = (MATDAT)seed;\n\n    crc = crc16(matrix_test(N, C, A, B, val), crc);\n\n    return crc;\n}\n\n/* Function: matrix_test\n        Perform matrix manipulation.\n\n        Parameters:\n        N - Dimensions of the matrix.\n        C - memory for result matrix.\n        A - input matrix\n        B - operator matrix (not changed during operations)\n\n        Returns:\n        A CRC value that captures all results calculated in the function.\n        In particular, crc of the value calculated on the result matrix\n        after each step by <matrix_sum>.\n\n        Operation:\n\n        1 - Add a constant value to all elements of a matrix.\n        2 - Multiply a matrix by a constant.\n        3 - Multiply a matrix by a vector.\n        4 - Multiply a matrix by a matrix.\n        5 - Add a constant value to all elements of a matrix.\n\n        After the last step, matrix A is back to original contents.\n*/\nee_s16\nmatrix_test(ee_u32 N, MATRES *C, MATDAT *A, MATDAT *B, MATDAT val)\n{\n    ee_u16 crc     = 0;\n    MATDAT clipval = matrix_big(val);\n\n    matrix_add_const(N, A, val); /* make sure data changes  */\n#if CORE_DEBUG\n    printmat(A, N, \"matrix_add_const\");\n#endif\n    matrix_mul_const(N, C, A, val);\n    crc = crc16(matrix_sum(N, C, clipval), crc);\n#if CORE_DEBUG\n    printmatC(C, N, \"matrix_mul_const\");\n#endif\n    matrix_mul_vect(N, C, A, B);\n    crc = crc16(matrix_sum(N, C, clipval), crc);\n#if CORE_DEBUG\n    printmatC(C, N, \"matrix_mul_vect\");\n#endif\n    matrix_mul_matrix(N, C, A, B);\n    crc = crc16(matrix_sum(N, C, clipval), crc);\n#if CORE_DEBUG\n    printmatC(C, N, \"matrix_mul_matrix\");\n#endif\n    matrix_mul_matrix_bitextract(N, C, A, B);\n    crc = crc16(matrix_sum(N, C, clipval), crc);\n#if CORE_DEBUG\n    printmatC(C, N, \"matrix_mul_matrix_bitextract\");\n#endif\n\n    matrix_add_const(N, A, -val); /* return matrix to initial value */\n    return crc;\n}\n\n/* Function : matrix_init\n        Initialize the memory block for matrix benchmarking.\n\n        Parameters:\n        blksize - Size of memory to be initialized.\n        memblk - Pointer to memory block.\n        seed - Actual values chosen depend on the seed parameter.\n        p - pointers to <mat_params> containing initialized matrixes.\n\n        Returns:\n        Matrix dimensions.\n\n        Note:\n        The seed parameter MUST be supplied from a source that cannot be\n   determined at compile time\n*/\nee_u32\ncore_init_matrix(ee_u32 blksize, void *memblk, ee_s32 seed, mat_params *p)\n{\n    ee_u32  N = 0;\n    MATDAT *A;\n    MATDAT *B;\n    ee_s32  order = 1;\n    MATDAT  val;\n    ee_u32  i = 0, j = 0;\n    if (seed == 0)\n        seed = 1;\n    while (j < blksize)\n    {\n        i++;\n        j = i * i * 2 * 4;\n    }\n    N = i - 1;\n    A = (MATDAT *)align_mem(memblk);\n    B = A + N * N;\n\n    for (i = 0; i < N; i++)\n    {\n        for (j = 0; j < N; j++)\n        {\n            seed         = ((order * seed) % 65536);\n            val          = (seed + order);\n            val          = matrix_clip(val, 0);\n            B[i * N + j] = val;\n            val          = (val + order);\n            val          = matrix_clip(val, 1);\n            A[i * N + j] = val;\n            order++;\n        }\n    }\n\n    p->A = A;\n    p->B = B;\n    p->C = (MATRES *)align_mem(B + N * N);\n    p->N = N;\n#if CORE_DEBUG\n    printmat(A, N, \"A\");\n    printmat(B, N, \"B\");\n#endif\n    return N;\n}\n\n/* Function: matrix_sum\n        Calculate a function that depends on the values of elements in the\n   matrix.\n\n        For each element, accumulate into a temporary variable.\n\n        As long as this value is under the parameter clipval,\n        add 1 to the result if the element is bigger then the previous.\n\n        Otherwise, reset the accumulator and add 10 to the result.\n*/\nee_s16\nmatrix_sum(ee_u32 N, MATRES *C, MATDAT clipval)\n{\n    MATRES tmp = 0, prev = 0, cur = 0;\n    ee_s16 ret = 0;\n    ee_u32 i, j;\n    for (i = 0; i < N; i++)\n    {\n        for (j = 0; j < N; j++)\n        {\n            cur = C[i * N + j];\n            tmp += cur;\n            if (tmp > clipval)\n            {\n                ret += 10;\n                tmp = 0;\n            }\n            else\n            {\n                ret += (cur > prev) ? 1 : 0;\n            }\n            prev = cur;\n        }\n    }\n    return ret;\n}\n\n/* Function: matrix_mul_const\n        Multiply a matrix by a constant.\n        This could be used as a scaler for instance.\n*/\nvoid\nmatrix_mul_const(ee_u32 N, MATRES *C, MATDAT *A, MATDAT val)\n{\n    ee_u32 i, j;\n    for (i = 0; i < N; i++)\n    {\n        for (j = 0; j < N; j++)\n        {\n            C[i * N + j] = (MATRES)A[i * N + j] * (MATRES)val;\n        }\n    }\n}\n\n/* Function: matrix_add_const\n        Add a constant value to all elements of a matrix.\n*/\nvoid\nmatrix_add_const(ee_u32 N, MATDAT *A, MATDAT val)\n{\n    ee_u32 i, j;\n    for (i = 0; i < N; i++)\n    {\n        for (j = 0; j < N; j++)\n        {\n            A[i * N + j] += val;\n        }\n    }\n}\n\n/* Function: matrix_mul_vect\n        Multiply a matrix by a vector.\n        This is common in many simple filters (e.g. fir where a vector of\n   coefficients is applied to the matrix.)\n*/\nvoid\nmatrix_mul_vect(ee_u32 N, MATRES *C, MATDAT *A, MATDAT *B)\n{\n    ee_u32 i, j;\n    for (i = 0; i < N; i++)\n    {\n        C[i] = 0;\n        for (j = 0; j < N; j++)\n        {\n            C[i] += (MATRES)A[i * N + j] * (MATRES)B[j];\n        }\n    }\n}\n\n/* Function: matrix_mul_matrix\n        Multiply a matrix by a matrix.\n        Basic code is used in many algorithms, mostly with minor changes such as\n   scaling.\n*/\nvoid\nmatrix_mul_matrix(ee_u32 N, MATRES *C, MATDAT *A, MATDAT *B)\n{\n    ee_u32 i, j, k;\n    for (i = 0; i < N; i++)\n    {\n        for (j = 0; j < N; j++)\n        {\n            C[i * N + j] = 0;\n            for (k = 0; k < N; k++)\n            {\n                C[i * N + j] += (MATRES)A[i * N + k] * (MATRES)B[k * N + j];\n            }\n        }\n    }\n}\n\n/* Function: matrix_mul_matrix_bitextract\n        Multiply a matrix by a matrix, and extract some bits from the result.\n        Basic code is used in many algorithms, mostly with minor changes such as\n   scaling.\n*/\nvoid\nmatrix_mul_matrix_bitextract(ee_u32 N, MATRES *C, MATDAT *A, MATDAT *B)\n{\n    ee_u32 i, j, k;\n    for (i = 0; i < N; i++)\n    {\n        for (j = 0; j < N; j++)\n        {\n            C[i * N + j] = 0;\n            for (k = 0; k < N; k++)\n            {\n                MATRES tmp = (MATRES)A[i * N + k] * (MATRES)B[k * N + j];\n                C[i * N + j] += bit_extract(tmp, 2, 4) * bit_extract(tmp, 5, 7);\n            }\n        }\n    }\n}\n","core_state.c":"/*\nCopyright 2018 Embedded Microprocessor Benchmark Consortium (EEMBC)\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\nOriginal Author: Shay Gal-on\n*/\n\n#include \"coremark.h\"\n/* local functions */\nenum CORE_STATE core_state_transition(ee_u8 **instr, ee_u32 *transition_count);\n\n/*\nTopic: Description\n        Simple state machines like this one are used in many embedded products.\n\n        For more complex state machines, sometimes a state transition table\nimplementation is used instead, trading speed of direct coding for ease of\nmaintenance.\n\n        Since the main goal of using a state machine in CoreMark is to excercise\nthe switch/if behaviour, we are using a small moore machine.\n\n        In particular, this machine tests type of string input,\n        trying to determine whether the input is a number or something else.\n        (see core_state.png).\n*/\n\n/* Function: core_bench_state\n        Benchmark function\n\n        Go over the input twice, once direct, and once after introducing some\n   corruption.\n*/\nee_u16\ncore_bench_state(ee_u32 blksize,\n                 ee_u8 *memblock,\n                 ee_s16 seed1,\n                 ee_s16 seed2,\n                 ee_s16 step,\n                 ee_u16 crc)\n{\n    ee_u32 final_counts[NUM_CORE_STATES];\n    ee_u32 track_counts[NUM_CORE_STATES];\n    ee_u8 *p = memblock;\n    ee_u32 i;\n\n#if CORE_DEBUG\n    ee_printf(\"State Bench: %d,%d,%d,%04x\\n\", seed1, seed2, step, crc);\n#endif\n    for (i = 0; i < NUM_CORE_STATES; i++)\n    {\n        final_counts[i] = track_counts[i] = 0;\n    }\n    /* run the state machine over the input */\n    while (*p != 0)\n    {\n        enum CORE_STATE fstate = core_state_transition(&p, track_counts);\n        final_counts[fstate]++;\n#if CORE_DEBUG\n        ee_printf(\"%d,\", fstate);\n    }\n    ee_printf(\"\\n\");\n#else\n    }\n#endif\n    p = memblock;\n    while (p < (memblock + blksize))\n    { /* insert some corruption */\n        if (*p != ',')\n            *p ^= (ee_u8)seed1;\n        p += step;\n    }\n    p = memblock;\n    /* run the state machine over the input again */\n    while (*p != 0)\n    {\n        enum CORE_STATE fstate = core_state_transition(&p, track_counts);\n        final_counts[fstate]++;\n#if CORE_DEBUG\n        ee_printf(\"%d,\", fstate);\n    }\n    ee_printf(\"\\n\");\n#else\n    }\n#endif\n    p = memblock;\n    while (p < (memblock + blksize))\n    { /* undo corruption is seed1 and seed2 are equal */\n        if (*p != ',')\n            *p ^= (ee_u8)seed2;\n        p += step;\n    }\n    /* end timing */\n    for (i = 0; i < NUM_CORE_STATES; i++)\n    {\n        crc = crcu32(final_counts[i], crc);\n        crc = crcu32(track_counts[i], crc);\n    }\n    return crc;\n}\n\n/* Default initialization patterns */\nstatic ee_u8 *intpat[4]\n    = { (ee_u8 *)\"5012\", (ee_u8 *)\"1234\", (ee_u8 *)\"-874\", (ee_u8 *)\"+122\" };\nstatic ee_u8 *floatpat[4] = { (ee_u8 *)\"35.54400\",\n                              (ee_u8 *)\".1234500\",\n                              (ee_u8 *)\"-110.700\",\n                              (ee_u8 *)\"+0.64400\" };\nstatic ee_u8 *scipat[4]   = { (ee_u8 *)\"5.500e+3\",\n                            (ee_u8 *)\"-.123e-2\",\n                            (ee_u8 *)\"-87e+832\",\n                            (ee_u8 *)\"+0.6e-12\" };\nstatic ee_u8 *errpat[4]   = { (ee_u8 *)\"T0.3e-1F\",\n                            (ee_u8 *)\"-T.T++Tq\",\n                            (ee_u8 *)\"1T3.4e4z\",\n                            (ee_u8 *)\"34.0e-T^\" };\n\n/* Function: core_init_state\n        Initialize the input data for the state machine.\n\n        Populate the input with several predetermined strings, interspersed.\n        Actual patterns chosen depend on the seed parameter.\n\n        Note:\n        The seed parameter MUST be supplied from a source that cannot be\n   determined at compile time\n*/\nvoid\ncore_init_state(ee_u32 size, ee_s16 seed, ee_u8 *p)\n{\n    ee_u32 total = 0, next = 0, i;\n    ee_u8 *buf = 0;\n#if CORE_DEBUG\n    ee_u8 *start = p;\n    ee_printf(\"State: %d,%d\\n\", size, seed);\n#endif\n    size--;\n    next = 0;\n    while ((total + next + 1) < size)\n    {\n        if (next > 0)\n        {\n            for (i = 0; i < next; i++)\n                *(p + total + i) = buf[i];\n            *(p + total + i) = ',';\n            total += next + 1;\n        }\n        seed++;\n        switch (seed & 0x7)\n        {\n            case 0: /* int */\n            case 1: /* int */\n            case 2: /* int */\n                buf  = intpat[(seed >> 3) & 0x3];\n                next = 4;\n                break;\n            case 3: /* float */\n            case 4: /* float */\n                buf  = floatpat[(seed >> 3) & 0x3];\n                next = 8;\n                break;\n            case 5: /* scientific */\n            case 6: /* scientific */\n                buf  = scipat[(seed >> 3) & 0x3];\n                next = 8;\n                break;\n            case 7: /* invalid */\n                buf  = errpat[(seed >> 3) & 0x3];\n                next = 8;\n                break;\n            default: /* Never happen, just to make some compilers happy */\n                break;\n        }\n    }\n    size++;\n    while (total < size)\n    { /* fill the rest with 0 */\n        *(p + total) = 0;\n        total++;\n    }\n#if CORE_DEBUG\n    ee_printf(\"State Input: %s\\n\", start);\n#endif\n}\n\nstatic ee_u8\nee_isdigit(ee_u8 c)\n{\n    ee_u8 retval;\n    retval = ((c >= '0') & (c <= '9')) ? 1 : 0;\n    return retval;\n}\n\n/* Function: core_state_transition\n        Actual state machine.\n\n        The state machine will continue scanning until either:\n        1 - an invalid input is detcted.\n        2 - a valid number has been detected.\n\n        The input pointer is updated to point to the end of the token, and the\n   end state is returned (either specific format determined or invalid).\n*/\n\nenum CORE_STATE\ncore_state_transition(ee_u8 **instr, ee_u32 *transition_count)\n{\n    ee_u8 *         str = *instr;\n    ee_u8           NEXT_SYMBOL;\n    enum CORE_STATE state = CORE_START;\n    for (; *str && state != CORE_INVALID; str++)\n    {\n        NEXT_SYMBOL = *str;\n        if (NEXT_SYMBOL == ',') /* end of this input */\n        {\n            str++;\n            break;\n        }\n        switch (state)\n        {\n            case CORE_START:\n                if (ee_isdigit(NEXT_SYMBOL))\n                {\n                    state = CORE_INT;\n                }\n                else if (NEXT_SYMBOL == '+' || NEXT_SYMBOL == '-')\n                {\n                    state = CORE_S1;\n                }\n                else if (NEXT_SYMBOL == '.')\n                {\n                    state = CORE_FLOAT;\n                }\n                else\n                {\n                    state = CORE_INVALID;\n                    transition_count[CORE_INVALID]++;\n                }\n                transition_count[CORE_START]++;\n                break;\n            case CORE_S1:\n                if (ee_isdigit(NEXT_SYMBOL))\n                {\n                    state = CORE_INT;\n                    transition_count[CORE_S1]++;\n                }\n                else if (NEXT_SYMBOL == '.')\n                {\n                    state = CORE_FLOAT;\n                    transition_count[CORE_S1]++;\n                }\n                else\n                {\n                    state = CORE_INVALID;\n                    transition_count[CORE_S1]++;\n                }\n                break;\n            case CORE_INT:\n                if (NEXT_SYMBOL == '.')\n                {\n                    state = CORE_FLOAT;\n                    transition_count[CORE_INT]++;\n                }\n                else if (!ee_isdigit(NEXT_SYMBOL))\n                {\n                    state = CORE_INVALID;\n                    transition_count[CORE_INT]++;\n                }\n                break;\n            case CORE_FLOAT:\n                if (NEXT_SYMBOL == 'E' || NEXT_SYMBOL == 'e')\n                {\n                    state = CORE_S2;\n                    transition_count[CORE_FLOAT]++;\n                }\n                else if (!ee_isdigit(NEXT_SYMBOL))\n                {\n                    state = CORE_INVALID;\n                    transition_count[CORE_FLOAT]++;\n                }\n                break;\n            case CORE_S2:\n                if (NEXT_SYMBOL == '+' || NEXT_SYMBOL == '-')\n                {\n                    state = CORE_EXPONENT;\n                    transition_count[CORE_S2]++;\n                }\n                else\n                {\n                    state = CORE_INVALID;\n                    transition_count[CORE_S2]++;\n                }\n                break;\n            case CORE_EXPONENT:\n                if (ee_isdigit(NEXT_SYMBOL))\n                {\n                    state = CORE_SCIENTIFIC;\n                    transition_count[CORE_EXPONENT]++;\n                }\n                else\n                {\n                    state = CORE_INVALID;\n                    transition_count[CORE_EXPONENT]++;\n                }\n                break;\n            case CORE_SCIENTIFIC:\n                if (!ee_isdigit(NEXT_SYMBOL))\n                {\n                    state = CORE_INVALID;\n                    transition_count[CORE_INVALID]++;\n                }\n                break;\n            default:\n                break;\n        }\n    }\n    *instr = str;\n    return state;\n}\n","core_util.c":"/*\nCopyright 2018 Embedded Microprocessor Benchmark Consortium (EEMBC)\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\nOriginal Author: Shay Gal-on\n*/\n\n#include \"coremark.h\"\n/* Function: get_seed\n        Get a values that cannot be determined at compile time.\n\n        Since different embedded systems and compilers are used, 3 different\n   methods are provided: 1 - Using a volatile variable. This method is only\n   valid if the compiler is forced to generate code that reads the value of a\n   volatile variable from memory at run time. Please note, if using this method,\n   you would need to modify core_portme.c to generate training profile. 2 -\n   Command line arguments. This is the preferred method if command line\n   arguments are supported. 3 - System function. If none of the first 2 methods\n   is available on the platform, a system function which is not a stub can be\n   used.\n\n        e.g. read the value on GPIO pins connected to switches, or invoke\n   special simulator functions.\n*/\n#if (SEED_METHOD == SEED_VOLATILE)\nextern volatile ee_s32 seed1_volatile;\nextern volatile ee_s32 seed2_volatile;\nextern volatile ee_s32 seed3_volatile;\nextern volatile ee_s32 seed4_volatile;\nextern volatile ee_s32 seed5_volatile;\nee_s32\nget_seed_32(int i)\n{\n    ee_s32 retval;\n    switch (i)\n    {\n        case 1:\n            retval = seed1_volatile;\n            break;\n        case 2:\n            retval = seed2_volatile;\n            break;\n        case 3:\n            retval = seed3_volatile;\n            break;\n        case 4:\n            retval = seed4_volatile;\n            break;\n        case 5:\n            retval = seed5_volatile;\n            break;\n        default:\n            retval = 0;\n            break;\n    }\n    return retval;\n}\n#elif (SEED_METHOD == SEED_ARG)\nee_s32\nparseval(char *valstring)\n{\n    ee_s32 retval  = 0;\n    ee_s32 neg     = 1;\n    int    hexmode = 0;\n    if (*valstring == '-')\n    {\n        neg = -1;\n        valstring++;\n    }\n    if ((valstring[0] == '0') && (valstring[1] == 'x'))\n    {\n        hexmode = 1;\n        valstring += 2;\n    }\n    /* first look for digits */\n    if (hexmode)\n    {\n        while (((*valstring >= '0') && (*valstring <= '9'))\n               || ((*valstring >= 'a') && (*valstring <= 'f')))\n        {\n            ee_s32 digit = *valstring - '0';\n            if (digit > 9)\n                digit = 10 + *valstring - 'a';\n            retval *= 16;\n            retval += digit;\n            valstring++;\n        }\n    }\n    else\n    {\n        while ((*valstring >= '0') && (*valstring <= '9'))\n        {\n            ee_s32 digit = *valstring - '0';\n            retval *= 10;\n            retval += digit;\n            valstring++;\n        }\n    }\n    /* now add qualifiers */\n    if (*valstring == 'K')\n        retval *= 1024;\n    if (*valstring == 'M')\n        retval *= 1024 * 1024;\n\n    retval *= neg;\n    return retval;\n}\n\nee_s32\nget_seed_args(int i, int argc, char *argv[])\n{\n    if (argc > i)\n        return parseval(argv[i]);\n    return 0;\n}\n\n#elif (SEED_METHOD == SEED_FUNC)\n/* If using OS based function, you must define and implement the functions below\n * in core_portme.h and core_portme.c ! */\nee_s32\nget_seed_32(int i)\n{\n    ee_s32 retval;\n    switch (i)\n    {\n        case 1:\n            retval = portme_sys1();\n            break;\n        case 2:\n            retval = portme_sys2();\n            break;\n        case 3:\n            retval = portme_sys3();\n            break;\n        case 4:\n            retval = portme_sys4();\n            break;\n        case 5:\n            retval = portme_sys5();\n            break;\n        default:\n            retval = 0;\n            break;\n    }\n    return retval;\n}\n#endif\n\n/* Function: crc*\n        Service functions to calculate 16b CRC code.\n\n*/\nee_u16\ncrcu8(ee_u8 data, ee_u16 crc)\n{\n    ee_u8 i = 0, x16 = 0, carry = 0;\n\n    for (i = 0; i < 8; i++)\n    {\n        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));\n        data >>= 1;\n\n        if (x16 == 1)\n        {\n            crc ^= 0x4002;\n            carry = 1;\n        }\n        else\n            carry = 0;\n        crc >>= 1;\n        if (carry)\n            crc |= 0x8000;\n        else\n            crc &= 0x7fff;\n    }\n    return crc;\n}\nee_u16\ncrcu16(ee_u16 newval, ee_u16 crc)\n{\n    crc = crcu8((ee_u8)(newval), crc);\n    crc = crcu8((ee_u8)((newval) >> 8), crc);\n    return crc;\n}\nee_u16\ncrcu32(ee_u32 newval, ee_u16 crc)\n{\n    crc = crc16((ee_s16)newval, crc);\n    crc = crc16((ee_s16)(newval >> 16), crc);\n    return crc;\n}\nee_u16\ncrc16(ee_s16 newval, ee_u16 crc)\n{\n    return crcu16((ee_u16)newval, crc);\n}\n\nee_u8\ncheck_data_types()\n{\n    ee_u8 retval = 0;\n    if (sizeof(ee_u8) != 1)\n    {\n        ee_printf(\"ERROR: ee_u8 is not an 8b datatype!\\n\");\n        retval++;\n    }\n    if (sizeof(ee_u16) != 2)\n    {\n        ee_printf(\"ERROR: ee_u16 is not a 16b datatype!\\n\");\n        retval++;\n    }\n    if (sizeof(ee_s16) != 2)\n    {\n        ee_printf(\"ERROR: ee_s16 is not a 16b datatype!\\n\");\n        retval++;\n    }\n    if (sizeof(ee_s32) != 4)\n    {\n        ee_printf(\"ERROR: ee_s32 is not a 32b datatype!\\n\");\n        retval++;\n    }\n    if (sizeof(ee_u32) != 4)\n    {\n        ee_printf(\"ERROR: ee_u32 is not a 32b datatype!\\n\");\n        retval++;\n    }\n    if (sizeof(ee_ptr_int) != sizeof(int *))\n    {\n        ee_printf(\n            \"ERROR: ee_ptr_int is not a datatype that holds an int pointer!\\n\");\n        retval++;\n    }\n    if (retval > 0)\n    {\n        ee_printf(\"ERROR: Please modify the datatypes in core_portme.h!\\n\");\n    }\n    return retval;\n}\n","coremark.h":"/*\nCopyright 2018 Embedded Microprocessor Benchmark Consortium (EEMBC)\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\nOriginal Author: Shay Gal-on\n*/\n\n/* Topic: Description\n        This file contains  declarations of the various benchmark functions.\n*/\n\n/* Configuration: TOTAL_DATA_SIZE\n        Define total size for data algorithms will operate on\n*/\n#ifndef TOTAL_DATA_SIZE\n#define TOTAL_DATA_SIZE 2 * 1000\n#endif\n\n#define SEED_ARG      0\n#define SEED_FUNC     1\n#define SEED_VOLATILE 2\n\n#define MEM_STATIC 0\n#define MEM_MALLOC 1\n#define MEM_STACK  2\n\n#include \"core_portme.h\"\n\n#if HAS_STDIO\n#include <stdio.h>\n#endif\n#if HAS_PRINTF\n#define ee_printf printf\n#endif\n\n/* Actual benchmark execution in iterate */\nvoid *iterate(void *pres);\n\n/* Typedef: secs_ret\n        For machines that have floating point support, get number of seconds as\n   a double. Otherwise an unsigned int.\n*/\n#if HAS_FLOAT\ntypedef double secs_ret;\n#else\ntypedef ee_u32 secs_ret;\n#endif\n\n#if MAIN_HAS_NORETURN\n#define MAIN_RETURN_VAL\n#define MAIN_RETURN_TYPE void\n#else\n#define MAIN_RETURN_VAL  0\n#define MAIN_RETURN_TYPE int\n#endif\n\nvoid       start_time(void);\nvoid       stop_time(void);\nCORE_TICKS get_time(void);\nsecs_ret   time_in_secs(CORE_TICKS ticks);\n\n/* Misc useful functions */\nee_u16 crcu8(ee_u8 data, ee_u16 crc);\nee_u16 crc16(ee_s16 newval, ee_u16 crc);\nee_u16 crcu16(ee_u16 newval, ee_u16 crc);\nee_u16 crcu32(ee_u32 newval, ee_u16 crc);\nee_u8  check_data_types(void);\nvoid * portable_malloc(ee_size_t size);\nvoid   portable_free(void *p);\nee_s32 parseval(char *valstring);\n\n/* Algorithm IDS */\n#define ID_LIST             (1 << 0)\n#define ID_MATRIX           (1 << 1)\n#define ID_STATE            (1 << 2)\n#define ALL_ALGORITHMS_MASK (ID_LIST | ID_MATRIX | ID_STATE)\n#define NUM_ALGORITHMS      3\n\n/* list data structures */\ntypedef struct list_data_s\n{\n    ee_s16 data16;\n    ee_s16 idx;\n} list_data;\n\ntypedef struct list_head_s\n{\n    struct list_head_s *next;\n    struct list_data_s *info;\n} list_head;\n\n/*matrix benchmark related stuff */\n#define MATDAT_INT 1\n#if MATDAT_INT\ntypedef ee_s16 MATDAT;\ntypedef ee_s32 MATRES;\n#else\ntypedef ee_f16 MATDAT;\ntypedef ee_f32 MATRES;\n#endif\n\ntypedef struct MAT_PARAMS_S\n{\n    int     N;\n    MATDAT *A;\n    MATDAT *B;\n    MATRES *C;\n} mat_params;\n\n/* state machine related stuff */\n/* List of all the possible states for the FSM */\ntypedef enum CORE_STATE\n{\n    CORE_START = 0,\n    CORE_INVALID,\n    CORE_S1,\n    CORE_S2,\n    CORE_INT,\n    CORE_FLOAT,\n    CORE_EXPONENT,\n    CORE_SCIENTIFIC,\n    NUM_CORE_STATES\n} core_state_e;\n\n/* Helper structure to hold results */\ntypedef struct RESULTS_S\n{\n    /* inputs */\n    ee_s16              seed1;       /* Initializing seed */\n    ee_s16              seed2;       /* Initializing seed */\n    ee_s16              seed3;       /* Initializing seed */\n    void *              memblock[4]; /* Pointer to safe memory location */\n    ee_u32              size;        /* Size of the data */\n    ee_u32              iterations;  /* Number of iterations to execute */\n    ee_u32              execs;       /* Bitmask of operations to execute */\n    struct list_head_s *list;\n    mat_params          mat;\n    /* outputs */\n    ee_u16 crc;\n    ee_u16 crclist;\n    ee_u16 crcmatrix;\n    ee_u16 crcstate;\n    ee_s16 err;\n    /* ultithread specific */\n    core_portable port;\n} core_results;\n\n/* Multicore execution handling */\n#if (MULTITHREAD > 1)\nee_u8 core_start_parallel(core_results *res);\nee_u8 core_stop_parallel(core_results *res);\n#endif\n\n/* list benchmark functions */\nlist_head *core_list_init(ee_u32 blksize, list_head *memblock, ee_s16 seed);\nee_u16     core_bench_list(core_results *res, ee_s16 finder_idx);\n\n/* state benchmark functions */\nvoid   core_init_state(ee_u32 size, ee_s16 seed, ee_u8 *p);\nee_u16 core_bench_state(ee_u32 blksize,\n                        ee_u8 *memblock,\n                        ee_s16 seed1,\n                        ee_s16 seed2,\n                        ee_s16 step,\n                        ee_u16 crc);\n\n/* matrix benchmark functions */\nee_u32 core_init_matrix(ee_u32      blksize,\n                        void *      memblk,\n                        ee_s32      seed,\n                        mat_params *p);\nee_u16 core_bench_matrix(mat_params *p, ee_s16 seed, ee_u16 crc);\n","simple/core_portme.c":"/*\nCopyright 2018 Embedded Microprocessor Benchmark Consortium (EEMBC)\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\nOriginal Author: Shay Gal-on\n*/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include \"coremark.h\"\n\n#if VALIDATION_RUN\nvolatile ee_s32 seed1_volatile = 0x3415;\nvolatile ee_s32 seed2_volatile = 0x3415;\nvolatile ee_s32 seed3_volatile = 0x66;\n#endif\n#if PERFORMANCE_RUN\nvolatile ee_s32 seed1_volatile = 0x0;\nvolatile ee_s32 seed2_volatile = 0x0;\nvolatile ee_s32 seed3_volatile = 0x66;\n#endif\n#if PROFILE_RUN\nvolatile ee_s32 seed1_volatile = 0x8;\nvolatile ee_s32 seed2_volatile = 0x8;\nvolatile ee_s32 seed3_volatile = 0x8;\n#endif\nvolatile ee_s32 seed4_volatile = ITERATIONS;\nvolatile ee_s32 seed5_volatile = 0;\n/* Porting : Timing functions\n        How to capture time and convert to seconds must be ported to whatever is\n   supported by the platform. e.g. Read value from on board RTC, read value from\n   cpu clock cycles performance counter etc. Sample implementation for standard\n   time.h and windows.h definitions included.\n*/\n/* Define : TIMER_RES_DIVIDER\n        Divider to trade off timer resolution and total time that can be\n   measured.\n\n        Use lower values to increase resolution, but make sure that overflow\n   does not occur. If there are issues with the return value overflowing,\n   increase this value.\n        */\n#define NSECS_PER_SEC              CLOCKS_PER_SEC\n#define CORETIMETYPE               clock_t\n#define GETMYTIME(_t)              (*_t = clock())\n#define MYTIMEDIFF(fin, ini)       ((fin) - (ini))\n#define TIMER_RES_DIVIDER          1\n#define SAMPLE_TIME_IMPLEMENTATION 1\n#define EE_TICKS_PER_SEC           (NSECS_PER_SEC / TIMER_RES_DIVIDER)\n\n/** Define Host specific (POSIX), or target specific global time variables. */\nstatic CORETIMETYPE start_time_val, stop_time_val;\n\n/* Function : start_time\n        This function will be called right before starting the timed portion of\n   the benchmark.\n\n        Implementation may be capturing a system timer (as implemented in the\n   example code) or zeroing some system parameters - e.g. setting the cpu clocks\n   cycles to 0.\n*/\nvoid\nstart_time(void)\n{\n    GETMYTIME(&start_time_val);\n}\n/* Function : stop_time\n        This function will be called right after ending the timed portion of the\n   benchmark.\n\n        Implementation may be capturing a system timer (as implemented in the\n   example code) or other system parameters - e.g. reading the current value of\n   cpu cycles counter.\n*/\nvoid\nstop_time(void)\n{\n    GETMYTIME(&stop_time_val);\n}\n/* Function : get_time\n        Return an abstract \"ticks\" number that signifies time on the system.\n\n        Actual value returned may be cpu cycles, milliseconds or any other\n   value, as long as it can be converted to seconds by <time_in_secs>. This\n   methodology is taken to accomodate any hardware or simulated platform. The\n   sample implementation returns millisecs by default, and the resolution is\n   controlled by <TIMER_RES_DIVIDER>\n*/\nCORE_TICKS\nget_time(void)\n{\n    CORE_TICKS elapsed\n        = (CORE_TICKS)(MYTIMEDIFF(stop_time_val, start_time_val));\n    return elapsed;\n}\n/* Function : time_in_secs\n        Convert the value returned by get_time to seconds.\n\n        The <secs_ret> type is used to accomodate systems with no support for\n   floating point. Default implementation implemented by the EE_TICKS_PER_SEC\n   macro above.\n*/\nsecs_ret\ntime_in_secs(CORE_TICKS ticks)\n{\n    secs_ret retval = ((secs_ret)ticks) / (secs_ret)EE_TICKS_PER_SEC;\n    return retval;\n}\n\nee_u32 default_num_contexts = 1;\n\n/* Function : portable_init\n        Target specific initialization code\n        Test for some common mistakes.\n*/\nvoid\nportable_init(core_portable *p, int *argc, char *argv[])\n{\n    if (sizeof(ee_ptr_int) != sizeof(ee_u8 *))\n    {\n        ee_printf(\n            \"ERROR! Please define ee_ptr_int to a type that holds a \"\n            \"pointer!\\n\");\n    }\n    if (sizeof(ee_u32) != 4)\n    {\n        ee_printf(\"ERROR! Please define ee_u32 to a 32b unsigned type!\\n\");\n    }\n    p->portable_id = 1;\n}\n/* Function : portable_fini\n        Target specific final code\n*/\nvoid\nportable_fini(core_portable *p)\n{\n    p->portable_id = 0;\n}\n","simple/core_portme.h":"/*\nCopyright 2018 Embedded Microprocessor Benchmark Consortium (EEMBC)\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\nOriginal Author: Shay Gal-on\n*/\n\n/* Topic : Description\n        This file contains configuration constants required to execute on\n   different platforms\n*/\n#ifndef CORE_PORTME_H\n#define CORE_PORTME_H\n/************************/\n/* Data types and settings */\n/************************/\n/* Configuration : HAS_FLOAT\n        Define to 1 if the platform supports floating point.\n*/\n#ifndef HAS_FLOAT\n#define HAS_FLOAT 1\n#endif\n/* Configuration : HAS_TIME_H\n        Define to 1 if platform has the time.h header file,\n        and implementation of functions thereof.\n*/\n#ifndef HAS_TIME_H\n#define HAS_TIME_H 1\n#endif\n/* Configuration : USE_CLOCK\n        Define to 1 if platform has the time.h header file,\n        and implementation of functions thereof.\n*/\n#ifndef USE_CLOCK\n#define USE_CLOCK 1\n#endif\n/* Configuration : HAS_STDIO\n        Define to 1 if the platform has stdio.h.\n*/\n#ifndef HAS_STDIO\n#define HAS_STDIO 1\n#endif\n/* Configuration : HAS_PRINTF\n        Define to 1 if the platform has stdio.h and implements the printf\n   function.\n*/\n#ifndef HAS_PRINTF\n#define HAS_PRINTF 1\n#endif\n\n/* Configuration : CORE_TICKS\n        Define type of return from the timing functions.\n */\n#include <time.h>\ntypedef clock_t CORE_TICKS;\n\n/* Definitions : COMPILER_VERSION, COMPILER_FLAGS, MEM_LOCATION\n        Initialize these strings per platform\n*/\n#ifndef COMPILER_VERSION\n#ifdef __GNUC__\n#define COMPILER_VERSION \"GCC\"__VERSION__\n#else\n#define COMPILER_VERSION \"Please put compiler version here (e.g. gcc 4.1)\"\n#endif\n#endif\n#ifndef COMPILER_FLAGS\n#define COMPILER_FLAGS \\\n    FLAGS_STR /* \"Please put compiler flags here (e.g. -o3)\" */\n#endif\n#ifndef MEM_LOCATION\n#define MEM_LOCATION \"STACK\"\n#endif\n\n/* Data Types :\n        To avoid compiler issues, define the data types that need ot be used for\n   8b, 16b and 32b in <core_portme.h>.\n\n        *Imprtant* :\n        ee_ptr_int needs to be the data type used to hold pointers, otherwise\n   coremark may fail!!!\n*/\ntypedef signed short   ee_s16;\ntypedef unsigned short ee_u16;\ntypedef signed int     ee_s32;\ntypedef double         ee_f32;\ntypedef unsigned char  ee_u8;\ntypedef unsigned int   ee_u32;\ntypedef size_t         ee_ptr_int;\ntypedef size_t         ee_size_t;\n/* align_mem :\n        This macro is used to align an offset to point to a 32b value. It is\n   used in the Matrix algorithm to initialize the input memory blocks.\n*/\n#define align_mem(x) (void *)(4 + (((ee_ptr_int)(x)-1) & ~3))\n\n/* Configuration : SEED_METHOD\n        Defines method to get seed values that cannot be computed at compile\n   time.\n\n        Valid values :\n        SEED_ARG - from command line.\n        SEED_FUNC - from a system function.\n        SEED_VOLATILE - from volatile variables.\n*/\n#ifndef SEED_METHOD\n#define SEED_METHOD SEED_VOLATILE\n#endif\n\n/* Configuration : MEM_METHOD\n        Defines method to get a block of memry.\n\n        Valid values :\n        MEM_MALLOC - for platforms that implement malloc and have malloc.h.\n        MEM_STATIC - to use a static memory array.\n        MEM_STACK - to allocate the data block on the stack (NYI).\n*/\n#ifndef MEM_METHOD\n#define MEM_METHOD MEM_STACK\n#endif\n\n/* Configuration : MULTITHREAD\n        Define for parallel execution\n\n        Valid values :\n        1 - only one context (default).\n        N>1 - will execute N copies in parallel.\n\n        Note :\n        If this flag is defined to more then 1, an implementation for launching\n   parallel contexts must be defined.\n\n        Two sample implementations are provided. Use <USE_PTHREAD> or <USE_FORK>\n   to enable them.\n\n        It is valid to have a different implementation of <core_start_parallel>\n   and <core_end_parallel> in <core_portme.c>, to fit a particular architecture.\n*/\n#ifndef MULTITHREAD\n#define MULTITHREAD 1\n#define USE_PTHREAD 0\n#define USE_FORK    0\n#define USE_SOCKET  0\n#endif\n\n/* Configuration : MAIN_HAS_NOARGC\n        Needed if platform does not support getting arguments to main.\n\n        Valid values :\n        0 - argc/argv to main is supported\n        1 - argc/argv to main is not supported\n\n        Note :\n        This flag only matters if MULTITHREAD has been defined to a value\n   greater then 1.\n*/\n#ifndef MAIN_HAS_NOARGC\n#define MAIN_HAS_NOARGC 0\n#endif\n\n/* Configuration : MAIN_HAS_NORETURN\n        Needed if platform does not support returning a value from main.\n\n        Valid values :\n        0 - main returns an int, and return value will be 0.\n        1 - platform does not support returning a value from main\n*/\n#ifndef MAIN_HAS_NORETURN\n#define MAIN_HAS_NORETURN 0\n#endif\n\n/* Variable : default_num_contexts\n        Not used for this simple port, must cintain the value 1.\n*/\nextern ee_u32 default_num_contexts;\n\ntypedef struct CORE_PORTABLE_S\n{\n    ee_u8 portable_id;\n} core_portable;\n\n/* target specific init/fini */\nvoid portable_init(core_portable *p, int *argc, char *argv[]);\nvoid portable_fini(core_portable *p);\n\n#if !defined(PROFILE_RUN) && !defined(PERFORMANCE_RUN) \\\n    && !defined(VALIDATION_RUN)\n#if (TOTAL_DATA_SIZE == 1200)\n#define PROFILE_RUN 1\n#elif (TOTAL_DATA_SIZE == 2000)\n#define PERFORMANCE_RUN 1\n#else\n#define VALIDATION_RUN 1\n#endif\n#endif\n\n#endif /* CORE_PORTME_H */\n"}