{"version":3,"file":"ir.js","mappings":"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AIN,EAAkBI,EAAIlJ,KAAK0I,eAAeQ,GAC9CE,IAAMJ,EAAMI,KACZL,EAASpC,KAAKyC,GACdJ,EAAMI,IAAK,GAIvB,OAAOL,GAEfM,aA1gBQ,SAAY/C,GAIR,IAHA,IAAIO,EAAK,GACLqC,EAAI5C,EAAEgD,IACNC,EAAIjD,EAAEkD,KACD9C,EAAI,EAAGF,EAAI0C,EAAEhG,OAAQwD,EAAIF,EAAGE,IACjCG,EAAGF,KAAK,CACJuC,EAAExC,GACF6C,EAAE7C,KAGV,OAAOG,EAggBL4C,CAAG,CACfH,IAAK1C,EAAE,CACP,GACA,GACA,GACAN,EACA,CAAC,GAAI,GACL,GACA,GACA,GACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACL,GACA,GACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACL,GACA,GACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACN,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,IACN,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,GACN,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,GACN,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,GACN,IACA,IACA,IACAA,EACA,CAAC,IAAK,GACN,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACN,IACA,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,GACN,IACA,IACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACN,IACA,IACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACN,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACN,IACA,IACA,IACA,IACA,MAEAkD,KAAM5C,EAAE,CACR,EACAN,EACA,CAAC,EAAG,GACJC,EACA,CAAC,GAAI,GACL,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACAA,EACA,CAAC,GAAI,GACLD,EACA,CAAC,EAAG,GACJ,EACAA,EACA,CAAC,EAAG,GACJ,EACA,EACAA,EACA,CAAC,EAAG,GACJC,EACA,CAAC,EAAG,GACJA,EACA,CAAC,EAAG,GACJA,EACA,CAAC,EAAG,GACJA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,EAAG,GACJ,EACAA,EACA,CAAC,EAAG,GACJD,EACA,CAAC,EAAG,IACJC,EACA,CAAC,GAAI,GACLA,EACA,CAAC,EAAG,GACJA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,EAAG,GACJA,EACA,CAAC,GAAI,GACLD,EACA,CAAC,EAAG,IACJ,EACA,EACAC,EACA,CAAC,IAAK,GACN,EACA,EACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,IAAK,GACN,EACA,EACA,EACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACL,EACA,EACA,EACAA,EACA,CAAC,EAAG,GACJA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACL,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACL,MAGFmD,cAAe,SAA+BC,EAAQC,EAAOC,EAAyBC,EAAMC,EAAUC,GAK5F,IAAI3C,EAAKrH,KAAKqH,GACV4C,EAAW5C,EAAGF,OACd+C,EAAU7C,EAAG8C,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GF,KAAKqE,GAEZ,OAAOnE,EAk8EZuE,CAAG,CACRX,IAAK7D,EAAE,CACP,GACA,EACA,GACAN,EACA,CAAC,EAAG,GACJ,GACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,EAAG,IACJ,EACA,EACAA,EACA,CAAC,EAAG,GACJ,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACAA,EACA,CAAC,EAAG,GACJ,GACA,GACA,EACA,GACA,EACA,GACA,GACA,EACA,EACA,EACA,GACA,GACA,EACA,EACA,EACA,EACA,GACA,GACA,EACA,EACA,GACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,GACA,EACA,GACA,GACA,GACA,GACA,GACAC,EACA,CAAC,GAAI,GACLD,EACA,CAAC,EAAG,GACJ,GACA,EACA,EACA,GACA,GACA,GACAA,EACA,CAAC,EAAG,GACJ,GACA,EACA,GACA,GACA,GACA,GACA,GACA,EACA,EACA,GACAC,EACA,CAAC,GAAI,GACLD,EACA,CAAC,EAAG,GACJ,GACA,GACA,EACA,EACA,EACAA,EACA,CAAC,EAAG,GACJ,GACA,EACAC,EACA,CAAC,EAAG,GACJ,GACAA,EACA,CAAC,IAAK,GACN,EACAD,EACA,CAAC,EAAG,GACJC,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACL,EACA,EACA,GACA,EACAA,EACA,CAAC,EAAG,GACJD,EACA,CAAC,EAAG,GACJ,EACA,GACA,EACA,EACA,EACA,GACAA,EACA,CAAC,EAAG,IACJ,GACA,GACA,GACA,GACAC,EACA,CAAC,GAAI,GACLA,EACA,CAAC,EAAG,GACJD,EACA,CAAC,EAAG,GACJ,GACA,GACA,GACAC,EACA,CAAC,GAAI,GACL,EACA,GACA,GACA,GACA,GACAD,EACA,CAAC,GAAI,GACL,GACA,GACA,GACA,GACAA,EACA,CAAC,GAAI,GACL,EACA,EACA,GACA,EACA,GACA,EACA,GACAA,EACA,CAAC,GAAI,GACL,EACA,GACAC,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACL,GACA,EACA,EACA,EACA,EACA,GACAA,EACA,CAAC,GAAI,GACL,EACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,IAAK,GACN,EACA,EACA,EACAA,EACA,CAAC,GAAI,GACL,EACA,GACA,GACA,EACA,GACAA,EACA,CAAC,IAAK,GACN,GACA,GACA,GACA,GACAD,EACA,CAAC,GAAI,GACL,GACA,GACA,GACAC,EACA,CAAC,IAAK,GACNA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACL,EACA,EACA,EACA,GACA,GACAA,EACA,CAAC,GAAI,GACL,GACA,GACA,EACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,GAAI,GACL,EACA,GACA,EACAA,EACA,CAAC,IAAK,GACND,EACA,CAAC,GAAI,GACL,GACA,GACA,GACAC,EACA,CAAC,GAAI,GACL,EACA,GACAA,EACA,CAAC,GAAI,GACL,GACA,EACA,GACAA,EACA,CAAC,GAAI,GACL,GACA,EACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACL,EACA,IAEAiC,OAAQ5B,EAAE,CACV,EACAN,EACA,CAAC,GAAI,GAAI,GACT,GACA,IACA,IACAA,EACA,CAAC,IAAK,EAAG,GACT,IACA,IACA,IACA,IACA,IACA,IACA,EACAC,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,GACL,IACA,IACA,EACA,GACA,GACA,GACA,GACA,IACA,IACA,IACA,IACA,IACA,EACA,EACA,EACA,EACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,KACL,GACA,GACA,GACAA,EACA,CAAC,EAAG,GACJ,EACA,GACA,GACA,GACA,IACA,EACA,GACA,EACA,GACA,GACA,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACL,GACA,GACA,IACA,IACA,IACA,EACA,GACA,GACA,GACAA,EACA,CAAC,IAAK,GACN,GACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLD,EACA,CAAC,IAAK,EAAG,GACT,IACA,IACA,GACA,GACA,IACA,IACAC,EACA,CAAC,GAAI,IACL,EACAD,EACA,CAAC,EAAG,EAAG,GACP,GACAA,EACA,CAAC,GAAI,EAAG,GACR,GACA,GACA,GACAA,EACA,CAAC,GAAI,EAAG,GACRA,EACA,CAAC,GAAI,GAAI,GACT,IACAC,EACA,CAAC,GAAI,GACLD,EACA,CAAC,GAAI,GAAI,GACTC,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,IACL,GACA,GACA,GACAD,EACA,CAAC,GAAI,EAAG,GACRC,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,IAAK,GACND,EACA,CAAC,IAAK,EAAG,GACTC,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACN,EACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,IACN,IACA,EACAA,EACA,CAAC,IAAK,IACN,IACA,IACA,IACAA,EACA,CAAC,IAAK,GACN,EACAA,EACA,CAAC,IAAK,IACN,GACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,IAAK,GACN,IACA,IACAA,EACA,CAAC,IAAK,GACN,GACA,GACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,IACL,EACA,GACA,EACA,GACA,GACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,IACN,IACA,EACA,EACAD,EACA,CAAC,EAAG,EAAG,GACPA,EACA,CAAC,GAAI,GAAI,GACT,GACAA,EACA,CAAC,GAAI,GAAI,GACT,IACAC,EACA,CAAC,GAAI,GACL,GACA,GACA,GACA,GACA,GACAD,EACA,CAAC,EAAG,GAAI,GACRC,EACA,CAAC,GAAI,IACL,GACA,GACA,GACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,IACL,GACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,GACN,GACA,GACAA,EACA,CAAC,EAAG,GACJA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,IAAK,IACND,EACA,CAAC,GAAI,EAAG,GACRC,EACA,CAAC,IAAK,IACN,GACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,GACN,IACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,IAAK,GACN,EACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,IAAK,GACN,GACA,GACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,GAAI,GACL,GACA,GACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,KAAM,GACP,EACAA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACN,GACAA,EACA,CAAC,KAAM,GACPD,EACA,CAAC,EAAG,GACJC,EACA,CAAC,IAAK,GACNA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACN,GACA,GACA,GACA,GACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,IAAK,GACN,EACA,EACA,EACA,EACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,KAAM,GACP,IACA,IACAA,EACA,CAAC,IAAK,IACN,EACA,GACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,GACN,GACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACL,EACAA,EACA,CAAC,GAAI,IACLD,EACA,CAAC,GAAI,GAAI,GACT,GACA,GACA,GACA,GACAC,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,IACL,EACA,EACA,EACAA,EACA,CAAC,KAAM,GACPA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,KACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACN,GACAA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,IAAK,KACNA,EACA,CAAC,GAAI,IACL,GACAA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACP,IACA,GACA,EACA,GACAD,EACA,CAAC,GAAI,GAAI,GACTC,EACA,CAAC,GAAI,GACLA,EACA,CAAC,KAAM,GACPA,EACA,CAAC,KAAM,GACP,IACAA,EACA,CAAC,EAAG,GACJA,EACA,CAAC,KAAM,GACPA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,KAAM,GACPA,EACA,CAAC,KAAM,GACPA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,GACPA,EACA,CAAC,KAAM,GACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACP,EACA,GACAA,EACA,CAAC,KAAM,GACP,EACA,EACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,IAAK,IACN,EACA,EACAA,EACA,CAAC,IAAK,GACN,GACAA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,KAAM,GACPA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,GAAI,KACLA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,GAAI,IACL,EACA,EACAA,EACA,CAAC,KAAM,IACPD,EACA,CAAC,GAAI,EAAG,GACRC,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,KACLA,EACA,CAAC,KAAM,GACPA,EACA,CAAC,IAAK,OAENhH,KAAMqH,EAAE,CACRN,EACA,CAAC,EAAG,IACJA,EACA,CAAC,EAAG,IACJ,EACAC,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLD,EACA,CAAC,EAAG,IACJC,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,KACLA,EACA,CAAC,EAAG,GACJA,EACA,CAAC,EAAG,GACJA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACND,EACA,CAAC,EAAG,IACJA,EACA,CAAC,EAAG,IACJC,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACND,EACA,CAAC,EAAG,IACJC,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACND,EACA,CAAC,EAAG,KACJC,EACA,CAAC,IAAK,IACNA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,KAAM,GACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,KACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,KAAM,GACPA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACND,EACA,CAAC,EAAG,KACJC,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,GAAI,KACLA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,GAAI,KACLA,EACA,CAAC,IAAK,MAENsC,MAAOjC,EAAE,CACT,EACAN,EACA,CAAC,EAAG,EAAG,GACP,GACA,GACA,GACA,GACA,GACA,EACAA,EACA,CAAC,EAAG,EAAG,GACPC,EACA,CAAC,GAAI,GACL,GACA,EACA,GACA,GACA,GACA,GACA,GACA,GACA,GACAA,EACA,CAAC,GAAI,GACL,GACAA,EACA,CAAC,EAAG,GACJ,GACAA,EACA,CAAC,EAAG,GACJ,GACAA,EACA,CAAC,EAAG,GACJ,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,IACA,GACA,GACA,GACA,GACA,GACAD,EACA,CAAC,IAAK,GAAI,GACV,IACA,IACA,GACA,GACA,GACA,GACA,GACA,GACA,IACAC,EACA,CAAC,GAAI,IACL,IACA,IACA,IACA,IACAA,EACA,CAAC,GAAI,GACL,IACA,IACA,IACA,IACA,IACAD,EACA,CAAC,IAAK,EAAG,GACT,GACA,IACA,IACA,GACA,GACAC,EACA,CAAC,GAAI,GACL,IACAA,EACA,CAAC,GAAI,IACL,IACA,IACA,IACAA,EACA,CAAC,GAAI,GACL,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,GACN,IACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,EAAG,GACJ,IACAA,EACA,CAAC,EAAG,GACJ,GACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,GACN,IACAA,EACA,CAAC,GAAI,GACL,IACAA,EACA,CAAC,IAAK,GACN,IACAA,EACA,CAAC,IAAK,IACN,IACA,IACA,IACAA,EACA,CAAC,GAAI,GACL,IACA,GACAA,EACA,CAAC,EAAG,GACJ,IACAA,EACA,CAAC,EAAG,GACJ,IACA,GACA,IACAA,EACA,CAAC,EAAG,GACJ,IACA,GACA,IACAA,EACA,CAAC,GAAI,IACL,IACA,IACAA,EACA,CAAC,GAAI,GACL,IACA,GACA,GACA,IACAA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,IAAK,GACN,GACA,GACAA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,GAAI,IACL,IACAD,EACA,CAAC,IAAK,EAAG,GACT,IACAC,EACA,CAAC,IAAK,IACN,IACA,GACA,IACA,GACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,GACN,GACA,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,GACL,IACAA,EACA,CAAC,GAAI,IACL,IACA,IACA,IACAA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,GAAI,IACL,IACA,IACA,IACA,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,GACL,IACAA,EACA,CAAC,GAAI,GACL,IACAA,EACA,CAAC,GAAI,GACL,IACAA,EACA,CAAC,EAAG,GACJ,IACAA,EACA,CAAC,EAAG,GACJ,IACAA,EACA,CAAC,IAAK,IACN,IACAD,EACA,CAAC,IAAK,EAAG,GACTC,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACA,IACAA,EACA,CAAC,IAAK,GACN,IACAA,EACA,CAAC,IAAK,GACN,IACA,GACA,GACA,IACA,GACAA,EACA,CAAC,GAAI,GACL,GACA,GACA,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,GACN,IACA,GACA,IACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,GAAI,GACL,IACA,IACAA,EACA,CAAC,GAAI,GACL,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,IAAK,IACN,IACA,IACA,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,IAAK,GACN,IACA,IACA,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,KAELqE,KAAMhE,EAAE,CACRN,EACA,CAAC,EAAG,IACJA,EACA,CAAC,EAAG,GACJC,EACA,CAAC,GAAI,KACLA,EACA,CAAC,GAAI,GACL,EACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,EAAG,GACJA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACLD,EACA,CAAC,EAAG,IACJC,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,IACLD,EACA,CAAC,EAAG,IACJC,EACA,CAAC,GAAI,GACLA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,EAAG,IACJA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACND,EACA,CAAC,EAAG,KACJC,EACA,CAAC,IAAK,KACND,EACA,CAAC,EAAG,KACJC,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,IAAK,KACND,EACA,CAAC,EAAG,IACJC,EACA,CAAC,IAAK,IACND,EACA,CAAC,EAAG,OAEJwE,KAAMlE,EAAE,CACR,EACAN,EACA,CAAC,GAAI,GAAI,GACT,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACAC,EACA,CAAC,GAAI,IACL,GACA,GACA,GACA,GACAD,EACA,CAAC,GAAI,GACLC,EACA,CAAC,GAAI,IACLD,EACA,CAAC,GAAI,GACLC,EACA,CAAC,GAAI,IACLD,EACA,CAAC,GAAI,GACLC,EACA,CAAC,GAAI,IACLD,EACA,CAAC,GAAI,GACLC,EACA,CAAC,GAAI,IACL,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,IACA,GACAD,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACN,GACA,IACA,GACA,GACA,GACA,GACAA,EACA,CAAC,IAAK,GACN,GACAA,EACA,CAAC,IAAK,IACNC,EACA,CAAC,GAAI,IACL,GACAD,EACA,CAAC,IAAK,GACN,GACAA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,GAAI,EAAG,GACR,GACA,GACAA,EACA,CAAC,IAAK,EAAG,GACT,IACA,GACA,GACA,GACAC,EACA,CAAC,GAAI,GACL,IACA,GACA,IACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACN,IACA,IACAD,EACA,CAAC,IAAK,EAAG,GACTC,EACA,CAAC,IAAK,GACN,GACA,IACA,GACAD,EACA,CAAC,IAAK,GACN,IACA,IACAC,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACLD,EACA,CAAC,IAAK,GACN,GACA,IACA,GACA,IACAC,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,GACLD,EACA,CAAC,IAAK,GACNC,EACA,CAAC,GAAI,IACLD,EACA,CAAC,IAAK,GACNC,EACA,CAAC,GAAI,IACL,IACA,IACA,IACA,IACA,IACA,GACAA,EACA,CAAC,IAAK,IACND,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,GAAI,GACVA,EACA,CAAC,GAAI,GACL,IACAA,EACA,CAAC,GAAI,GACL,IACA,IACA,GACA,IACA,GACA,IACAA,EACA,CAAC,GAAI,IACL,IACA,IACA,IACAA,EACA,CAAC,GAAI,IACL,IACAC,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACLD,EACA,CAAC,GAAI,GACL,IACA,GACAA,EACA,CAAC,GAAI,GACL,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACLC,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACND,EACA,CAAC,GAAI,GACL,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACL,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,IACL,IACA,IACA,GACA,GACAA,EACA,CAAC,GAAI,GACL,IACA,IACAA,EACA,CAAC,GAAI,GACL,IACA,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,IACL,IACA,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACL,IACA,IACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,GACL,IACA,GACA,GACA,IACA,IACAA,EACA,CAAC,GAAI,IACLC,EACA,CAAC,IAAK,GACN,IACAA,EACA,CAAC,IAAK,IACN,GACA,GACAD,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACLC,EACA,CAAC,IAAK,IACN,IACA,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACL,IACA,GACA,IACA,IACAA,EACA,CAAC,GAAI,GACL,IACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,GACN,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,GACA,GACA,IACAA,EACA,CAAC,IAAK,IACN,IACA,IACA,IACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,GAAI,IACL,IACA,IACA,IACA,IACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,GACAA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,IACL,IACA,IACA,IACA,IACA,IACA,IACA,GACAA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,KACLA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,IAAK,IACN,IACA,IACA,IACAA,EACA,CAAC,GAAI,IACL,IACA,IACA,IACA,IACA,IACA,GACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,GACA,GACAA,EACA,CAAC,GAAI,IACL,IACA,IACAA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,KAAM,GACP,IACAA,EACA,CAAC,KAAM,GACP,IACAA,EACA,CAAC,GAAI,IACL,IACA,IACAD,EACA,CAAC,GAAI,GACL,IACA,GACA,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,GAAI,GACL,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACL,IACAA,EACA,CAAC,GAAI,GACLC,EACA,CAAC,IAAK,IACN,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,IACND,EACA,CAAC,GAAI,GACL,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,IACL,IACA,IACA,GACA,GACAA,EACA,CAAC,GAAI,GACL,IACA,IACAA,EACA,CAAC,GAAI,GACL,IACA,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACL,IACA,IACAA,EACA,CAAC,GAAI,GACL,IACA,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,IACL,IACA,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,IACL,IACA,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,IACL,IACA,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,IACL,IACA,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACL,IACA,IACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,GACL,IACA,IACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,GACL,IACA,GACA,GACA,IACA,IACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,GACL,IACA,GACA,GACA,IACA,IACAA,EACA,CAAC,GAAI,IACLC,EACA,CAAC,IAAK,IACN,IACA,IACA,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,IACL,IACA,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,IAAK,IACN,IACA,IACA,IACAA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACA,IACAD,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,IAAK,GACN,IACA,IACAC,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,IAAK,QAGR8E,eA5+IQ,SAAa/E,GAIT,IAHA,IAAIO,EAAK,GACLuC,EAAI9C,EAAEgF,IACNT,EAAIvE,EAAEwE,KACDpE,EAAI,EAAGF,EAAI4C,EAAElG,OAAQwD,EAAIF,EAAGE,IAAK,CAEtCG,EADQuC,EAAE1C,IACFmE,EAAEnE,GAEd,OAAOG,EAo+IH0E,CAAI,CAClBD,IAAK1E,EAAE,CACPN,EACA,CAAC,EAAG,EAAG,GACPA,EACA,CAAC,GAAI,GAAI,GACTA,EACA,CAAC,GAAI,EAAG,GACR,GACA,GACA,GACAA,EACA,CAAC,GAAI,EAAG,GACR,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACAA,EACA,CAAC,GAAI,EAAG,GACR,GACA,GACAA,EACA,CAAC,IAAK,EAAG,GACT,IACA,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,EAAG,GACT,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,EAAG,GACT,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,EAAG,GACT,IACAA,EACA,CAAC,IAAK,GAAI,GACV,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,EAAG,GACT,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,EAAG,GACT,IACA,IACAA,EACA,CAAC,IAAK,EAAG,GACT,IACA,IACAA,EACA,CAAC,IAAK,EAAG,GACT,IACA,IACA,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,EAAG,GACT,IACA,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,EAAG,KAETwE,KAAMlE,EAAE,CACR,EACA,IACA,IACA,IACAN,EACA,CAAC,IAAK,GAAI,GACV,IACA,IACA,IACA,IACA,IACA,EACA,IACA,GACA,GACA,IACA,EACAA,EACA,CAAC,GAAI,EAAG,GACR,IACA,GACA,IACA,IACA,IACA,IACA,GACA,IACA,GACA,GACAA,EACA,CAAC,GAAI,EAAG,GACR,GACA,GACAA,EACA,CAAC,EAAG,EAAG,GACP,GACA,EACA,GACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,EAAG,GACT,IACA,GACA,GACA,IACA,GACA,GACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,GAAI,GAAI,GACT,GACA,GACAA,EACA,CAAC,GAAI,EAAG,GACR,GACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,GACA,GACA,GACA,GACA,GACA,GACA,IACA,GACA,GACA,GACA,IACA,IACA,GACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,GACA,GACA,GACA,GACA,IACA,IACA,IACA,IACA,IACA,IACA,GACA,GACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,QAGFkF,WAAY,SAAoBC,EAAKhG,EAAMiG,GACvC,IAAIjG,EAAKkG,YAYL,KAN0B,mBAAf3L,KAAKoH,OACZpH,KAAKoH,MAAMqE,GAEVC,IACDA,EAAiB1L,KAAKuF,kBAEpB,IAAImG,EAAeD,EAAKhG,GAXJ,mBAAfzF,KAAKoH,OACZpH,KAAKoH,MAAMqE,GAEfhG,EAAKmG,WAWbC,MAAO,SAAeC,GAClB,IAQIlC,EACAD,EAaAQ,EAtBA4B,EAAO/L,KACPmG,EAAQ,IAAI5D,MAAM,KAClByJ,EAAS,IAAIzJ,MAAM,KAEnB0J,EAAS,IAAI1J,MAAM,KACnB2J,EAAS,IAAI3J,MAAM,KACnB4G,EAAQnJ,KAAKmJ,MACbgD,EAAK,EAML3D,EAAS,EAKTZ,GADS5H,KAAK2H,OACR3H,KAAK4H,KAEXwE,GADsCpM,KAAKsH,QAAQE,+BACvC,CAAC,EAAG,MAIhB2C,EADAnK,KAAKqM,UACGrM,KAAKqM,UAELrM,KAAKqM,UAAY1G,OAAOuB,OAAOlH,KAAKmK,OAGhD,IAAImC,EAAiB,CACjBd,gBAAYnB,EACZhC,eAAWgC,EACXF,WAAOE,EACPlD,YAAQkD,EACRkC,eAAWlC,EACXmC,gBAAYnC,EACZoC,aAASpC,EACTqC,cAAUrC,GAsBd,SAASsC,EAAaC,GAClB,GAAmB,iBAARA,EAAkB,CACzB,IAAIC,EAAM,GACV,IAAK,IAAIC,KAAKF,EACNjH,OAAOsB,UAAUb,eAAe2G,KAAKH,EAAKE,KAC1CD,EAAIC,GAAKF,EAAIE,IAGrB,OAAOD,EAEX,OAAOD,EAEX,SAASI,EAAuBH,EAAKD,GACjC,IAAK,IAAIE,KAAKF,OACY,IAAXC,EAAIC,IAAsBnH,OAAOsB,UAAUb,eAAe2G,KAAKH,EAAKE,KAC3ED,EAAIC,GAAKF,EAAIE,IAIzB,SAASG,EAAYhO,GACjB,IAAI4H,EAAK8F,EAAa1N,GAItB,OAHI4H,GAAMA,EAAGqG,QACTrG,EAAGqG,MAAQrG,EAAGqG,MAAMC,MAAM,IAEvBtG,EAsUX,SAASuG,IACL,IAAIC,EAAQlD,EAAMiD,UAMlB,MAJqB,iBAAVC,IACPA,EAAQtB,EAAKtE,SAAS4F,IAAUA,GAG7BA,GAASzF,EAvXE,mBAAX0F,QAOEA,OAGbtN,KAAKuN,iBAAmB,WACpB,OAAOjB,GAmCXU,EAAuBV,EAAgBtM,KAAKqH,IAE5CiF,EAAenC,MAAQA,EACvBmC,EAAenF,OAASnH,KAQiB,mBAA9BsM,EAAed,WACtBxL,KAAKwL,WAAa,SAAuBC,EAAKhG,EAAMiG,GAIhD,OAHKA,IACDA,EAAiB1L,KAAKuF,kBAEnB+G,EAAed,WAAWuB,KAAK/M,KAAMyL,EAAKhG,EAAMiG,IAG3D1L,KAAKwL,WAAaxL,KAAK8H,mBAIa,mBAA7BwE,EAAejE,UACtBrI,KAAKqI,UAAY,SAAsBC,GACnC,OAAOgE,EAAejE,UAAU0E,KAAK/M,KAAMsI,IAG/CtI,KAAKqI,UAAYrI,KAAK6H,kBAS1B7H,KAAK+H,kBAAoB,SAAkCyF,EAAaC,EAAqBC,GACzF,IAAI7G,EAGIpB,EADJgI,KAGInB,EAAeE,YAAcxM,KAAKwM,cAGlC/G,EAAOzF,KAAKgI,wBAAwB,KAAsB,KAA0B,MAAM,IAG1FsE,EAAeE,iBAEG,KADlB3F,EAAKyF,EAAeE,WAAWO,KAAK/M,KAAMsM,EAAgBkB,EAAa/H,MACxC+H,EAAc3G,GAE7C7G,KAAKwM,iBAEa,KADlB3F,EAAK7G,KAAKwM,WAAWO,KAAK/M,KAAMsM,EAAgBkB,EAAa/H,MAC9B+H,EAAc3G,GAI7CpB,GAAQA,EAAKmG,SACbnG,EAAKmG,WAIb,GAAI5L,KAAKkI,uBAAyB,EAAG,OAAOsF,EA8B5C,GA3BIrD,EAAMwD,iBACNxD,EAAMwD,gBAAgBD,GAItBpB,IACAA,EAAenC,WAAQE,EACvBiC,EAAenF,YAASkD,EACpBF,EAAM9C,KAAOiF,IACbnC,EAAM9C,QAAKgD,IAGnBiC,OAAiBjC,EACjBrK,KAAKwL,WAAaxL,KAAK8H,mBACvB9H,KAAKqI,UAAYrI,KAAK6H,kBAItB1B,EAAMjD,OAAS,EACf8I,EAAO9I,OAAS,EAChBgJ,EAAOhJ,OAAS,EAChB+I,EAAO/I,OAAS,EAChBiJ,EAAK,GAKAuB,EAAwB,CACzB,IAAK,IAAIhH,EAAI1G,KAAKmI,cAAcjF,OAAS,EAAGwD,GAAK,EAAGA,IAAK,CACrD,IAAIkH,EAAK5N,KAAKmI,cAAczB,GACxBkH,GAA4B,mBAAfA,EAAGhC,SAChBgC,EAAGhC,UAGX5L,KAAKmI,cAAcjF,OAAS,EAKhC,OAAOsK,GAeXxN,KAAKiI,oBAAsB,SAAoC4F,EAAaC,EAAYC,EAAcC,EAAaC,GAC/G,IAIIpH,EAJAqH,EAAmB,EAAdL,EACLM,EAAkB,EAAbL,EACLM,EAAKL,EACLM,EAAKL,EAMT,IAAKI,GACkB,MAAfP,EACA,IAAK,IAAInH,EAAIwH,EAAIxH,GAAKyH,KAClBC,EAAKlC,EAAOxF,IADUA,KASlC,IAAK2H,GACiB,MAAdP,EACA,IAASpH,EAAIyH,EAAIzH,GAAKwH,KAClBG,EAAKnC,EAAOxF,IADUA,KAUlC,IAAK0H,GAAqB,MAAfP,EAAqB,CAE5B,IAAKI,EACD,IAASvH,GAAKwH,GAAM/B,GAAM,EAAGzF,GAAK,KAC9B0H,EAAKlC,EAAOxF,IADqBA,KAOzC,OAAK0H,IAkBDvH,EAAK8F,EAAayB,IACfE,WAAazH,EAAG0H,UACnB1H,EAAG2H,aAAe3H,EAAG4H,YACjB5H,EAAGqG,QAEHrG,EAAGqG,MAAQrG,EAAGqG,MAAMC,MAAM,GAC1BtG,EAAGqG,MAAM,GAAKrG,EAAGqG,MAAM,IAGvBmB,IAEArB,EAAuBnG,EAAIwH,GAC3BxH,EAAG0H,UAAYF,EAAGE,UAClB1H,EAAG4H,YAAcJ,EAAGI,YAChB5H,EAAGqG,OAASmB,EAAGnB,QACfrG,EAAGqG,MAAM,GAAKmB,EAAGnB,MAAM,KAGxBrG,GAnCFwH,IAQDxH,EAAK8F,EAAa0B,IACXnB,QAEHrG,EAAGqG,MAAQrG,EAAGqG,MAAMC,MAAM,IAEvBtG,QATP,EAuCZ,GAJKuH,IACDA,EAAKC,EACLA,EAAK,MAEJD,EA0BL,OApBAvH,EAAK8F,EAAayB,IAMXlB,QAEHrG,EAAGqG,MAAQrG,EAAGqG,MAAMC,MAAM,IAG1BkB,IACArB,EAAuBnG,EAAIwH,GAC3BxH,EAAG0H,UAAYF,EAAGE,UAClB1H,EAAG4H,YAAcJ,EAAGI,YAChB5H,EAAGqG,OAASmB,EAAGnB,QACfrG,EAAGqG,MAAM,GAAKmB,EAAGnB,MAAM,KAIxBrG,GAKX7G,KAAKgI,wBAA0B,SAAwCxC,EAAKkJ,EAAIC,EAAUhD,GACtF,IAAIiD,EAAM,CACNC,OAAQrJ,EACRO,UAAW2I,EACXI,KAAM3E,EAAM4E,MACZtP,MAAO0K,EAAMR,OACb0D,MAAOrN,KAAK0I,eAAeF,IAAWA,EACtCwG,SAAUxG,EACVyG,KAAM9E,EAAM+E,SACZjQ,IAAKgO,EAAY9C,EAAMgF,QACvBR,SAAUA,EACVhD,YAAaA,EACb9C,MAAOA,EACPuG,OAAQA,EACRC,UAAWC,EACXC,aAAcpJ,EACdqJ,YAAaxD,EACbyD,YAAaxD,EACbyD,eAAgBxD,EAChByD,cAAexD,EACf9E,GAAIiF,EACJnC,MAAOA,EACPhD,OAAQnH,KASR4L,QAAS,WAOL,IAAIgE,IAAQ5P,KAAK2L,YACjB,IAAK,IAAIlD,KAAOzI,KACRA,KAAKoG,eAAeqC,IAAuB,iBAARA,IACnCzI,KAAKyI,QAAO4B,GAGpBrK,KAAK2L,YAAciE,IAK3B,OADA5P,KAAKmI,cAAcxB,KAAKiI,GACjBA,GA4CX,IAGI/F,EAAOuG,EAAQ7F,EAAGgB,EAMlBrB,EACA2G,EACAC,EACAR,EAZAS,EApBJ,WACI,IAAI1C,EAAQlD,EAAM4F,MAMlB,MAJqB,iBAAV1C,IACPA,EAAQtB,EAAKtE,SAAS4F,IAAUA,GAG7BA,GAASzF,GAiBhBoI,EAAQ,CACR5F,GAAG,EACHE,QAAID,EACJhD,GAAIiF,GAMJ2D,GAAS,EAGb,IASI,GARAjQ,KAAKkI,yBAELiC,EAAM+F,SAASpE,EAAOQ,GAMO,mBAAlBnC,EAAMgG,QACGhG,EAAMgG,UACR/C,UACV2C,EAAM3C,GAuBd,IAnBAxD,EAAQO,EAAMgF,OACdjD,EAAOC,GAAMvC,EACbqC,EAAOE,GAAM,KACbH,EAAOG,GAAM,EACbhG,EAAMgG,GAAM,IACVA,EAEFxC,EAASQ,EAAMR,OAIX3J,KAAKuM,WACLvM,KAAKuM,UAAUQ,KAAK/M,KAAMsM,GAE1BA,EAAeC,WACfD,EAAeC,UAAUQ,KAAK/M,KAAMsM,GAGxCgD,EAAWtD,EAAOG,EAAK,KACd,CAKL,GAHAtD,EAAQyG,EAGJtP,KAAKqL,eAAexC,GACpBuG,EAAS,EACTE,EAAWtP,KAAKqL,eAAexC,QAyB/B,GAnBKL,IACDA,EAASuH,KAGbxF,EAAKpB,EAAMN,IAAUM,EAAMN,GAAOL,IAAY4D,EAC9CkD,EAAW/E,EAAE,KACb6E,EAAS7E,EAAE,IAaE,CACT,IAAIsE,EACAuB,EAAkBpQ,KAAK0I,eAAeF,IAAWA,EACjDmG,EAAW3O,KAAK4I,2BAA2BC,GAI3CgG,EAD0B,iBAAnB1E,EAAM+E,SACJ,wBAA0B/E,EAAM+E,SAAW,GAAK,KAEhD,gBAEqB,mBAAvB/E,EAAMkG,eACbxB,GAAU,KAAO1E,EAAMkG,aAAa,GAAS,IAAM,MAEnD1B,EAASzL,OACT2L,GAAU,aAAeF,EAAS2B,KAAK,MAAQ,oBAAsBF,EAErEvB,GAAU,cAAgBuB,EAG9BlH,EAAIlJ,KAAKgI,wBAAwB6G,EAAQ,KAAMF,GAAU,QAExC,KADjBpF,EAAIvJ,KAAKwL,WAAWtC,EAAE2F,OAAQ3F,EAAGlJ,KAAKuF,qBAElC0K,EAAS1G,GAEb,MAeR,OAAQ6F,GAER,QAEI,GAAIA,aAAkB7M,MAAO,CACzB2G,EAAIlJ,KAAKgI,wBAAwB,oDAAsDa,EAAQ,YAAcL,EAAQ,KAAM,MAAM,QAEhH,KADjBe,EAAIvJ,KAAKwL,WAAWtC,EAAE2F,OAAQ3F,EAAGlJ,KAAKuF,qBAElC0K,EAAS1G,GAEb,MAIJL,EAAIlJ,KAAKgI,wBAAwB,8FAA+F,KAAM,MAAM,QAE3H,KADjBuB,EAAIvJ,KAAKwL,WAAWtC,EAAE2F,OAAQ3F,EAAGlJ,KAAKuF,qBAElC0K,EAAS1G,GAEb,MAGJ,KAAK,EACDpD,EAAMgG,GAAM3D,EACZyD,EAAOE,GAAMhC,EAAMR,OACnBuC,EAAOC,GAAMc,EAAY9C,EAAMgF,QAC/BnD,EAAOG,GAAMmD,IAEXnD,EACF3D,EAAS,EAOTmB,EAASQ,EAAMR,OAEfC,EAAQO,EAAMgF,OACd,SAGJ,KAAK,EAkBD,GAbAU,GADAC,EAAkB9P,KAAKqJ,aAAaiG,EAAW,IACnB,QAaX,KAFjB/F,EAAIvJ,KAAK0J,cAAcqD,KAAKiD,EAAOrG,EAAQC,EAAO0F,EAAUnD,EAAK,EAAGF,EAAQC,IAE9C,CAC1B+D,EAAS1G,EACT,MAIJ4C,GAAM0D,EAGN,IAAIU,EAAWT,EAAgB,GAC/B3J,EAAMgG,GAAMoE,EACZtE,EAAOE,GAAM6D,EAAM5F,EACnB8B,EAAOC,GAAM6D,EAAM1F,GAEnBgF,EAAWnG,EAAM6C,EAAOG,EAAK,IAAIoE,GACjCvE,EAAOG,GAAMmD,IACXnD,EAUF,SAGJ,KAAK,GACW,IAARA,IACA8D,GAAS,EAsBT9D,SAC0B,IAAfF,EAAOE,KACd8D,EAAShE,EAAOE,KAO5B,OAEN,MAAOuC,GAGL,GAAIA,aAAc1O,KAAKuF,iBACnB,MAAMmJ,EAEL,GAAIvE,GAA0C,mBAA1BA,EAAMqG,iBAAkC9B,aAAcvE,EAAMqG,gBACjF,MAAM9B,EAGVxF,EAAIlJ,KAAKgI,wBAAwB,oCAAqC0G,EAAI,MAAM,GAChFuB,GAAS,OAEQ,KADjB1G,EAAIvJ,KAAKwL,WAAWtC,EAAE2F,OAAQ3F,EAAGlJ,KAAKuF,qBAElC0K,EAAS1G,GAEf,QACE0G,EAASjQ,KAAK+H,kBAAkBkI,GAAQ,GAAM,GAC9CjQ,KAAKkI,yBAGT,OAAO+H,IAGX9I,EAAOW,mBAAqBX,EAAOqE,WACnCrE,EAAOU,kBAAoBV,EAAOkB,UAElC,MAAMkC,EAAI,EAAQ,KAElB,SAASkG,IACPzQ,KAAKqH,GAAK,GAKZ,OAHAoJ,EAAOxJ,UAAYE,EACnBA,EAAOsJ,OAASA,EAET,IAAIA,EAx/KiB,GA+/K1BC,EAAQvJ,OAAS7B,EACjBoL,EAAQD,OAASnL,EAAUmL,OAC3BC,EAAQ7E,MAAQ,WACd,OAAOvG,EAAUuG,MAAM9E,MAAMzB,EAAWqL,cC73LxCC,EAA2B,GAG/B,SAASC,EAAoBC,GAE5B,IAAIC,EAAeH,EAAyBE,GAC5C,QAAqBzG,IAAjB0G,EACH,OAAOA,EAAaL,QAGrB,IAAIM,EAASJ,EAAyBE,GAAY,CAGjDJ,QAAS,IAOV,OAHAO,EAAoBH,GAAUE,EAAQA,EAAON,QAASG,GAG/CG,EAAON,QCpBfG,EAAoBzH,EAAI,CAACsH,EAASQ,KACjC,IAAI,IAAIzI,KAAOyI,EACXL,EAAoBM,EAAED,EAAYzI,KAASoI,EAAoBM,EAAET,EAASjI,IAC5E9C,OAAOC,eAAe8K,EAASjI,EAAK,CAAE5C,YAAY,EAAMuL,IAAKF,EAAWzI,MCJ3EoI,EAAoBM,EAAI,CAACE,EAAKC,IAAU3L,OAAOsB,UAAUb,eAAe2G,KAAKsE,EAAKC,GCClFT,EAAoBtH,EAAKmH,IACH,oBAAXa,QAA0BA,OAAOC,aAC1C7L,OAAOC,eAAe8K,EAASa,OAAOC,YAAa,CAAE/R,MAAO,WAE7DkG,OAAOC,eAAe8K,EAAS,aAAc,CAAEjR,OAAO,K,gCCHhD,MAAMgS,eAAezL,MAGxBhH,YAAYkH,EAA0BwL,EAA2BC,GAC7DrS,MAAM4G,GAD4B,KAAAwL,KAAAA,EAA2B,KAAAC,MAAAA,EAFjE,KAAAtS,KAAO,SAKCqS,GAAMzS,MACNe,KAAKkG,SAAW,OAAS0L,EAAeF,EAAKzS,KACzC0S,GAAO1S,MAAKe,KAAKkG,SAAW,OAAS0L,EAAeD,EAAM1S,IAAK,yBAKxE,SAAS2S,EAAe3S,EAAe8E,EAAgB,YAC1D,MAAM8N,EAAQ5S,EAAI6S,OAAOC,MAAM,MAC/B,GAAI9S,EAAIqP,YAAcuD,EAAM3O,OAAQ,MAAO,GAAGa,eAE9C,IAAIiO,EAAS,GAAGjO,OAEhB,MAAMkO,EAAaC,KAAKC,KAAKD,KAAKE,MAAMnT,EAAIsP,UAAY,IACxD,SAAS8D,EAAWC,GAChBN,GAAU,KAAKM,EAAO,GAAGC,WAAWC,SAASP,EAAY,SAASJ,EAAMS,OAkB5E,OAfIrT,EAAIqP,WAAa,GAAG+D,EAAWpT,EAAIqP,WAAa,GAChDrP,EAAIqP,WAAa,GAAG+D,EAAWpT,EAAIqP,WAAa,GACpD+D,EAAWpT,EAAIqP,YAGf0D,GAAU,IAAIzP,MAAM,EAAI0P,EAAahT,EAAIuP,cAAc8B,KAAK,KACxDrR,EAAIqP,aAAerP,EAAIsP,UACvByD,GAAU,IAAIzP,MAAM,EAAItD,EAAIwP,YAAcxP,EAAIuP,cAAc8B,KAAK,KAEjE0B,GAAU,IAEdA,GAAU,KAEN/S,EAAIqP,WAAa,EAAIuD,EAAM3O,QAAQmP,EAAWpT,EAAIqP,WAAa,GAC/DrP,EAAIqP,WAAa,EAAIuD,EAAM3O,QAAQmP,EAAWpT,EAAIqP,WAAa,GAC5D0D,ECjCJ,MAAMS,UAMTzT,YAAqB0S,EACAgB,EACAC,EACFC,EACExP,GAAoB,GAJpB,KAAAsO,KAAAA,EACA,KAAAgB,WAAAA,EACA,KAAAC,eAAAA,EACF,KAAAC,eAAAA,EACE,KAAAxP,SAAAA,EATZ,KAAAyP,SAAW,WACX,KAAAC,MAAQ,EACR,KAAAC,UAAY,EACZ,KAAAC,YAAa,EAQZN,aAAsBO,OAAQC,EAAkBR,GACtDC,EAAeQ,SAAQ1Q,GAAKyQ,EAAkBzQ,KAGlD2Q,OAAO7I,GACH,OAAOA,aAAakI,WACblI,EAAEmI,WAAWU,OAAOpT,KAAK0S,aACzBnI,EAAEoI,eAAezP,SAAWlD,KAAK2S,eAAezP,QAChDqH,EAAEoI,eAAeU,OAAM,CAACC,EAAO5M,IAAM1G,KAAK2S,eAAejM,GAAG0M,OAAOE,MACnE/I,EAAEnH,WAAapD,KAAKoD,SAG3BmQ,wBACA,OAAOC,EAAa,IAAIC,SAASzT,KAAK0R,KAAM1R,MAAM,EAAOA,MAAO0T,EAAa1T,QAI9E,MAAMyT,SAMTzU,YAAqB0S,EACAnS,EACToU,GAAoB,EACXC,GAHA,KAAAlC,KAAAA,EACA,KAAAnS,KAAAA,EAEA,KAAAqU,SAAAA,EARZ,KAAAd,MAAQ,EACR,KAAAC,UAAY,EACZ,KAAAC,YAAa,EAQdW,IAAU3T,KAAK6T,UAAY,SAGnCT,OAAO7I,GACH,OAAOA,aAAakJ,UAAYlJ,EAAEsJ,YAAc7T,KAAK6T,WAAa7T,KAAKT,KAAK6T,OAAO7I,EAAEhL,MAGrFgU,wBACA,OAAOvT,KAGP6S,eACA,OAAO7S,KAAKT,KAAKsT,SAAW,KAAO7S,KAAK6T,UAAY,IAAM7T,KAAK6T,UAAY,KAI5E,MAAMC,OAGT9U,YAAqB0S,EAAsCnS,EAAoB2D,GAA1D,KAAAwO,KAAAA,EAAsC,KAAAnS,KAAAA,EAAoB,KAAA2D,OAAAA,EAC3EgQ,EAAkB3T,GAClBS,KAAK+S,UAAYxT,EAAKwT,UAGtBD,YACA,QAAoBzI,IAAhBrK,KAAKkD,OAAsB,MAAM,IAAI8C,MAAM,wCAC/C,OAAOhG,KAAKT,KAAKuT,MAAQ9S,KAAKkD,OAG9B8P,iBACA,YAAuB3I,IAAhBrK,KAAKkD,OAGhBkQ,OAAO7I,GACH,OAAOA,aAAauJ,QAAUvJ,EAAErH,SAAWlD,KAAKkD,QAAUlD,KAAKT,KAAK6T,OAAO7I,EAAEhL,MAG7EgU,wBACA,OAAOC,EAAa,IAAIC,SAASzT,KAAK0R,KAAM1R,KAAKT,MAAM,EAAOS,MAAO0T,EAAa1T,OAGlF6S,eACA,OAAI7S,KAAKkD,OACElD,KAAKT,KAAKsT,SAAW,IAAM7S,KAAKkD,OAAS,IAEzClD,KAAKT,KAAKsT,SAAW,MAOjC,MAAMkB,gBACT/U,YAAqB0S,EAA0BrS,EAAuBE,GAAjD,KAAAmS,KAAAA,EAA0B,KAAArS,KAAAA,EAAuB,KAAAE,KAAAA,GAGnE,MAAMyU,QAGThV,YAAmB0S,EAAsCrS,GAAtC,KAAAqS,KAAAA,EAAsC,KAAArS,KAAAA,EAGrD4U,cACA,QAAsB5J,IAAlBrK,KAAKkU,SAAwB,MAAM,IAAIlO,MAAM,6CACjD,OAAOhG,KAAKkU,SAGZD,YAAQE,GACR,QAAsB9J,IAAlBrK,KAAKkU,SAAwB,MAAM,IAAIlO,MAAM,qCACjD,GAAwB,IAApBmO,EAASjR,OAAc,MAAM,IAAI8C,MAAM,uCAC3ChG,KAAKkU,SAAWC,EAGhBrB,YACA,GAAI9S,KAAKgT,WAAY,MAAM,IAAIhN,MAAM,wCACrC,OAAOhG,KAAKiU,QAAQG,QAAO,CAACC,EAAO5R,KAE/B4R,EAAQnC,KAAKC,KAAKkC,EAAQ5R,EAAElD,KAAKwT,WAAatQ,EAAElD,KAAKwT,WACtCtQ,EAAElD,KAAKuT,OACvB,GAGHC,gBACA,OAAOb,KAAKoC,OAAOtU,KAAKiU,QAAQM,KAAI9R,GAAKA,EAAElD,KAAKwT,aAGhDC,iBACA,YAAyB3I,IAAlBrK,KAAKkU,SAGhBd,OAAO7I,GACH,OAAMA,aAAayJ,eACD3J,IAAdrK,KAAKX,WAAiCgL,IAAXE,EAAElL,KAKzBW,KAAKiU,QAAQ/Q,SAAWqH,EAAE0J,QAAQ/Q,QAC/BlD,KAAKiU,QAAQZ,OAAM,CAAC5Q,EAAGiE,IAAM6D,EAAE0J,QAAQvN,GAAGrH,OAASoD,EAAEpD,MAAQkL,EAAE0J,QAAQvN,GAAGnH,KAAK6T,OAAO3Q,EAAElD,QAE5FgL,EAAElL,OAASW,KAAKX,MAG3BmV,WAAW7J,GACP,MAAM8J,EAASzU,KAAKiU,QAAQS,MAAKjS,GAAKA,EAAEpD,OAASsL,IACjD,GAAI8J,EAAQ,OAAOA,EAAOlV,KAC1B,MAAM,IAAIyG,MAAM,mCAAmC2E,MAGvDgK,iBACI,YAEMtK,IAFCrK,KAAKiU,QAAQS,MAAK/J,GACrB+I,EAAa/I,EAAEpL,QAAWoL,EAAEpL,gBAAgBqV,QAAUjK,EAAEpL,gBAAgByU,UAAYrJ,EAAEpL,KAAKoV,mBAI/FpB,wBACA,OAAOvT,KAGP6S,eACA,OAAI7S,KAAKX,KACE,UAAYW,KAAKX,KAEjB,WAAaW,KAAKiU,QAAQM,KAAI9R,GAAKA,EAAElD,KAAKsT,SAAW,IAAMpQ,EAAEpD,KAAO,MAAKiR,KAAK,KAAO,KAKjG,MAAMsE,OAGT5V,YAAmB0S,EAAsCrS,GAAtC,KAAAqS,KAAAA,EAAsC,KAAArS,KAAAA,EAGrD4U,cACA,QAAsB5J,IAAlBrK,KAAKkU,SAAwB,MAAM,IAAIlO,MAAM,4CACjD,OAAOhG,KAAKkU,SAGZD,YAAQE,GACR,QAAsB9J,IAAlBrK,KAAKkU,SAAwB,MAAM,IAAIlO,MAAM,oCACjD,GAAwB,IAApBmO,EAASjR,OAAc,MAAM,IAAI8C,MAAM,uCAC3ChG,KAAKkU,SAAWC,EAGhBrB,YACA,GAAI9S,KAAKgT,WAAY,MAAM,IAAIhN,MAAM,wCACrC,OAAOhG,KAAKiU,QAAQG,QAAO,CAACC,EAAO5R,IAAMyP,KAAKoC,IAAID,EAAO5R,EAAElD,KAAKuT,QAAQ,GAGxEC,gBACA,OAAOb,KAAKoC,OAAOtU,KAAKiU,QAAQM,KAAI9R,GAAKA,EAAElD,KAAKwT,aAGhDC,iBACA,YAAyB3I,IAAlBrK,KAAKkU,SAGhBd,OAAO7I,GACH,OAAMA,aAAaqK,cACDvK,IAAdrK,KAAKX,WAAiCgL,IAAXE,EAAElL,KACzBW,KAAKiU,QAAQ/Q,SAAWqH,EAAE0J,QAAQ/Q,QAC/BlD,KAAKiU,QAAQZ,OAAM,CAAC5Q,EAAGiE,IAAM6D,EAAE0J,QAAQvN,GAAGrH,OAASoD,EAAEpD,MAAQkL,EAAE0J,QAAQvN,GAAGnH,KAAK6T,OAAO3Q,EAAElD,QAE5FgL,EAAElL,OAASW,KAAKX,MAG3BmV,WAAW7J,GACP,MAAM8J,EAASzU,KAAKiU,QAAQS,MAAKjS,GAAKA,EAAEpD,OAASsL,IACjD,GAAI8J,EAAQ,OAAOA,EAAOlV,KAC1B,MAAM,IAAIyG,MAAM,kCAAkC2E,MAGtDgK,iBACI,YAEMtK,IAFCrK,KAAKiU,QAAQS,MAAK/J,GACrB+I,EAAa/I,EAAEpL,QAAWoL,EAAEpL,gBAAgBqV,QAAUjK,EAAEpL,gBAAgByU,UAAYrJ,EAAEpL,KAAKoV,mBAI/FpB,wBACA,OAAOvT,KAGP6S,eACA,OAAI7S,KAAKX,KACE,SAAWW,KAAKX,KAEhB,UAAYW,KAAKiU,QAAQM,KAAI9R,GAAKA,EAAElD,KAAKsT,SAAW,IAAMpQ,EAAEpD,KAAO,MAAKiR,KAAK,KAAO,KAMhG,MAAMuE,MAIT7V,YAAmB0S,EAAsCrS,GAAtC,KAAAqS,KAAAA,EAAsC,KAAArS,KAAAA,EAHhD,KAAAwT,SAAW,OAMhBiC,aACA,QAAqBzK,IAAjBrK,KAAK+U,QAAuB,MAAM,IAAI/O,MAAM,0CAChD,OAAOhG,KAAK+U,QAGZD,WAAOX,GACP,QAAqB9J,IAAjBrK,KAAK+U,QAAuB,MAAM,IAAI/O,MAAM,mCAChD,GAAwB,IAApBmO,EAASjR,OAAc,MAAM,IAAI8C,MAAM,oCAC3ChG,KAAK+U,QAAUZ,EAGfnB,iBACA,YAAwB3I,IAAjBrK,KAAK+U,QAGhB3B,OAAO7I,GACH,YAAkBF,IAAdrK,KAAKX,KAA2BW,OAASuK,EACtCA,aAAasK,OAAStK,EAAElL,OAASW,KAAKX,MAI9C,MAAM4T,MAAb,cACa,KAAAJ,SAAW,OACX,KAAAC,MAAQ,EACR,KAAAC,UAAY,EACZ,KAAAC,YAAa,EACb,KAAAtB,UAAOrH,EAEhB+I,OAAO7I,GACH,OAAOA,aAAa0I,MAGpBM,wBACA,OAAOvT,MAIR,MAAMgV,YAKT,YAA6BnC,EAA2BC,EAAwBvT,GAAnD,KAAAsT,SAAAA,EAA2B,KAAAC,MAAAA,EAAwB,KAAAvT,KAAAA,EAJvE,KAAAyT,YAAa,EACb,KAAAtB,UAAOrH,EAIZrK,KAAK+S,UAAYD,EAGrBM,OAAO7I,GACH,OAAOA,aAAayK,aAAezK,EAAEsI,WAAa7S,KAAK6S,UAAYtI,EAAEhL,OAASS,KAAKT,MAAQgL,EAAEuI,QAAU9S,KAAK8S,MAG5GmC,eACA,GAAID,YAAYE,KAAK9B,OAAOpT,MAAO,OAAO,EAE1C,OAAQA,KAAKT,MACb,IAAK,QACD,OAAQ4V,IACZ,IAAK,WACD,OAAO,EACX,IAAK,SACD,QAAS,KAAOC,OAAoB,EAAbpV,KAAK8S,OAAa,MAI7CuC,eACA,GAAIL,YAAYE,KAAK9B,OAAOpT,MAAO,OAAO,EAE1C,OAAQA,KAAKT,MACb,IAAK,QACD,OAAO4V,IACX,IAAK,WACD,OAAO,IAAMC,OAAoB,EAAbpV,KAAK8S,OAAa,GAC1C,IAAK,SACD,OAAO,KAAOsC,OAAoB,EAAbpV,KAAK8S,OAAa,IAAM,IAIjDS,wBACA,OAAOvT,MAGK,YAAAsV,KAAO,IAAIN,YAAY,QAAS,EAAG,SACnC,YAAAO,KAAO,IAAIP,YAAY,SAAU,EAAG,SAEpC,YAAAQ,GAAK,IAAIR,YAAY,OAAQ,EAAG,YAChC,YAAAS,GAAK,IAAIT,YAAY,cAAe,EAAG,UACvC,YAAAU,IAAM,IAAIV,YAAY,iBAAkB,EAAG,YAC3C,YAAAW,IAAM,IAAIX,YAAY,QAAS,EAAG,UAClC,YAAAY,IAAM,IAAIZ,YAAY,eAAgB,EAAG,YACzC,YAAAa,IAAM,IAAIb,YAAY,MAAO,EAAG,UAChC,YAAAc,IAAM,IAAId,YAAY,gBAAiB,EAAG,YAC1C,YAAAe,IAAM,IAAIf,YAAY,OAAQ,EAAG,UAEjC,YAAAE,KAAO,IAAIF,YAAY,OAAQ,EAAG,UAG/C,MAAMgB,EAAShB,YAAYY,IAG5BK,EAAY1E,OAAO,SASlB,SAASiC,EAA8BjJ,EAAMsJ,GAChD,QAAkBxJ,IAAdwJ,EAAyB,OAAOtJ,EACpC,GAAI5E,OAAOsB,UAAUb,eAAe2G,KAAKxC,EAAG,aACxC,MAAM,IAAIvE,MAAM,gCAGpB,MAAMkQ,EAAW3L,EACjB,GAAI2L,EAASD,GAET,OAAOC,EAASD,GAGpB,MAAM1W,EAAOoG,OAAOqB,eAAe,CAAC6M,YAAWsC,MAAO5L,GAAIA,GAE1D,OADA2L,EAASD,GAAa1W,EACfA,EAGJ,SAASmU,EAAanJ,GACzB,OAAOA,GAAGsJ,UAIP,SAASuC,EAAiB7L,GAC7B,MAAe,UAAXA,EAAEhL,KAAyBgL,EAC3BA,EAAEuI,MAAQkC,YAAYa,IAAI/C,OAASvI,IAAMyK,YAAYE,KAAaF,YAAYa,IAC3EtL,EAIJ,SAAS8L,EAA0BC,EAAiBC,GACvD,OAAID,IAAOtB,YAAYO,MAAQgB,IAAOvB,YAAYO,KAAaP,YAAYO,KACvEe,IAAOtB,YAAYM,MAAQiB,IAAOvB,YAAYM,KAAaN,YAAYM,MAG3EgB,EAAKF,EAAiBE,GACtBC,EAAKH,EAAiBG,GAElBD,IAAOtB,YAAYc,KAAOS,IAAOvB,YAAYc,IAAYd,YAAYc,IACrEQ,IAAOtB,YAAYe,KAAOQ,IAAOvB,YAAYe,IAAYf,YAAYe,IACrEO,IAAOtB,YAAYY,KAAOW,IAAOvB,YAAYY,IAAYZ,YAAYY,IAClEZ,YAAYa,KAIhB,SAASW,EAAkBhV,GAC9B,MAAMiV,EAAOjV,EAAc2L,QAE3B,SAASuJ,EAAOpQ,GACZ,MAAMgF,EAAMmL,EAAKE,QAAQrQ,GACzB,OAAIgF,GAAO,IACPmL,EAAKG,OAAOtL,EAAK,IACV,GAKf,SAAStC,EAASvG,GACd,KAAIgU,EAAKvT,OAAS,GAClB,OAAOT,EAGX,OAAIiU,EAAO,QACA1N,EAAM,IAAIiK,OACVyD,EAAO,WACdA,EAAO,QACA1N,EAAMgM,YAAYO,OAClBmB,EAAO,SACP1N,EAAMgM,YAAYM,MAClBoB,EAAO,QACVA,EAAO,UAAkB1N,EAAMgM,YAAYS,KAC/CiB,EAAO,YACA1N,EAAMgM,YAAYQ,KAClBkB,EAAO,UACdA,EAAO,OACHA,EAAO,YAAoB1N,EAAMgM,YAAYU,MACjDgB,EAAO,UACA1N,EAAMgM,YAAYW,OAClBe,EAAO,SACdA,EAAO,QACPA,EAAO,OACHA,EAAO,YAAoB1N,EAAMgM,YAAYc,MACjDY,EAAO,UACA1N,EAAMgM,YAAYe,OAClBW,EAAO,OACVA,EAAO,YAAoB1N,EAAMgM,YAAYY,MACjDc,EAAO,UACA1N,EAAMgM,YAAYa,MAClBa,EAAO,YACP1N,EAAMgM,YAAYY,KAClBc,EAAO,UACP1N,EAAMgM,YAAYa,KAClBa,EAAO,QACP1N,EAAMgM,YAAYE,WADtB,EAOJ,SAAShC,EAAmC3T,EAASmS,EAA8BnS,EAAKmS,MAC3F,GAAInS,EAAKyT,WACL,MAAM,IAAI,cAAcvB,OAAd,c,oBACN,KAAApS,KAAO,wBACT,oCAAqCqS,GAE3C,OAAOnS,ECtcX,MAAMsX,EAAe,IAAIC,IAElB,SAASC,EAAwCC,EAAaC,EAAuB,IACxF,IAAK,MAAMvF,KAAQsF,EAAU,CACzBC,EAAQtQ,KAAK+K,GACbqF,EAASrF,EAAKyC,WAAY8C,GAC1BA,EAAQ3N,MAER,IAAK,MAAM4N,KAAaL,EAAazF,IAAIzL,OAAOwR,eAAezF,GAAM1S,cAAgB,GACjFkY,EAAUxF,EAAMuF,GAGxB,OAAOD,EAGJ,MAAMI,iCAAiC3F,OAG1CzS,YAAY0S,EAA6BxL,EAAiByL,GACtDrS,MAAMoS,GAAQA,EAAKzS,IAAM,QAAQyS,EAAKzS,IAAIqP,WAAa,MAAMpI,IAAYA,EAASwL,EAAMC,GAHnF,KAAAtS,KAAO,uBAOpB,SAAS6X,EAA+B3X,EAAiCmB,GACrE,MAAM2W,EAAaR,EAAazF,IAAI7R,GAChC8X,EACAA,EAAW1Q,KAAKjG,GAEhBmW,EAAaS,IAAI/X,EAAM,CAACmB,IAahC,MAAM6W,EAAkBnO,IACpB,GAAIA,EAAE3H,cAAcyB,OAAS,EAAG,MAAM,IAAIkU,yBAAyBhO,EAAG,wBAT1E,SAAoB5H,EAAgDkQ,GAChE,GAAIlQ,EAAc6R,OAAMmE,GAAkB,iBAANA,MAC3BhB,EAAkBhV,GACnB,MAAM,IAAI4V,yBAAyB1F,EAAM,wBAA0BlQ,EAAc8O,KAAK,OAO9FmH,CAAWrO,EAAE5H,cAAe4H,IAehC,SAASsO,EAAoB3M,EAAckM,GACvC,IAAK,IAAIvQ,EAAIuQ,EAAQ/T,OAAS,EAAGwD,GAAK,EAAGA,IAAK,CAC1C,KAAMuQ,EAAQvQ,aAAc,eAAsC,WAApBuQ,EAAQvQ,GAAGnH,KAAmB,OAC5E,GAAwB,iBAApB0X,EAAQvQ,GAAGnH,KAAyB,MAAM,IAAI6X,yBAAyBrM,EAAG,2BAftFmM,EAAU,sBAAwBK,GAClCL,EAAU,wBAA0BK,GACpCL,EAAU,yBAA0B,CAAC9N,EAAG6N,KACpC,GAAI7N,EAAExH,YAAYsB,OAAS,EAAG,MAAM,IAAIkU,yBAAyBhO,EAAG,+BACpE,GAAIA,EAAEvH,gBAAgBqB,OAAS,EAAG,MAAM,IAAIkU,yBAAyBhO,EAAG,8BAExE,GAAyB,YAArBA,EAAExH,YAAY,IAAuC,IAAnBqV,EAAQ/T,OAC1C,MAAM,IAAIkU,yBAAyBhO,EAAG,sCAY9C8N,EAAU,mBAAoB,CAACxF,EAAMiG,KACjC,OAAQjG,EAAKnS,MACb,IAAK,mBACL,IAAK,mBACL,IAAK,kBACL,IAAK,kBACL,IAAK,YACL,IAAK,cACDmY,EAAoBhG,EAAMiG,OAGlCT,EAAU,oBAAqB,CAACxF,EAAMiG,KAClC,OAAQjG,EAAKnS,MACb,IAAK,QACL,IAAK,iBACDmY,EAAoBhG,EAAMiG,OAGlCT,EAAU,yBAA2BQ,GAGrCR,EAAU,yBAA2BQ,G,aChFrC,MAAME,EAAWjS,OAAOkS,YAAY,CAChC,KAAM,QAAS,OAAQ,OAAQ,QAAS,WAAY,UAAW,KAAM,SAAU,OAAQ,OAAQ,SAAU,QACzG,MAAO,SAAU,MAAO,OAAQ,SAAU,QAAS,SAAU,SAAU,SAAU,SAAU,SAAU,UACrG,QAAS,WAAY,OAAQ,QAAS,QAAS,OAG/C,OAAQ,WAAY,WAGpB,UACFtD,KAAI9R,GAAK,CAACA,EAAGA,EAAEqV,kBAQXC,EAAkG,CACpG,CACIxY,KAAO+G,GAAMsR,EAAStR,IAAM,aAC5B0R,MAAO,0BAEX,CACIzY,KAAMkD,GAAKA,EACXuV,MAAO,IAAIC,OAbH,CACZ,MAAM,MAAM,MACZ,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAC1F,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,KAU9D1D,KAAIjO,GAAKA,EAAE4R,QAAQ,sBAAuB,UAAS5H,KAAK,OAEtF,CACI/Q,KAAM,iBACNyY,MAAO,gHAEX,CACIzY,KAAM,eACNyY,MAAO,sDAEX,CACIzY,KAAM,iBACNyY,MAAO,4CAEX,CACIzY,KAAM,eACNyY,MAAO,sDAEX,CACIzY,KAAM,gBACNyY,MAAO,sDACPvY,MAAOgD,GAAKA,EAAE0K,MAAM,GAAI,IAE5B,CACI5N,KAAM,iBACNyY,MAAO,+DACPvY,MAAOgD,GAAKA,EAAE0K,MAAM,GAAI,KAIzB,MAAMgL,MAAb,cAGY,KAAArG,OAAS,GACT,KAAAsG,MAAQ,EACR,KAAAnJ,KAAO,EACP,KAAAoJ,IAAM,EAEdC,OAEI,KAAOtY,KAAKoY,MAAQpY,KAAK8R,OAAO5O,SAAuC,MAA5BlD,KAAK8R,OAAO9R,KAAKoY,QACzB,OAA5BpY,KAAK8R,OAAO9R,KAAKoY,QAA+C,OAA5BpY,KAAK8R,OAAO9R,KAAKoY,QACzB,OAA5BpY,KAAK8R,OAAO9R,KAAKoY,QAA+C,OAA5BpY,KAAK8R,OAAO9R,KAAKoY,SAExB,OAA5BpY,KAAK8R,OAAO9R,KAAKoY,QACjBpY,KAAKiP,OACLjP,KAAKqY,IAAM,GAEXrY,KAAKqY,MAETrY,KAAKoY,QAGT,MAAMnZ,EAAgB,CAClBqP,WAAYtO,KAAKiP,KACjBT,aAAcxO,KAAKqY,IACnB9J,UAAWvO,KAAKiP,KAChBR,YAAazO,KAAKqY,IAAM,EACxBvG,OAAQ9R,KAAK8R,QAIjB,GAAI9R,KAAKoY,QAAUpY,KAAK8R,OAAO5O,OAC3B,MAAO,CAAC3D,KAAM,MAAOE,MAAO,GAAIqP,KAAM,GAAI7P,OAI9CkZ,MAAMH,MAAMO,UAAYvY,KAAKoY,MAC7B,MAAMrJ,EAAQoJ,MAAMH,MAAMQ,KAAKxY,KAAK8R,QACpC,IAAK/C,EAAO,MAAM,IAAI0J,WAAWxZ,GAGjC,MAAM6P,EAAOC,EAAM,GACnB/O,KAAKoY,OAAStJ,EAAK5L,OACnBlD,KAAKqY,KAAOvJ,EAAK5L,OACjBjE,EAAIwP,YAAczO,KAAKqY,IAGvB,IAAIK,EAAW,EACf,UAA+BrO,IAAxB0E,EAAM2J,EAAW,IAAkBA,IAC1C,MAAMC,EAAQZ,EAAMW,GAEpB,MAAO,CACHnZ,KAA4B,mBAAfoZ,EAAMpZ,KAAsBoZ,EAAMpZ,KAAKuP,GAAQ6J,EAAMpZ,KAClEE,MAAOkZ,EAAMlZ,QAAQqP,IAASA,EAC9BA,OAAM7P,OAId2Z,MAAMtS,GACFtG,KAAK8R,OAASxL,EACdtG,KAAKoY,MAAQ,EACbpY,KAAKiP,KAAO,EACZjP,KAAKqY,IAAM,GA9DR,MAAAL,MAAQ,IAAIC,OAAOF,EAAMxD,KAAI9R,GAAK,IAAMA,EAAEuV,MAAMlG,OAAS,MAAKxB,KAAK,KAAM,MAkEpF,MAAMmI,mBAAmBhH,OAGrBzS,YAAYC,GACRK,MAAM,gBAAiB,IAAI,cAAc,EAAAP,UAAd,c,oBACvB,KAAAQ,KAAO,YACTN,IALN,KAAAI,KAAO,cASJ,MAAM8K,EAAQ,IAAIgO,MChGzB,MAAMU,EAAkB,EAMjB,SAAShN,EAAMC,GAClB,IAEI,OAAOiL,EADM8B,EAAgBhN,MAAMC,IAErC,MAAOhF,GAIL,MAHIA,GAAGrB,MAAMxG,MACT6H,EAAEZ,SAAW,OAAS0L,EAAe9K,EAAErB,MAAMxG,MAE3C6H,GAbd+R,EAAgB1R,OAAOgD,MAAQ,IAzC/B,MAAM2O,aAAN,cAKY,KAAAC,MAAQ,IAAIjC,IAGpB/G,MACI,MAAM1C,EAAQlD,EAAMmO,OAKpB,OAJAtY,KAAK2J,OAAS0D,EAAM5N,MACpBO,KAAKmP,OAAS9B,EAAMpO,IACpBe,KAAKkP,SAAW7B,EAAMpO,IAAIqP,WAEP,eAAfjB,EAAM9N,MAAyBS,KAAK+Y,MAAM3H,IAAI/D,EAAMyB,MAC7C,YAEJzB,EAAM9N,KAGjB2Q,SAASpE,GACL9L,KAAK2J,YAASU,EACdrK,KAAKmP,YAAS9E,EACdrK,KAAKkP,cAAW7E,EAChBrK,KAAK+Y,MAAMC,QAEX7O,EAAMyO,MAAM9M,GAGhBtB,oBAAoBpB,GAChB,GAAkC,YAA9BA,EAAElH,SAASN,YAAY,GAE3B,IAAK,IAAI0B,KAAc8F,EAAEjH,KAAM,CAC3B,OAASmB,aAAsB2V,EAAUjW,uBAAuBM,EAAaA,EAAWxD,KACxFE,KAAK+Y,MAAMzB,IAAIhU,EAAWvB,IAAI,MCpCnC,MAAM,0CAA4B0P,OAGrCzS,YAAY0S,EAA0BwH,EAA6BC,GAC/D7Z,MAAM6Z,EAAa,YAAYD,aAAsBC,aAAwB,YAAYD,IAAcxH,GADrE,KAAAwH,WAAAA,EAA6B,KAAAC,WAAAA,EAFnE,KAAA9Z,KAAO,uBASJ,SAAS+Z,EAAa1H,EAAiBnH,GAC1C,GAAIA,aAAayK,YAAa,OAAOzK,EACrC,MAAM,IAAI,kCAAoBmH,EAAM,aAAcnH,EAAEsI,UAGjD,SAASwG,EAAU3H,EAAiBnH,GACvC,MAAM+O,EAAaF,EAAa1H,EAAMnH,GACtC,OAAQ+O,EAAW/Z,MACnB,IAAK,SACL,IAAK,WACD,OAAO+Z,EACX,QACI,MAAM,IAAI,kCAAoB5H,EAAM,UAAWnH,EAAEsI,WAIlD,SAAS0G,EAAU7H,EAAiBnH,GACvC,GAAIA,aAAakJ,SAAU,OAAOlJ,EAClC,MAAM,IAAI,kCAAoBmH,EAAM,UAAWnH,EAAEsI,UAG9C,SAAS2G,EAAsB9H,EAAiBnH,GACnD,GAAIA,aAAayK,YAAa,OAAOzK,EACrC,GAAIA,aAAakJ,SAAU,OAAOlJ,EAClC,MAAM,IAAI,kCAAoBmH,EAAM,wBAAyBnH,EAAEsI,UAG5D,SAAS4G,EAAsC/H,EAAiBnH,GACnE,GAAIA,aAAakJ,UAAYlJ,EAAEhL,gBAAgBkT,UAC3C,MAAM,IAAI,kCAAoBf,EAAM,uBAAwB,oBAEhE,OAAOnH,EAgBJ,SAASmP,EAAYzV,EAAyB0V,GACjD,GAAI1V,EAAW0V,SAAWA,EAAQ,OAAO1V,EACzC,MAAM,IAAI,kCAAoBA,EAAWyN,KAAM,UAAUiI,IAAU,UAAU1V,EAAW0V,UCzCrF,MAAMC,UAGT5a,YAAqB0S,EAA0BnS,EAA4BE,GAAtD,KAAAiS,KAAAA,EAA0B,KAAAnS,KAAAA,EAA4B,KAAAE,MAAAA,EAFlE,KAAAka,QAAS,EAKlBE,WAAWta,GACP,GAAIS,KAAKT,KAAK6T,OAAO7T,GAAO,OAAOS,KAEnC,IAAI8Z,EACJ,GAAIva,EAAK6T,OAAO4B,YAAYE,MAExB4E,EAAyB,GAAd9Z,KAAKP,MAAa,EAAI,OAC9B,GAAkB,UAAdF,EAAKA,KACZua,EAAWC,OAAO/Z,KAAKP,WACpB,CACH,GAAIO,KAAKP,MAAQF,EAAK8V,UAAYrV,KAAKP,MAAQF,EAAK0V,SAChD,MAAM,IAAI,kCAA2BjV,KAAK0R,KAAM,uBAAuBnS,EAAKsT,WAAY7S,KAAKP,MAAM8S,YAEvGuH,EAAW1E,OAAOpV,KAAKP,OAE3B,OAAO,IAAIma,UAAU5Z,KAAK0R,KAAMnS,EAAMua,GAI1C,iBAKG,MAAME,YAGThb,YAAqB0S,EAA0BjS,GAA1B,KAAAiS,KAAAA,EAA0B,KAAAjS,MAAAA,EAC3CO,KAAK2Z,SAAWla,EAAMF,gBAAgBkT,WAGtClT,WACA,OAAOS,KAAKP,MAAMF,KAAKgU,kBAG3B,qBACUvT,MAIP,MAAMia,eAITjb,YAAqB0S,EAA0BjS,GAE3C,GAFiB,KAAAiS,KAAAA,EAA0B,KAAAjS,MAAAA,EAHtC,KAAAka,QAAS,EAKO,IAAjBla,EAAMyD,QAA4C,KAA5BzD,EAAMA,EAAMyD,OAAS,GAC3C,MAAM,IAAI,kCAA2BwO,EAAM,yBAA0B,UAEzE1R,KAAKT,KAAO,IAAIuU,OAAOpC,EAAMsD,YAAYQ,GAAI/V,EAAMyD,QAAQqQ,kBAG/D,iBAKG,MAAM2G,cAKTlb,YAAqB0S,EAA0B5R,EAA4Ba,GAKvE,GALiB,KAAA+Q,KAAAA,EAA0B,KAAA5R,KAAAA,EAA4B,KAAAa,KAAAA,EAJlE,KAAAgZ,QAAS,EAKd3Z,KAAKma,OD3CN,SAAoBzI,EAAiBnH,GACxC,GAAIA,aAAakI,UAAW,OAAOlI,EACnC,GAAIA,aAAakJ,UAAYlJ,EAAEhL,gBAAgBkT,UAAW,OAAOlI,EAAEhL,KACnE,MAAM,IAAI,kCAAoBmS,EAAM,WAAYnH,EAAEsI,UCwChC,CAAkB/S,EAAK4R,KAAM5R,EAAKP,MAChDS,KAAKT,KAAOS,KAAKma,OAAOzH,WAAWa,kBAG/BvT,KAAKma,OAAO/W,UAAYpD,KAAKma,OAAOxH,eAAezP,OAASvC,EAAKuC,OACjE,MAAM,IAAI,kCAA2BwO,EAAM,YAAY1R,KAAKma,OAAOxH,eAAezP,2CAC/E,IAAKlD,KAAKma,OAAO/W,UAAYpD,KAAKma,OAAOxH,eAAezP,SAAWvC,EAAKuC,OAC3E,MAAM,IAAI,kCAA2BwO,EAAM,GAAG1R,KAAKma,OAAOxH,eAAezP,qBAAsB,GAAGvC,EAAKuC,UAE3G,IAAK,IAAIwD,EAAI,EAAGA,EAAI1G,KAAKma,OAAOxH,eAAezP,OAAQwD,IACnD0T,YAAYC,qBAAqB1Z,EAAK+F,GAAGgL,KAAM1R,KAAKma,OAAOxH,eAAejM,GAAI/F,EAAK+F,IAI3F,qBACW1G,KAAKF,KAAKwa,cACjB,IAAK,MAAM7T,KAAKzG,KAAKW,WAAa8F,EAAE6T,eAIrC,MAAMC,cAMTvb,YAAqB0S,EAA0B5R,EAA4B2U,GAAtD,KAAA/C,KAAAA,EAA0B,KAAA5R,KAAAA,EAA4B,KAAA2U,OAAAA,EACvE,MAAM+F,EAAW1a,EAAKP,gBAAgBkU,SAAY3T,EAAKP,KAAKqU,UAAY9T,EAAKP,KAAQO,EAAKP,KACpFkb,EAAc,EAAiB3a,EAAK4R,KAAM8I,GAChDxa,KAAK0a,YDlEN,SAAyBhJ,EAAiBnH,GAE7C,GADA2I,EAAkB3I,GACdA,aAAayJ,QAAS,OAAOzJ,EACjC,GAAIA,aAAaqK,OAAQ,OAAOrK,EAChC,MAAM,IAAI,kCAAoBmH,EAAM,kBAAmBnH,EAAEsI,UC8DlC,CAAuB/S,EAAK4R,KAAM+I,EAAYlb,MAEjE,MAAMA,EAAOS,KAAK0a,YAAYlG,WAAWC,GACzCzU,KAAKT,KAAOA,EAAKgU,kBACjBvT,KAAK2Z,SAAW3Z,KAAKT,gBAAgBuU,QAGzC,qBACW9T,KAAKF,KAAKwa,eAIlB,MAAMK,UAIT3b,YAAqB0S,EAA0B5R,EAC1B8a,EAA0BC,GAD1B,KAAAnJ,KAAAA,EAA0B,KAAA5R,KAAAA,EAC1B,KAAA8a,GAAAA,EAA0B,KAAAC,IAAAA,EAJtC,KAAAlB,QAAS,EAKd,EAAmB7Z,GAAM,GAEzB,MAAM0a,EAAW1a,EAAKP,gBAAgBkU,SAAY3T,EAAKP,KAAKqU,UAAY9T,EAAKP,KAAQO,EAAKP,KAC1FS,KAAKT,KAAO,EAA4BO,EAAK4R,KAAM,EAA6B5R,EAAK4R,KAAM8I,IACvFxa,KAAKT,gBAAgBkU,UAAUP,EAAkBlT,KAAKT,KAAKA,MAGnE,qBACWS,KAAKF,KAAKwa,eAIlB,MAAMQ,QAKT9b,YAAqB0S,EAAiB5R,GAElC,GAFiB,KAAA4R,KAAAA,EAJZ,KAAAiI,QAAS,EACT,KAAApa,KAAOyW,EAIZhW,KAAKF,KAAOA,aAAgB2T,SAAY3T,EAAK8T,UAAY9T,EAAQA,EAC7DE,KAAKF,KAAKkT,YAAkC,IAApBhT,KAAKF,KAAKgT,OAAe9S,KAAKF,gBAAgB2S,UACtE,MAAM,IAAI,kCAA2Bf,EAAM,6BAA8B5R,EAAK+S,UAItF,iBAKG,MAAMkI,WAKT/b,YAAqB0S,EAAiB5R,GAAjB,KAAA4R,KAAAA,EAJZ,KAAAiI,QAAS,EAKd,MAAMa,EAAW1a,EAAKP,gBAAgBkU,SAAY3T,EAAKP,KAAKqU,UAAY9T,EAAKP,KAAQO,EAAKP,KACpFO,aAAgBka,aAAeQ,aAAoB/H,WAAY,EAAmB3S,GAAM,GAC9FE,KAAKT,KAAO,IAAIkU,SAAS/B,EAAM8I,GAE3B1a,aAAgBka,cAEfla,EAAKL,MAAgCub,aAAc,GAExDhb,KAAKF,KAAOA,EAGhB,qBACWE,KAAKF,KAAKwa,eAIlB,MAAMW,aAITjc,YAAqB0S,EAA0B5R,GAA1B,KAAA4R,KAAAA,EAA0B,KAAA5R,KAAAA,EAHtC,KAAA6Z,QAAS,EAId3Z,KAAKT,KAAO,EAAiBmS,EAAM5R,EAAKP,MAAMA,KAAKgU,kBAGvD,qBACWvT,KAAKF,KAAKwa,eAIlB,MAAMY,gBAKTlc,YAAqB0S,EAA0B5R,EAA4B8a,GAAtD,KAAAlJ,KAAAA,EAA0B,KAAA5R,KAAAA,EAA4B,KAAA8a,GAAAA,EAJlE,KAAAjB,QAAS,EAKd3Z,KAAKwa,SAAW,EAAoB1a,EAAK4R,KAAM5R,EAAKP,MACpDS,KAAKT,KAAO6W,EAAiBpW,KAAKwa,UAGtC,qBACWxa,KAAKF,KAAKwa,eAIlB,MAAMa,YAKTnc,YAAqB0S,EAA0B5R,GAA1B,KAAA4R,KAAAA,EAA0B,KAAA5R,KAAAA,EAJtC,KAAA6Z,QAAS,EAKd3Z,KAAKwa,SAAW,EAAiB1a,EAAK4R,KAAM5R,EAAKP,MACjDS,KAAKT,KAAOS,KAAKwa,SAAS1H,MAAQkC,YAAYa,IAAI/C,MAAQkC,YAAYa,IAAM7V,KAAKwa,SAGrF,qBACWxa,KAAKF,KAAKwa,eAIlB,MAAMc,YAITpc,YAAqB0S,EAA0B5R,GAA1B,KAAA4R,KAAAA,EAA0B,KAAA5R,KAAAA,EAHtC,KAAA6Z,QAAS,EACT,KAAApa,KAAOyV,YAAYa,IAGxB,EAA6B/V,EAAK4R,KAAM5R,EAAKP,MAGjD,qBACWS,KAAKF,KAAKwa,eAIlB,MAAMe,MAITrc,YAAqB0S,EAAiBnS,EAAsBO,GAAvC,KAAA4R,KAAAA,EAAuC,KAAA5R,KAAAA,EAHnD,KAAA6Z,QAAS,EAId3Z,KAAKT,KAAOA,EAAKgU,kBAGrB,qBACWvT,KAAKF,KAAKwa,eAIlB,MAAMgB,QAITtc,YAAqB0S,EAA0BvR,EAA2BC,EAA2Bwa,GAAhF,KAAAlJ,KAAAA,EAA0B,KAAAvR,IAAAA,EAA2B,KAAAC,IAAAA,EAA2B,KAAAwa,GAAAA,EAH5F,KAAAjB,QAAS,EAId3Z,KAAKT,KAAO8W,EACR,EAAoBlW,EAAIuR,KAAMvR,EAAIZ,MAClC,EAAoBa,EAAIsR,KAAMtR,EAAIb,OAG1C,qBACWS,KAAKG,IAAIma,oBACTta,KAAKI,IAAIka,eAIjB,MAAMiB,KAITvc,YAAqB0S,EAA0BvR,EAA2BC,GAArD,KAAAsR,KAAAA,EAA0B,KAAAvR,IAAAA,EAA2B,KAAAC,IAAAA,EAHjE,KAAAuZ,QAAS,EAId3Z,KAAKT,KAAO8W,EACR,EAAiBlW,EAAIuR,KAAMvR,EAAIZ,MAC/B,EAAiBa,EAAIsR,KAAMtR,EAAIb,OAGvC,qBACWS,KAAKG,IAAIma,oBACTta,KAAKI,IAAIka,eAKjB,MAAMkB,QAITxc,YAAqB0S,EAA0BvR,EAA2BC,EAA2Bwa,GACjG,GADiB,KAAAlJ,KAAAA,EAA0B,KAAAvR,IAAAA,EAA2B,KAAAC,IAAAA,EAA2B,KAAAwa,GAAAA,EAH5F,KAAAjB,QAAS,EAIVxZ,EAAIZ,gBAAgBkU,UAAYrT,EAAIb,gBAAgBkU,SAAU,CAC9D,IAAKtT,EAAIZ,KAAK6T,OAAOhT,EAAIb,MAAO,MAAM,IAAI,kCAA2BmS,EAAM,uCAC3EwB,EAAkB/S,EAAIZ,KAAKA,MAC3BS,KAAKT,KAAO,EAA4BY,EAAIuR,KAAMvR,EAAIZ,MACtD,EAA4Ba,EAAIsR,KAAMtR,EAAIb,WAEnCY,EAAIZ,gBAAgBkU,UAC3B,EAAiBrT,EAAIsR,KAAMtR,EAAIb,MAC/B2T,EAAkB/S,EAAIZ,KAAKA,MAC3BS,KAAKT,KAAO,EAA4BY,EAAIuR,KAAMvR,EAAIZ,OAE/Ca,EAAIb,gBAAgBkU,UAC3B,EAAiBtT,EAAIuR,KAAMvR,EAAIZ,MAC/B2T,EAAkB9S,EAAIb,KAAKA,MAC3BS,KAAKT,KAAO,EAA4Ba,EAAIsR,KAAMtR,EAAIb,OAGtDS,KAAKT,KAAO8W,EAA0B,EAAoBlW,EAAIuR,KAAMvR,EAAIZ,MAAO,EAAoBa,EAAIsR,KAAMtR,EAAIb,OAIzH,qBACWS,KAAKG,IAAIma,oBACTta,KAAKI,IAAIka,eAIjB,MAAMmB,OAITzc,YAAqB0S,EAA0BvR,EAA2BC,EAA2Bsb,GAAhF,KAAAhK,KAAAA,EAA0B,KAAAvR,IAAAA,EAA2B,KAAAC,IAAAA,EAA2B,KAAAsb,IAAAA,EAH5F,KAAA/B,QAAS,EAId3Z,KAAKT,KAAO6W,EAAiB,EAAiBjW,EAAIuR,KAAMvR,EAAIZ,OAC5D,EAAiBa,EAAIsR,KAAMtR,EAAIb,MAGnC,qBACWS,KAAKG,IAAIma,oBACTta,KAAKI,IAAIka,eAIjB,MAAMqB,YAKT3c,YAAqB0S,EAA0BvR,EAA2BC,EAA2Bwa,GAAhF,KAAAlJ,KAAAA,EAA0B,KAAAvR,IAAAA,EAA2B,KAAAC,IAAAA,EAA2B,KAAAwa,GAAAA,EAJ5F,KAAAjB,QAAS,EACT,KAAApa,KAAOyV,YAAYE,KAIxB,EAA6B/U,EAAIuR,KAAMvR,EAAIZ,MAC3C,EAA6Ba,EAAIsR,KAAMtR,EAAIb,MAE3CS,KAAK4b,WAAavF,EACdlW,EAAIZ,gBAAgByV,YAAc7U,EAAIZ,KAAOyW,EAC7C5V,EAAIb,gBAAgByV,YAAc5U,EAAIb,KAAOyW,GAGrD,qBACWhW,KAAKG,IAAIma,oBACTta,KAAKI,IAAIka,eAIjB,MAAMuB,UAKT7c,YAAqB0S,EAA0BvR,EAA2BC,EAA2Bwa,GAAhF,KAAAlJ,KAAAA,EAA0B,KAAAvR,IAAAA,EAA2B,KAAAC,IAAAA,EAA2B,KAAAwa,GAAAA,EAJ5F,KAAAjB,QAAS,EACT,KAAApa,KAAOyV,YAAYE,KAIxB,EAA6B/U,EAAIuR,KAAMvR,EAAIZ,MAC3C,EAA6Ba,EAAIsR,KAAMtR,EAAIb,MAE3CS,KAAK4b,WAAavF,EACdlW,EAAIZ,gBAAgByV,YAAc7U,EAAIZ,KAAOyW,EAC7C5V,EAAIb,gBAAgByV,YAAc5U,EAAIb,KAAOyW,GAGrD,qBACWhW,KAAKG,IAAIma,oBACTta,KAAKI,IAAIka,eAIjB,MAAMwB,cAIT9c,YAAqB0S,EAA0BvR,EAA2BC,EAA2Bwa,GAAhF,KAAAlJ,KAAAA,EAA0B,KAAAvR,IAAAA,EAA2B,KAAAC,IAAAA,EAA2B,KAAAwa,GAAAA,EAH5F,KAAAjB,QAAS,EAId3Z,KAAKT,KAAO8W,EACR,EAAiBlW,EAAIuR,KAAMvR,EAAIZ,MAC/B,EAAiBa,EAAIsR,KAAMtR,EAAIb,OAGvC,qBACWS,KAAKG,IAAIma,oBACTta,KAAKI,IAAIka,eAIjB,MAAMyB,cAIT/c,YAAqB0S,EAA0BvR,EAA2BC,EAA2Bwa,GAAhF,KAAAlJ,KAAAA,EAA0B,KAAAvR,IAAAA,EAA2B,KAAAC,IAAAA,EAA2B,KAAAwa,GAAAA,EAH5F,KAAAjB,QAAS,EACT,KAAApa,KAAOyV,YAAYE,KAGxB,EAA6B/U,EAAIuR,KAAMvR,EAAIZ,MAC3C,EAA6Ba,EAAIsR,KAAMtR,EAAIb,MAG/C,qBACWS,KAAKG,IAAIma,oBACTta,KAAKI,IAAIka,eAIjB,MAAM0B,aAIThd,YAAqB0S,EAA0B9M,EAA4B5D,EAAiCC,GAGxG,GAHiB,KAAAyQ,KAAAA,EAA0B,KAAA9M,KAAAA,EAA4B,KAAA5D,UAAAA,EAAiC,KAAAC,WAAAA,EAHnG,KAAA0Y,QAAS,EAId,EAA6B/U,EAAK8M,KAAM9M,EAAKrF,MAEzCyB,EAAUzB,gBAAgByV,aAAe/T,EAAW1B,gBAAgByV,YACpEhV,KAAKT,KAAO8W,EAA0BrV,EAAUzB,KAAM0B,EAAW1B,UADrE,CAGO,IAAIyB,EAAUzB,KAAK6T,OAAOnS,EAAW1B,MAArC,CAGA,GAAIyB,EAAUzB,gBAAgBkU,UAAYxS,EAAW1B,gBAAgBkU,SAAU,CAElF,GAAIzS,EAAUzB,KAAKA,gBAAgB0T,MAE/B,YADAjT,KAAKT,KAAO0B,EAAW1B,MAEpB,GAAI0B,EAAW1B,KAAKA,gBAAgB0T,MAEvC,YADAjT,KAAKT,KAAOyB,EAAUzB,WAGvB,GAAIyB,EAAUzB,gBAAgBkU,UAAYxS,EAAW1B,gBAAgBkU,SAAU,CAElF,MAAMwI,EAAajb,EAAUzB,gBAAgBkU,SAAWxS,EAAaD,EAErE,GAAIib,aAAsBrC,WAAiC,GAApBqC,EAAWxc,MAE9C,YADAO,KAAKT,KAAOyB,EAAUzB,gBAAgBkU,SAAWzS,EAAUzB,KAAO0B,EAAW1B,MAIrF,MAAM,IAAI,kCAA2BmS,EAAM,kDAAmD,mBApB1F1R,KAAKT,KAAOyB,EAAUzB,MAuB9B,qBACWS,KAAK4E,KAAK0V,oBACVta,KAAKgB,UAAUsZ,oBACfta,KAAKiB,WAAWqZ,eAIxB,MAAMF,YAKTpb,YAAqB0S,EAA0BvR,EAA2BC,EACrD8b,EAA4CC,GAA6B,GADzE,KAAAzK,KAAAA,EAA0B,KAAAvR,IAAAA,EAA2B,KAAAC,IAAAA,EACrD,KAAA8b,eAAAA,EAA4C,KAAAC,kBAAAA,EALxD,KAAAxC,QAAS,EAOd,MAAMyC,EAAUjc,EAAIZ,gBAAgBkU,SAAYtT,EAAIZ,KAAKqU,UAAYzT,EAAIZ,KAAQY,EAAIZ,KAErF,GADA,EAAmBY,GAAK,GACnBic,aAAmBtI,SAAWqI,GAAsBC,aAAmB3J,WAAatS,EAAIZ,KAAKyT,WAC9F,MAAM,IAAI,kCAA2B7S,EAAIuR,KAAM,mBAC5C,GAA8B,UAA1BgC,EAAa0I,KAAyBD,EAC7C,MAAM,IAAI,kCAA2Bhc,EAAIuR,KAAM,sBAC5C,IAAK0K,aAAmBpI,SAAWoI,aAAmBxH,SAAWwH,EAAQzH,mBAAqBwH,EACjG,MAAM,IAAI,kCAA2Bhc,EAAIuR,KAAM,oCAKnD,GAHA1R,KAAKT,KAAO6c,EAAQ7I,kBAGhB2I,EAAgB,CAChB,GAAI9b,aAAeic,aACf,MAAM,IAAI,kCAA2B3K,EAAK,kDAE9C,IAAI4K,EAAUlc,EAAIb,KAIlB,OAAQ2c,GACR,IAAK,MAAOI,EAAU,IAAIhB,QAAQ5J,EAAMvR,EAAKC,EAAK,KAAKb,KAAM,MAC7D,IAAK,MAAO+c,EAAU,IAAIhB,QAAQ5J,EAAMvR,EAAKC,EAAK,KAAKb,KAAM,MAC7D,IAAK,MAAO+c,EAAU,IAAIf,KAAK7J,EAAMvR,EAAKC,GAAKb,KAAM,MACrD,IAAK,MAAO+c,EAAU,IAAId,QAAQ9J,EAAMvR,EAAKC,EAAK,KAAKb,KAAM,MAC7D,IAAK,MAAO+c,EAAU,IAAId,QAAQ9J,EAAMvR,EAAKC,EAAK,KAAKb,KAAM,MAC7D,IAAK,YAAa+c,EAAU,IAAIb,OAAO/J,EAAMvR,EAAKC,EAAK,QAAQb,KAAM,MACrE,IAAK,aAAc+c,EAAU,IAAIb,OAAO/J,EAAMvR,EAAKC,EAAK,SAASb,KAAM,MACvE,IAAK,aAAc+c,EAAU,IAAIR,cAAcpK,EAAMvR,EAAKC,EAAK,OAAOb,KAAM,MAC5E,IAAK,YAAa+c,EAAU,IAAIR,cAAcpK,EAAMvR,EAAKC,EAAK,MAAMb,KAAM,MAC1E,IAAK,aAAc+c,EAAU,IAAIR,cAAcpK,EAAMvR,EAAKC,EAAK,OAAOb,KAAM,MAC5E,QAAS,MAAM,IAAI,kCAA2BmS,EAAM,yBAEpD0I,YAAYmC,0BAA0B7K,EAAM0K,EAASE,QAErDlC,YAAYC,qBAAqB3I,EAAM0K,EAAShc,GAIxD,qBACWJ,KAAKG,IAAIma,oBACTta,KAAKI,IAAIka,cAGpBkC,4BAA4B9K,EAAiB+K,EAAgBhd,GAErDgd,aAAmBhJ,UAAYhU,aAAiBma,WAC5B,KAAhBna,EAAMA,OAEdO,KAAKuc,0BAA0B7K,EAAM+K,EAAShd,EAAMF,MAGhDid,iCAAiC9K,EAAiB+K,EAAgB/c,GACtE,KAAI+c,EAAQrJ,OAAO1T,IACf+c,aAAmBzH,aAAetV,aAAqBsV,aAA3D,CAGA,GAAIyH,aAAmBhJ,UAAY/T,aAAqB+T,SAAU,CAE9D,GAAIgJ,EAAQld,gBAAgB0T,OAASvT,EAAUH,gBAAgB0T,MAAO,OAEtE,GAAIwJ,EAAQld,KAAK6T,OAAO1T,EAAUH,MAAO,OAE7C,KAAIkd,aAAmBhJ,UAAY/T,aAAqB+S,WAEhDgK,EAAQld,KAAK6T,OAAO1T,IAF5B,CAIA,GAAIA,aAAqB+T,UAAY/T,EAAUkU,SAAU,CAErD,GAAI6I,EAAQrJ,OAAO1T,EAAUkU,UAAW,OAExC,GAAI6I,aAAmB3I,QAAUpU,EAAUkU,oBAAoBE,QAAU2I,EAAQld,KAAK6T,OAAO1T,EAAUH,QAE9FG,EAAUkU,SAAS1Q,QAAU,IAAMuZ,EAAQvZ,QAAU,GAAI,OAItE,MAAM,IAAI,kCAA2BwO,EAAM+K,EAAQ5J,SAAUnT,EAAUmT,aAIxE,MAAM6J,OAIT1d,YAAqB0S,EAA0BvR,EAA2BC,GAArD,KAAAsR,KAAAA,EAA0B,KAAAvR,IAAAA,EAA2B,KAAAC,IAAAA,EAHjE,KAAAuZ,QAAS,EAId3Z,KAAKT,KAAOa,EAAIb,KAGpB,qBACWS,KAAKG,IAAIma,oBACTta,KAAKI,IAAIka,eAKjB,MAAM+B,aAITrd,YAAqB0S,EAA0B5R,EAAsCP,GAAhE,KAAAmS,KAAAA,EAA0B,KAAA5R,KAAAA,EAFvC,KAAA6c,aAAwB,GAI5B3c,KAAK4c,MAAQrd,GAAQ,IAAIuU,YAAOzJ,EAAW,IAAIoJ,cAASpJ,EAAW,IAAI4I,OAAUnT,EAAKoD,QAGtF2Z,kBACA,OAAO7c,KAAK2c,aAGZpd,WACA,OAAOS,KAAK4c,MAKZrd,SAAKE,GAGL,GAFAO,KAAK2c,aAAe,GAEhBld,aAAiBqU,OAAQ,CACzB,GAAI9T,KAAKF,KAAKoD,QAAUzD,EAAMyD,QAAUiS,KACpC,MAAM,IAAI,kCAA2BnV,KAAK0R,KAAM,WAAWjS,EAAMyD,kBAAmB,GAAGlD,KAAKF,KAAKoD,mBAErG,IAAK,IAAIwD,EAAI,EAAGA,EAAI1G,KAAKF,KAAKoD,OAAQwD,IAClC1G,KAAKF,KAAK4G,GAAK2V,aAAaS,UAAUrd,EAAMF,KAAMS,KAAKF,KAAK4G,IAC5D1G,KAAK2c,aAAahW,KAAKlH,EAAMF,WAG9B,GAAIE,aAAiBuU,QAAS,CACjC,GAAIhU,KAAKF,KAAKoD,OAASzD,EAAMwU,QAAQ/Q,OACjC,MAAM,IAAI,kCAA2BlD,KAAK0R,KAAM,WAAWjS,EAAMwU,QAAQ/Q,kBAAmB,GAAGlD,KAAKF,KAAKoD,mBAE7G,IAAK,IAAIwD,EAAI,EAAGA,EAAI1G,KAAKF,KAAKoD,OAAQwD,IAClC1G,KAAKF,KAAK4G,GAAK2V,aAAaS,UAAUrd,EAAMwU,QAAQvN,GAAGnH,KAAMS,KAAKF,KAAK4G,IACvE1G,KAAK2c,aAAahW,KAAKlH,EAAMwU,QAAQvN,GAAGnH,UAGzC,MAAIE,aAAiBmV,QASxB,MAAM,IAAI,kCAA2B5U,KAAK0R,KAAM,gCARhD,GAAI1R,KAAKF,KAAKoD,OAAS,EACnB,MAAM,IAAI,kCAA2BlD,KAAK0R,KAAM,6CAA8C,GAAG1R,KAAKF,KAAKoD,mBAC/E,IAArBlD,KAAKF,KAAKoD,SACjBlD,KAAKF,KAAK,GAAKuc,aAAaS,UAAUrd,EAAMwU,QAAQ,GAAG1U,KAAMS,KAAKF,KAAK,IACvEE,KAAK2c,aAAahW,KAAKlH,EAAMwU,QAAQ,GAAG1U,OAMhDS,KAAK4c,MAAQnd,EAGjB,eACI,IAAK,MAAM8G,KAAKvG,KAAKF,WAAayG,EAAE+T,cAGhCkC,iBAAiBO,EAAoB1b,GAUzC,OATIA,aAAgBgb,aAChBhb,EAAK9B,KAAOwd,GAEZ3C,YAAYC,qBAAqBhZ,EAAKqQ,KAAMqL,EAAa1b,GAErDA,aAAgBuY,WAAamD,aAAuB/H,aAAe3T,EAAK9B,OAASwd,IACjF1b,EAAOA,EAAKwY,WAAWkD,KAGxB1b,GChmBR,MAAM2b,MAMThe,YAAqB0S,EACAiG,EACAsF,EAAoCtF,GAAQsF,MAF5C,KAAAvL,KAAAA,EACA,KAAAiG,OAAAA,EACA,KAAAsF,KAAAA,EAPb,KAAAC,KAAO,IAAIpG,IACX,KAAAwD,YAAc,IAAIxD,IAClB,KAAAqG,SAAW,IAAIrG,IAQfsG,QAAQC,GAEZ,OAAOrd,KAAKkd,KAAK9L,IAAIiM,IAAQrd,KAAK2X,QAAQyF,QAAQC,GAGtDC,UAA+BD,EAAanE,EAAyCxH,GACjF,MAAM6L,EAASvd,KAAKod,QAAQC,GAC5B,GAAInE,GAAcqE,GAAUrE,EAAWjS,YAActB,OAAOwR,eAAeoG,GACvE,MAAM,IAAIC,WAAW,IAAMH,EAAM,+BAAiCE,EAAO1K,SAAU0K,EAAO7L,KAAMA,GAEpG,OAAO6L,EAGXE,OAAOhe,GACH,IAAKA,EAAMJ,KAAM,MAAM,IAAI2G,MAAM,8CACjC,GAAIhG,KAAKod,QAAQ3d,EAAMJ,MAAO,MAAM,IAAIme,WAAW,kBAAoB/d,EAAMJ,KAAO,wBAAyBI,EAAMiS,MACnH1R,KAAKkd,KAAK5F,IAAI7X,EAAMJ,KAAMI,GAGtBie,OAAOre,GACX,OAAOW,KAAKsa,YAAYlJ,IAAI/R,IAASW,KAAK2X,QAAQ+F,OAAOre,GAG7Dse,iBAAiBte,EAAcqS,GAC3B,MAAM6L,EAASvd,KAAK0d,OAAOre,GAC3B,IAAKke,EACD,MAAM,IAAIC,WAAW,mBAAqBne,EAAO,IAAKqS,GAE1D,OAAO6L,EAGXK,cAAcne,GACV,MAAMoe,EAAW7d,KAAKsa,YAAYlJ,IAAI3R,EAAMJ,MAC5C,GAAIwe,EACA,GAAIA,EAASte,KAAK6T,OAAO3T,EAAMF,OAASse,aAAoBC,kBAAoBre,aAAiBse,gBAEpE,aAArBF,EAASG,SAA4C,aAAlBve,EAAMue,UAEzCve,EAAMue,QAAUH,EAASG,SAE7BH,EAAS3M,WAAazR,MACnB,IAAIoe,EAASte,KAAK6T,OAAO3T,EAAMF,OAASE,aAAiBqe,iBAG5D,YADID,aAAoBC,mBAAkBD,EAASI,WAATJ,EAASI,SAAaxe,EAAMwe,YAEnE,KAAIJ,EAASte,KAAK6T,OAAO3T,EAAMF,OAASse,aAAoBK,iBAAmBze,aAAiB0e,gBAOhG,IAAIN,EAASte,KAAK6T,OAAO3T,EAAMF,OAASE,aAAiBye,gBAAiB,CAE7E,GAAyB,aAArBL,EAASG,SAA0BH,EAASG,UAAYve,EAAMue,QAE9D,MAAM,IAAIR,WAAW,aAAe/d,EAAMJ,KAAO,6BAA+Bwe,EAASG,QAAU,WAAYH,EAASnM,KAAMjS,EAAMiS,MAExI,OAEA,MAAM,IAAI8L,WAAW,eAAiB/d,EAAMJ,KAAO,sCAAuCwe,EAASnM,KAAMjS,EAAMiS,MAb/G,GAAyB,aAArBmM,EAASG,SAA0BH,EAASG,UAAYve,EAAMue,QAE9D,MAAM,IAAIR,WAAW,aAAe/d,EAAMJ,KAAO,6BAA+Bwe,EAASG,QAAU,WAAYH,EAASnM,KAAMjS,EAAMiS,MAExImM,EAAS3M,WAAazR,EAY9BO,KAAKsa,YAAYhD,IAAI7X,EAAMJ,KAAMI,GAGjCmD,mBACA,MAAO,IAAI5C,KAAKsa,YAAYxF,UAGxBsJ,YAAYrc,GAEhB,OAAO/B,KAAKmd,SAAS/L,IAAIrP,IAAO/B,KAAK2X,QAAQyG,YAAYrc,GAG7Dsc,cAActc,EAAY2P,GACtB,MAAM6L,EAASvd,KAAKoe,YAAYrc,GAChC,QAAesI,IAAXkT,EACA,MAAM,IAAIC,WAAW,YAAczb,EAAK,uBAAwB2P,GAEpE,OAAO6L,EAGXe,WAAWvc,EAAYxC,EAAamS,GAChC,MAAMmM,EAAW7d,KAAKoe,YAAYrc,GAClC,GAAI8b,EAAU,CACV,GAAIA,EAASzK,OAAO7T,GAAO,OAC3B,MAAM,IAAIie,WAAW,gDAAiD9L,GAE1E1R,KAAKmd,SAAS7F,IAAIvV,EAAIxC,IAI9B,MAAMie,mBAAmB/L,OAAzB,c,oBACI,KAAApS,KAAO,cC5GJ,MAAMkf,mBAITvf,YAAqB0S,EAA6BiG,GAA7B,KAAAjG,KAAAA,EAA6B,KAAAiG,OAAAA,EAFzC,KAAA6G,WAA2B,GAGhCxe,KAAKye,MAAQ,IAAIzB,MAAMtL,EAAMiG,EAAO8G,MAAO9G,aAAkBoG,gBAAkBpG,OAAStN,IAIzF,MAAMqU,qBACT1f,YAAqB0S,EAA6BzN,EAAkC0T,GAA/D,KAAAjG,KAAAA,EAA6B,KAAAzN,WAAAA,EAAkC,KAAA0T,OAAAA,EAGhF8G,YACA,OAAOze,KAAK2X,OAAO8G,OAIpB,MAAME,KACT3f,YAAqB0S,EAAwBiG,GAAxB,KAAAjG,KAAAA,EAAwB,KAAAiG,OAAAA,EAGzC8G,YACA,OAAOze,KAAK2X,OAAO8G,OAIpB,MAAMG,IAIT5f,YAAqB0S,EAA+B9M,EAA4B+S,GAA3D,KAAAjG,KAAAA,EAA+B,KAAA9M,KAAAA,EAA4B,KAAA+S,OAAAA,EAC5E6B,EAAsB5U,EAAK8M,KAAM9M,EAAKrF,MAGtCkf,YACA,OAAOze,KAAK2X,OAAO8G,OAIpB,MAAMI,SAQT7f,YAAqB0S,EAA2BiG,GAA3B,KAAAjG,KAAAA,EAA2B,KAAAiG,OAAAA,EAC5C3X,KAAKye,MAAQ,IAAIzB,MAAMtL,EAAMiG,EAAO8G,QAIrC,MAAMK,WAGT9f,YAAqB0S,EAA6B9M,EAA4B+S,GAAzD,KAAAjG,KAAAA,EAA6B,KAAA9M,KAAAA,EAA4B,KAAA+S,OAAAA,EAC1E6B,EAAsB5U,EAAK8M,KAAM9M,EAAKrF,MAGtCkf,YACA,OAAOze,KAAK2X,OAAO8G,OAIpB,MAAMM,QAGT/f,YAAqB0S,EAA+B9M,EAA4B+S,GAA3D,KAAAjG,KAAAA,EAA+B,KAAA9M,KAAAA,EAA4B,KAAA+S,OAAAA,EAC5E6B,EAAsB5U,EAAK8M,KAAM9M,EAAKrF,MAGtCkf,YACA,OAAOze,KAAK2X,OAAO8G,OAIpB,MAAMO,MACThgB,YAAqB0S,EAAiCzM,EAAqC0S,GAAtE,KAAAjG,KAAAA,EAAiC,KAAAzM,OAAAA,EAAqC,KAAA0S,OAAAA,EAGvF8G,YACA,OAAOze,KAAK2X,OAAO8G,OAIpB,MAAMQ,QAGTjgB,YAAqB0S,EAAmCzN,EAAkC0T,GAArE,KAAAjG,KAAAA,EAAmC,KAAAzN,WAAAA,EAAkC,KAAA0T,OAAAA,EAF1F,KAAAxD,SAA4E,GAKxEsK,YACA,OAAOze,KAAK2X,OAAO8G,OAIpB,MAAMS,UACTlgB,YAAqB0S,EACAyN,EACAxH,GAFA,KAAAjG,KAAAA,EACA,KAAAyN,KAAAA,EACA,KAAAxH,OAAAA,EAGjB8G,YACA,OAAOze,KAAK2X,OAAO8G,OAIpB,MAAMW,OACTpgB,YAAqB0S,EACAzM,EACA0S,GAFA,KAAAjG,KAAAA,EACA,KAAAzM,OAAAA,EACA,KAAA0S,OAAAA,EAGjB8G,YACA,OAAOze,KAAK2X,OAAO8G,OAIpB,MAAMY,QACTrgB,YAAqB0S,EACAuL,EACFxd,EACEkY,GAEjB,GALiB,KAAAjG,KAAAA,EACA,KAAAuL,KAAAA,EACF,KAAAxd,MAAAA,EACE,KAAAkY,OAAAA,OAEHtN,IAAV5K,GACA,GAAIwd,EAAK1d,KAAKmT,WAAWI,MAAQ,EAE7B,MAAM,IAAI,kCAAoBpB,EAAM,wBAAyB,kBAG5DuL,EAAK1d,KAAKmT,WAAWU,OAAO3T,EAAMF,OAEnC6a,YAAYC,qBAAqB3I,EAAMuL,EAAK1d,KAAKmT,WAAYjT,GAKrEgf,YACA,OAAOze,KAAK2X,OAAO8G,OAKpB,MAAMa,mBAGTtgB,YAAqB0S,EAA6B3N,GAA7B,KAAA2N,KAAAA,EAA6B,KAAA3N,MAAAA,GCpJ/C,MAAMma,gBAKTlf,YAAqB0S,EACArS,EACAE,EACAggB,EACAvB,GAJA,KAAAtM,KAAAA,EACA,KAAArS,KAAAA,EACA,KAAAE,KAAAA,EACA,KAAAggB,QAAAA,EACA,KAAAvB,QAAAA,EARZ,KAAAwB,SAAW,WACpB,KAAAC,cAAwB,EAUpBzE,gBAAY0E,G,MACR1f,KAAK2f,aAAa,EAAA3f,KAAK2f,aAAY3E,cAAW,EAAXA,YAAgB0E,GAClD1f,KAAKyf,eAALzf,KAAKyf,aAAiBC,GAG3B1E,kBACA,OAAOhb,KAAK2f,YAAc3f,KAAK2f,YAAY3E,YAAchb,KAAKyf,aAG9DvO,eAAWsG,GACX,QAAUnN,IAANmN,EAAiB,MAAM,IAAIxR,MAAM,sCACrCwR,EAAEwD,cAAFxD,EAAEwD,YAAgBhb,KAAKyf,cACvBzf,KAAK2f,YAAcnI,EAGnBtG,iBACA,OAAOlR,KAAK2f,aAIb,MAAMxB,eAMTnf,YAAqB0S,EACArS,EACAE,EACAggB,EACFvB,GAJE,KAAAtM,KAAAA,EACA,KAAArS,KAAAA,EACA,KAAAE,KAAAA,EACA,KAAAggB,QAAAA,EACF,KAAAvB,QAAAA,EATV,KAAAwB,SAAW,WAEpB,KAAAxE,aAAuB,EACd,KAAA4E,aAAe,IAAI9I,KAUzB,MAAM+I,UAMT7gB,YAAqB0S,EACArS,EACAE,EACA6Y,GAHA,KAAA1G,KAAAA,EACA,KAAArS,KAAAA,EACA,KAAAE,KAAAA,EACA,KAAA6Y,MAAAA,EARZ,KAAAoH,SAAW,WACX,KAAAD,QAAU,WACV,KAAAvB,QAAU,OACnB,KAAAhD,aAAuB,GASpB,MAAM8C,iBAIT9e,YAAqB0S,EACArS,EACAE,EACAye,EACFC,GAAoB,GAJlB,KAAAvM,KAAAA,EACA,KAAArS,KAAAA,EACA,KAAAE,KAAAA,EACA,KAAAye,QAAAA,EACF,KAAAC,SAAAA,EAPV,KAAAuB,SAAW,YAwBjB,MAAMzB,gBAMT/e,YAAqB0S,EACArS,EACAE,EACFye,EACE8B,GAJA,KAAApO,KAAAA,EACA,KAAArS,KAAAA,EACA,KAAAE,KAAAA,EACF,KAAAye,QAAAA,EACE,KAAA8B,gBAAAA,EATZ,KAAAN,SAAW,WAEX,KAAAI,aAAe,IAAI9I,IACnB,KAAAiJ,MAA2B,CAACC,QAAQ,GAOzChgB,KAAKF,KAAO,IAAIye,mBAAmB7M,EAAK5R,KAAME,MAG9Cye,YACA,OAAOze,KAAK8f,gBAGhB1M,OAAO7I,GACH,OAAOA,IAAMvK,KAGjBigB,cACI,OAAOjgB,MCjHf,MAAMkgB,EAA2B,IAAI,cAAc,EAAAnhB,UAG/CC,cACIM,MAAM,CAACgP,WAAY,EAAGE,aAAc,EAAGD,UAAW,EAAGE,YAAa,EAAGqD,OAAQ,KAHxE,KAAAvS,KAAe,iBAOf4gB,EAAe,CAMxBC,KAAM,IAAItC,iBACNoC,EACA,WACA,IAAIzN,UAAUyN,EAAe,IAAIjN,MAAS,CAAC+B,YAAYY,UAAMvL,GAAW,GACxE,YAGJgW,SAAU,IAAIvC,iBACVoC,EACA,eACA,IAAIzN,UAAUyN,EAAelL,YAAYY,IAAK,CAACZ,YAAYY,UAAMvL,GAAW,GAC5E,YAGJiW,SAAU,IAAIxC,iBACVoC,EACA,eACA,IAAIzN,UAAUyN,EAAelL,YAAYc,IAAK,CAACd,YAAYY,UAAMvL,GAAW,GAC5E,YAGJkW,SAAU,IAAIzC,iBACVoC,EACA,eACA,IAAIzN,UAAUyN,EAAelL,YAAYM,KAAM,CAACN,YAAYY,UAAMvL,GAAW,GAC7E,YAGJmW,SAAU,IAAI1C,iBACVoC,EACA,eACA,IAAIzN,UAAUyN,EAAelL,YAAYO,KAAM,CAACP,YAAYY,UAAMvL,GAAW,GAC7E,YAMJoW,SAAU,IAAI3C,iBACVoC,EACA,eACA,IAAIzN,UAAUyN,EAAe,IAAIzM,SAASyM,EAAe,IAAIjN,OAAS,GAAO,IAC7E,YASJyN,WAAY,IAAI5C,iBACZoC,EACA,iBACA,IAAIzN,UAAUyN,EAAe,IAAIzM,SAASyM,EAAe,IAAIjN,OAAS,GAAO,CAAC,IAAIQ,SAASyM,EAAe,IAAIjN,OAAS,KACvH,aAIK0N,EAAiB,IAAI3D,MAClCrX,OAAOmP,OAAOqL,GAAchN,SAAQ1Q,GAAKke,EAAe/C,cAAcnb,KCxEtE,MAAMme,EAAWrP,OAAO,YAcxB,SAASsP,EAAK/Z,GACTA,EAAsC8Z,IAAY,EAIhD,SAASE,EAAeha,EAAgBia,GAC3C,GAAOja,EAAwC8Z,IAAa,EAA5D,CAEO,GAAI9Z,aAAa8S,UACpB,MAAO,CAACna,MAAOqH,EAAErH,MAAOF,KAAMuH,EAAEvH,MAC7B,GAAIuH,aAAakT,aAAelT,EAAErH,iBAAiB0e,gBAA6C,UAA3BrX,EAAErH,MAAMF,KAAKsU,WAAyB/M,EAAErH,MAAMuhB,uBAAuBpH,UAC7I,OAAOkH,EAAeha,EAAErH,MAAMuhB,YAAaD,GAExC,GAAIja,aAAagU,QACpB,OAAOmG,EAAc,CAACxhB,MAAOqH,EAAEhH,KAAKgT,MAAOvT,KAAMyW,IAE9C,GAAIlP,aAAaoU,gBAAiB,CACrC,MAAM1D,EAAIsJ,EAAeha,EAAEhH,KAAMihB,GACjC,OAAKvJ,EACW,MAAT1Q,EAAE8T,GAAapD,EAAI,CAAC/X,OAAQ+X,EAAE/X,MAAOF,KAAMuH,EAAEvH,MADrCshB,EAAK/Z,GAGjB,GAAIA,aAAaqU,YAAa,CACjC,MAAM3D,EAAI0J,EAAYpa,EAAEhH,KAAMihB,GAC9B,OAAKvJ,EACEyJ,EAAc,CAACxhB,OAAQ+X,EAAE/X,MAAOF,KAAMiY,EAAEjY,OADhCshB,EAAK/Z,GAGjB,GAAIA,aAAasU,YAAa,CACjC,MAAM5D,EAAIsJ,EAAeha,EAAEhH,KAAMihB,GACjC,OAAKvJ,EAEE,CAAC/X,MAAkB,GAAX+X,EAAE/X,MAAa,GAAK,GAAIF,KAAMyV,YAAYa,KAF1CgL,EAAK/Z,GAIjB,GAAIA,aAAauU,QAAUvU,EAAEvH,gBAAgByV,aAAelO,EAAEvH,gBAAgBkU,UAAW,CAC5F,MAAM+D,EAAIsJ,EAAeha,EAAEhH,KAAMihB,GACjC,OAAKvJ,EACEyJ,EAAc,CAACxhB,MAAO+X,EAAE/X,MAAOF,KAAMuH,EAAEvH,OAD/BshB,EAAK/Z,GAGjB,GAAIA,aAAawU,QAAS,CAC7B,MAAMnb,EAAM2gB,EAAeha,EAAE3G,IAAK4gB,GAAQ3gB,EAAM0gB,EAAeha,EAAE1G,IAAK2gB,GACtE,IAAK5gB,IAAQC,EAAK,OAAOygB,EAAK/Z,GAC9B,GAAa,MAATA,EAAE8T,GACF,MAAoB,UAAhB9T,EAAEvH,KAAKA,KACA,CAACE,MAAOsa,OAAO5Z,EAAIV,OAASsa,OAAO3Z,EAAIX,OAAQF,KAAMuH,EAAEvH,MAE3D0hB,EAAc,CAACxhB,MAAO2V,OAAOjV,EAAIV,OAAS2V,OAAOhV,EAAIX,OAAQF,KAAMuH,EAAEvH,OAGzE,GAAiB,GAAba,EAAIX,MACX,MAAoB,UAAhBqH,EAAEvH,KAAKA,KACA,CAACE,MAAOsa,OAAO5Z,EAAIV,OAASsa,OAAO3Z,EAAIX,OAAQF,KAAMuH,EAAEvH,MAE3D0hB,EAAc,CAACxhB,MAAO2V,OAAOjV,EAAIV,OAAS2V,OAAOhV,EAAIX,OAAQF,KAAMuH,EAAEvH,WAG7E,IAAIuH,aAAayU,KAAM,CAC1B,MAAMpb,EAAM+gB,EAAYpa,EAAE3G,IAAK4gB,GAAQ3gB,EAAM8gB,EAAYpa,EAAE1G,IAAK2gB,GAChE,OAAK5gB,GAAQC,GAAqB,KAAdA,EAAIX,MACjBwhB,EAAc,CAACxhB,MAAOU,EAAIV,MAAQW,EAAIX,MAAOF,KAAMuH,EAAEvH,OADfshB,EAAK/Z,GAG/C,GAAIA,aAAa0U,SAAW1U,EAAEvH,gBAAgByV,YAAa,CAC9D,MAAM7U,EAAM2gB,EAAeha,EAAE3G,IAAK4gB,GAAQ3gB,EAAM0gB,EAAeha,EAAE1G,IAAK2gB,GACtE,OAAK5gB,GAAQC,EACA,MAAT0G,EAAE8T,GACkB,UAAhB9T,EAAEvH,KAAKA,KACA,CAACE,MAAOsa,OAAO5Z,EAAIV,OAASsa,OAAO3Z,EAAIX,OAAQF,KAAMuH,EAAEvH,MAE3D0hB,EAAc,CAACxhB,MAAO2V,OAAOjV,EAAIV,OAAS2V,OAAOhV,EAAIX,OAAQF,KAAMuH,EAAEvH,OAExD,UAAhBuH,EAAEvH,KAAKA,KACA,CAACE,MAAOsa,OAAO5Z,EAAIV,OAASsa,OAAO3Z,EAAIX,OAAQF,KAAMuH,EAAEvH,MAE3D0hB,EAAc,CAACxhB,MAAO2V,OAAOjV,EAAIV,OAAS2V,OAAOhV,EAAIX,OAAQF,KAAMuH,EAAEvH,OAVvDshB,EAAK/Z,GAa3B,GAAIA,aAAa2U,OAAQ,CAC5B,MAAMtb,EAAM+gB,EAAYpa,EAAE3G,IAAK4gB,GAAQ3gB,EAAM8gB,EAAYpa,EAAE1G,IAAK2gB,GAChE,OAAK5gB,GAAQC,EACC,SAAV0G,EAAE4U,IACKuF,EAAc,CAACxhB,MAAOU,EAAIV,OAASW,EAAIX,MAAOF,KAAMuH,EAAEvH,OAE1D0hB,EAAc,CAACxhB,MAAOU,EAAIV,OAASW,EAAIX,MAAOF,KAAMuH,EAAEvH,OAJpCshB,EAAK/Z,GAM3B,GAAIA,aAAa6U,YAAa,CACjC,MAAMxb,EAAM2gB,EAAeha,EAAE3G,IAAK4gB,GAAQ3gB,EAAM0gB,EAAeha,EAAE1G,IAAK2gB,GACtE,OAAK5gB,GAAQC,EACA,OAAT0G,EAAE8T,GACK,CAACnb,MAAOU,EAAIV,MAAQW,EAAIX,MAAQ,GAAK,GAAIF,KAAMyV,YAAYa,KAClD,OAAT/O,EAAE8T,GACF,CAACnb,MAAOU,EAAIV,MAAQW,EAAIX,MAAQ,GAAK,GAAIF,KAAMyV,YAAYa,KAClD,QAAT/O,EAAE8T,GACF,CAACnb,MAAOU,EAAIV,OAASW,EAAIX,MAAQ,GAAK,GAAIF,KAAMyV,YAAYa,KAE5D,CAACpW,MAAOU,EAAIV,OAASW,EAAIX,MAAQ,GAAK,GAAIF,KAAMyV,YAAYa,KAR9CgL,EAAK/Z,GAW3B,GAAIA,aAAa+U,UAAW,CAC/B,MAAM1b,EAAM2gB,EAAeha,EAAE3G,IAAK4gB,GAAQ3gB,EAAM0gB,EAAeha,EAAE1G,IAAK2gB,GACtE,OAAK5gB,GAAQC,EACA,OAAT0G,EAAE8T,GAEK,CAACnb,MAAOU,EAAIV,OAASW,EAAIX,MAAQ,GAAK,GAAIF,KAAMyV,YAAYa,KAG5D,CAACpW,MAAOU,EAAIV,OAASW,EAAIX,MAAQ,GAAK,GAAIF,KAAMyV,YAAYa,KAN9CgL,EAAK/Z,GAS3B,GAAIA,aAAagV,cAAe,CACnC,MAAM3b,EAAM+gB,EAAYpa,EAAE3G,IAAK4gB,GAAQ3gB,EAAM8gB,EAAYpa,EAAE1G,IAAK2gB,GAChE,OAAK5gB,GAAQC,EACA,QAAT0G,EAAE8T,GACKqG,EAAc,CAACxhB,MAAOU,EAAIV,MAAQW,EAAIX,MAAOF,KAAMuH,EAAEvH,OAC5C,OAATuH,EAAE8T,GACFqG,EAAc,CAACxhB,MAAOU,EAAIV,MAAQW,EAAIX,MAAOF,KAAMuH,EAAEvH,OAErD0hB,EAAc,CAACxhB,MAAOU,EAAIV,MAAQW,EAAIX,MAAOF,KAAMuH,EAAEvH,OANvCshB,EAAK/Z,GAS3B,GAAIA,aAAaiV,cAAe,CACnC,MAAM5b,EAAM2gB,EAAeha,EAAE3G,IAAK4gB,GAClC,IAAK5gB,EAAK,OAAO0gB,EAAK/Z,GACtB,GAAa,QAATA,EAAE8T,GAAc,CAEhB,GAAiB,GAAbza,EAAIV,MAAY,CAChB,MAAMW,EAAM0gB,EAAeha,EAAE1G,IAAK2gB,GAClC,IAAK3gB,EAAK,OAAOygB,EAAK/Z,GAEtB,GAAiB,GAAb1G,EAAIX,MAAY,MAAO,CAACA,MAAO,GAAIF,KAAMyV,YAAYa,KAE7D,MAAO,CAACpW,MAAO,GAAIF,KAAMyV,YAAYa,KAClC,CAEH,GAAiB,GAAb1V,EAAIV,MAAY,MAAO,CAACA,MAAO,GAAIF,KAAMyV,YAAYa,KACzD,MAAMzV,EAAM0gB,EAAeha,EAAE1G,IAAK2gB,GAClC,OAAK3gB,EAEY,GAAbA,EAAIX,MAAmB,CAACA,MAAO,GAAIF,KAAMyV,YAAYa,KAClD,CAACpW,MAAO,GAAIF,KAAMyV,YAAYa,KAHpBgL,EAAK/Z,IAMvB,GAAIA,aAAakV,eAAiBlV,EAAEvH,gBAAgByV,aAAelO,EAAEvH,gBAAgBkU,UAAW,CACnG,MAAM7O,EAAOkc,EAAeha,EAAElC,KAAMmc,GACpC,IAAKnc,EAAM,OAAOic,EAAK/Z,GACvB,IAAIrH,EAOJ,OAJIA,EADc,GAAdmF,EAAKnF,MACGqhB,EAAeha,EAAE9F,UAAW+f,GAE5BD,EAAeha,EAAE7F,WAAY8f,GAEpCthB,EACEwhB,EAAc,CAACxhB,MAAOA,EAAMA,MAAOF,KAAMuH,EAAEvH,OAD/BshB,EAAK/Z,IAM5B,QAAcuD,IAAV0W,EAAqB,CACrB,MAAMvJ,EAAIuJ,EAAMja,GAAIqa,GAAOL,EAAeK,EAAIJ,IAAQF,GACtD,GAAIrJ,EAAG,OAAOA,EAGlBqJ,EAAK/Z,IAGF,SAASoa,EAAYpa,EAAgBia,GACxC,MAAMvJ,EAAIsJ,EAAeha,EAAGia,GAC5B,GAAIvJ,GAAGjY,gBAAgByV,aAA+B,UAAhBwC,EAAEjY,KAAKA,KAAkB,MAAO,CAACE,MAAO2V,OAAOoC,EAAE/X,OAAQF,KAAMiY,EAAEjY,MAI3G,SAAS0hB,EAAczJ,GACnB,GAAIA,EAAEjY,gBAAgByV,YAAa,CAC/B,GAAIA,YAAYE,KAAK9B,OAAOoE,EAAEjY,MAE1B,MAAO,CAACE,MAAkB,GAAX+X,EAAE/X,MAAa,GAAK,GAAIF,KAAMyV,YAAYE,MACtD,GAAoB,UAAhBsC,EAAEjY,KAAKA,KACd,MAAO,CAACE,MAA0B,iBAAZ+X,EAAE/X,MAAqB+X,EAAE/X,MAAQsa,OAAOvC,EAAE/X,OAAQF,KAAMiY,EAAEjY,MAC7E,CACH,IAAIE,EAIIA,EAHe,iBAAZ+X,EAAE/X,MAEL2hB,MAAM5J,EAAE/X,OACA,GACD+X,EAAE/X,MAAQ+X,EAAEjY,KAAK8V,SAChBD,OAAOoC,EAAEjY,KAAK8V,UACfmC,EAAE/X,MAAQ+X,EAAEjY,KAAK0V,SAChBG,OAAOoC,EAAEjY,KAAK0V,UAEdG,OAAOlD,KAAKmP,MAAM7J,EAAE/X,QAGxB+X,EAAE/X,MAGd,MAAM6hB,EAAU,IAAMlM,OAAO,EAAIoC,EAAEjY,KAAKuT,OAAS,GACjD,GAAoB,aAAhB0E,EAAEjY,KAAKA,KACPE,GAAS6hB,MACN,CACH,MAAMrM,EAAWG,OAAOoC,EAAEjY,KAAK0V,UAC/BxV,GAAUA,EAAQwV,EAAYqM,GAAWrM,EAG7C,MAAO,CAACxV,QAAOF,KAAMiY,EAAEjY,OAK3B,MAAO,CAACE,MADMwhB,EAAc,CAACxhB,MAAO+X,EAAE/X,MAAOF,KAAMyV,YAAYY,MAAMnW,MAC/CF,KAAMiY,EAAEjY,MCtN/B,SAASgiB,EAAQpQ,EAAoBsN,GACxC,IAAIlf,EAyER,SAA0B6J,EAAsDqV,GAC5E,MAAM+C,EAAapY,EAAE5H,cACfigB,EAAwC,IAAtBD,EAAWte,OAAese,EAAW,QAAKnX,EAElE,GAAIoX,aAA2B,uBAAyB,CACpD,MAAMliB,EAAqC,WAA9BkiB,EAAgB9e,UAAyBqR,QAAUY,OAChE,IAAIjS,EAAY,IAAIpD,EAAKkiB,EAAiBA,EAAgB1f,IAC1D,GAAI0f,EAAgB1f,GAAI,CAEpB,MAAM8b,EAA6BY,EAAMnB,UAAUmE,EAAgB1f,GAAIxC,EAAakiB,GAChF5D,EACAlb,EAAYkb,EAEZY,EAAMhB,OAAO9a,GAGrB,IAAK8e,EAAgB7e,aAAc,OAAOD,EAE1C,MAAMmS,EAA4B,GAClC,IAAK,MAAM4M,KAAeD,EAAgB7e,aAAc,CACpD,MAAMsT,EAAWqL,EAAQG,EAAajD,GAEtC,IAAK,MAAMnb,KAAcoe,EAAYvf,KAAM,CACvC,MAAM5C,EAAOoiB,EAAkBzL,EAAU5S,EAAYmb,GAC/Cpf,EAAOuiB,EAAkBte,GAC/B,GAAI/D,EAAKyT,YAA6B,IAAfzT,EAAKuT,OAAevT,aAAgBkT,UACvD,MAAM,IAAI2E,yBAAyB9T,EAAY,yBAGnDwR,EAAOnO,KAAK,IAAIoN,gBAAgB2N,EAAariB,EAAME,KAK3D,OAFAoD,EAAUsR,QAAUa,EACpBnS,EAAU+O,KAAO+P,EACV9e,EAEJ,GAAI8e,aAA2B,gBAAkB,CACpD,IAAII,EAAQ,IAAIhN,MAAM4M,EAAiBA,EAAgB1f,IACvD,GAAI0f,EAAgB1f,GAAI,CAEpB,MAAM8b,EAAWY,EAAMnB,UAAUmE,EAAgB1f,GAAI8S,MAAO4M,GACxD5D,EACAgE,EAAQhE,EAERY,EAAMhB,OAAOoE,GAGrB,IAAKJ,EAAgB3hB,KAAM,OAAOkV,YAAYa,IAG9C,IAAIiM,EAAY,GAChB,MAAMhN,EAAS,GACf,IAAK,MAAMhO,KAAK2a,EAAgB3hB,KAAM,CAC9BgH,EAAErH,QAAOqiB,EAAYC,EAAoBjb,EAAErH,MAAOgf,GAAOhf,OAG7D,MAAMuiB,EAAe,IAAI7D,eAAerX,EAAGA,EAAE/E,GAAIyR,EAAawB,YAAYa,IAAK,SAAU,SAAU,YACnGmM,EAAahB,YAAc,IAAIpH,UAAU9S,EAAGkO,YAAYa,IAAKiM,GAE7DrD,EAAMb,cAAcoE,GACpBlN,EAAOnO,KAAK,CAACtH,KAAMyH,EAAE/E,GAAItC,MAAOqiB,MAIpC,OAFAD,EAAM/M,OAASA,EACf+M,EAAMnQ,KAAO+P,EACNzM,YAAYa,IAEhB,GAAI2L,EAAWnO,OAAM5Q,GAAkB,iBAANA,IAAiB,CAErD,MAAMlD,EAAOiX,EAAkBgL,GAC/B,GAAIjiB,EAAM,OAAOA,OAEd,GAA0B,IAAtBiiB,EAAWte,QAAgBse,EAAW,aAAc,sBAE3D,OAAO/C,EAAMJ,cAAcmD,EAAW,GAAGniB,MAG7C,MAAM,IAAI+X,yBAAyBhO,EAAG,qBArJ3B6Y,CAAiB9Q,EAAEjP,SAAUuc,GAGxC,OAFItN,EAAEjP,SAAST,cAAcyB,SAAQ3D,EAAOiU,EAAajU,EAAM4R,EAAEjP,SAAST,cAAc,KACpF0P,EAAE7N,aAAY/D,EAAOoiB,EAAkBpiB,EAAM4R,EAAE7N,WAAYmb,IACxDlf,EAIJ,SAASoiB,EAAkBpiB,EAAa+D,EAAmDmb,GAC9F,IAAIrV,EAAuD9F,EAE3D,KAAO8F,KAAOA,aAAa,yBACvB,GAAIA,aAAa,qBAAwBA,aAAa,4BAA8B,CAChF,IAAI8Y,EAA8B9Y,EAAEvI,QACpC,KAAOqhB,GACH3iB,EAAO,IAAIkU,SAASyO,EAAK3iB,EAAM2iB,EAAIzgB,eAAe0gB,SAAS,UAC3DD,EAAMA,EAAIpiB,KAEdsJ,EAAIA,EAAEtJ,UAEH,GAAIsJ,aAAa,mBAAsBA,aAAa,0BAA4B,CAEnF,GADA7J,EAAO,IAAIuU,OAAO1K,EAAG7J,GACjB6J,EAAElG,SACF3D,EAAK2D,OAAS6W,OAAOgI,EAAoB3Y,EAAElG,OAAQub,GAAOhf,OACtDF,EAAK2D,QAAU,GAAG,MAAM,IAAIkU,yBAAyBhO,EAAElG,OAAQ,wBAEvEkG,EAAIA,EAAEtJ,SAEH,CACH,MAAM6S,EAAiB,GACvB,IAAIC,EAEJ,IAAK,MAAMwP,KAAShZ,EAAEzI,MAAQ,GAAI,CAC9B,IAAIpB,EAAOgiB,EAAQa,EAAO3D,GAC1B,GAAIlf,aAAgBuU,OAEhBvU,EAAO,IAAIkU,SAASlU,EAAKmS,KAAMnS,EAAKA,WACjC,GAAIA,aAAgBkT,UACvB,MAAM,IAAI2E,yBAAyBgL,EAAO,kCAS9C,GAPAzP,EAAehM,KAAKpH,GAEhB6iB,EAAM9e,aAAe8e,EAAM9e,WAAWP,qBACtC6P,IAAAA,EAAmB,IACnBA,EAAejM,KAAKib,EAAkBQ,EAAM9e,cAG5CsP,GAAkBA,EAAe1P,SAAWyP,EAAezP,OAC3D,MAAM,IAAIkU,yBAAyBgL,EAAO,yDAIpB,IAA1BzP,EAAezP,QAAgByP,EAAe,aAAcM,OAAON,EAAexH,QAExD,IAA1BwH,EAAezP,SAEf0P,EAAiB,IAGrBrT,EAAO,IAAIkT,UAAUrJ,EAAG7J,EAAsBoT,EAAgBC,EAAgBxJ,EAAEhG,UAChFgG,EAAIA,EAAEtJ,KAGd,OAAOP,EAGJ,SAASqiB,EAAkBte,GAC9B,OAASA,aAAsB,yBAC3BA,EAAaA,EAAWxD,KAE5B,OAAOwD,EAAWvB,GCvEf,SAASsgB,EAAavb,EAAkB2X,GAC3C,GAAI3X,aAAa,qBAEb,OAAOub,EAAavb,EAAEzF,KAAMod,GAEzB,GAAI3X,aAAa,WACpB,OAyHD,SAAoBA,GACvB,IACIvH,EADAE,EAAQqH,EAAErH,MAGd,GAAoB,QAAhBqH,EAAEpH,WAAuC,QAAhBoH,EAAEpH,WAAuC,QAAhBoH,EAAEpH,UAAqB,CACzE,IAkBI4iB,EAaAC,EA/BAC,GAAW,EAAOC,GAAO,EAmB7B,GAlBAhjB,EAAQA,EAAMijB,cACVjjB,EAAMkjB,SAAS,OACfljB,EAAQA,EAAM0N,MAAM,GAAI,GACxBqV,GAAW,GAEX/iB,EAAMkjB,SAAS,OACfljB,EAAQA,EAAM0N,MAAM,GAAI,GACxBsV,GAAO,EAEHhjB,EAAMkjB,SAAS,OAAMljB,EAAQA,EAAM0N,MAAM,GAAI,MAEhDqV,GAAY/iB,EAAMkjB,SAAS,OAE5BljB,EAAQA,EAAM0N,MAAM,GAAI,GACxBqV,GAAW,GAIK,QAAhB1b,EAAEpH,UAEF4iB,EAAMlN,OAAO3V,OACV,CAEH6iB,EAAM,GACN,IAAK,IAAI5b,EAAI,EAAGA,EAAIjH,EAAMyD,OAAS,EAAGwD,IAClC4b,GAAOlN,OAAO3V,EAAMA,EAAMyD,OAAS,EAAIwD,IAAO,IAAM0O,OAAO1O,GAW/D6b,EALgB,QAAhBzb,EAAEpH,WAAwB8iB,GAAaC,EAEhB,QAAhB3b,EAAEpH,WAAwB8iB,GAAaC,EAEvCD,GAAYC,EACH,CAACzN,YAAYc,KACtB2M,EACS,CAACzN,YAAYe,IAAKf,YAAYc,KAE9B,CAACd,YAAYY,IAAKZ,YAAYc,KAN9B,CAACd,YAAYa,IAAKb,YAAYY,IAAKZ,YAAYe,IAAKf,YAAYc,KAFhE,CAACd,YAAYa,IAAKb,YAAYe,IAAKf,YAAYc,KAYnE,IAAK,MAAMvW,KAAQgjB,EACf,GAAID,GAAO/iB,EAAK0V,UAAYqN,GAAO/iB,EAAK8V,SACpC,OAAO,IAAIuE,UAAU9S,EAAGvH,EAAM+iB,GAGtC,MAAM,IAAIlL,yBAAyBtQ,EAAG,2CAEnC,GAAoB,UAAhBA,EAAEpH,UAQT,OANID,EAAMkjB,SAAS,MACfljB,EAAQA,EAAM0N,MAAM,GAAI,GACxB5N,EAAOyV,YAAYM,MAEnB/V,EAAOyV,YAAYO,KAEhB,IAAIqE,UAAU9S,EAAGvH,EAAMqjB,WAAWnjB,IAEtC,GAAoB,SAAhBqH,EAAEpH,UAET,OADAD,EAAQojB,EAAapjB,EAAOqH,GACrB,IAAI8S,UAAU9S,EAAGkO,YAAYQ,GAAIJ,OAAO3V,EAAMqjB,YAAY,KAGrE,MAAM,IAAI1L,yBAAyBtQ,EAAG,0BAjM3Bic,CAAWjc,GAEf,GAAIA,aAAa,aAAe,CACnC,MAAM/E,EAAK,IAAIiY,YAAYlT,EAAG2X,EAAMd,iBAAiB7W,EAAEzH,KAAMyH,IAE7D,OADI2X,EAAMxB,MAAMwB,EAAMxB,KAAK2C,aAAatI,IAAIvV,EAAGtC,OAAO,GAC/CsC,EAEJ,GAAI+E,aAAa,gBAAkB,CACtC,MAAMkc,EAAgB,GAChBC,EAAY,yDAClB,KAAOA,EAAU1K,UAAYzR,EAAErH,MAAMyD,QAAQ,CACzC,MAAM6L,EAAQkU,EAAUzK,KAAK1R,EAAErH,OAC/B,IAAIsP,GAAiC,IAAxBkU,EAAU1K,UAInB,MAAM,IAAInB,yBAAyBtQ,EAAG,0BAHtCkc,EAAIrc,KAAKyO,OAAOyN,EAAa9T,EAAM,GAAIjI,GAAGgc,YAAY,IAAM,IAOpE,OADAE,EAAIrc,KAAK,IACF,IAAIsT,eAAenT,EAAGkc,GAE1B,GAAIlc,aAAa,kBACpB,OA0CR,SAAiBA,EAAuB2X,GAEpC,MAAM3e,EAAOuiB,EAAavb,EAAEhH,KAAM2e,GAClC,GAAe,oBAAX3X,EAAEvH,KAA4B,OAAO,IAAIob,UAAU7T,EAAGhH,EAAM,KAAM,OACtE,GAAe,oBAAXgH,EAAEvH,KAA4B,OAAO,IAAIob,UAAU7T,EAAGhH,EAAM,KAAM,OACtE,GAAe,qBAAXgH,EAAEvH,KAA6B,OAAO,IAAIob,UAAU7T,EAAGhH,EAAM,KAAM,QACvE,GAAe,qBAAXgH,EAAEvH,KAA6B,OAAO,IAAIob,UAAU7T,EAAGhH,EAAM,KAAM,QACvE,GAAe,cAAXgH,EAAEvH,KAAsB,OAAO,IAAIwb,WAAWjU,EAAGhH,GACrD,GAAe,gBAAXgH,EAAEvH,KAAwB,OAAO,IAAI0b,aAAanU,EAAGhH,GACzD,GAAe,cAAXgH,EAAEvH,KAAsB,OAAO,IAAI2b,gBAAgBpU,EAAGhH,EAAM,KAChE,GAAe,eAAXgH,EAAEvH,KAAuB,OAAO,IAAI2b,gBAAgBpU,EAAGhH,EAAM,KACjE,GAAe,eAAXgH,EAAEvH,KAAuB,OAAO,IAAI4b,YAAYrU,EAAGhH,GACvD,GAAe,eAAXgH,EAAEvH,KAAuB,OAAO,IAAI6b,YAAYtU,EAAGhH,GAEvD,MAAM,IAAIsX,yBAAyBtQ,EAAG,4BAxD3Boc,CAAQpc,EAAG2X,GAEf,GAAI3X,aAAa,mBACpB,OAwDR,SAAkBA,EAAwB2X,GAEtC,MAAMte,EAAMkiB,EAAavb,EAAE3G,IAAKse,GAAQre,EAAMiiB,EAAavb,EAAE1G,IAAKqe,GAElE,GAAe,QAAX3X,EAAEvH,KAAgB,OAAO,IAAI+b,QAAQxU,EAAG3G,EAAKC,EAAK,KACtD,GAAe,QAAX0G,EAAEvH,KAAgB,OAAO,IAAI+b,QAAQxU,EAAG3G,EAAKC,EAAK,KACtD,GAAe,QAAX0G,EAAEvH,KAAgB,OAAO,IAAIgc,KAAKzU,EAAG3G,EAAKC,GAC9C,GAAe,QAAX0G,EAAEvH,KAAgB,OAAO,IAAIic,QAAQ1U,EAAG3G,EAAKC,EAAK,KACtD,GAAe,QAAX0G,EAAEvH,KAAgB,OAAO,IAAIic,QAAQ1U,EAAG3G,EAAKC,EAAK,KACtD,GAAe,qBAAX0G,EAAEvH,KAA6B,OAAO,IAAIkc,OAAO3U,EAAG3G,EAAKC,EAAK,QAClE,GAAe,sBAAX0G,EAAEvH,KAA8B,OAAO,IAAIkc,OAAO3U,EAAG3G,EAAKC,EAAK,SAEnE,GAAe,iBAAX0G,EAAEvH,KAAyB,OAAO,IAAIoc,YAAY7U,EAAG3G,EAAKC,EAAK,MACnE,GAAe,iBAAX0G,EAAEvH,KAAyB,OAAO,IAAIoc,YAAY7U,EAAG3G,EAAKC,EAAK,MACnE,GAAe,kBAAX0G,EAAEvH,KAA0B,OAAO,IAAIoc,YAAY7U,EAAG3G,EAAKC,EAAK,OACpE,GAAe,kBAAX0G,EAAEvH,KAA0B,OAAO,IAAIoc,YAAY7U,EAAG3G,EAAKC,EAAK,OACpE,GAAe,iBAAX0G,EAAEvH,KAAyB,OAAO,IAAIsc,UAAU/U,EAAG3G,EAAKC,EAAK,MACjE,GAAe,kBAAX0G,EAAEvH,KAA0B,OAAO,IAAIsc,UAAU/U,EAAG3G,EAAKC,EAAK,MAElE,GAAe,eAAX0G,EAAEvH,KAAuB,OAAO,IAAIuc,cAAchV,EAAG3G,EAAKC,EAAK,OACnE,GAAe,eAAX0G,EAAEvH,KAAuB,OAAO,IAAIuc,cAAchV,EAAG3G,EAAKC,EAAK,OACnE,GAAe,cAAX0G,EAAEvH,KAAsB,OAAO,IAAIuc,cAAchV,EAAG3G,EAAKC,EAAK,MAClE,GAAe,eAAX0G,EAAEvH,KAAuB,OAAO,IAAIwc,cAAcjV,EAAG3G,EAAKC,EAAK,OACnE,GAAe,cAAX0G,EAAEvH,KAAsB,OAAO,IAAIwc,cAAcjV,EAAG3G,EAAKC,EAAK,MAElE,GAAe,UAAX0G,EAAEvH,KAAkB,OAAO,IAAImd,OAAO5V,EAAG3G,EAAKC,GAClD,GAAe,mBAAX0G,EAAEvH,KAEF,OAAO,IAAI0b,aAAanU,EAAG,IAAI0U,QAAQ1U,EAAGub,EAAavb,EAAE3G,IAAKse,GAAQ4D,EAAavb,EAAE1G,IAAKqe,GAAQ,MAGtG,MAAM,IAAIrH,yBAAyBtQ,EAAG,6BAvF3Bqc,CAASrc,EAAG2X,GAEhB,GAAI3X,aAAa,mBACpB,OAAIA,EAAEhH,gBAAgB,aACX,IAAIgb,QAAQhU,EAAGub,EAAavb,EAAEhH,KAAM2e,GAAOlf,MAE3C,IAAIub,QAAQhU,EAAGya,EAAQza,EAAEhH,KAAM2e,IAGvC,GAAI3X,aAAa,iBACpB,OAAO,IAAIuU,MAAMvU,EAAGya,EAAQza,EAAEtG,WAAYie,GAAQ4D,EAAavb,EAAEhH,KAAM2e,IAEpE,GAAI3X,aAAa,yBACpB,OAAO,IAAIoT,cAAcpT,EAAGub,EAAavb,EAAEpG,GAAI+d,IAAS3X,EAAEnG,MAAQ,IAAI4T,KAAIzN,GAAKub,EAAavb,EAAG2X,MAE5F,GAAI3X,aAAa,yBAA2B,CAC/C,IAAIhH,EAAOuiB,EAAavb,EAAE3G,IAAKse,GAI/B,OAHK3X,EAAEjG,UACHf,EAAO,IAAIib,WAAWjU,EAAGhH,IAEtB,IAAIya,cAAczT,EAAGhH,EAAMgH,EAAE1G,KAEjC,GAAI0G,aAAa,wBACpB,OAAO,IAAIkV,aAAalV,EAAGub,EAAavb,EAAE/F,UAAW0d,GAAQ4D,EAAavb,EAAE9F,UAAWyd,GAAQ4D,EAAavb,EAAE7F,WAAYwd,IAEvH,GAAI3X,aAAa,uBACpB,OAAO,IAAIsT,YAAYtT,EAAGub,EAAavb,EAAE3G,IAAKse,GAAQ4D,EAAavb,EAAE1G,IAAKqe,GAAQ3X,EAAE3F,YAIxF,MAAM,IAAIiW,yBAAyBtQ,EAAG,sBAInC,SAASib,EAAoBxb,EAA0BkY,GAE1D,OFjEG,SAAsB3X,EAAgBia,GACzC,MAAMvJ,EAAI0J,EAAYpa,EAAGia,GACzB,GAAIvJ,EAAG,OAAOA,EACd,MAAM,IAAI,kCAAoB1Q,EAAE4K,KAAM,+BE8D/B0R,CADMf,EAAa9b,EAAElF,KAAMod,IAwItC,SAASoE,EAAavc,EAAWoL,GAC7B,GAAIpL,EAAE+c,WAAW,MAAO,CACpB,GAAU,QAAN/c,EAAa,MAAO,KACxB,GAAU,QAANA,EAAa,MAAO,KACxB,GAAU,QAANA,EAAa,MAAO,KACxB,GAAU,QAANA,EAAa,MAAO,KACxB,GAAU,QAANA,EAAa,MAAO,KACxB,GAAU,QAANA,EAAa,MAAO,KACxB,GAAU,QAANA,EAAa,MAAO,IACxB,GAAU,SAANA,EAAc,MAAO,KACzB,GAAU,QAANA,EAAa,MAAO,IACxB,GAAU,QAANA,EAAa,MAAO,IACxB,GAAU,QAANA,EAAa,MAAO,IAExB,IAAI7G,EASJ,GANIA,EAFA6G,EAAE+c,WAAW,OAELC,SAAShd,EAAE6G,MAAM,GAAI,IAGrBmW,SAAShd,EAAE6G,MAAM,GAAI,IAG5BiU,MAAM3hB,IAAUA,GAAS,GAAKA,GAAS,IACxC,OAAO8jB,OAAOC,aAAa/jB,GAE/B,MAAM,IAAI2X,yBAAyB1F,EAAM,4BAG7C,MAAM+R,EAAYnd,EAAEwc,YAAY,GAChC,GAAiB,IAAbxc,EAAEpD,aAA8BmH,IAAdoZ,GAA2BA,EAAY,IACzD,MAAM,IAAIrM,yBAAyB1F,EAAM,qBAE7C,OAAOpL,EC9NX,SAASod,EAAchC,EAA6BjD,EAAckF,GAC9D,GAA4C,YAAxCjC,EAAYxf,SAASN,YAAY,GAEjC,OAqFR,SAAmB8P,EAAsB+M,GACrC,GAAyB,IAArB/M,EAAKvP,KAAKe,OAAc,MAAM,IAAIkU,yBAAyB1F,EAAM,+CACrE,MAAMwE,EAAWqL,EAAQ7P,EAAM+M,GAE/B,IAAK,MAAMmF,KAAQlS,EAAKvP,KAAM,CAC1B,GAAIyhB,aAAgB,iBAAmB,MAAM,IAAIxM,yBAAyB1F,EAAM,+BAChF,MAAMnS,EAAOoiB,EAAkBzL,EAAU0N,EAAMnF,GACzCpf,EAAOuiB,EAAkBgC,GAC/BnF,EAAMH,WAAWjf,EAAME,EAAMqkB,IA9F7BC,CAAUnC,EAAajD,GAChB,GAGX,MAAMe,EAAW+B,EAAQG,EAAajD,GAChCqF,EAAc,GACpB,IAAK,IAAIC,KAASrC,EAAYvf,KAAM,CAChC,MAAM9C,EAAOuiB,EAAkBmC,GAE/B,IAAIC,EACAD,aAAiB,mBACjBC,EAAeC,EAAcF,EAAOA,EAAM1hB,YAAaoc,GACvDsF,EAAQA,EAAMjkB,MAGlB,MAAMP,EAAOoiB,EAAkBnC,EAAUuE,EAAOtF,GAC1CyF,EAAcF,GAAczkB,gBAAgBkU,SAAWuQ,EAAazkB,KAAKqU,UAAYoQ,EAAazkB,KAAOykB,GAAczkB,KAM7H,GALI2kB,aAAuBpQ,QAAUvU,aAAgBuU,QAAUvU,EAAKyT,aAEhEzT,EAAK2D,OAASghB,EAAYhhB,QAG1B3D,EAAKyT,WACL,MAAM,IAAI,kCAAoBzT,EAAKmS,MAAQqS,EAAO,gBAAiB,mBAChE,GAAIxkB,aAAgBkT,UAAW,CAElC,MAAMuL,EAAkD,WAAxC0D,EAAYxf,SAASN,YAAY,GAAkB,WAAa,WAC1Eqc,EAAuD,WAA5CyD,EAAYxf,SAASL,gBAAgB,GACtD4c,EAAMb,cAAc,IAAIE,iBAAiBiG,EAAO1kB,EAAME,EAAMye,EAASC,QAClE,CACH,GAAIyD,EAAYxf,SAASL,gBAAgBqB,OAAS,EAC9C,MAAM,IAAI,kCAAoB6gB,EAAO,gDAIzC,IAAIxE,EACAvB,EACAwB,EACwC,WAAxCkC,EAAYxf,SAASN,YAAY,IACjC2d,EAAU,SACVvB,EAAU2F,EAAa,OAAS,WAChCnE,EAAWmE,QAAgDtZ,IAAjB2Z,EAAlB7F,eAAgED,iBACzC,WAAxCwD,EAAYxf,SAASN,YAAY,IACxC2d,EAAU,SACVvB,EAAU,WACVwB,EAAWtB,kBAEXqB,EAAUoE,EAAa,QAAU,SACjC3F,EAAU2F,EAAa,OAAS,WAChCnE,EAAWmE,QAAgDtZ,IAAjB2Z,EAAlB7F,eAAgED,iBAE5F,MAAMiG,EAAO,IAAI3E,EAASuE,EAAO1kB,EAAME,EAAMggB,EAASvB,GAItD,GAHAS,EAAMb,cAAcuG,GAGhBH,EAAc,CACd,GAAIG,aAAgBjG,gBAChB,MAAM,IAAI,kCAAoB6F,EAAO,cAAe,gCAUxD,GARIC,aAAwB3H,eACxB2H,EAAazkB,KAAOA,GAEpBykB,aAAwBpK,WAAara,aAAgByV,aAAezV,IAASykB,EAAazkB,OAE1FykB,EAAeA,EAAanK,WAAWta,IAGvCokB,GAA+B,WAAjBQ,EAAK5E,QAAsB,CACzC,MAAMxd,EAAkB,IAAIiY,YAAY+J,EAAOI,GAC/CL,EAAYnd,KAAK,IAAIyT,YAAY2J,EAAOhiB,EAAIiiB,OAAc3Z,GAAW,QAClE,CAEH8Z,EAAKnD,YAAcgD,EACnB5J,YAAYC,qBAAqB0J,EAAOxkB,EAAM4kB,EAAKnD,aAGnD,IAAK,MAAMoD,KAAcJ,EAAa1J,cAClC6J,EAAKvE,aAAatI,IAAI8M,EAAW3kB,OAAO,MAM5D,OAAOqkB,EAgBX,SAASG,EAAcvS,EAAoBrP,EAA6Boc,GACpE,OAAIlc,MAAMC,QAAQH,GACP,IAAIga,aAAa3K,EAAMrP,EAAYkS,KAAI9R,GAAKwhB,EAAcvS,EAAMjP,EAAGgc,MAEnE4D,EAAahgB,EAA8Boc,GAK1D,SAAS4F,EAAW3jB,EAA2B+d,GAC3C,GAAuC,WAAnC/d,EAAGwB,SAASL,gBAAgB,GAC5B,MAAM,IAAI,kCAAoBnB,EAAI,iDAItC,MAAMnB,EAAOgiB,EAAQ7gB,EAAI+d,GACzB,KAAMlf,aAAgBkT,WAAY,MAAM,IAAI2E,yBAAyB1W,EAAI,yBAEzE,MAAMrB,EAAOuiB,EAAkBlhB,EAAG4C,YAElC,IAAI0a,EACJ,GAAmC,WAA/Btd,EAAGwB,SAASN,YAAY,GAAiBoc,EAAU,eAClD,IAAmC,YAA/Btd,EAAGwB,SAASN,YAAY,GAAkB,MAAM,IAAIwV,yBAAyB1W,EAAI,mBACrFsd,EAAU,WAEf,MAAMsG,EAAM,IAAIvG,gBAAgBrd,EAAIrB,EAAME,EAAMye,EAASS,GAKzD,GAJA6F,EAAIvE,MAAMC,OAA4C,WAAnCtf,EAAGwB,SAASL,gBAAgB,GAC/C4c,EAAMb,cAAc0G,IAGf/kB,EAAKqT,eAAgB,MAAM,IAAIwE,yBAAyB1W,EAAI,4BACjE,IAAK,IAAIgG,EAAI,EAAGA,EAAInH,EAAKoT,eAAezP,OAAQwD,IAC5C4d,EAAIxkB,KAAK2e,MAAMb,cAAc,IAAIiC,UAAUnf,EAAInB,EAAKqT,eAAelM,GAAInH,EAAKoT,eAAejM,GAAIA,IAOnG,GAHA6d,EAAW7jB,EAAGZ,KAAMwkB,KAGd/kB,EAAKmT,sBAAsBO,OAAWuR,EAAaF,EAAIxkB,OACzD,MAAM,IAAIsX,yBAAyB1W,EAAGZ,KAAM,oCAKpD,SAAS0kB,EAAaC,GAClB,GAAIA,aAAqBpF,QACrB,OAAO,EACJ,GAAIoF,aAAqBlG,oBAC5B,IAAK,IAAI7X,EAAI,EAAGA,EAAI+d,EAAUjG,WAAWtb,OAAQwD,IAC7C,GAAI8d,EAAaC,EAAUjG,WAAW9X,IAAK,CACvC,GAAIA,EAAI,EAAI+d,EAAUjG,WAAWtb,OAAQ,CAGrC,GAAIuhB,EAAUjG,WAAW9X,EAAI,KAAO+d,EAAUhG,MAAMiG,mBAAmB5kB,KAEnE,SAIJ,MAAM,IAAIsX,yBAAyBqN,EAAUjG,WAAW9X,EAAI,GAAGgL,KAAM,0BAEzE,OAAO,OAGZ,IAAI+S,aAAqB7F,IAC5B,OAAO4F,EAAaC,EAAUvgB,SAAWsgB,EAAaC,EAAUtgB,UAC7D,GAAIsgB,aAAqB1F,QAC5B,OAAOyF,EAAaC,EAAU3kB,MAC3B,GAAI2kB,aAAqBxF,QAE5B,OAAOwF,EAAUtQ,SAASd,OAAM5Q,GAAK+hB,EAAa/hB,EAAE3C,cACJuK,IAA5Coa,EAAUtQ,SAASO,MAAKjS,GAAKA,EAAEkiB,UAEvC,OAAO,EAIX,SAASC,EAAYlT,EAAoBiG,GACrC,GAAIjG,aAAgB,oBAChB,OAAO6S,EAAW7S,EAAMiG,GAErB,GAAIjG,aAAgB,sBACvB,OAAO,IAAIgN,qBAAqBhN,EAAM2Q,EAAa3Q,EAAKzN,WAAY0T,EAAO8G,OAAQ9G,GAEhF,GAAIjG,aAAgB,cAAgB,CACvC,MAAMpL,EAAI,IAAIsY,IAAIlN,EAAM2Q,EAAa3Q,EAAKzN,WAAY0T,EAAO8G,OAAQ9G,GAGrE,OAFArR,EAAEpC,OAAS0gB,EAAYlT,EAAKxN,OAAQoC,GAChCoL,EAAKvN,WAAUmC,EAAEnC,SAAWygB,EAAYlT,EAAKvN,SAAUmC,IACpDA,EAEJ,GAAIoL,aAAgB,UAAY,CACnC,MAAMpL,EAAI,IAAIuY,SAASnN,EAAMiG,GAU7B,OATIjG,EAAK/M,gBAAgB,uBAA0B+M,EAAK/M,gBAAgB,OACpE2B,EAAE3B,KAAOigB,EAAYlT,EAAK/M,KAAM2B,GAEhCA,EAAE3B,KAAO+e,EAAchS,EAAK/M,KAAM2B,EAAEmY,OAAO,GACtClK,KAAIzN,GAAK,IAAI4X,qBAAqB5X,EAAE4K,KAAM5K,EAAGR,KAEtDA,EAAE1B,KAAOggB,EAAYlT,EAAK9M,KAAM0B,GAC5BoL,EAAK7M,SAAQyB,EAAEzB,OAASwd,EAAa3Q,EAAK7M,OAAQyB,EAAEmY,QACxDnY,EAAExG,KAAO8kB,EAAYlT,EAAK5R,KAAMwG,GACzBA,EAEJ,GAAIoL,aAAgB,YAAc,CACrC,MAAMpL,EAAI,IAAIwY,WAAWpN,EAAM2Q,EAAa3Q,EAAK9M,KAAM+S,EAAO8G,OAAQ9G,GAEtE,OADArR,EAAExG,KAAO8kB,EAAYlT,EAAK5R,KAAMwG,GACzBA,EAEJ,GAAIoL,aAAgB,cAAgB,CACvC,MAAMpL,EAAI,IAAIyY,QAAQrN,EAAM2Q,EAAa3Q,EAAK9M,KAAM+S,EAAO8G,OAAQ9G,GAEnE,OADArR,EAAExG,KAAO8kB,EAAYlT,EAAK5R,KAAMwG,GACzBA,EAEJ,GAAIoL,aAAgB,gBAAkB,CACzC,IAAIxI,EAAkCyO,EACtC,KAAOzO,EAAEuV,MAAMiG,mBAAmB3gB,QAAU2N,EAAKzM,QAAQ,CACrD,GAAIiE,EAAEyO,kBAAkBoG,gBACpB,MAAM,IAAI3G,yBAAyB1F,EAAM,iEAE7CxI,EAAIA,EAAEyO,OAEV,OAAO,IAAIqH,MAAMtN,EAAMxI,EAAEuV,MAAMiG,kBAAmB/M,GAE/C,GAAIjG,aAAgB,oBAAsB,CAC7C,IAAIxI,EAAgByO,EACpB,OAASzO,aAAa2V,UAAY3V,aAAa4V,YAAc5V,aAAa6V,UAAU,CAChF,GAAI7V,EAAEyO,kBAAkBoG,gBACpB,MAAM,IAAI3G,yBAAyB1F,EAAM,oCAE7CxI,EAAIA,EAAEyO,OAEV,OAAO,IAAIuH,UAAUxN,EAAMxI,EAAGyO,GAE3B,GAAIjG,aAAgB,iBAAmB,CAC1C,IAAIxI,EAAgByO,EACpB,OAASzO,aAAa2V,UAAY3V,aAAa4V,YAAc5V,aAAa6V,SAAW7V,aAAa+V,UAAU,CACxG,GAAI/V,EAAEyO,kBAAkBoG,gBACpB,MAAM,IAAI3G,yBAAyB1F,EAAM,iCAE7CxI,EAAIA,EAAEyO,OAEV,OAAO,IAAIyH,OAAO1N,EAAMxI,EAAGyO,GAExB,GAAIjG,aAAgB,kBAAoB,CAC3C,MAAMpL,EAAI,IAAI2Y,QAAQvN,EAAM2Q,EAAa3Q,EAAKzN,WAAY0T,EAAO8G,OAAQ9G,GAEzE,OAgER,SAAsBrR,EAAYoL,EAA0B+M,GACxD,KAAM/M,EAAK5R,gBAAgB,qBACvB,MAAM,IAAIsX,yBAAyB1F,EAAM,+DAE7C,MAAMyC,EAAWzC,EAAK5R,KAAKA,KAAKqN,QAChC,KAAOgH,EAASjR,OAAS,GAAG,CACxB,MAAM2hB,EAAQ1Q,EAAShJ,QACvB,GAAI0Z,aAAiB,iBAAoBA,aAAiB,mBAAqB,CAC3E,IAAIC,EACAxe,EAAE6N,SAASjR,OAAS,GAAkE,IAA7DoD,EAAE6N,SAAS7N,EAAE6N,SAASjR,OAAS,GAAGpD,KAAK0e,WAAWtb,OAE3E4hB,EAAQxe,EAAE6N,SAAS7N,EAAE6N,SAASjR,OAAS,IAGvC4hB,EAAQ,CAACC,MAAO,GAAIJ,SAAS,EAAO7kB,KAAM,IAAIye,mBAAmB7M,EAAMpL,IACvEA,EAAE6N,SAASxN,KAAKme,IAGhBD,aAAiB,gBACjBC,EAAMC,MAAMpe,KAAKob,EAAoB8C,EAAMplB,MAAOgf,IAElDqG,EAAMH,SAAU,EAIpBxQ,EAAS6Q,QAAQH,EAAM/kB,WACpB,GAAI+kB,EAAO,CAEd,GAA0B,IAAtBve,EAAE6N,SAASjR,OACX,MAAM,IAAIkU,yBAAyByN,EAAO,wDAG9CI,EAAcJ,EADGve,EAAE6N,SAAS7N,EAAE6N,SAASjR,OAAS,GAAGpD,QAhGvDolB,CAAa5e,EAAGoL,EAAMiG,EAAO8G,OACtBnY,EAEJ,GAAIoL,aAAgB,kBAAoB,CAC3C,IAAIxI,EAAkCyO,EACtC,OAASzO,aAAa6U,kBAAkB7U,EAAIA,EAAEyO,OAE9C,MAAMlY,EAAQiS,EAAKjS,MAAQ4iB,EAAa3Q,EAAKjS,MAAOkY,EAAO8G,YAASpU,EACpE,OAAO,IAAIgV,QAAQ3N,EAAMxI,EAAGzJ,EAAOkY,GAEhC,GAAIjG,aAAgB,OACvB,OAAO,IAAIiN,KAAKjN,EAAMiG,GAEnB,GAAIjG,aAAgB,gBAEvB,MAAM,IAAI0F,yBAAyB1F,EAAM,6BACtC,GAAIA,aAAgB,mBACvB,MAAM,IAAI0F,yBAAyB1F,EAAM,gCAG7C,MAAM,IAAI0F,yBAAyB1F,EAAM,0BAI7C,SAAS6S,EAAW7S,EAA4BiG,GAC5C,MAAMpR,EAAIoR,aAAkBoG,gBAAkBpG,EAAO7X,KAAO,IAAIye,mBAAmB7M,EAAMiG,GAGnFwN,EAAWzT,EAAK5R,KAAKslB,QAAO3iB,GAAKA,aAAa,kBAA4B4H,IAAZ5H,EAAEsB,QACtE,GAAIohB,EAASjiB,OAAS,EAClB,MAAM,IAAIkU,yBAAyB+N,EAAS,GAAI,qDAAsDA,EAAS,IACpF,IAApBA,EAASjiB,SAChBqD,EAAEkY,MAAMiG,kBAAoB,IAAIpF,mBAAmB6F,EAAS,GAAIA,EAAS,GAAGphB,QAGhF,IAAK,MAAM8gB,KAASnT,EAAK5R,KACrBmlB,EAAcJ,EAAOte,GAEzB,OAAOA,EAIX,SAAS0e,EAAcJ,EAAsCte,GACzD,GAAIse,aAAiB,cACjB,IAAK,MAAMQ,KAAc3B,EAAcmB,EAAOte,EAAEkY,OAAO,GAEnDlY,EAAEiY,WAAW7X,KAAK,IAAI+X,qBAAqB2G,EAAW3T,KAAM2T,EAAY9e,QAEzE,CACH,MAAMke,EAAYG,EAAYC,EAAOte,GACrCA,EAAEiY,WAAW7X,KAAK8d,QAEEpa,IAAhBwa,EAAM9gB,OAAuBwC,EAAEkY,MAAMiG,mBAAmBhT,OAASmT,IAEjEte,EAAEkY,MAAMiG,kBAAkB5kB,KAAO2kB,ICnUtC,SAASa,EAAKxT,GAEjB,ODMG,SAAqBgO,GACxB,MAAMyF,EAAY,IAAIvI,WAAM3S,EAAWsW,GACvC,IAAK,MAAMiD,KAAQ9D,EACX8D,aAAgB,qBAChBS,EAAWT,EAAM2B,GAEjB7B,EAAcE,EAAM2B,GAAW,GAGvC,OAAOA,ECfAC,CADiB3Z,EAAMiG,ICFlC,MAAM2T,EAAY,iNAUhBC,YAEF,IAAIC,EAAY,EACZC,EAAqC,IAAIC,QAE7C,SAASC,EAAMzU,GACX,IAAItP,EAAK6jB,EAAaxU,IAAIC,GAC1B,YAAWhH,IAAPtI,GACAA,EAAK4jB,IACLC,EAAatO,IAAIjG,EAAKtP,GACf,CAACA,GAAI,IAET,CAACA,GAAI,GAGhB,SAASgkB,GAAcpO,EAAqBlP,EAAa4I,GACrD,MAAM2U,EAAKC,SAASC,cAAc,MAElC,GADAvO,EAAOwO,YAAYH,GACA,iBAAR3U,EAEP,YADA2U,EAAGI,UAAY,qBAAqB3d,aAAe4I,KAKvD,MAAOtP,EAAIskB,GAASP,EAAMzU,GAI1B,GAHA2U,EAAGM,UAAUC,IAAI,QAAQxkB,KACrBskB,IAAOL,EAAGjkB,GAAK,QAAQA,KAC3BikB,EAAGI,UAAY,qBAAqB3d,mBAAqB4I,aAAe2D,YAAc3D,EAAIwB,SAAWlN,OAAOwR,eAAe9F,GAAKrS,YAAYK,iBACxIgS,aAAe2D,cAAiB3D,EAAYwC,aAG5CmS,EAAGI,WADHC,EACgB,sBAAsBtkB,YAEtB,8BAA8BA,MAAOA,QAIrDskB,GAAO,CAEPL,EAAGM,UAAUC,IAAI,cACjBP,EAAGQ,iBAAiB,SAAS1f,IACzBA,EAAE2f,kBACF,MAAMC,EAAOV,EAAGW,wBACZ7f,EAAE8f,QAAUF,EAAKG,KAAO,IAAM/f,EAAEggB,QAAUJ,EAAKK,IAAM,IACrDf,EAAGM,UAAUU,OAAO,aAI5B,MAAMC,EAAKhB,SAASC,cAAc,MAGlC,GAFAF,EAAGG,YAAYc,GAEX5V,aAAeyF,IACf,IAAK,MAAOrO,EAAKhJ,KAAU4R,EAAI6V,UAC3BnB,GAAckB,EAAIxe,EAAKhJ,QAG3B,IAAK,MAAOgJ,EAAKhJ,KAAUkG,OAAOuhB,QAAQ7V,GAC1B,SAAR5I,GACJsd,GAAckB,EAAIxe,EAAKhJ,GAIJ,IAAvBwnB,EAAG9S,SAASjR,SAEZ+jB,EAAGvQ,SACHsP,EAAGM,UAAU5P,OAAO,gBAKhC,SAAS7R,GAAOiH,GACZ,MAAMwO,EAAc6M,OAAOlB,SAASmB,eAAe,eAC7ClK,EAAOiK,OAAOlB,SAASmB,eAAe,QACtCjK,EAAWgK,OAAOlB,SAASmB,eAAe,YAC1CC,EAASF,OAAOlB,SAASmB,eAAe,UAC9C,KAAK9M,GAAgB4C,GAASmK,GAAWlK,GAAU,MAAM,IAAInX,MAAM,qBAKnE,IAAIshB,EAJJhN,EAAY8L,UAAYlJ,EAAKqK,UAAYpK,EAASoK,UAAY,GAC9D5B,EAAY,EACZC,EAAe,IAAIC,QAGnB,IACIyB,EAAKhC,EAAKxZ,GACZ,MAAOhF,GAEL,MADAugB,EAAOE,UAAYzgB,EAAEyL,WACfzL,EAGVugB,EAAOjB,UAAY,GACnBN,EAAMwB,GACN,IAAK,MAAO7e,EAAKhJ,KAAW6nB,EAAWhN,YACnCyL,GAAczL,EAAa7R,EAAKhJ,GAEpC,IAAK,MAAOgJ,EAAKhJ,KAAW6nB,EAAWpK,KACnC6I,GAAc7I,EAAMzU,EAAKhJ,GAE7B,IAAK,MAAOgJ,EAAKhJ,KAAW6nB,EAAWnK,SACnC4I,GAAc5I,EAAU1U,EAAKhJ,GAKrC,GAAsB,oBAAX0nB,QAA0BA,OAAOlB,SAAU,CAClDkB,OAAOlB,SAASuB,MAAM,wIAG6D/B,g5CAsDnF,MAAMgC,EAAYN,OAAOlB,SAASmB,eAAe,aACjDK,EAAUjB,iBAAiB,SAAS,IAAM3hB,GAAO4iB,EAAUhoB,SAC3DoF,GAAO4iB,EAAUhoB,YAEjBioB,QAAQC,IAAIrC,EAAKG,K","sources":["webpack://@ictrobot/c2wasm/./src/parsing/parsetree.ts","webpack://@ictrobot/c2wasm/./src/parsing/gen/c_grammar.js","webpack://@ictrobot/c2wasm/webpack/bootstrap","webpack://@ictrobot/c2wasm/webpack/runtime/define property getters","webpack://@ictrobot/c2wasm/webpack/runtime/hasOwnProperty shorthand","webpack://@ictrobot/c2wasm/webpack/runtime/make namespace object","webpack://@ictrobot/c2wasm/./src/c_error.ts","webpack://@ictrobot/c2wasm/./src/ir/types.ts","webpack://@ictrobot/c2wasm/./src/parsing/validation.ts","webpack://@ictrobot/c2wasm/./src/parsing/lexer.ts","webpack://@ictrobot/c2wasm/./src/parsing/parser.ts","webpack://@ictrobot/c2wasm/./src/ir/type_checking.ts","webpack://@ictrobot/c2wasm/./src/ir/expressions.ts","webpack://@ictrobot/c2wasm/./src/ir/scope.ts","webpack://@ictrobot/c2wasm/./src/ir/statements.ts","webpack://@ictrobot/c2wasm/./src/ir/declarations.ts","webpack://@ictrobot/c2wasm/./src/ir/internal_scope.ts","webpack://@ictrobot/c2wasm/./src/ir/transform/constant_expressions.ts","webpack://@ictrobot/c2wasm/./src/ir/transform/type_transform.ts","webpack://@ictrobot/c2wasm/./src/ir/transform/expr_transform.ts","webpack://@ictrobot/c2wasm/./src/ir/transform/transform.ts","webpack://@ictrobot/c2wasm/./src/ir/index.ts","webpack://@ictrobot/c2wasm/./demos/ir.ts"],"sourcesContent":["import type {Location} from \"./lexer\";\n\n// Classes used to build up the C parse tree - mostly just simple objects storing the relevant fields.\n\nexport abstract class ParseNode {\n    abstract readonly type: string;\n\n    constructor(readonly loc: Location) {\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        // return any children of the node\n    }\n}\n\n// Expressions\n\nexport abstract class Expression extends ParseNode {\n    // typescript does structural equality when type checking, so for this class to be different from\n    // the base ParseNode add a simple private field.\n    private readonly _expression: boolean = true;\n}\n\nexport class Identifier extends Expression {\n    readonly type = \"identifier\";\n\n    constructor(loc: Location, readonly name: string) {\n        super(loc);\n    }\n}\n\nexport class Constant extends Expression {\n    readonly type = \"constant\";\n\n    constructor(loc: Location, readonly value: string, readonly valueType: \"float\" | \"char\" | \"int\" | \"oct\" | \"hex\") {\n        super(loc);\n    }\n}\n\nexport class StringLiteral extends Expression {\n    readonly type = \"stringLiteral\";\n\n    constructor(loc: Location, readonly value: string) {\n        super(loc);\n    }\n}\n\nexport const UnaryOperations = [\n    \"postfixIncrement\", \"postfixDecrement\", \"prefixIncrement\", \"prefixDecrement\",\n    \"addressOf\", \"dereference\", \"unaryPlus\", \"unaryMinus\", \"bitwiseNot\", \"logicalNot\"] as const;\nexport type UnaryOp = typeof UnaryOperations[number];\nexport class UnaryExpression extends Expression {\n    private readonly _unaryExpr = true;\n\n    constructor(loc: Location, readonly type: UnaryOp, readonly body: Expression) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.body;\n    }\n}\n\nexport const BinaryOperations = [\"arraySubscript\", \"comma\",\n    \"mul\", \"div\", \"mod\", \"add\", \"sub\", \"bitwiseShiftLeft\", \"bitwiseShiftRight\",\n    \"relationalLT\", \"relationalGT\", \"relationalLEq\", \"relationalGEq\", \"relationalEq\", \"relationalNEq\",\n    \"bitwiseAnd\", \"bitwiseXor\", \"bitwiseOr\", \"logicalAnd\", \"logicalOr\"] as const;\nexport type BinaryOp = typeof BinaryOperations[number];\nexport class BinaryExpression extends Expression {\n    private readonly _binaryExpr = true;\n\n    constructor(loc: Location, readonly type: BinaryOp, readonly lhs: Expression, readonly rhs: Expression) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.lhs;\n        yield this.rhs;\n    }\n}\n\nexport class SizeofExpression extends Expression {\n    readonly type = \"sizeof\";\n\n    constructor(loc: Location, readonly body: Expression | TypeName) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.body;\n    }\n}\n\nexport class CastExpression extends Expression {\n    readonly type = \"cast\";\n\n    constructor(loc: Location, readonly targetType: TypeName, readonly body: Expression) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.targetType;\n        yield this.body;\n    }\n}\n\nexport class FunctionCallExpression extends Expression {\n    readonly type = \"functionCall\";\n\n    constructor(loc: Location, readonly fn: Expression, readonly args: ReadonlyArray<Expression> = []) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.fn;\n        yield* this.args;\n    }\n}\n\nexport class MemberAccessExpression extends Expression {\n    readonly type = \"access\";\n\n    constructor(loc: Location, readonly pointer: boolean, readonly lhs: Expression, readonly rhs: string) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.lhs;\n    }\n}\n\nexport class ConditionalExpression extends Expression {\n    readonly type = \"conditional\";\n\n    constructor(loc: Location, readonly condition: Expression, readonly trueValue: Expression, readonly falseValue: Expression) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.condition;\n        yield this.trueValue;\n        yield this.falseValue;\n    }\n}\n\nexport type AssignmentType = undefined | \"mul\" | \"div\" | \"mod\" | \"add\" | \"sub\" | \"leftShift\"| \"rightShift\" | \"bitwiseAnd\" | \"bitwiseXor\" | \"bitwiseOr\";\nexport class AssignmentExpression extends Expression {\n    readonly type = \"assign\";\n\n    constructor(loc: Location, readonly assignType: AssignmentType, readonly lhs: Expression, readonly rhs: Expression) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.lhs;\n        yield this.rhs;\n    }\n}\n\nexport class ConstantExpression extends Expression {\n    readonly type = \"constantExpr\";\n\n    constructor(loc: Location, readonly expr: Expression) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.expr;\n    }\n}\n\n// Declarations\nexport class CustomTypeSpecifier extends ParseNode {\n    readonly type = \"customType\";\n\n    public constructor(loc: Location, readonly name: string) {\n        super(loc);\n    }\n}\n\nexport type StorageClass = \"typedef\" | \"extern\" | \"static\"; // | \"auto\" | \"register\";\nexport type TypeSpecifier =\n    \"void\" | \"char\" | \"short\" | \"int\" | \"long\" | \"float\" | \"double\" | \"signed\" | \"unsigned\" | \"bool\" // | \"complex\" | \"imaginary\"]\n    | StructUnionSpecifier\n    | EnumSpecifier\n    | CustomTypeSpecifier;\nexport type TypeQualifier = \"const\"; // | \"restrict\" | \"volatile\";\nexport type FnSpecifier = \"import\" | \"inline\";\n\nexport class SpecifierQualifiers extends ParseNode {\n    readonly type = \"specifiersAndQualifiers\";\n\n    constructor(loc: Location,\n                readonly specifierList: ReadonlyArray<TypeSpecifier>,\n                readonly qualifierList: ReadonlyArray<TypeQualifier>) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        for (const specifier of this.specifierList) {\n            if (specifier instanceof ParseNode) yield specifier;\n        }\n    }\n}\n\nexport class DeclarationSpecifiers extends ParseNode {\n    readonly type = \"declarationSpecifiers\";\n\n    constructor(loc: Location,\n                readonly specifierList: ReadonlyArray<TypeSpecifier>,\n                readonly qualifierList: ReadonlyArray<TypeQualifier>,\n                readonly storageList: ReadonlyArray<StorageClass>,\n                readonly fnSpecifierList: ReadonlyArray<FnSpecifier>) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        for (const specifier of this.specifierList) {\n            if (specifier instanceof ParseNode) yield specifier;\n        }\n    }\n}\n\nexport class EnumSpecifier extends ParseNode {\n    type = \"enum\";\n\n    constructor(loc: Location, readonly id?: string, readonly body?: ReadonlyArray<Enumerator>) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        if (this.body) yield* this.body;\n    }\n}\n\nexport class Enumerator extends ParseNode {\n    type = \"enumerator\";\n\n    constructor(loc: Location, readonly id: string, readonly value?: ConstantExpression) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        if (this.value) yield this.value;\n    }\n}\n\nexport class Declaration extends ParseNode{\n    readonly type = \"declaration\";\n\n    constructor(loc: Location, readonly typeInfo: DeclarationSpecifiers, readonly list: ReadonlyArray<Declarator | InitDeclarator> = []) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.typeInfo;\n        yield* this.list;\n    }\n}\n\nexport class InitDeclarator extends ParseNode {\n    readonly type = \"initDeclarator\";\n\n    constructor(loc: Location, readonly body: Declarator, readonly initializer: Initializer) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.body;\n        yield* this.exploreInitializer();\n    }\n\n    private *exploreInitializer(initializer: Initializer = this.initializer): Iterable<ParseNode> {\n        if (initializer instanceof AssignmentExpression) {\n            yield initializer;\n        } else if (Array.isArray(initializer)) {\n            for (const x of initializer) yield* this.exploreInitializer(x);\n        }\n    }\n}\n\nexport class StructUnionSpecifier extends ParseNode {\n    readonly type = \"structUnionSpecifier\";\n\n    constructor(loc: Location, readonly structure: \"struct\" | \"union\", readonly id?: string, readonly declarations?: ReadonlyArray<StructDeclaration>) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        if (this.declarations) yield* this.declarations;\n    }\n}\n\nexport class StructDeclaration extends ParseNode {\n    readonly type = \"structDeclaration\";\n\n    constructor(loc: Location, readonly typeInfo: DeclarationSpecifiers, readonly list: ReadonlyArray<Declarator> = []) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.typeInfo;\n        yield* this.list;\n    }\n}\n\nexport type Declarator = PointerDeclarator | IdentifierDeclarator | ArrayDeclarator | FunctionDeclarator;\n\nexport class PointerDeclarator extends ParseNode {\n    readonly type = \"pointerDeclarator\";\n    readonly abstractDeclarator = false;\n\n    constructor(loc: Location, readonly pointer: Pointer, readonly body: Declarator) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.pointer;\n        yield this.body;\n    }\n}\n\nexport class IdentifierDeclarator extends ParseNode {\n    readonly type = \"identifierDeclarator\";\n    readonly abstractDeclarator = false;\n\n    constructor(loc: Location, readonly id: string) {\n        super(loc);\n    }\n}\n\nexport class ArrayDeclarator extends ParseNode {\n    readonly type = \"arrayDeclarator\";\n    readonly abstractDeclarator = false;\n\n    constructor(loc: Location, readonly body: Declarator, readonly length?: ConstantExpression) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.body;\n        if (this.length) yield this.length;\n    }\n}\n\nexport class FunctionDeclarator extends ParseNode {\n    readonly type = \"functionDeclarator\";\n    readonly abstractDeclarator = false;\n\n    constructor(loc: Location, readonly body: Declarator, readonly args?: ReadonlyArray<ParameterDeclaration>, readonly variadic: boolean = false) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.body;\n        for (const value of this.args ?? []) {\n            if (value instanceof ParseNode) yield value;\n        }\n    }\n}\n\nexport class ParameterDeclaration extends ParseNode {\n    readonly type = \"parameterDeclaration\";\n\n    constructor(loc: Location, readonly typeInfo: DeclarationSpecifiers, readonly declarator?: Declarator | AbstractDeclarator) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.typeInfo;\n        if (this.declarator) yield this.declarator;\n    }\n}\n\nexport class Pointer extends ParseNode {\n    readonly type = \"pointer\";\n\n    constructor(loc: Location, readonly qualifierList?: ReadonlyArray<TypeQualifier>, readonly body?: Pointer) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        if (this.body) yield this.body;\n    }\n}\n\nexport class TypeName extends ParseNode {\n    readonly type = \"typeName\";\n\n    constructor(loc: Location, readonly typeInfo: SpecifierQualifiers, readonly declarator?: AbstractDeclarator) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.typeInfo;\n        if (this.declarator) yield this.declarator;\n    }\n}\n\nexport type AbstractDeclarator = AbstractPointerDeclarator | AbstractArrayDeclarator | AbstractFunctionDeclarator;\n\nexport class AbstractPointerDeclarator extends ParseNode {\n    readonly type = \"abstractPointerDeclarator\";\n    readonly abstractDeclarator = true;\n\n    constructor(loc: Location, readonly pointer: Pointer, readonly body?: AbstractDeclarator) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.pointer;\n        if (this.body) yield this.body;\n    }\n}\n\nexport class AbstractArrayDeclarator extends ParseNode {\n    readonly type = \"abstractArrayDeclarator\";\n    readonly abstractDeclarator = true;\n\n    constructor(loc: Location, readonly body?: AbstractDeclarator, readonly length?: ConstantExpression) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        if (this.body) yield this.body;\n        if (this.length) yield this.length;\n    }\n}\n\nexport class AbstractFunctionDeclarator extends ParseNode {\n    readonly type = \"abstractFunctionDeclarator\";\n    readonly abstractDeclarator = true;\n\n    constructor(loc: Location, readonly body?: AbstractDeclarator, readonly args?: ReadonlyArray<ParameterDeclaration>, readonly variadic: boolean = false) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        if (this.body) yield this.body;\n        if (this.args) yield* this.args;\n    }\n}\n\nexport type Initializer = Expression | ReadonlyArray<Initializer>;\n\n// Statements\n\nexport abstract class Statement extends ParseNode {\n    private readonly _statement: boolean = true;\n    label?: string;\n\n    setLabel(label: string): this {\n        this.label = label;\n        return this;\n    }\n}\n\nexport class IfStatement extends Statement {\n    readonly type = \"ifStatement\";\n\n    constructor(loc: Location, readonly expression: Expression, readonly ifBody: Statement, readonly elseBody?: Statement) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.expression;\n        yield this.ifBody;\n        if (this.elseBody) yield this.elseBody;\n    }\n}\n\nexport class SwitchStatement extends Statement {\n    readonly type = \"switchStatement\";\n\n    constructor(loc: Location, readonly expression: Expression, readonly body: Statement) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.expression;\n        yield this.body;\n    }\n}\n\nexport class CaseStatement extends Statement {\n    readonly type = \"caseStatement\";\n\n    constructor(loc: Location, readonly value: ConstantExpression, readonly body: Statement) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.value;\n        yield this.body;\n    }\n}\n\nexport class DefaultStatement extends Statement {\n    readonly type = \"defaultStatement\";\n\n    constructor(loc: Location, readonly body: Statement) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.body;\n    }\n}\n\nexport class CompoundStatement extends Statement {\n    readonly type = \"compoundStatement\";\n\n    constructor(loc: Location, readonly body: ReadonlyArray<Statement | Declaration>) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield* this.body;\n    }\n}\n\nexport class ExpressionStatement extends Statement {\n    readonly type = \"expressionStatement\";\n\n    constructor(loc: Location, readonly expression: Expression) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.expression;\n    }\n}\n\nexport class NoOp extends Statement {\n    readonly type = \"nopStatement\";\n\n    constructor(loc: Location) {\n        super(loc);\n    }\n}\n\nexport class ForLoop extends Statement {\n    readonly type = \"forStatement\";\n\n    constructor(loc: Location,\n                readonly init: ExpressionStatement | NoOp | Declaration,\n                readonly test: ExpressionStatement | NoOp,\n                readonly update: Expression | undefined,\n                readonly body: Statement) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.init;\n        yield this.test;\n        if (this.update) yield this.update;\n        yield this.body;\n    }\n}\n\nexport class WhileLoop extends Statement {\n    readonly type = \"whileStatement\";\n\n    constructor(loc: Location, readonly test: Expression, readonly body: Statement) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.test;\n        yield this.body;\n    }\n}\n\nexport class DoWhileLoop extends Statement {\n    readonly type = \"doWhileStatement\";\n\n    constructor(loc: Location, readonly body: Statement, readonly test: Expression) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.body;\n        yield this.test;\n    }\n}\n\nexport class GotoStatement extends Statement {\n    readonly type = \"gotoStatement\";\n\n    constructor(loc: Location, readonly target: string) {\n        super(loc);\n    }\n}\n\nexport class ContinueStatement extends Statement {\n    readonly type = \"continueStatement\";\n}\n\nexport class BreakStatement extends Statement {\n    readonly type = \"breakStatement\";\n}\n\nexport class ReturnStatement extends Statement {\n    readonly type = \"returnStatement\";\n\n    constructor(loc: Location, readonly value?: Expression) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        if (this.value) yield this.value;\n    }\n}\n\nexport class FunctionDefinition extends ParseNode {\n    readonly type = \"functionDefinition\";\n\n    constructor(loc: Location,\n                readonly typeInfo: DeclarationSpecifiers,\n                readonly declarator: Declarator,\n                readonly body: CompoundStatement) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.typeInfo;\n        yield this.declarator;\n        yield this.body;\n    }\n}\n\nexport type TranslationUnit = ReadonlyArray<FunctionDefinition | Declaration>;\n","\n/* parser generated by jison 0.6.1-215 */\n\n/*\n * Returns a Parser object of the following structure:\n *\n *  Parser: {\n *    yy: {}     The so-called \"shared state\" or rather the *source* of it;\n *               the real \"shared state\" `yy` passed around to\n *               the rule actions, etc. is a derivative/copy of this one,\n *               not a direct reference!\n *  }\n *\n *  Parser.prototype: {\n *    yy: {},\n *    EOF: 1,\n *    TERROR: 2,\n *\n *    trace: function(errorMessage, ...),\n *\n *    JisonParserError: function(msg, hash),\n *\n *    quoteName: function(name),\n *               Helper function which can be overridden by user code later on: put suitable\n *               quotes around literal IDs in a description string.\n *\n *    originalQuoteName: function(name),\n *               The basic quoteName handler provided by JISON.\n *               `cleanupAfterParse()` will clean up and reset `quoteName()` to reference this function\n *               at the end of the `parse()`.\n *\n *    describeSymbol: function(symbol),\n *               Return a more-or-less human-readable description of the given symbol, when\n *               available, or the symbol itself, serving as its own 'description' for lack\n *               of something better to serve up.\n *\n *               Return NULL when the symbol is unknown to the parser.\n *\n *    symbols_: {associative list: name ==> number},\n *    terminals_: {associative list: number ==> name},\n *    nonterminals: {associative list: rule-name ==> {associative list: number ==> rule-alt}},\n *    terminal_descriptions_: (if there are any) {associative list: number ==> description},\n *    productions_: [...],\n *\n *    performAction: function parser__performAction(yytext, yyleng, yylineno, yyloc, yystate, yysp, yyvstack, yylstack, yystack, yysstack),\n *\n *               The function parameters and `this` have the following value/meaning:\n *               - `this`    : reference to the `yyval` internal object, which has members (`$` and `_$`)\n *                             to store/reference the rule value `$$` and location info `@$`.\n *\n *                 One important thing to note about `this` a.k.a. `yyval`: every *reduce* action gets\n *                 to see the same object via the `this` reference, i.e. if you wish to carry custom\n *                 data from one reduce action through to the next within a single parse run, then you\n *                 may get nasty and use `yyval` a.k.a. `this` for storing you own semi-permanent data.\n *\n *                 `this.yy` is a direct reference to the `yy` shared state object.\n *\n *                 `%parse-param`-specified additional `parse()` arguments have been added to this `yy`\n *                 object at `parse()` start and are therefore available to the action code via the\n *                 same named `yy.xxxx` attributes (where `xxxx` represents a identifier name from\n *                 the %parse-param` list.\n *\n *               - `yytext`  : reference to the lexer value which belongs to the last lexer token used\n *                             to match this rule. This is *not* the look-ahead token, but the last token\n *                             that's actually part of this rule.\n *\n *                 Formulated another way, `yytext` is the value of the token immediately preceeding\n *                 the current look-ahead token.\n *                 Caveats apply for rules which don't require look-ahead, such as epsilon rules.\n *\n *               - `yyleng`  : ditto as `yytext`, only now for the lexer.yyleng value.\n *\n *               - `yylineno`: ditto as `yytext`, only now for the lexer.yylineno value.\n *\n *               - `yyloc`   : ditto as `yytext`, only now for the lexer.yylloc lexer token location info.\n *\n *                               WARNING: since jison 0.4.18-186 this entry may be NULL/UNDEFINED instead\n *                               of an empty object when no suitable location info can be provided.\n *\n *               - `yystate` : the current parser state number, used internally for dispatching and\n *                               executing the action code chunk matching the rule currently being reduced.\n *\n *               - `yysp`    : the current state stack position (a.k.a. 'stack pointer')\n *\n *                 This one comes in handy when you are going to do advanced things to the parser\n *                 stacks, all of which are accessible from your action code (see the next entries below).\n *\n *                 Also note that you can access this and other stack index values using the new double-hash\n *                 syntax, i.e. `##$ === ##0 === yysp`, while `##1` is the stack index for all things\n *                 related to the first rule term, just like you have `$1`, `@1` and `#1`.\n *                 This is made available to write very advanced grammar action rules, e.g. when you want\n *                 to investigate the parse state stack in your action code, which would, for example,\n *                 be relevant when you wish to implement error diagnostics and reporting schemes similar\n *                 to the work described here:\n *\n *                 + Pottier, F., 2016. Reachability and error diagnosis in LR(1) automata.\n *                   In Journes Francophones des Languages Applicatifs.\n *\n *                 + Jeffery, C.L., 2003. Generating LR syntax error messages from examples.\n *                   ACM Transactions on Programming Languages and Systems (TOPLAS), 25(5), pp.631640.\n *\n *               - `yyrulelength`: the current rule's term count, i.e. the number of entries occupied on the stack.\n *\n *                 This one comes in handy when you are going to do advanced things to the parser\n *                 stacks, all of which are accessible from your action code (see the next entries below).\n *\n *               - `yyvstack`: reference to the parser value stack. Also accessed via the `$1` etc.\n *                             constructs.\n *\n *               - `yylstack`: reference to the parser token location stack. Also accessed via\n *                             the `@1` etc. constructs.\n *\n *                             WARNING: since jison 0.4.18-186 this array MAY contain slots which are\n *                             UNDEFINED rather than an empty (location) object, when the lexer/parser\n *                             action code did not provide a suitable location info object when such a\n *                             slot was filled!\n *\n *               - `yystack` : reference to the parser token id stack. Also accessed via the\n *                             `#1` etc. constructs.\n *\n *                 Note: this is a bit of a **white lie** as we can statically decode any `#n` reference to\n *                 its numeric token id value, hence that code wouldn't need the `yystack` but *you* might\n *                 want access this array for your own purposes, such as error analysis as mentioned above!\n *\n *                 Note that this stack stores the current stack of *tokens*, that is the sequence of\n *                 already parsed=reduced *nonterminals* (tokens representing rules) and *terminals*\n *                 (lexer tokens *shifted* onto the stack until the rule they belong to is found and\n *                 *reduced*.\n *\n *               - `yysstack`: reference to the parser state stack. This one carries the internal parser\n *                             *states* such as the one in `yystate`, which are used to represent\n *                             the parser state machine in the *parse table*. *Very* *internal* stuff,\n *                             what can I say? If you access this one, you're clearly doing wicked things\n *\n *               - `...`     : the extra arguments you specified in the `%parse-param` statement in your\n *                             grammar definition file.\n *\n *    table: [...],\n *               State transition table\n *               ----------------------\n *\n *               index levels are:\n *               - `state`  --> hash table\n *               - `symbol` --> action (number or array)\n *\n *                 If the `action` is an array, these are the elements' meaning:\n *                 - index [0]: 1 = shift, 2 = reduce, 3 = accept\n *                 - index [1]: GOTO `state`\n *\n *                 If the `action` is a number, it is the GOTO `state`\n *\n *    defaultActions: {...},\n *\n *    parseError: function(str, hash, ExceptionClass),\n *    yyError: function(str, ...),\n *    yyRecovering: function(),\n *    yyErrOk: function(),\n *    yyClearIn: function(),\n *\n *    constructParseErrorInfo: function(error_message, exception_object, expected_token_set, is_recoverable),\n *               Helper function **which will be set up during the first invocation of the `parse()` method**.\n *               Produces a new errorInfo 'hash object' which can be passed into `parseError()`.\n *               See it's use in this parser kernel in many places; example usage:\n *\n *                   var infoObj = parser.constructParseErrorInfo('fail!', null,\n *                                     parser.collect_expected_token_set(state), true);\n *                   var retVal = parser.parseError(infoObj.errStr, infoObj, parser.JisonParserError);\n *\n *    originalParseError: function(str, hash, ExceptionClass),\n *               The basic `parseError` handler provided by JISON.\n *               `cleanupAfterParse()` will clean up and reset `parseError()` to reference this function\n *               at the end of the `parse()`.\n *\n *    options: { ... parser %options ... },\n *\n *    parse: function(input[, args...]),\n *               Parse the given `input` and return the parsed value (or `true` when none was provided by\n *               the root action, in which case the parser is acting as a *matcher*).\n *               You MAY use the additional `args...` parameters as per `%parse-param` spec of this grammar:\n *               these extra `args...` are added verbatim to the `yy` object reference as member variables.\n *\n *               WARNING:\n *               Parser's additional `args...` parameters (via `%parse-param`) MAY conflict with\n *               any attributes already added to `yy` by the jison run-time;\n *               when such a collision is detected an exception is thrown to prevent the generated run-time\n *               from silently accepting this confusing and potentially hazardous situation!\n *\n *               The lexer MAY add its own set of additional parameters (via the `%parse-param` line in\n *               the lexer section of the grammar spec): these will be inserted in the `yy` shared state\n *               object and any collision with those will be reported by the lexer via a thrown exception.\n *\n *    cleanupAfterParse: function(resultValue, invoke_post_methods, do_not_nuke_errorinfos),\n *               Helper function **which will be set up during the first invocation of the `parse()` method**.\n *               This helper API is invoked at the end of the `parse()` call, unless an exception was thrown\n *               and `%options no-try-catch` has been defined for this grammar: in that case this helper MAY\n *               be invoked by calling user code to ensure the `post_parse` callbacks are invoked and\n *               the internal parser gets properly garbage collected under these particular circumstances.\n *\n *    yyMergeLocationInfo: function(first_index, last_index, first_yylloc, last_yylloc, dont_look_back),\n *               Helper function **which will be set up during the first invocation of the `parse()` method**.\n *               This helper API can be invoked to calculate a spanning `yylloc` location info object.\n *\n *               Note: %epsilon rules MAY specify no `first_index` and `first_yylloc`, in which case\n *               this function will attempt to obtain a suitable location marker by inspecting the location stack\n *               backwards.\n *\n *               For more info see the documentation comment further below, immediately above this function's\n *               implementation.\n *\n *    lexer: {\n *        yy: {...},           A reference to the so-called \"shared state\" `yy` once\n *                             received via a call to the `.setInput(input, yy)` lexer API.\n *        EOF: 1,\n *        ERROR: 2,\n *        JisonLexerError: function(msg, hash),\n *        parseError: function(str, hash, ExceptionClass),\n *        setInput: function(input, [yy]),\n *        input: function(),\n *        unput: function(str),\n *        more: function(),\n *        reject: function(),\n *        less: function(n),\n *        pastInput: function(n),\n *        upcomingInput: function(n),\n *        showPosition: function(),\n *        test_match: function(regex_match_array, rule_index, ...),\n *        next: function(...),\n *        lex: function(...),\n *        begin: function(condition),\n *        pushState: function(condition),\n *        popState: function(),\n *        topState: function(),\n *        _currentRules: function(),\n *        stateStackSize: function(),\n *        cleanupAfterLex: function()\n *\n *        options: { ... lexer %options ... },\n *\n *        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START, ...),\n *        rules: [...],\n *        conditions: {associative list: name ==> set},\n *    }\n *  }\n *\n *\n *  token location info (@$, _$, etc.): {\n *    first_line: n,\n *    last_line: n,\n *    first_column: n,\n *    last_column: n,\n *    range: [start_number, end_number]\n *               (where the numbers are indexes into the input string, zero-based)\n *  }\n *\n * ---\n *\n * The `parseError` function receives a 'hash' object with these members for lexer and\n * parser errors:\n *\n *  {\n *    text:        (matched text)\n *    token:       (the produced terminal token, if any)\n *    token_id:    (the produced terminal token numeric ID, if any)\n *    line:        (yylineno)\n *    loc:         (yylloc)\n *  }\n *\n * parser (grammar) errors will also provide these additional members:\n *\n *  {\n *    expected:    (array describing the set of expected tokens;\n *                  may be UNDEFINED when we cannot easily produce such a set)\n *    state:       (integer (or array when the table includes grammar collisions);\n *                  represents the current internal state of the parser kernel.\n *                  can, for example, be used to pass to the `collect_expected_token_set()`\n *                  API to obtain the expected token set)\n *    action:      (integer; represents the current internal action which will be executed)\n *    new_state:   (integer; represents the next/planned internal state, once the current\n *                  action has executed)\n *    recoverable: (boolean: TRUE when the parser MAY have an error recovery rule\n *                  available for this particular error)\n *    state_stack: (array: the current parser LALR/LR internal state stack; this can be used,\n *                  for instance, for advanced error analysis and reporting)\n *    value_stack: (array: the current parser LALR/LR internal `$$` value stack; this can be used,\n *                  for instance, for advanced error analysis and reporting)\n *    location_stack: (array: the current parser LALR/LR internal location stack; this can be used,\n *                  for instance, for advanced error analysis and reporting)\n *    yy:          (object: the current parser internal \"shared state\" `yy`\n *                  as is also available in the rule actions; this can be used,\n *                  for instance, for advanced error analysis and reporting)\n *    lexer:       (reference to the current lexer instance used by the parser)\n *    parser:      (reference to the current parser instance)\n *  }\n *\n * while `this` will reference the current parser instance.\n *\n * When `parseError` is invoked by the lexer, `this` will still reference the related *parser*\n * instance, while these additional `hash` fields will also be provided:\n *\n *  {\n *    lexer:       (reference to the current lexer instance which reported the error)\n *  }\n *\n * When `parseError` is invoked by the parser due to a **JavaScript exception** being fired\n * from either the parser or lexer, `this` will still reference the related *parser*\n * instance, while these additional `hash` fields will also be provided:\n *\n *  {\n *    exception:   (reference to the exception thrown)\n *  }\n *\n * Please do note that in the latter situation, the `expected` field will be omitted as\n * this type of failure is assumed not to be due to *parse errors* but rather due to user\n * action code in either parser or lexer failing unexpectedly.\n *\n * ---\n *\n * You can specify parser options by setting / modifying the `.yy` object of your Parser instance.\n * These options are available:\n *\n * ### options which are global for all parser instances\n *\n *  Parser.pre_parse: function(yy)\n *                 optional: you can specify a pre_parse() function in the chunk following\n *                 the grammar, i.e. after the last `%%`.\n *  Parser.post_parse: function(yy, retval, parseInfo) { return retval; }\n *                 optional: you can specify a post_parse() function in the chunk following\n *                 the grammar, i.e. after the last `%%`. When it does not return any value,\n *                 the parser will return the original `retval`.\n *\n * ### options which can be set up per parser instance\n *\n *  yy: {\n *      pre_parse:  function(yy)\n *                 optional: is invoked before the parse cycle starts (and before the first\n *                 invocation of `lex()`) but immediately after the invocation of\n *                 `parser.pre_parse()`).\n *      post_parse: function(yy, retval, parseInfo) { return retval; }\n *                 optional: is invoked when the parse terminates due to success ('accept')\n *                 or failure (even when exceptions are thrown).\n *                 `retval` contains the return value to be produced by `Parser.parse()`;\n *                 this function can override the return value by returning another.\n *                 When it does not return any value, the parser will return the original\n *                 `retval`.\n *                 This function is invoked immediately before `parser.post_parse()`.\n *\n *      parseError: function(str, hash, ExceptionClass)\n *                 optional: overrides the default `parseError` function.\n *      quoteName: function(name),\n *                 optional: overrides the default `quoteName` function.\n *  }\n *\n *  parser.lexer.options: {\n *      pre_lex:  function()\n *                 optional: is invoked before the lexer is invoked to produce another token.\n *                 `this` refers to the Lexer object.\n *      post_lex: function(token) { return token; }\n *                 optional: is invoked when the lexer has produced a token `token`;\n *                 this function can override the returned token value by returning another.\n *                 When it does not return any (truthy) value, the lexer will return\n *                 the original `token`.\n *                 `this` refers to the Lexer object.\n *\n *      ranges: boolean\n *                 optional: `true` ==> token location info will include a .range[] member.\n *      flex: boolean\n *                 optional: `true` ==> flex-like lexing behaviour where the rules are tested\n *                 exhaustively to find the longest match.\n *      backtrack_lexer: boolean\n *                 optional: `true` ==> lexer regexes are tested in order and for invoked;\n *                 the lexer terminates the scan when a token is returned by the action code.\n *      xregexp: boolean\n *                 optional: `true` ==> lexer rule regexes are \"extended regex format\" requiring the\n *                 `XRegExp` library. When this `%option` has not been specified at compile time, all lexer\n *                 rule regexes have been written as standard JavaScript RegExp expressions.\n *  }\n */\n\n        \n    \n            var c_grammar = (function () {\n\n\n// See also:\n// http://stackoverflow.com/questions/1382107/whats-a-good-way-to-extend-error-in-javascript/#35881508\n// but we keep the prototype.constructor and prototype.name assignment lines too for compatibility\n// with userland code which might access the derived class in a 'classic' way.\nfunction JisonParserError(msg, hash) {\n    Object.defineProperty(this, 'name', {\n        enumerable: false,\n        writable: false,\n        value: 'JisonParserError'\n    });\n\n    if (msg == null) msg = '???';\n\n    Object.defineProperty(this, 'message', {\n        enumerable: false,\n        writable: true,\n        value: msg\n    });\n\n    this.hash = hash;\n\n    var stacktrace;\n    if (hash && hash.exception instanceof Error) {\n        var ex2 = hash.exception;\n        this.message = ex2.message || msg;\n        stacktrace = ex2.stack;\n    }\n    if (!stacktrace) {\n        if (Error.hasOwnProperty('captureStackTrace')) {        // V8/Chrome engine\n            Error.captureStackTrace(this, this.constructor);\n        } else {\n            stacktrace = (new Error(msg)).stack;\n        }\n    }\n    if (stacktrace) {\n        Object.defineProperty(this, 'stack', {\n            enumerable: false,\n            writable: false,\n            value: stacktrace\n        });\n    }\n}\n\nif (typeof Object.setPrototypeOf === 'function') {\n    Object.setPrototypeOf(JisonParserError.prototype, Error.prototype);\n} else {\n    JisonParserError.prototype = Object.create(Error.prototype);\n}\nJisonParserError.prototype.constructor = JisonParserError;\nJisonParserError.prototype.name = 'JisonParserError';\n\n\n\n\n        // helper: reconstruct the productions[] table\n        function bp(s) {\n            var rv = [];\n            var p = s.pop;\n            var r = s.rule;\n            for (var i = 0, l = p.length; i < l; i++) {\n                rv.push([\n                    p[i],\n                    r[i]\n                ]);\n            }\n            return rv;\n        }\n    \n\n\n        // helper: reconstruct the defaultActions[] table\n        function bda(s) {\n            var rv = {};\n            var d = s.idx;\n            var g = s.goto;\n            for (var i = 0, l = d.length; i < l; i++) {\n                var j = d[i];\n                rv[j] = g[i];\n            }\n            return rv;\n        }\n    \n\n\n        // helper: reconstruct the 'goto' table\n        function bt(s) {\n            var rv = [];\n            var d = s.len;\n            var y = s.symbol;\n            var t = s.type;\n            var a = s.state;\n            var m = s.mode;\n            var g = s.goto;\n            for (var i = 0, l = d.length; i < l; i++) {\n                var n = d[i];\n                var q = {};\n                for (var j = 0; j < n; j++) {\n                    var z = y.shift();\n                    switch (t.shift()) {\n                    case 2:\n                        q[z] = [\n                            m.shift(),\n                            g.shift()\n                        ];\n                        break;\n\n                    case 0:\n                        q[z] = a.shift();\n                        break;\n\n                    default:\n                        // type === 1: accept\n                        q[z] = [\n                            3\n                        ];\n                    }\n                }\n                rv.push(q);\n            }\n            return rv;\n        }\n    \n\n\n        // helper: runlength encoding with increment step: code, length: step (default step = 0)\n        // `this` references an array\n        function s(c, l, a) {\n            a = a || 0;\n            for (var i = 0; i < l; i++) {\n                this.push(c);\n                c += a;\n            }\n        }\n\n        // helper: duplicate sequence from *relative* offset and length.\n        // `this` references an array\n        function c(i, l) {\n            i = this.length - i;\n            for (l += i; i < l; i++) {\n                this.push(this[i]);\n            }\n        }\n\n        // helper: unpack an array using helpers and data, all passed in an array argument 'a'.\n        function u(a) {\n            var rv = [];\n            for (var i = 0, l = a.length; i < l; i++) {\n                var e = a[i];\n                // Is this entry a helper function?\n                if (typeof e === 'function') {\n                    i++;\n                    e.apply(rv, a[i]);\n                } else {\n                    rv.push(e);\n                }\n            }\n            return rv;\n        }\n    \n\nvar parser = {\n    // Code Generator Information Report\n    // ---------------------------------\n    //\n    // Options:\n    //\n    //   default action mode: ............. [\"none\",\"merge\"]\n    //   test-compile action mode: ........ \"parser:*,lexer:*\"\n    //   try..catch: ...................... true\n    //   default resolve on conflict: ..... true\n    //   on-demand look-ahead: ............ false\n    //   error recovery token skip maximum: 3\n    //   yyerror in parse actions is: ..... NOT recoverable,\n    //   yyerror in lexer actions and other non-fatal lexer are:\n    //   .................................. NOT recoverable,\n    //   debug grammar/output: ............ false\n    //   has partial LR conflict upgrade:   true\n    //   rudimentary token-stack support:   false\n    //   parser table compression mode: ... 2\n    //   export debug tables: ............. false\n    //   export *all* tables: ............. false\n    //   module type: ..................... commonjs\n    //   parser engine type: .............. lalr\n    //   output main() in the module: ..... true\n    //   has user-specified main(): ....... false\n    //   has user-specified require()/import modules for main():\n    //   .................................. false\n    //   number of expected conflicts: .... 0\n    //\n    //\n    // Parser Analysis flags:\n    //\n    //   no significant actions (parser is a language matcher only):\n    //   .................................. false\n    //   uses yyleng: ..................... false\n    //   uses yylineno: ................... false\n    //   uses yytext: ..................... true\n    //   uses yylloc: ..................... false\n    //   uses ParseError API: ............. false\n    //   uses YYERROR: .................... false\n    //   uses YYRECOVERING: ............... false\n    //   uses YYERROK: .................... false\n    //   uses YYCLEARIN: .................. false\n    //   tracks rule values: .............. true\n    //   assigns rule values: ............. true\n    //   uses location tracking: .......... true\n    //   assigns location: ................ true\n    //   uses yystack: .................... false\n    //   uses yysstack: ................... false\n    //   uses yysp: ....................... true\n    //   uses yyrulelength: ............... false\n    //   uses yyMergeLocationInfo API: .... true\n    //   has error recovery: .............. false\n    //   has error reporting: ............. false\n    //\n    // --------- END OF REPORT -----------\n\ntrace: function no_op_trace() { },\nJisonParserError: JisonParserError,\nyy: {},\noptions: {\n  type: \"lalr\",\n  hasPartialLrUpgradeOnConflict: true,\n  errorRecoveryTokenDiscardCount: 3\n},\nsymbols_: {\n  \"!\": 14,\n  \"!=\": 43,\n  \"$accept\": 0,\n  \"$end\": 1,\n  \"%\": 16,\n  \"%=\": 48,\n  \"&\": 9,\n  \"&&\": 44,\n  \"&=\": 53,\n  \"(\": 3,\n  \")\": 4,\n  \"*\": 10,\n  \"*=\": 46,\n  \"+\": 11,\n  \"++\": 35,\n  \"+=\": 49,\n  \",\": 8,\n  \"-\": 12,\n  \"--\": 36,\n  \"-=\": 50,\n  \"->\": 34,\n  \".\": 7,\n  \"...\": 76,\n  \"/\": 15,\n  \"/=\": 47,\n  \":\": 22,\n  \";\": 24,\n  \"<\": 17,\n  \"<<\": 38,\n  \"<<=\": 51,\n  \"<=\": 40,\n  \"=\": 23,\n  \"==\": 42,\n  \">\": 18,\n  \">=\": 41,\n  \">>\": 39,\n  \">>=\": 52,\n  \"?\": 21,\n  \"BREAK\": 87,\n  \"CASE\": 77,\n  \"CHAR\": 60,\n  \"CONST\": 73,\n  \"CONSTANT_CHAR\": 32,\n  \"CONSTANT_FLOAT\": 28,\n  \"CONSTANT_HEX\": 29,\n  \"CONSTANT_INT\": 31,\n  \"CONSTANT_OCTAL\": 30,\n  \"CONTINUE\": 86,\n  \"DEFAULT\": 78,\n  \"DO\": 83,\n  \"DOUBLE\": 65,\n  \"ELSE\": 80,\n  \"ENUM\": 72,\n  \"EOF\": 1,\n  \"EXTERN\": 57,\n  \"FLOAT\": 64,\n  \"FOR\": 84,\n  \"GOTO\": 85,\n  \"IDENTIFIER\": 27,\n  \"IF\": 79,\n  \"IMPORT\": 75,\n  \"INLINE\": 74,\n  \"INT\": 62,\n  \"LONG\": 63,\n  \"RETURN\": 88,\n  \"SHORT\": 61,\n  \"SIGNED\": 66,\n  \"SIZEOF\": 37,\n  \"STATIC\": 58,\n  \"STRING_LITERAL\": 33,\n  \"STRUCT\": 70,\n  \"SWITCH\": 81,\n  \"TYPEDEF\": 56,\n  \"TYPE_NAME\": 69,\n  \"UNION\": 71,\n  \"UNSIGNED\": 67,\n  \"VOID\": 59,\n  \"WHILE\": 82,\n  \"[\": 5,\n  \"]\": 6,\n  \"^\": 19,\n  \"^=\": 54,\n  \"_BOOL\": 68,\n  \"abstract_declarator\": 141,\n  \"additive_expression\": 101,\n  \"and_expression\": 105,\n  \"argument_expression_list\": 96,\n  \"assignment_expression\": 111,\n  \"assignment_operator\": 112,\n  \"ast_tree\": 89,\n  \"block_item\": 149,\n  \"block_item_list\": 148,\n  \"cast_expression\": 99,\n  \"compound_statement\": 147,\n  \"concat_string_literals\": 93,\n  \"conditional_expression\": 110,\n  \"constant\": 91,\n  \"constant_expression\": 114,\n  \"declaration\": 115,\n  \"declaration_specifiers\": 116,\n  \"declarator\": 133,\n  \"direct_abstract_declarator\": 142,\n  \"direct_declarator\": 134,\n  \"enum_specifier\": 128,\n  \"enumerator\": 130,\n  \"enumerator_list\": 129,\n  \"equality_expression\": 104,\n  \"error\": 2,\n  \"exclusive_or_expression\": 106,\n  \"expression\": 113,\n  \"expression_statement\": 150,\n  \"external_declaration\": 155,\n  \"function_definition\": 156,\n  \"function_specifier\": 132,\n  \"identifier\": 90,\n  \"inclusive_or_expression\": 107,\n  \"init_declarator\": 118,\n  \"init_declarator_list\": 117,\n  \"initializer\": 143,\n  \"initializer_list\": 144,\n  \"iteration_statement\": 152,\n  \"jump_statement\": 153,\n  \"labeled_statement\": 146,\n  \"logical_and_expression\": 108,\n  \"logical_or_expression\": 109,\n  \"multiplicative_expression\": 100,\n  \"parameter_declaration\": 139,\n  \"parameter_list\": 138,\n  \"parameter_type_list\": 137,\n  \"pointer\": 135,\n  \"postfix_expression\": 95,\n  \"primary_expression\": 94,\n  \"relational_expression\": 103,\n  \"selection_statement\": 151,\n  \"shift_expression\": 102,\n  \"specifier_qualifier_list\": 125,\n  \"statement\": 145,\n  \"storage_class_specifier\": 119,\n  \"string_literal\": 92,\n  \"struct_declaration\": 124,\n  \"struct_declaration_list\": 123,\n  \"struct_declarator\": 127,\n  \"struct_declarator_list\": 126,\n  \"struct_or_union\": 122,\n  \"struct_or_union_specifier\": 121,\n  \"translation_unit\": 154,\n  \"type_name\": 140,\n  \"type_qualifier\": 131,\n  \"type_qualifier_list\": 136,\n  \"type_specifier\": 120,\n  \"unary_expression\": 97,\n  \"unary_operator\": 98,\n  \"{\": 25,\n  \"|\": 20,\n  \"|=\": 55,\n  \"||\": 45,\n  \"}\": 26,\n  \"~\": 13\n},\nterminals_: {\n  1: \"EOF\",\n  2: \"error\",\n  3: \"(\",\n  4: \")\",\n  5: \"[\",\n  6: \"]\",\n  7: \".\",\n  8: \",\",\n  9: \"&\",\n  10: \"*\",\n  11: \"+\",\n  12: \"-\",\n  13: \"~\",\n  14: \"!\",\n  15: \"/\",\n  16: \"%\",\n  17: \"<\",\n  18: \">\",\n  19: \"^\",\n  20: \"|\",\n  21: \"?\",\n  22: \":\",\n  23: \"=\",\n  24: \";\",\n  25: \"{\",\n  26: \"}\",\n  27: \"IDENTIFIER\",\n  28: \"CONSTANT_FLOAT\",\n  29: \"CONSTANT_HEX\",\n  30: \"CONSTANT_OCTAL\",\n  31: \"CONSTANT_INT\",\n  32: \"CONSTANT_CHAR\",\n  33: \"STRING_LITERAL\",\n  34: \"->\",\n  35: \"++\",\n  36: \"--\",\n  37: \"SIZEOF\",\n  38: \"<<\",\n  39: \">>\",\n  40: \"<=\",\n  41: \">=\",\n  42: \"==\",\n  43: \"!=\",\n  44: \"&&\",\n  45: \"||\",\n  46: \"*=\",\n  47: \"/=\",\n  48: \"%=\",\n  49: \"+=\",\n  50: \"-=\",\n  51: \"<<=\",\n  52: \">>=\",\n  53: \"&=\",\n  54: \"^=\",\n  55: \"|=\",\n  56: \"TYPEDEF\",\n  57: \"EXTERN\",\n  58: \"STATIC\",\n  59: \"VOID\",\n  60: \"CHAR\",\n  61: \"SHORT\",\n  62: \"INT\",\n  63: \"LONG\",\n  64: \"FLOAT\",\n  65: \"DOUBLE\",\n  66: \"SIGNED\",\n  67: \"UNSIGNED\",\n  68: \"_BOOL\",\n  69: \"TYPE_NAME\",\n  70: \"STRUCT\",\n  71: \"UNION\",\n  72: \"ENUM\",\n  73: \"CONST\",\n  74: \"INLINE\",\n  75: \"IMPORT\",\n  76: \"...\",\n  77: \"CASE\",\n  78: \"DEFAULT\",\n  79: \"IF\",\n  80: \"ELSE\",\n  81: \"SWITCH\",\n  82: \"WHILE\",\n  83: \"DO\",\n  84: \"FOR\",\n  85: \"GOTO\",\n  86: \"CONTINUE\",\n  87: \"BREAK\",\n  88: \"RETURN\"\n},\nTERROR: 2,\n    EOF: 1,\n\n    // internals: defined here so the object *structure* doesn't get modified by parse() et al,\n    // thus helping JIT compilers like Chrome V8.\n    originalQuoteName: null,\n    originalParseError: null,\n    cleanupAfterParse: null,\n    constructParseErrorInfo: null,\n    yyMergeLocationInfo: null,\n\n    __reentrant_call_depth: 0,      // INTERNAL USE ONLY\n    __error_infos: [],              // INTERNAL USE ONLY: the set of parseErrorInfo objects created since the last cleanup\n    __error_recovery_infos: [],     // INTERNAL USE ONLY: the set of parseErrorInfo objects created since the last cleanup\n\n    // APIs which will be set up depending on user action code analysis:\n    //yyRecovering: 0,\n    //yyErrOk: 0,\n    //yyClearIn: 0,\n\n    // Helper APIs\n    // -----------\n\n    // Helper function which can be overridden by user code later on: put suitable quotes around\n    // literal IDs in a description string.\n    quoteName: function parser_quoteName(id_str) {\n        return '\"' + id_str + '\"';\n    },\n\n    // Return the name of the given symbol (terminal or non-terminal) as a string, when available.\n    //\n    // Return NULL when the symbol is unknown to the parser.\n    getSymbolName: function parser_getSymbolName(symbol) {\n        if (this.terminals_[symbol]) {\n            return this.terminals_[symbol];\n        }\n\n        // Otherwise... this might refer to a RULE token i.e. a non-terminal: see if we can dig that one up.\n        //\n        // An example of this may be where a rule's action code contains a call like this:\n        //\n        //      parser.getSymbolName(#$)\n        //\n        // to obtain a human-readable name of the current grammar rule.\n        var s = this.symbols_;\n        for (var key in s) {\n            if (s[key] === symbol) {\n                return key;\n            }\n        }\n        return null;\n    },\n\n    // Return a more-or-less human-readable description of the given symbol, when available,\n    // or the symbol itself, serving as its own 'description' for lack of something better to serve up.\n    //\n    // Return NULL when the symbol is unknown to the parser.\n    describeSymbol: function parser_describeSymbol(symbol) {\n        if (symbol !== this.EOF && this.terminal_descriptions_ && this.terminal_descriptions_[symbol]) {\n            return this.terminal_descriptions_[symbol];\n        }\n        else if (symbol === this.EOF) {\n            return 'end of input';\n        }\n        var id = this.getSymbolName(symbol);\n        if (id) {\n            return this.quoteName(id);\n        }\n        return null;\n    },\n\n    // Produce a (more or less) human-readable list of expected tokens at the point of failure.\n    //\n    // The produced list may contain token or token set descriptions instead of the tokens\n    // themselves to help turning this output into something that easier to read by humans\n    // unless `do_not_describe` parameter is set, in which case a list of the raw, *numeric*,\n    // expected terminals and nonterminals is produced.\n    //\n    // The returned list (array) will not contain any duplicate entries.\n    collect_expected_token_set: function parser_collect_expected_token_set(state, do_not_describe) {\n        var TERROR = this.TERROR;\n        var tokenset = [];\n        var check = {};\n        // Has this (error?) state been outfitted with a custom expectations description text for human consumption?\n        // If so, use that one instead of the less palatable token set.\n        if (!do_not_describe && this.state_descriptions_ && this.state_descriptions_[state]) {\n            return [\n                this.state_descriptions_[state]\n            ];\n        }\n        for (var p in this.table[state]) {\n            p = +p;\n            if (p !== TERROR) {\n                var d = do_not_describe ? p : this.describeSymbol(p);\n                if (d && !check[d]) {\n                    tokenset.push(d);\n                    check[d] = true;        // Mark this token description as already mentioned to prevent outputting duplicate entries.\n                }\n            }\n        }\n        return tokenset;\n    },\nproductions_: bp({\n  pop: u([\n  89,\n  89,\n  90,\n  s,\n  [91, 5],\n  92,\n  93,\n  93,\n  s,\n  [94, 4],\n  s,\n  [95, 8],\n  96,\n  96,\n  s,\n  [97, 6],\n  s,\n  [98, 6],\n  99,\n  99,\n  s,\n  [100, 4],\n  s,\n  [101, 3],\n  s,\n  [102, 3],\n  s,\n  [103, 5],\n  s,\n  [104, 3],\n  105,\n  105,\n  106,\n  106,\n  107,\n  107,\n  108,\n  108,\n  109,\n  109,\n  110,\n  110,\n  111,\n  111,\n  s,\n  [112, 11],\n  113,\n  113,\n  114,\n  115,\n  115,\n  s,\n  [116, 8],\n  117,\n  117,\n  118,\n  118,\n  s,\n  [119, 3],\n  s,\n  [120, 13],\n  s,\n  [121, 3],\n  122,\n  122,\n  123,\n  123,\n  124,\n  s,\n  [125, 4],\n  126,\n  126,\n  127,\n  s,\n  [128, 5],\n  129,\n  129,\n  130,\n  130,\n  131,\n  132,\n  132,\n  133,\n  133,\n  s,\n  [134, 6],\n  s,\n  [135, 4],\n  136,\n  136,\n  137,\n  137,\n  138,\n  138,\n  s,\n  [139, 3],\n  140,\n  140,\n  s,\n  [141, 3],\n  s,\n  [142, 9],\n  s,\n  [143, 3],\n  144,\n  144,\n  s,\n  [145, 6],\n  s,\n  [146, 3],\n  147,\n  147,\n  148,\n  148,\n  149,\n  149,\n  150,\n  150,\n  s,\n  [151, 3],\n  s,\n  [152, 6],\n  s,\n  [153, 5],\n  154,\n  154,\n  155,\n  155,\n  156\n]),\n  rule: u([\n  2,\n  s,\n  [1, 9],\n  c,\n  [10, 4],\n  3,\n  1,\n  4,\n  3,\n  4,\n  3,\n  3,\n  2,\n  2,\n  c,\n  [10, 3],\n  s,\n  [2, 4],\n  4,\n  s,\n  [1, 7],\n  4,\n  1,\n  s,\n  [3, 3],\n  c,\n  [4, 3],\n  c,\n  [3, 6],\n  c,\n  [8, 7],\n  c,\n  [36, 3],\n  c,\n  [4, 6],\n  5,\n  c,\n  [4, 3],\n  s,\n  [1, 11],\n  c,\n  [59, 3],\n  c,\n  [3, 3],\n  c,\n  [80, 3],\n  c,\n  [4, 4],\n  c,\n  [32, 4],\n  s,\n  [1, 15],\n  5,\n  4,\n  c,\n  [107, 4],\n  2,\n  3,\n  c,\n  [31, 4],\n  c,\n  [114, 4],\n  5,\n  5,\n  6,\n  c,\n  [40, 8],\n  c,\n  [17, 4],\n  c,\n  [130, 4],\n  c,\n  [125, 3],\n  c,\n  [67, 4],\n  c,\n  [21, 3],\n  c,\n  [139, 3],\n  c,\n  [22, 4],\n  c,\n  [46, 3],\n  3,\n  3,\n  4,\n  c,\n  [4, 4],\n  c,\n  [33, 3],\n  c,\n  [83, 8],\n  c,\n  [41, 3],\n  c,\n  [39, 5],\n  c,\n  [31, 3],\n  5,\n  7,\n  5,\n  5,\n  7,\n  6,\n  7,\n  6,\n  7,\n  c,\n  [49, 3],\n  c,\n  [20, 6],\n  3\n])\n}),\nperformAction: function parser__PerformAction(yytext, yyloc, yystate /* action[1] */, yysp, yyvstack, yylstack) {\n\n          /* this == yyval */\n\n          // the JS engine itself can go and remove these statements when `yy` turns out to be unused in any action code!\n          var yy = this.yy;\n          var yyparser = yy.parser;\n          var yylexer = yy.lexer;\n\n          \n\n          switch (yystate) {\ncase 0:\n    /*! Production::    $accept : ast_tree $end */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,-,-,LT,LA,-,-):\n    this.$ = undefined;\n    this._$ = yylstack[yysp - 1];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,-,-,LT,LA,-,-)\n    break;\n\ncase 1:\n    /*! Production::    ast_tree : translation_unit EOF */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,-,-,LT,LA,-,-):\n    this.$ = undefined;\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,-,-,LT,LA,-,-)\n    \n    \n    return yyvstack[yysp - 1];\n    break;\n\ncase 2:\n    /*! Production::    ast_tree : EOF */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,-,-,LT,LA,-,-):\n    this.$ = undefined;\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,-,-,LT,LA,-,-)\n    \n    \n    return [];\n    break;\n\ncase 3:\n    /*! Production::    identifier : IDENTIFIER */\ncase 9:\n    /*! Production::    string_literal : STRING_LITERAL */\ncase 100:\n    /*! Production::    storage_class_specifier : TYPEDEF */\ncase 101:\n    /*! Production::    storage_class_specifier : EXTERN */\ncase 102:\n    /*! Production::    storage_class_specifier : STATIC */\ncase 103:\n    /*! Production::    type_specifier : VOID */\ncase 104:\n    /*! Production::    type_specifier : CHAR */\ncase 105:\n    /*! Production::    type_specifier : SHORT */\ncase 106:\n    /*! Production::    type_specifier : INT */\ncase 107:\n    /*! Production::    type_specifier : LONG */\ncase 108:\n    /*! Production::    type_specifier : FLOAT */\ncase 109:\n    /*! Production::    type_specifier : DOUBLE */\ncase 110:\n    /*! Production::    type_specifier : SIGNED */\ncase 111:\n    /*! Production::    type_specifier : UNSIGNED */\ncase 142:\n    /*! Production::    function_specifier : IMPORT */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (yytext);\n    break;\n\ncase 4:\n    /*! Production::    constant : CONSTANT_FLOAT */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.Constant(this._$, yytext, \"float\"));\n    break;\n\ncase 5:\n    /*! Production::    constant : CONSTANT_HEX */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.Constant(this._$, yytext, \"hex\"));\n    break;\n\ncase 6:\n    /*! Production::    constant : CONSTANT_OCTAL */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.Constant(this._$, yytext, \"oct\"));\n    break;\n\ncase 7:\n    /*! Production::    constant : CONSTANT_INT */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.Constant(this._$, yytext, \"int\"));\n    break;\n\ncase 8:\n    /*! Production::    constant : CONSTANT_CHAR */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.Constant(this._$, yytext, \"char\"));\n    break;\n\ncase 10:\n    /*! Production::    concat_string_literals : string_literal */\ncase 13:\n    /*! Production::    primary_expression : constant */\ncase 16:\n    /*! Production::    postfix_expression : primary_expression */\ncase 26:\n    /*! Production::    unary_expression : postfix_expression */\ncase 38:\n    /*! Production::    cast_expression : unary_expression */\ncase 40:\n    /*! Production::    multiplicative_expression : cast_expression */\ncase 44:\n    /*! Production::    additive_expression : multiplicative_expression */\ncase 47:\n    /*! Production::    shift_expression : additive_expression */\ncase 50:\n    /*! Production::    relational_expression : shift_expression */\ncase 55:\n    /*! Production::    equality_expression : relational_expression */\ncase 58:\n    /*! Production::    and_expression : equality_expression */\ncase 60:\n    /*! Production::    exclusive_or_expression : and_expression */\ncase 62:\n    /*! Production::    inclusive_or_expression : exclusive_or_expression */\ncase 64:\n    /*! Production::    logical_and_expression : inclusive_or_expression */\ncase 66:\n    /*! Production::    logical_or_expression : logical_and_expression */\ncase 68:\n    /*! Production::    conditional_expression : logical_or_expression */\ncase 70:\n    /*! Production::    assignment_expression : conditional_expression */\ncase 83:\n    /*! Production::    expression : assignment_expression */\ncase 98:\n    /*! Production::    init_declarator : declarator */\ncase 113:\n    /*! Production::    type_specifier : struct_or_union_specifier */\ncase 114:\n    /*! Production::    type_specifier : enum_specifier */\ncase 130:\n    /*! Production::    struct_declarator : declarator */\ncase 144:\n    /*! Production::    declarator : direct_declarator */\ncase 167:\n    /*! Production::    abstract_declarator : direct_abstract_declarator */\ncase 178:\n    /*! Production::    initializer : assignment_expression */\ncase 183:\n    /*! Production::    statement : labeled_statement */\ncase 184:\n    /*! Production::    statement : compound_statement */\ncase 185:\n    /*! Production::    statement : expression_statement */\ncase 186:\n    /*! Production::    statement : selection_statement */\ncase 187:\n    /*! Production::    statement : iteration_statement */\ncase 188:\n    /*! Production::    statement : jump_statement */\ncase 196:\n    /*! Production::    block_item : declaration */\ncase 197:\n    /*! Production::    block_item : statement */\ncase 216:\n    /*! Production::    external_declaration : function_definition */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (yyvstack[yysp]);\n    break;\n\ncase 11:\n    /*! Production::    concat_string_literals : concat_string_literals string_literal */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (yyvstack[yysp - 1] + yyvstack[yysp]);\n    break;\n\ncase 12:\n    /*! Production::    primary_expression : identifier */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.Identifier(this._$, yytext));\n    break;\n\ncase 14:\n    /*! Production::    primary_expression : concat_string_literals */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.StringLiteral(this._$, yyvstack[yysp]));\n    break;\n\ncase 15:\n    /*! Production::    primary_expression : \"(\" expression \")\" */\ncase 146:\n    /*! Production::    direct_declarator : \"(\" declarator \")\" */\ncase 169:\n    /*! Production::    direct_abstract_declarator : \"(\" abstract_declarator \")\" */\ncase 179:\n    /*! Production::    initializer : \"{\" initializer_list \"}\" */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (yyvstack[yysp - 1]);\n    break;\n\ncase 17:\n    /*! Production::    postfix_expression : postfix_expression \"[\" expression \"]\" */\n\n    // default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);\n    // END of default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"arraySubscript\", yyvstack[yysp - 3], yyvstack[yysp - 1]));\n    break;\n\ncase 18:\n    /*! Production::    postfix_expression : postfix_expression \"(\" \")\" */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.FunctionCallExpression(this._$, yyvstack[yysp - 2]));\n    break;\n\ncase 19:\n    /*! Production::    postfix_expression : postfix_expression \"(\" argument_expression_list \")\" */\n\n    // default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);\n    // END of default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.FunctionCallExpression(this._$, yyvstack[yysp - 3], yyvstack[yysp - 1]));\n    break;\n\ncase 20:\n    /*! Production::    postfix_expression : postfix_expression \".\" identifier */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.MemberAccessExpression(this._$, false, yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 21:\n    /*! Production::    postfix_expression : postfix_expression \"->\" identifier */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.MemberAccessExpression(this._$, true, yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 22:\n    /*! Production::    postfix_expression : postfix_expression \"++\" */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.UnaryExpression(this._$, \"postfixIncrement\", yyvstack[yysp - 1]));\n    break;\n\ncase 23:\n    /*! Production::    postfix_expression : postfix_expression \"--\" */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.UnaryExpression(this._$, \"postfixDecrement\", yyvstack[yysp - 1]));\n    break;\n\ncase 24:\n    /*! Production::    argument_expression_list : assignment_expression */\ncase 96:\n    /*! Production::    init_declarator_list : init_declarator */\ncase 121:\n    /*! Production::    struct_declaration_list : struct_declaration */\ncase 128:\n    /*! Production::    struct_declarator_list : struct_declarator */\ncase 136:\n    /*! Production::    enumerator_list : enumerator */\ncase 155:\n    /*! Production::    type_qualifier_list : type_qualifier */\ncase 159:\n    /*! Production::    parameter_list : parameter_declaration */\ncase 181:\n    /*! Production::    initializer_list : initializer */\ncase 194:\n    /*! Production::    block_item_list : block_item */\ncase 214:\n    /*! Production::    translation_unit : external_declaration */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = ([yyvstack[yysp]]);\n    break;\n\ncase 25:\n    /*! Production::    argument_expression_list : argument_expression_list \",\" assignment_expression */\ncase 97:\n    /*! Production::    init_declarator_list : init_declarator_list \",\" init_declarator */\ncase 129:\n    /*! Production::    struct_declarator_list : struct_declarator_list \",\" struct_declarator */\ncase 137:\n    /*! Production::    enumerator_list : enumerator_list \",\" enumerator */\ncase 160:\n    /*! Production::    parameter_list : parameter_list \",\" parameter_declaration */\ncase 182:\n    /*! Production::    initializer_list : initializer_list \",\" initializer */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = ((yyvstack[yysp - 2].push(yyvstack[yysp]), yyvstack[yysp - 2]));\n    break;\n\ncase 27:\n    /*! Production::    unary_expression : \"++\" unary_expression */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.UnaryExpression(this._$, \"prefixIncrement\", yyvstack[yysp]));\n    break;\n\ncase 28:\n    /*! Production::    unary_expression : \"--\" unary_expression */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.UnaryExpression(this._$, \"prefixDecrement\", yyvstack[yysp]));\n    break;\n\ncase 29:\n    /*! Production::    unary_expression : unary_operator cast_expression */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.UnaryExpression(this._$, yyvstack[yysp - 1], yyvstack[yysp]));\n    break;\n\ncase 30:\n    /*! Production::    unary_expression : SIZEOF unary_expression */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.SizeofExpression(this._$, yyvstack[yysp]));\n    break;\n\ncase 31:\n    /*! Production::    unary_expression : SIZEOF \"(\" type_name \")\" */\n\n    // default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);\n    // END of default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.SizeofExpression(this._$, yyvstack[yysp - 1]));\n    break;\n\ncase 32:\n    /*! Production::    unary_operator : \"&\" */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"addressOf\");\n    break;\n\ncase 33:\n    /*! Production::    unary_operator : \"*\" */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"dereference\");\n    break;\n\ncase 34:\n    /*! Production::    unary_operator : \"+\" */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"unaryPlus\");\n    break;\n\ncase 35:\n    /*! Production::    unary_operator : \"-\" */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"unaryMinus\");\n    break;\n\ncase 36:\n    /*! Production::    unary_operator : \"~\" */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"bitwiseNot\");\n    break;\n\ncase 37:\n    /*! Production::    unary_operator : \"!\" */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"logicalNot\");\n    break;\n\ncase 39:\n    /*! Production::    cast_expression : \"(\" type_name \")\" cast_expression */\n\n    // default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);\n    // END of default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.CastExpression(this._$, yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 41:\n    /*! Production::    multiplicative_expression : multiplicative_expression \"*\" cast_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"mul\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 42:\n    /*! Production::    multiplicative_expression : multiplicative_expression \"/\" cast_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"div\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 43:\n    /*! Production::    multiplicative_expression : multiplicative_expression \"%\" cast_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"mod\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 45:\n    /*! Production::    additive_expression : additive_expression \"+\" multiplicative_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"add\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 46:\n    /*! Production::    additive_expression : additive_expression \"-\" multiplicative_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"sub\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 48:\n    /*! Production::    shift_expression : shift_expression \"<<\" additive_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"bitwiseShiftLeft\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 49:\n    /*! Production::    shift_expression : shift_expression \">>\" additive_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"bitwiseShiftRight\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 51:\n    /*! Production::    relational_expression : relational_expression \"<\" shift_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"relationalLT\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 52:\n    /*! Production::    relational_expression : relational_expression \">\" shift_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"relationalGT\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 53:\n    /*! Production::    relational_expression : relational_expression \"<=\" shift_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"relationalLEq\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 54:\n    /*! Production::    relational_expression : relational_expression \">=\" shift_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"relationalGEq\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 56:\n    /*! Production::    equality_expression : equality_expression \"==\" relational_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"relationalEq\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 57:\n    /*! Production::    equality_expression : equality_expression \"!=\" relational_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"relationalNEq\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 59:\n    /*! Production::    and_expression : and_expression \"&\" equality_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"bitwiseAnd\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 61:\n    /*! Production::    exclusive_or_expression : exclusive_or_expression \"^\" and_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"bitwiseXor\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 63:\n    /*! Production::    inclusive_or_expression : inclusive_or_expression \"|\" exclusive_or_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"bitwiseOr\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 65:\n    /*! Production::    logical_and_expression : logical_and_expression \"&&\" inclusive_or_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"logicalAnd\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 67:\n    /*! Production::    logical_or_expression : logical_or_expression \"||\" logical_and_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"logicalOr\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 69:\n    /*! Production::    conditional_expression : logical_or_expression \"?\" expression \":\" conditional_expression */\n\n    // default action (generated by JISON mode none/merge :: 5,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 4, yysp);\n    // END of default action (generated by JISON mode none/merge :: 5,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.ConditionalExpression(this._$, yyvstack[yysp - 4], yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 71:\n    /*! Production::    assignment_expression : unary_expression assignment_operator assignment_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.AssignmentExpression(this._$, yyvstack[yysp - 1], yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 72:\n    /*! Production::    assignment_operator : \"=\" */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (undefined);\n    break;\n\ncase 73:\n    /*! Production::    assignment_operator : \"*=\" */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"mul\");\n    break;\n\ncase 74:\n    /*! Production::    assignment_operator : \"/=\" */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"div\");\n    break;\n\ncase 75:\n    /*! Production::    assignment_operator : \"%=\" */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"mod\");\n    break;\n\ncase 76:\n    /*! Production::    assignment_operator : \"+=\" */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"add\");\n    break;\n\ncase 77:\n    /*! Production::    assignment_operator : \"-=\" */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"sub\");\n    break;\n\ncase 78:\n    /*! Production::    assignment_operator : \"<<=\" */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"leftShift\");\n    break;\n\ncase 79:\n    /*! Production::    assignment_operator : \">>=\" */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"rightShift\");\n    break;\n\ncase 80:\n    /*! Production::    assignment_operator : \"&=\" */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"bitwiseAnd\");\n    break;\n\ncase 81:\n    /*! Production::    assignment_operator : \"^=\" */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"bitwiseXor\");\n    break;\n\ncase 82:\n    /*! Production::    assignment_operator : \"|=\" */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"bitwiseOr\");\n    break;\n\ncase 84:\n    /*! Production::    expression : expression \",\" assignment_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"comma\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 85:\n    /*! Production::    constant_expression : conditional_expression */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.ConstantExpression(this._$, yyvstack[yysp]));\n    break;\n\ncase 86:\n    /*! Production::    declaration : declaration_specifiers \";\" */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.Declaration(this._$, yyvstack[yysp - 1]));\n    break;\n\ncase 87:\n    /*! Production::    declaration : declaration_specifiers init_declarator_list \";\" */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.Declaration(this._$, yyvstack[yysp - 2], yyvstack[yysp - 1]));\n    break;\n\ncase 88:\n    /*! Production::    declaration_specifiers : storage_class_specifier */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.DeclarationSpecifiers(this._$, [], [], [yyvstack[yysp]], []));\n    break;\n\ncase 89:\n    /*! Production::    declaration_specifiers : storage_class_specifier declaration_specifiers */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.DeclarationSpecifiers(this._$, yyvstack[yysp].specifierList, yyvstack[yysp].qualifierList, [yyvstack[yysp - 1], ...yyvstack[yysp].storageList], yyvstack[yysp].fnSpecifierList));\n    break;\n\ncase 90:\n    /*! Production::    declaration_specifiers : type_specifier */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.DeclarationSpecifiers(this._$, [yyvstack[yysp]], [], [], []));\n    break;\n\ncase 91:\n    /*! Production::    declaration_specifiers : type_specifier declaration_specifiers */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.DeclarationSpecifiers(this._$, [yyvstack[yysp - 1], ...yyvstack[yysp].specifierList], yyvstack[yysp].qualifierList, yyvstack[yysp].storageList, yyvstack[yysp].fnSpecifierList));\n    break;\n\ncase 92:\n    /*! Production::    declaration_specifiers : type_qualifier */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.DeclarationSpecifiers(this._$, [], [yyvstack[yysp]], [], []));\n    break;\n\ncase 93:\n    /*! Production::    declaration_specifiers : type_qualifier declaration_specifiers */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.DeclarationSpecifiers(this._$, yyvstack[yysp].specifierList, [yyvstack[yysp - 1], ...yyvstack[yysp].qualifierList], yyvstack[yysp].storageList, yyvstack[yysp].fnSpecifierList));\n    break;\n\ncase 94:\n    /*! Production::    declaration_specifiers : function_specifier */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.DeclarationSpecifiers(this._$, [], [], [], [yyvstack[yysp]]));\n    break;\n\ncase 95:\n    /*! Production::    declaration_specifiers : function_specifier declaration_specifiers */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.DeclarationSpecifiers(this._$, yyvstack[yysp].specifierList, yyvstack[yysp].qualifierList, yyvstack[yysp].storageList, [yyvstack[yysp - 1], ...yyvstack[yysp].fnSpecifierList]));\n    break;\n\ncase 99:\n    /*! Production::    init_declarator : declarator \"=\" initializer */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.InitDeclarator(this._$, yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 112:\n    /*! Production::    type_specifier : _BOOL */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"bool\");\n    break;\n\ncase 115:\n    /*! Production::    type_specifier : TYPE_NAME */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.CustomTypeSpecifier(this._$, yyvstack[yysp]));\n    break;\n\ncase 116:\n    /*! Production::    struct_or_union_specifier : struct_or_union identifier \"{\" struct_declaration_list \"}\" */\n\n    // default action (generated by JISON mode none/merge :: 5,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 4, yysp);\n    // END of default action (generated by JISON mode none/merge :: 5,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.StructUnionSpecifier(this._$, yyvstack[yysp - 4], yyvstack[yysp - 3], yyvstack[yysp - 1]));\n    break;\n\ncase 117:\n    /*! Production::    struct_or_union_specifier : struct_or_union \"{\" struct_declaration_list \"}\" */\n\n    // default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);\n    // END of default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.StructUnionSpecifier(this._$, yyvstack[yysp - 3], undefined, yyvstack[yysp - 1]));\n    break;\n\ncase 118:\n    /*! Production::    struct_or_union_specifier : struct_or_union identifier */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.StructUnionSpecifier(this._$, yyvstack[yysp - 1], yyvstack[yysp]));\n    break;\n\ncase 119:\n    /*! Production::    struct_or_union : STRUCT */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"struct\");\n    break;\n\ncase 120:\n    /*! Production::    struct_or_union : UNION */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"union\");\n    break;\n\ncase 122:\n    /*! Production::    struct_declaration_list : struct_declaration_list struct_declaration */\ncase 156:\n    /*! Production::    type_qualifier_list : type_qualifier_list type_qualifier */\ncase 195:\n    /*! Production::    block_item_list : block_item_list block_item */\ncase 215:\n    /*! Production::    translation_unit : translation_unit external_declaration */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = ((yyvstack[yysp - 1].push(yyvstack[yysp]), yyvstack[yysp - 1]));\n    break;\n\ncase 123:\n    /*! Production::    struct_declaration : specifier_qualifier_list struct_declarator_list \";\" */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.StructDeclaration(this._$, yyvstack[yysp - 2], yyvstack[yysp - 1]));\n    break;\n\ncase 124:\n    /*! Production::    specifier_qualifier_list : type_specifier specifier_qualifier_list */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.SpecifierQualifiers(this._$, [yyvstack[yysp - 1], ...yyvstack[yysp].specifierList], yyvstack[yysp].qualifierList));\n    break;\n\ncase 125:\n    /*! Production::    specifier_qualifier_list : type_specifier */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.SpecifierQualifiers(this._$, [yyvstack[yysp]], []));\n    break;\n\ncase 126:\n    /*! Production::    specifier_qualifier_list : type_qualifier specifier_qualifier_list */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.SpecifierQualifiers(this._$, yyvstack[yysp].specifierList, [yyvstack[yysp - 1], ...yyvstack[yysp].qualifierList]));\n    break;\n\ncase 127:\n    /*! Production::    specifier_qualifier_list : type_qualifier */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.SpecifierQualifiers(this._$, [], [yyvstack[yysp]]));\n    break;\n\ncase 131:\n    /*! Production::    enum_specifier : ENUM \"{\" enumerator_list \"}\" */\n\n    // default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);\n    // END of default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.EnumSpecifier(this._$, undefined, yyvstack[yysp - 1]));\n    break;\n\ncase 132:\n    /*! Production::    enum_specifier : ENUM identifier \"{\" enumerator_list \"}\" */\n\n    // default action (generated by JISON mode none/merge :: 5,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 4, yysp);\n    // END of default action (generated by JISON mode none/merge :: 5,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.EnumSpecifier(this._$, yyvstack[yysp - 3], yyvstack[yysp - 1]));\n    break;\n\ncase 133:\n    /*! Production::    enum_specifier : ENUM \"{\" enumerator_list \",\" \"}\" */\n\n    // default action (generated by JISON mode none/merge :: 5,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 4, yysp);\n    // END of default action (generated by JISON mode none/merge :: 5,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.EnumSpecifier(this._$, undefined, yyvstack[yysp - 2]));\n    break;\n\ncase 134:\n    /*! Production::    enum_specifier : ENUM identifier \"{\" enumerator_list \",\" \"}\" */\n\n    // default action (generated by JISON mode none/merge :: 6,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 5, yysp);\n    // END of default action (generated by JISON mode none/merge :: 6,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.EnumSpecifier(this._$, yyvstack[yysp - 4], yyvstack[yysp - 2]));\n    break;\n\ncase 135:\n    /*! Production::    enum_specifier : ENUM identifier */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.EnumSpecifier(this._$, yyvstack[yysp]));\n    break;\n\ncase 138:\n    /*! Production::    enumerator : identifier */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.Enumerator(this._$, yyvstack[yysp]));\n    break;\n\ncase 139:\n    /*! Production::    enumerator : identifier \"=\" constant_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.Enumerator(this._$, yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 140:\n    /*! Production::    type_qualifier : CONST */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"const\");\n    break;\n\ncase 141:\n    /*! Production::    function_specifier : INLINE */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"inline\");\n    break;\n\ncase 143:\n    /*! Production::    declarator : pointer direct_declarator */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.PointerDeclarator(this._$, yyvstack[yysp - 1], yyvstack[yysp]));\n    break;\n\ncase 145:\n    /*! Production::    direct_declarator : identifier */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.IdentifierDeclarator(this._$, yyvstack[yysp]));\n    break;\n\ncase 147:\n    /*! Production::    direct_declarator : direct_declarator \"[\" constant_expression \"]\" */\n\n    // default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);\n    // END of default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.ArrayDeclarator(this._$, yyvstack[yysp - 3], yyvstack[yysp - 1]));\n    break;\n\ncase 148:\n    /*! Production::    direct_declarator : direct_declarator \"[\" \"]\" */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.ArrayDeclarator(this._$, yyvstack[yysp - 2]));\n    break;\n\ncase 149:\n    /*! Production::    direct_declarator : direct_declarator \"(\" parameter_type_list \")\" */\n\n    // default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);\n    // END of default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.FunctionDeclarator(this._$, yyvstack[yysp - 3], yyvstack[yysp - 1], yyvstack[yysp - 1].variadic));\n    break;\n\ncase 150:\n    /*! Production::    direct_declarator : direct_declarator \"(\" \")\" */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.FunctionDeclarator(this._$, yyvstack[yysp - 2]));\n    break;\n\ncase 151:\n    /*! Production::    pointer : \"*\" */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.Pointer(this._$));\n    break;\n\ncase 152:\n    /*! Production::    pointer : \"*\" type_qualifier_list */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.Pointer(this._$, yyvstack[yysp]));\n    break;\n\ncase 153:\n    /*! Production::    pointer : \"*\" pointer */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.Pointer(this._$, undefined, yyvstack[yysp]));\n    break;\n\ncase 154:\n    /*! Production::    pointer : \"*\" type_qualifier_list pointer */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.Pointer(this._$, yyvstack[yysp - 1], yyvstack[yysp]));\n    break;\n\ncase 157:\n    /*! Production::    parameter_type_list : parameter_list */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = ((yyvstack[yysp].variadic = false, yyvstack[yysp]));\n    break;\n\ncase 158:\n    /*! Production::    parameter_type_list : parameter_list \",\" \"...\" */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = ((yyvstack[yysp - 2].variadic = true, yyvstack[yysp - 2]));\n    break;\n\ncase 161:\n    /*! Production::    parameter_declaration : declaration_specifiers declarator */\ncase 162:\n    /*! Production::    parameter_declaration : declaration_specifiers abstract_declarator */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.ParameterDeclaration(this._$, yyvstack[yysp - 1], yyvstack[yysp]));\n    break;\n\ncase 163:\n    /*! Production::    parameter_declaration : declaration_specifiers */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.ParameterDeclaration(this._$, yyvstack[yysp]));\n    break;\n\ncase 164:\n    /*! Production::    type_name : specifier_qualifier_list */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.TypeName(this._$, yyvstack[yysp]));\n    break;\n\ncase 165:\n    /*! Production::    type_name : specifier_qualifier_list abstract_declarator */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.TypeName(this._$, yyvstack[yysp - 1], yyvstack[yysp]));\n    break;\n\ncase 166:\n    /*! Production::    abstract_declarator : pointer */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.AbstractPointerDeclarator(this._$, yyvstack[yysp]));\n    break;\n\ncase 168:\n    /*! Production::    abstract_declarator : pointer direct_abstract_declarator */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.AbstractPointerDeclarator(this._$, yyvstack[yysp - 1], yyvstack[yysp]));\n    break;\n\ncase 170:\n    /*! Production::    direct_abstract_declarator : \"[\" \"]\" */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.AbstractArrayDeclarator(this._$));\n    break;\n\ncase 171:\n    /*! Production::    direct_abstract_declarator : \"[\" constant_expression \"]\" */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.AbstractArrayDeclarator(this._$, undefined, yyvstack[yysp - 1]));\n    break;\n\ncase 172:\n    /*! Production::    direct_abstract_declarator : direct_abstract_declarator \"[\" \"]\" */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.AbstractArrayDeclarator(this._$, yyvstack[yysp - 2]));\n    break;\n\ncase 173:\n    /*! Production::    direct_abstract_declarator : direct_abstract_declarator \"[\" constant_expression \"]\" */\n\n    // default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);\n    // END of default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.AbstractArrayDeclarator(this._$, yyvstack[yysp - 3], yyvstack[yysp - 1]));\n    break;\n\ncase 174:\n    /*! Production::    direct_abstract_declarator : \"(\" \")\" */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.AbstractFunctionDeclarator(this._$));\n    break;\n\ncase 175:\n    /*! Production::    direct_abstract_declarator : \"(\" parameter_type_list \")\" */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.AbstractFunctionDeclarator(this._$, undefined, yyvstack[yysp - 1], yyvstack[yysp - 1].variadic));\n    break;\n\ncase 176:\n    /*! Production::    direct_abstract_declarator : direct_abstract_declarator \"(\" \")\" */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.AbstractFunctionDeclarator(this._$, yyvstack[yysp - 2]));\n    break;\n\ncase 177:\n    /*! Production::    direct_abstract_declarator : direct_abstract_declarator \"(\" parameter_type_list \")\" */\n\n    // default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);\n    // END of default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.AbstractFunctionDeclarator(this._$, yyvstack[yysp - 3], yyvstack[yysp - 1], yyvstack[yysp - 1].variadic));\n    break;\n\ncase 180:\n    /*! Production::    initializer : \"{\" initializer_list \",\" \"}\" */\n\n    // default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);\n    // END of default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (yyvstack[yysp - 2]);\n    break;\n\ncase 189:\n    /*! Production::    labeled_statement : identifier \":\" statement */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (yyvstack[yysp].setLabel(yyvstack[yysp - 2]));\n    break;\n\ncase 190:\n    /*! Production::    labeled_statement : CASE constant_expression \":\" statement */\n\n    // default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);\n    // END of default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.CaseStatement(this._$, yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 191:\n    /*! Production::    labeled_statement : DEFAULT \":\" statement */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.DefaultStatement(this._$, yyvstack[yysp]));\n    break;\n\ncase 192:\n    /*! Production::    compound_statement : \"{\" \"}\" */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.CompoundStatement(this._$, []));\n    break;\n\ncase 193:\n    /*! Production::    compound_statement : \"{\" block_item_list \"}\" */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.CompoundStatement(this._$, yyvstack[yysp - 1]));\n    break;\n\ncase 198:\n    /*! Production::    expression_statement : \";\" */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.NoOp(this._$));\n    break;\n\ncase 199:\n    /*! Production::    expression_statement : expression \";\" */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.ExpressionStatement(this._$, yyvstack[yysp - 1]));\n    break;\n\ncase 200:\n    /*! Production::    selection_statement : IF \"(\" expression \")\" statement */\n\n    // default action (generated by JISON mode none/merge :: 5,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 4, yysp);\n    // END of default action (generated by JISON mode none/merge :: 5,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.IfStatement(this._$, yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 201:\n    /*! Production::    selection_statement : IF \"(\" expression \")\" statement ELSE statement */\n\n    // default action (generated by JISON mode none/merge :: 7,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 6, yysp);\n    // END of default action (generated by JISON mode none/merge :: 7,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.IfStatement(this._$, yyvstack[yysp - 4], yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 202:\n    /*! Production::    selection_statement : SWITCH \"(\" expression \")\" statement */\n\n    // default action (generated by JISON mode none/merge :: 5,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 4, yysp);\n    // END of default action (generated by JISON mode none/merge :: 5,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.SwitchStatement(this._$, yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 203:\n    /*! Production::    iteration_statement : WHILE \"(\" expression \")\" statement */\n\n    // default action (generated by JISON mode none/merge :: 5,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 4, yysp);\n    // END of default action (generated by JISON mode none/merge :: 5,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.WhileLoop(this._$, yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 204:\n    /*! Production::    iteration_statement : DO statement WHILE \"(\" expression \")\" \";\" */\n\n    // default action (generated by JISON mode none/merge :: 7,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 6, yysp);\n    // END of default action (generated by JISON mode none/merge :: 7,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.DoWhileLoop(this._$, yyvstack[yysp - 5], yyvstack[yysp - 2]));\n    break;\n\ncase 205:\n    /*! Production::    iteration_statement : FOR \"(\" expression_statement expression_statement \")\" statement */\ncase 207:\n    /*! Production::    iteration_statement : FOR \"(\" declaration expression_statement \")\" statement */\n\n    // default action (generated by JISON mode none/merge :: 6,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 5, yysp);\n    // END of default action (generated by JISON mode none/merge :: 6,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.ForLoop(this._$, yyvstack[yysp - 3], yyvstack[yysp - 2], undefined, yyvstack[yysp]));\n    break;\n\ncase 206:\n    /*! Production::    iteration_statement : FOR \"(\" expression_statement expression_statement expression \")\" statement */\ncase 208:\n    /*! Production::    iteration_statement : FOR \"(\" declaration expression_statement expression \")\" statement */\n\n    // default action (generated by JISON mode none/merge :: 7,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 6, yysp);\n    // END of default action (generated by JISON mode none/merge :: 7,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.ForLoop(this._$, yyvstack[yysp - 4], yyvstack[yysp - 3], yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 209:\n    /*! Production::    jump_statement : GOTO identifier \";\" */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.GotoStatement(this._$, yyvstack[yysp - 1]));\n    break;\n\ncase 210:\n    /*! Production::    jump_statement : CONTINUE \";\" */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.ContinueStatement(this._$));\n    break;\n\ncase 211:\n    /*! Production::    jump_statement : BREAK \";\" */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BreakStatement(this._$));\n    break;\n\ncase 212:\n    /*! Production::    jump_statement : RETURN \";\" */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.ReturnStatement(this._$));\n    break;\n\ncase 213:\n    /*! Production::    jump_statement : RETURN expression \";\" */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.ReturnStatement(this._$, yyvstack[yysp - 1]));\n    break;\n\ncase 217:\n    /*! Production::    external_declaration : declaration */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = ((yylexer.externalDeclaration(yyvstack[yysp]), yyvstack[yysp]));\n    break;\n\ncase 218:\n    /*! Production::    function_definition : declaration_specifiers declarator compound_statement */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.FunctionDefinition(this._$, yyvstack[yysp - 2], yyvstack[yysp - 1], yyvstack[yysp]));\n    break;\n\n}\n},\ntable: bt({\n  len: u([\n  34,\n  1,\n  32,\n  s,\n  [0, 4],\n  10,\n  s,\n  [35, 4],\n  s,\n  [0, 19],\n  3,\n  3,\n  s,\n  [0, 4],\n  5,\n  0,\n  2,\n  4,\n  7,\n  0,\n  10,\n  0,\n  7,\n  s,\n  [0, 5],\n  28,\n  23,\n  4,\n  28,\n  0,\n  40,\n  91,\n  0,\n  8,\n  7,\n  39,\n  32,\n  9,\n  0,\n  0,\n  1,\n  23,\n  23,\n  0,\n  9,\n  26,\n  26,\n  2,\n  0,\n  3,\n  4,\n  0,\n  0,\n  41,\n  0,\n  37,\n  8,\n  42,\n  25,\n  25,\n  26,\n  25,\n  c,\n  [25, 3],\n  s,\n  [0, 5],\n  10,\n  0,\n  0,\n  44,\n  61,\n  11,\n  s,\n  [0, 6],\n  12,\n  0,\n  14,\n  18,\n  20,\n  22,\n  25,\n  0,\n  0,\n  90,\n  c,\n  [25, 6],\n  s,\n  [0, 4],\n  39,\n  38,\n  1,\n  0,\n  2,\n  s,\n  [1, 3],\n  59,\n  1,\n  c,\n  [6, 3],\n  40,\n  c,\n  [113, 3],\n  1,\n  s,\n  [0, 3],\n  c,\n  [19, 3],\n  c,\n  [45, 3],\n  0,\n  0,\n  23,\n  0,\n  c,\n  [9, 3],\n  s,\n  [0, 4],\n  4,\n  38,\n  2,\n  2,\n  0,\n  38,\n  s,\n  [0, 11],\n  39,\n  35,\n  39,\n  40,\n  c,\n  [19, 3],\n  c,\n  [9, 3],\n  s,\n  [0, 3],\n  61,\n  34,\n  33,\n  c,\n  [68, 3],\n  7,\n  32,\n  31,\n  30,\n  30,\n  s,\n  [29, 4],\n  28,\n  28,\n  27,\n  27,\n  s,\n  [26, 3],\n  0,\n  0,\n  59,\n  1,\n  59,\n  0,\n  38,\n  s,\n  [39, 3],\n  1,\n  70,\n  c,\n  [85, 4],\n  c,\n  [46, 3],\n  30,\n  0,\n  0,\n  8,\n  4,\n  42,\n  c,\n  [51, 3],\n  8,\n  c,\n  [85, 5],\n  c,\n  [174, 3],\n  2,\n  9,\n  2,\n  c,\n  [99, 5],\n  1,\n  10,\n  11,\n  0,\n  26,\n  c,\n  [103, 3],\n  12,\n  14,\n  18,\n  18,\n  s,\n  [20, 4],\n  22,\n  22,\n  25,\n  c,\n  [168, 3],\n  c,\n  [67, 3],\n  c,\n  [56, 3],\n  2,\n  2,\n  1,\n  41,\n  41,\n  c,\n  [49, 5],\n  39,\n  32,\n  1,\n  c,\n  [156, 3],\n  c,\n  [77, 4],\n  0,\n  37,\n  0,\n  c,\n  [144, 5],\n  s,\n  [59, 3],\n  39,\n  40,\n  40,\n  c,\n  [21, 8],\n  0,\n  52,\n  c,\n  [47, 3],\n  59,\n  2,\n  59,\n  c,\n  [82, 3],\n  59,\n  1,\n  c,\n  [60, 3],\n  c,\n  [62, 3],\n  0,\n  0\n]),\n  symbol: u([\n  1,\n  s,\n  [56, 20, 1],\n  89,\n  115,\n  116,\n  s,\n  [119, 4, 1],\n  128,\n  131,\n  132,\n  154,\n  155,\n  156,\n  1,\n  c,\n  [35, 21],\n  c,\n  [34, 9],\n  155,\n  156,\n  3,\n  10,\n  24,\n  27,\n  90,\n  117,\n  118,\n  133,\n  134,\n  135,\n  3,\n  4,\n  5,\n  8,\n  c,\n  [13, 3],\n  c,\n  [48, 20],\n  c,\n  [47, 8],\n  c,\n  [35, 105],\n  25,\n  27,\n  90,\n  c,\n  [3, 3],\n  8,\n  23,\n  24,\n  25,\n  147,\n  8,\n  24,\n  3,\n  27,\n  90,\n  134,\n  c,\n  [52, 4],\n  c,\n  [14, 3],\n  c,\n  [59, 5],\n  27,\n  73,\n  131,\n  135,\n  136,\n  3,\n  10,\n  27,\n  90,\n  c,\n  [181, 9],\n  25,\n  c,\n  [77, 21],\n  c,\n  [17, 15],\n  s,\n  [120, 6, 1],\n  128,\n  131,\n  27,\n  90,\n  129,\n  130,\n  c,\n  [55, 28],\n  3,\n  s,\n  [9, 6, 1],\n  25,\n  s,\n  [27, 7, 1],\n  35,\n  36,\n  37,\n  s,\n  [90, 6, 1],\n  s,\n  [97, 15, 1],\n  143,\n  c,\n  [40, 7],\n  s,\n  [24, 10, 1],\n  c,\n  [42, 3],\n  c,\n  [80, 20],\n  77,\n  78,\n  79,\n  s,\n  [81, 8, 1],\n  c,\n  [73, 21],\n  113,\n  c,\n  [398, 9],\n  s,\n  [145, 9, 1],\n  c,\n  [221, 4],\n  c,\n  [403, 8],\n  c,\n  [246, 4],\n  6,\n  c,\n  [107, 6],\n  c,\n  [146, 30],\n  114,\n  4,\n  c,\n  [338, 28],\n  137,\n  138,\n  139,\n  c,\n  [317, 9],\n  4,\n  c,\n  [282, 23],\n  26,\n  c,\n  [24, 18],\n  c,\n  [23, 4],\n  c,\n  [142, 4],\n  126,\n  127,\n  c,\n  [143, 6],\n  10,\n  27,\n  c,\n  [36, 18],\n  c,\n  [35, 4],\n  c,\n  [26, 25],\n  8,\n  26,\n  8,\n  23,\n  26,\n  c,\n  [371, 5],\n  c,\n  [343, 39],\n  144,\n  4,\n  6,\n  s,\n  [8, 5, 1],\n  s,\n  [15, 10, 1],\n  26,\n  s,\n  [38, 18, 1],\n  112,\n  c,\n  [37, 3],\n  21,\n  22,\n  24,\n  26,\n  45,\n  s,\n  [3, 10, 1],\n  c,\n  [48, 11],\n  34,\n  35,\n  36,\n  c,\n  [51, 18],\n  c,\n  [128, 7],\n  c,\n  [127, 18],\n  c,\n  [25, 50],\n  99,\n  c,\n  [26, 25],\n  c,\n  [151, 7],\n  44,\n  45,\n  c,\n  [9, 3],\n  c,\n  [140, 3],\n  c,\n  [10, 4],\n  c,\n  [162, 21],\n  s,\n  [33, 4, 1],\n  c,\n  [163, 18],\n  92,\n  c,\n  [88, 17],\n  c,\n  [339, 15],\n  c,\n  [576, 22],\n  c,\n  [361, 6],\n  140,\n  c,\n  [115, 3],\n  c,\n  [94, 4],\n  c,\n  [126, 7],\n  9,\n  c,\n  [12, 18],\n  c,\n  [109, 4],\n  c,\n  [14, 4],\n  c,\n  [134, 6],\n  24,\n  26,\n  c,\n  [127, 6],\n  c,\n  [18, 12],\n  c,\n  [147, 8],\n  c,\n  [20, 4],\n  11,\n  12,\n  c,\n  [22, 20],\n  c,\n  [199, 11],\n  c,\n  [25, 10],\n  c,\n  [778, 85],\n  c,\n  [777, 7],\n  c,\n  [1182, 9],\n  5,\n  c,\n  [325, 16],\n  c,\n  [486, 46],\n  c,\n  [810, 13],\n  22,\n  c,\n  [1109, 3],\n  s,\n  [3, 3],\n  c,\n  [183, 8],\n  c,\n  [46, 10],\n  c,\n  [162, 33],\n  c,\n  [153, 3],\n  c,\n  [152, 5],\n  27,\n  90,\n  24,\n  24,\n  c,\n  [64, 8],\n  c,\n  [722, 31],\n  113,\n  c,\n  [963, 3],\n  6,\n  4,\n  4,\n  8,\n  c,\n  [895, 6],\n  c,\n  [1205, 4],\n  141,\n  142,\n  c,\n  [874, 23],\n  8,\n  24,\n  c,\n  [811, 3],\n  c,\n  [810, 8],\n  c,\n  [196, 31],\n  c,\n  [857, 3],\n  26,\n  c,\n  [42, 37],\n  111,\n  c,\n  [38, 38],\n  113,\n  c,\n  [39, 35],\n  c,\n  [74, 40],\n  4,\n  c,\n  [40, 22],\n  s,\n  [96, 16, 1],\n  27,\n  90,\n  27,\n  90,\n  c,\n  [157, 56],\n  c,\n  [794, 44],\n  c,\n  [100, 34],\n  c,\n  [34, 33],\n  4,\n  8,\n  4,\n  c,\n  [1252, 4],\n  c,\n  [443, 3],\n  c,\n  [43, 32],\n  c,\n  [32, 31],\n  c,\n  [31, 30],\n  c,\n  [30, 59],\n  c,\n  [29, 115],\n  c,\n  [28, 55],\n  c,\n  [27, 53],\n  c,\n  [26, 59],\n  c,\n  [993, 52],\n  22,\n  c,\n  [1053, 60],\n  c,\n  [918, 111],\n  c,\n  [39, 43],\n  82,\n  c,\n  [1204, 18],\n  c,\n  [1449, 20],\n  c,\n  [1438, 31],\n  150,\n  24,\n  8,\n  24,\n  s,\n  [56, 21, 1],\n  c,\n  [33, 8],\n  c,\n  [2155, 5],\n  c,\n  [2486, 3],\n  142,\n  c,\n  [8, 4],\n  c,\n  [2076, 5],\n  c,\n  [102, 21],\n  c,\n  [47, 8],\n  c,\n  [1299, 3],\n  c,\n  [2207, 3],\n  c,\n  [859, 3],\n  c,\n  [2280, 38],\n  c,\n  [2192, 4],\n  c,\n  [2191, 4],\n  c,\n  [1324, 11],\n  c,\n  [1658, 12],\n  c,\n  [2135, 22],\n  8,\n  22,\n  c,\n  [1948, 9],\n  6,\n  8,\n  c,\n  [974, 3],\n  c,\n  [1953, 10],\n  c,\n  [1848, 11],\n  c,\n  [587, 27],\n  4,\n  5,\n  c,\n  [205, 4],\n  10,\n  c,\n  [2403, 28],\n  c,\n  [197, 6],\n  c,\n  [1916, 56],\n  c,\n  [1934, 30],\n  c,\n  [20, 60],\n  c,\n  [1994, 22],\n  c,\n  [2016, 43],\n  c,\n  [2041, 34],\n  c,\n  [805, 50],\n  c,\n  [387, 3],\n  c,\n  [391, 3],\n  c,\n  [1924, 9],\n  c,\n  [697, 32],\n  150,\n  c,\n  [41, 42],\n  c,\n  [627, 4],\n  c,\n  [2865, 70],\n  c,\n  [549, 3],\n  c,\n  [856, 37],\n  c,\n  [1009, 45],\n  c,\n  [1106, 59],\n  c,\n  [59, 118],\n  c,\n  [2030, 56],\n  c,\n  [40, 56],\n  6,\n  4,\n  c,\n  [2640, 43],\n  s,\n  [80, 9, 1],\n  c,\n  [588, 3],\n  c,\n  [653, 60],\n  c,\n  [61, 120],\n  c,\n  [2629, 9],\n  c,\n  [475, 110]\n]),\n  type: u([\n  s,\n  [2, 21],\n  s,\n  [0, 13],\n  1,\n  c,\n  [35, 32],\n  c,\n  [15, 10],\n  s,\n  [2, 27],\n  c,\n  [45, 12],\n  c,\n  [35, 103],\n  c,\n  [3, 6],\n  c,\n  [5, 8],\n  c,\n  [52, 15],\n  c,\n  [69, 6],\n  c,\n  [76, 31],\n  c,\n  [92, 25],\n  c,\n  [55, 46],\n  c,\n  [338, 16],\n  c,\n  [314, 13],\n  s,\n  [2, 47],\n  s,\n  [0, 40],\n  c,\n  [43, 8],\n  c,\n  [73, 46],\n  c,\n  [491, 36],\n  c,\n  [333, 19],\n  c,\n  [409, 26],\n  c,\n  [142, 15],\n  c,\n  [97, 21],\n  c,\n  [26, 38],\n  c,\n  [35, 21],\n  c,\n  [253, 26],\n  c,\n  [329, 34],\n  s,\n  [2, 67],\n  c,\n  [112, 25],\n  c,\n  [25, 33],\n  c,\n  [51, 43],\n  c,\n  [146, 46],\n  c,\n  [576, 61],\n  s,\n  [2, 173],\n  c,\n  [777, 42],\n  c,\n  [1182, 34],\n  c,\n  [105, 50],\n  c,\n  [162, 65],\n  c,\n  [428, 23],\n  c,\n  [409, 35],\n  c,\n  [874, 32],\n  c,\n  [927, 19],\n  c,\n  [1006, 54],\n  c,\n  [42, 27],\n  c,\n  [576, 39],\n  c,\n  [74, 74],\n  c,\n  [40, 24],\n  c,\n  [1420, 3],\n  c,\n  [1389, 71],\n  c,\n  [794, 46],\n  c,\n  [34, 50],\n  c,\n  [1657, 13],\n  c,\n  [43, 29],\n  c,\n  [32, 31],\n  c,\n  [31, 30],\n  c,\n  [30, 59],\n  c,\n  [29, 115],\n  c,\n  [28, 55],\n  c,\n  [27, 53],\n  c,\n  [26, 69],\n  c,\n  [1357, 73],\n  c,\n  [623, 63],\n  c,\n  [918, 78],\n  c,\n  [922, 61],\n  c,\n  [1438, 53],\n  c,\n  [56, 33],\n  c,\n  [2037, 26],\n  c,\n  [902, 45],\n  c,\n  [314, 25],\n  c,\n  [1413, 8],\n  c,\n  [97, 20],\n  c,\n  [1822, 76],\n  c,\n  [116, 13],\n  c,\n  [200, 38],\n  s,\n  [2, 266],\n  c,\n  [865, 54],\n  c,\n  [48, 41],\n  c,\n  [89, 45],\n  c,\n  [2865, 60],\n  c,\n  [73, 33],\n  c,\n  [2165, 68],\n  c,\n  [1166, 59],\n  c,\n  [59, 105],\n  c,\n  [2030, 63],\n  c,\n  [938, 93],\n  c,\n  [2875, 93],\n  c,\n  [61, 121],\n  c,\n  [475, 88]\n]),\n  state: u([\n  1,\n  s,\n  [6, 4, 1],\n  25,\n  31,\n  26,\n  10,\n  11,\n  2,\n  s,\n  [4, 6, 1],\n  c,\n  [12, 5],\n  36,\n  5,\n  44,\n  39,\n  42,\n  37,\n  41,\n  40,\n  47,\n  c,\n  [16, 7],\n  48,\n  c,\n  [8, 7],\n  49,\n  c,\n  [8, 7],\n  50,\n  c,\n  [8, 7],\n  51,\n  54,\n  55,\n  44,\n  60,\n  65,\n  64,\n  63,\n  44,\n  66,\n  41,\n  40,\n  71,\n  25,\n  31,\n  68,\n  69,\n  70,\n  26,\n  72,\n  75,\n  73,\n  74,\n  97,\n  98,\n  107,\n  99,\n  89,\n  83,\n  81,\n  86,\n  s,\n  [115, 6, -1],\n  108,\n  101,\n  96,\n  88,\n  82,\n  80,\n  78,\n  77,\n  128,\n  c,\n  [22, 19],\n  142,\n  132,\n  119,\n  121,\n  c,\n  [76, 7],\n  120,\n  122,\n  123,\n  117,\n  118,\n  s,\n  [124, 4, 1],\n  44,\n  143,\n  144,\n  41,\n  40,\n  c,\n  [67, 6],\n  148,\n  c,\n  [45, 12],\n  147,\n  145,\n  153,\n  c,\n  [43, 7],\n  149,\n  151,\n  152,\n  155,\n  154,\n  c,\n  [112, 3],\n  157,\n  c,\n  [112, 4],\n  c,\n  [8, 3],\n  159,\n  c,\n  [7, 3],\n  44,\n  160,\n  161,\n  162,\n  c,\n  [133, 5],\n  163,\n  c,\n  [19, 5],\n  164,\n  c,\n  [137, 3],\n  168,\n  c,\n  [137, 22],\n  170,\n  169,\n  171,\n  c,\n  [24, 6],\n  191,\n  86,\n  c,\n  [8, 6],\n  193,\n  c,\n  [8, 7],\n  148,\n  86,\n  194,\n  c,\n  [9, 6],\n  195,\n  86,\n  199,\n  c,\n  [58, 20],\n  142,\n  200,\n  c,\n  [89, 3],\n  202,\n  26,\n  72,\n  201,\n  c,\n  [202, 34],\n  219,\n  c,\n  [201, 5],\n  39,\n  42,\n  c,\n  [202, 23],\n  221,\n  c,\n  [66, 22],\n  228,\n  s,\n  [122, 6, 1],\n  230,\n  c,\n  [125, 21],\n  234,\n  44,\n  238,\n  41,\n  240,\n  239,\n  241,\n  c,\n  [239, 7],\n  75,\n  248,\n  c,\n  [88, 20],\n  249,\n  c,\n  [58, 20],\n  254,\n  c,\n  [79, 21],\n  255,\n  c,\n  [64, 17],\n  256,\n  c,\n  [40, 21],\n  257,\n  c,\n  [22, 6],\n  259,\n  c,\n  [23, 14],\n  260,\n  261,\n  262,\n  c,\n  [290, 22],\n  c,\n  [312, 28],\n  263,\n  c,\n  [115, 16],\n  264,\n  c,\n  [17, 15],\n  265,\n  269,\n  268,\n  241,\n  c,\n  [19, 14],\n  271,\n  c,\n  [15, 13],\n  272,\n  c,\n  [14, 12],\n  273,\n  c,\n  [13, 12],\n  274,\n  c,\n  [13, 11],\n  275,\n  c,\n  [12, 11],\n  276,\n  c,\n  [12, 11],\n  277,\n  c,\n  [12, 11],\n  278,\n  c,\n  [12, 10],\n  279,\n  c,\n  [11, 10],\n  280,\n  c,\n  [11, 9],\n  281,\n  c,\n  [10, 9],\n  282,\n  c,\n  [10, 8],\n  283,\n  c,\n  [9, 8],\n  284,\n  c,\n  [9, 8],\n  285,\n  c,\n  [454, 22],\n  286,\n  s,\n  [122, 7, 1],\n  c,\n  [29, 21],\n  288,\n  c,\n  [29, 6],\n  c,\n  [295, 20],\n  289,\n  c,\n  [316, 21],\n  290,\n  c,\n  [22, 21],\n  291,\n  c,\n  [22, 21],\n  292,\n  c,\n  [22, 21],\n  132,\n  295,\n  c,\n  [665, 8],\n  294,\n  c,\n  [833, 8],\n  299,\n  44,\n  60,\n  300,\n  44,\n  c,\n  [13, 8],\n  66,\n  41,\n  240,\n  305,\n  151,\n  152,\n  303,\n  c,\n  [378, 15],\n  c,\n  [593, 6],\n  307,\n  44,\n  308,\n  c,\n  [854, 3],\n  c,\n  [621, 8],\n  c,\n  [841, 15],\n  311,\n  c,\n  [50, 8],\n  317,\n  300,\n  c,\n  [76, 8],\n  269,\n  c,\n  [74, 5],\n  c,\n  [251, 22],\n  318,\n  c,\n  [251, 26],\n  142,\n  132,\n  323,\n  c,\n  [23, 22],\n  324,\n  c,\n  [149, 20],\n  326,\n  c,\n  [110, 8],\n  328,\n  151,\n  152,\n  c,\n  [32, 19],\n  332,\n  c,\n  [75, 20],\n  333,\n  c,\n  [148, 22],\n  334,\n  c,\n  [428, 28],\n  335,\n  c,\n  [29, 28],\n  336,\n  c,\n  [206, 27],\n  337,\n  c,\n  [22, 21],\n  339,\n  c,\n  [22, 21],\n  341,\n  c,\n  [95, 22],\n  346,\n  c,\n  [124, 28],\n  348,\n  c,\n  [29, 28],\n  350,\n  c,\n  [29, 28],\n  352,\n  c,\n  [29, 28],\n  353,\n  c,\n  [29, 6]\n]),\n  mode: u([\n  s,\n  [1, 46],\n  s,\n  [2, 7],\n  c,\n  [27, 101],\n  c,\n  [31, 5],\n  1,\n  c,\n  [27, 7],\n  c,\n  [9, 3],\n  c,\n  [43, 8],\n  c,\n  [18, 5],\n  c,\n  [12, 8],\n  s,\n  [2, 20],\n  c,\n  [100, 22],\n  c,\n  [44, 38],\n  s,\n  [1, 57],\n  c,\n  [96, 6],\n  c,\n  [327, 43],\n  c,\n  [218, 8],\n  c,\n  [369, 35],\n  c,\n  [20, 35],\n  c,\n  [299, 11],\n  c,\n  [352, 20],\n  c,\n  [317, 10],\n  c,\n  [250, 19],\n  c,\n  [24, 7],\n  c,\n  [67, 6],\n  c,\n  [289, 19],\n  c,\n  [310, 86],\n  c,\n  [146, 12],\n  c,\n  [412, 22],\n  c,\n  [440, 60],\n  c,\n  [236, 15],\n  c,\n  [65, 20],\n  c,\n  [8, 22],\n  c,\n  [34, 18],\n  c,\n  [30, 22],\n  c,\n  [87, 7],\n  c,\n  [55, 20],\n  c,\n  [271, 60],\n  c,\n  [246, 30],\n  c,\n  [688, 75],\n  c,\n  [561, 7],\n  c,\n  [502, 7],\n  s,\n  [1, 217],\n  c,\n  [219, 219],\n  s,\n  [1, 232],\n  c,\n  [680, 7],\n  c,\n  [458, 70],\n  c,\n  [1605, 13],\n  c,\n  [1062, 14],\n  c,\n  [1676, 26],\n  c,\n  [123, 26],\n  c,\n  [1116, 48],\n  c,\n  [1134, 38],\n  c,\n  [20, 60],\n  c,\n  [1194, 23],\n  c,\n  [1216, 42],\n  c,\n  [1241, 80],\n  c,\n  [2006, 28],\n  c,\n  [690, 216],\n  s,\n  [2, 42],\n  c,\n  [538, 11],\n  s,\n  [1, 155]\n]),\n  goto: u([\n  3,\n  s,\n  [12, 13, 1],\n  27,\n  33,\n  34,\n  32,\n  28,\n  29,\n  30,\n  35,\n  c,\n  [21, 20],\n  45,\n  43,\n  38,\n  46,\n  s,\n  [88, 7],\n  c,\n  [31, 20],\n  s,\n  [90, 7],\n  c,\n  [27, 20],\n  s,\n  [92, 7],\n  c,\n  [27, 20],\n  s,\n  [94, 7],\n  c,\n  [27, 20],\n  52,\n  46,\n  53,\n  46,\n  98,\n  56,\n  98,\n  57,\n  59,\n  58,\n  45,\n  46,\n  62,\n  144,\n  61,\n  s,\n  [144, 4],\n  s,\n  [151, 4],\n  43,\n  151,\n  28,\n  45,\n  43,\n  46,\n  s,\n  [118, 6],\n  67,\n  s,\n  [118, 21],\n  c,\n  [74, 15],\n  46,\n  s,\n  [135, 6],\n  76,\n  s,\n  [135, 21],\n  100,\n  s,\n  [90, 6, 1],\n  79,\n  46,\n  s,\n  [102, 5, 1],\n  109,\n  84,\n  85,\n  87,\n  c,\n  [18, 7],\n  131,\n  57,\n  116,\n  c,\n  [20, 10],\n  c,\n  [159, 20],\n  129,\n  130,\n  s,\n  [133, 9, 1],\n  c,\n  [144, 3],\n  62,\n  143,\n  61,\n  s,\n  [143, 4],\n  100,\n  146,\n  c,\n  [62, 6],\n  c,\n  [59, 10],\n  150,\n  c,\n  [60, 20],\n  s,\n  [152, 4],\n  43,\n  152,\n  28,\n  156,\n  c,\n  [25, 15],\n  158,\n  c,\n  [16, 15],\n  c,\n  [88, 3],\n  s,\n  [125, 5],\n  c,\n  [23, 15],\n  s,\n  [127, 5],\n  c,\n  [20, 15],\n  166,\n  165,\n  138,\n  167,\n  138,\n  46,\n  c,\n  [206, 18],\n  s,\n  [38, 15],\n  172,\n  s,\n  [38, 10],\n  s,\n  [173, 10, 1],\n  s,\n  [68, 3],\n  183,\n  s,\n  [68, 3],\n  184,\n  186,\n  26,\n  185,\n  26,\n  187,\n  s,\n  [26, 16],\n  188,\n  189,\n  190,\n  s,\n  [26, 18],\n  192,\n  c,\n  [230, 16],\n  c,\n  [17, 17],\n  c,\n  [138, 7],\n  c,\n  [17, 10],\n  196,\n  c,\n  [17, 16],\n  s,\n  [66, 7],\n  197,\n  66,\n  s,\n  [64, 3],\n  198,\n  s,\n  [64, 6],\n  s,\n  [14, 21],\n  109,\n  s,\n  [14, 21],\n  c,\n  [96, 17],\n  c,\n  [272, 15],\n  s,\n  [62, 3],\n  203,\n  s,\n  [62, 7],\n  s,\n  [60, 3],\n  204,\n  s,\n  [60, 8],\n  s,\n  [58, 10],\n  205,\n  206,\n  58,\n  58,\n  s,\n  [55, 4],\n  207,\n  208,\n  s,\n  [55, 6],\n  209,\n  210,\n  s,\n  [55, 4],\n  s,\n  [50, 12],\n  211,\n  212,\n  s,\n  [50, 6],\n  s,\n  [47, 4],\n  213,\n  214,\n  s,\n  [47, 16],\n  s,\n  [44, 4],\n  215,\n  44,\n  44,\n  216,\n  217,\n  s,\n  [44, 16],\n  c,\n  [576, 9],\n  218,\n  c,\n  [576, 43],\n  38,\n  46,\n  s,\n  [12, 15],\n  220,\n  s,\n  [12, 23],\n  c,\n  [248, 17],\n  222,\n  224,\n  223,\n  225,\n  226,\n  227,\n  c,\n  [117, 9],\n  c,\n  [25, 10],\n  c,\n  [96, 11],\n  229,\n  46,\n  231,\n  232,\n  c,\n  [34, 7],\n  233,\n  c,\n  [33, 10],\n  c,\n  [860, 3],\n  235,\n  236,\n  157,\n  237,\n  242,\n  163,\n  243,\n  163,\n  43,\n  46,\n  244,\n  c,\n  [160, 15],\n  246,\n  245,\n  247,\n  c,\n  [590, 8],\n  c,\n  [50, 10],\n  251,\n  250,\n  253,\n  252,\n  c,\n  [21, 17],\n  c,\n  [17, 52],\n  258,\n  c,\n  [18, 16],\n  46,\n  c,\n  [109, 18],\n  c,\n  [482, 32],\n  c,\n  [49, 34],\n  266,\n  224,\n  267,\n  270,\n  164,\n  243,\n  43,\n  c,\n  [178, 69],\n  c,\n  [17, 193],\n  c,\n  [539, 23],\n  287,\n  c,\n  [31, 30],\n  c,\n  [129, 68],\n  293,\n  c,\n  [99, 8],\n  c,\n  [784, 30],\n  296,\n  224,\n  297,\n  c,\n  [23, 20],\n  298,\n  242,\n  166,\n  243,\n  166,\n  46,\n  302,\n  167,\n  301,\n  167,\n  242,\n  304,\n  243,\n  43,\n  46,\n  c,\n  [35, 20],\n  100,\n  306,\n  c,\n  [115, 16],\n  c,\n  [1337, 3],\n  309,\n  c,\n  [1293, 9],\n  310,\n  c,\n  [24, 10],\n  224,\n  312,\n  s,\n  [67, 7],\n  197,\n  67,\n  313,\n  224,\n  314,\n  315,\n  316,\n  s,\n  [65, 3],\n  198,\n  s,\n  [65, 6],\n  s,\n  [63, 3],\n  203,\n  s,\n  [63, 7],\n  c,\n  [193, 17],\n  270,\n  166,\n  243,\n  270,\n  c,\n  [124, 3],\n  c,\n  [123, 20],\n  s,\n  [61, 3],\n  204,\n  s,\n  [61, 8],\n  s,\n  [59, 10],\n  205,\n  206,\n  59,\n  59,\n  s,\n  [56, 4],\n  207,\n  208,\n  s,\n  [56, 6],\n  209,\n  210,\n  s,\n  [56, 4],\n  s,\n  [57, 4],\n  207,\n  208,\n  s,\n  [57, 6],\n  209,\n  210,\n  s,\n  [57, 4],\n  s,\n  [51, 12],\n  211,\n  212,\n  s,\n  [51, 6],\n  s,\n  [52, 12],\n  211,\n  212,\n  s,\n  [52, 6],\n  s,\n  [53, 12],\n  211,\n  212,\n  s,\n  [53, 6],\n  s,\n  [54, 12],\n  211,\n  212,\n  s,\n  [54, 6],\n  s,\n  [48, 4],\n  213,\n  214,\n  s,\n  [48, 16],\n  s,\n  [49, 4],\n  213,\n  214,\n  s,\n  [49, 16],\n  s,\n  [45, 4],\n  215,\n  45,\n  45,\n  216,\n  217,\n  s,\n  [45, 16],\n  s,\n  [46, 4],\n  215,\n  46,\n  46,\n  216,\n  217,\n  s,\n  [46, 16],\n  c,\n  [554, 30],\n  319,\n  224,\n  320,\n  224,\n  321,\n  224,\n  322,\n  c,\n  [492, 18],\n  c,\n  [18, 18],\n  302,\n  168,\n  301,\n  168,\n  100,\n  325,\n  c,\n  [358, 16],\n  327,\n  c,\n  [352, 20],\n  329,\n  330,\n  331,\n  c,\n  [738, 64],\n  c,\n  [30, 67],\n  c,\n  [107, 11],\n  338,\n  c,\n  [18, 17],\n  340,\n  c,\n  [18, 16],\n  342,\n  343,\n  s,\n  [200, 43],\n  344,\n  s,\n  [200, 8],\n  345,\n  224,\n  c,\n  [139, 30],\n  347,\n  c,\n  [32, 31],\n  349,\n  c,\n  [32, 31],\n  351,\n  c,\n  [264, 60]\n])\n}),\ndefaultActions: bda({\n  idx: u([\n  s,\n  [3, 4, 1],\n  s,\n  [12, 19, 1],\n  s,\n  [33, 4, 1],\n  38,\n  42,\n  44,\n  s,\n  [46, 5, 1],\n  55,\n  58,\n  64,\n  65,\n  69,\n  74,\n  77,\n  78,\n  80,\n  s,\n  [89, 7, 1],\n  97,\n  98,\n  s,\n  [102, 6, 1],\n  109,\n  115,\n  116,\n  118,\n  119,\n  120,\n  s,\n  [122, 6, 1],\n  131,\n  142,\n  143,\n  146,\n  147,\n  s,\n  [148, 4, 2],\n  155,\n  156,\n  158,\n  159,\n  s,\n  [161, 5, 1],\n  170,\n  s,\n  [172, 11, 1],\n  189,\n  190,\n  191,\n  193,\n  194,\n  195,\n  199,\n  218,\n  219,\n  223,\n  231,\n  232,\n  233,\n  235,\n  236,\n  238,\n  239,\n  244,\n  245,\n  s,\n  [247, 4, 1],\n  252,\n  254,\n  258,\n  260,\n  261,\n  262,\n  266,\n  268,\n  s,\n  [283, 4, 1],\n  288,\n  289,\n  s,\n  [296, 4, 1],\n  304,\n  306,\n  s,\n  [308, 4, 1],\n  313,\n  314,\n  316,\n  317,\n  318,\n  325,\n  327,\n  s,\n  [329, 5, 1],\n  335,\n  336,\n  342,\n  343,\n  346,\n  348,\n  s,\n  [350, 4, 1]\n]),\n  goto: u([\n  2,\n  214,\n  216,\n  217,\n  s,\n  [100, 16, 1],\n  140,\n  141,\n  142,\n  119,\n  120,\n  1,\n  215,\n  86,\n  96,\n  145,\n  3,\n  s,\n  [89, 4, 2],\n  218,\n  87,\n  153,\n  155,\n  121,\n  136,\n  99,\n  178,\n  70,\n  16,\n  s,\n  [32, 6, 1],\n  12,\n  13,\n  s,\n  [4, 5, 1],\n  10,\n  9,\n  40,\n  192,\n  194,\n  196,\n  197,\n  s,\n  [183, 6, 1],\n  198,\n  83,\n  97,\n  148,\n  85,\n  38,\n  150,\n  159,\n  154,\n  156,\n  146,\n  117,\n  122,\n  128,\n  130,\n  124,\n  126,\n  131,\n  181,\n  s,\n  [72, 11, 1],\n  22,\n  23,\n  s,\n  [27, 4, 1],\n  11,\n  193,\n  195,\n  199,\n  210,\n  211,\n  212,\n  147,\n  149,\n  161,\n  162,\n  116,\n  123,\n  133,\n  137,\n  139,\n  132,\n  179,\n  71,\n  18,\n  24,\n  20,\n  21,\n  15,\n  165,\n  41,\n  42,\n  43,\n  189,\n  191,\n  84,\n  209,\n  213,\n  158,\n  160,\n  174,\n  170,\n  129,\n  134,\n  180,\n  182,\n  17,\n  19,\n  31,\n  39,\n  190,\n  172,\n  176,\n  169,\n  175,\n  171,\n  69,\n  25,\n  202,\n  203,\n  173,\n  177,\n  205,\n  207,\n  201,\n  204,\n  206,\n  208\n])\n}),\nparseError: function parseError(str, hash, ExceptionClass) {\n    if (hash.recoverable) {\n        if (typeof this.trace === 'function') {\n            this.trace(str);\n        }\n        hash.destroy();             // destroy... well, *almost*!\n    } else {\n        if (typeof this.trace === 'function') {\n            this.trace(str);\n        }\n        if (!ExceptionClass) {\n            ExceptionClass = this.JisonParserError;\n        }\n        throw new ExceptionClass(str, hash);\n    }\n},\nparse: function parse(input) {\n    var self = this;\n    var stack = new Array(128);         // token stack: stores token which leads to state at the same index (column storage)\n    var sstack = new Array(128);        // state stack: stores states (column storage)\n\n    var vstack = new Array(128);        // semantic value stack\n    var lstack = new Array(128);        // location stack\n    var table = this.table;\n    var sp = 0;                         // 'stack pointer': index into the stacks\n    var yyloc;\n    var yytext;\n    \n\n\n    var symbol = 0;\n\n\n\n    var TERROR = this.TERROR;\n    var EOF = this.EOF;\n    var ERROR_RECOVERY_TOKEN_DISCARD_COUNT = (this.options.errorRecoveryTokenDiscardCount | 0) || 3;\n    var NO_ACTION = [0, 354 /* === table.length :: ensures that anyone using this new state will fail dramatically! */];\n\n    var lexer;\n    if (this.__lexer__) {\n        lexer = this.__lexer__;\n    } else {\n        lexer = this.__lexer__ = Object.create(this.lexer);\n    }\n\n    var sharedState_yy = {\n        parseError: undefined,\n        quoteName: undefined,\n        lexer: undefined,\n        parser: undefined,\n        pre_parse: undefined,\n        post_parse: undefined,\n        pre_lex: undefined,\n        post_lex: undefined      // WARNING: must be written this way for the code expanders to work correctly in both ES5 and ES6 modes!\n    };\n\n    var ASSERT;\n    if (typeof assert !== 'function') {\n        ASSERT = function JisonAssert(cond, msg) {\n            if (!cond) {\n                throw new Error('assertion failed: ' + (msg || '***'));\n            }\n        };\n    } else {\n        ASSERT = assert;\n    }\n\n    this.yyGetSharedState = function yyGetSharedState() {\n        return sharedState_yy;\n    };\n\n\n    // shallow clone objects, straight copy of simple `src` values\n    // e.g. `lexer.yytext` MAY be a complex value object,\n    // rather than a simple string/value.\n    function shallow_copy(src) {\n        if (typeof src === 'object') {\n            var dst = {};\n            for (var k in src) {\n                if (Object.prototype.hasOwnProperty.call(src, k)) {\n                    dst[k] = src[k];\n                }\n            }\n            return dst;\n        }\n        return src;\n    }\n    function shallow_copy_noclobber(dst, src) {\n        for (var k in src) {\n            if (typeof dst[k] === 'undefined' && Object.prototype.hasOwnProperty.call(src, k)) {\n                dst[k] = src[k];\n            }\n        }\n    }\n    function copy_yylloc(loc) {\n        var rv = shallow_copy(loc);\n        if (rv && rv.range) {\n            rv.range = rv.range.slice(0);\n        }\n        return rv;\n    }\n\n    // copy state\n    shallow_copy_noclobber(sharedState_yy, this.yy);\n\n    sharedState_yy.lexer = lexer;\n    sharedState_yy.parser = this;\n\n\n\n\n\n\n    // Does the shared state override the default `parseError` that already comes with this instance?\n    if (typeof sharedState_yy.parseError === 'function') {\n        this.parseError = function parseErrorAlt(str, hash, ExceptionClass) {\n            if (!ExceptionClass) {\n                ExceptionClass = this.JisonParserError;\n            }\n            return sharedState_yy.parseError.call(this, str, hash, ExceptionClass);\n        };\n    } else {\n        this.parseError = this.originalParseError;\n    }\n\n    // Does the shared state override the default `quoteName` that already comes with this instance?\n    if (typeof sharedState_yy.quoteName === 'function') {\n        this.quoteName = function quoteNameAlt(id_str) {\n            return sharedState_yy.quoteName.call(this, id_str);\n        };\n    } else {\n        this.quoteName = this.originalQuoteName;\n    }\n\n    // set up the cleanup function; make it an API so that external code can re-use this one in case of\n    // calamities or when the `%options no-try-catch` option has been specified for the grammar, in which\n    // case this parse() API method doesn't come with a `finally { ... }` block any more!\n    //\n    // NOTE: as this API uses parse() as a closure, it MUST be set again on every parse() invocation,\n    //       or else your `sharedState`, etc. references will be *wrong*!\n    this.cleanupAfterParse = function parser_cleanupAfterParse(resultValue, invoke_post_methods, do_not_nuke_errorinfos) {\n        var rv;\n\n        if (invoke_post_methods) {\n            var hash;\n\n            if (sharedState_yy.post_parse || this.post_parse) {\n                // create an error hash info instance: we re-use this API in a **non-error situation**\n                // as this one delivers all parser internals ready for access by userland code.\n                hash = this.constructParseErrorInfo(null /* no error! */, null /* no exception! */, null, false);\n            }\n\n            if (sharedState_yy.post_parse) {\n                rv = sharedState_yy.post_parse.call(this, sharedState_yy, resultValue, hash);\n                if (typeof rv !== 'undefined') resultValue = rv;\n            }\n            if (this.post_parse) {\n                rv = this.post_parse.call(this, sharedState_yy, resultValue, hash);\n                if (typeof rv !== 'undefined') resultValue = rv;\n            }\n\n            // cleanup:\n            if (hash && hash.destroy) {\n                hash.destroy();\n            }\n        }\n\n        if (this.__reentrant_call_depth > 1) return resultValue;        // do not (yet) kill the sharedState when this is a reentrant run.\n\n        // clean up the lingering lexer structures as well:\n        if (lexer.cleanupAfterLex) {\n            lexer.cleanupAfterLex(do_not_nuke_errorinfos);\n        }\n\n        // prevent lingering circular references from causing memory leaks:\n        if (sharedState_yy) {\n            sharedState_yy.lexer = undefined;\n            sharedState_yy.parser = undefined;\n            if (lexer.yy === sharedState_yy) {\n                lexer.yy = undefined;\n            }\n        }\n        sharedState_yy = undefined;\n        this.parseError = this.originalParseError;\n        this.quoteName = this.originalQuoteName;\n\n        // nuke the vstack[] array at least as that one will still reference obsoleted user values.\n        // To be safe, we nuke the other internal stack columns as well...\n        stack.length = 0;               // fastest way to nuke an array without overly bothering the GC\n        sstack.length = 0;\n        lstack.length = 0;\n        vstack.length = 0;\n        sp = 0;\n\n        // nuke the error hash info instances created during this run.\n        // Userland code must COPY any data/references\n        // in the error hash instance(s) it is more permanently interested in.\n        if (!do_not_nuke_errorinfos) {\n            for (var i = this.__error_infos.length - 1; i >= 0; i--) {\n                var el = this.__error_infos[i];\n                if (el && typeof el.destroy === 'function') {\n                    el.destroy();\n                }\n            }\n            this.__error_infos.length = 0;\n\n\n        }\n\n        return resultValue;\n    };\n\n    // merge yylloc info into a new yylloc instance.\n    //\n    // `first_index` and `last_index` MAY be UNDEFINED/NULL or these are indexes into the `lstack[]` location stack array.\n    //\n    // `first_yylloc` and `last_yylloc` MAY be UNDEFINED/NULL or explicit (custom or regular) `yylloc` instances, in which\n    // case these override the corresponding first/last indexes.\n    //\n    // `dont_look_back` is an optional flag (default: FALSE), which instructs this merge operation NOT to search\n    // through the parse location stack for a location, which would otherwise be used to construct the new (epsilon!)\n    // yylloc info.\n    //\n    // Note: epsilon rule's yylloc situation is detected by passing both `first_index` and `first_yylloc` as UNDEFINED/NULL.\n    this.yyMergeLocationInfo = function parser_yyMergeLocationInfo(first_index, last_index, first_yylloc, last_yylloc, dont_look_back) {\n        var i1 = first_index | 0,\n            i2 = last_index | 0;\n        var l1 = first_yylloc,\n            l2 = last_yylloc;\n        var rv;\n\n        // rules:\n        // - first/last yylloc entries override first/last indexes\n\n        if (!l1) {\n            if (first_index != null) {\n                for (var i = i1; i <= i2; i++) {\n                    l1 = lstack[i];\n                    if (l1) {\n                        break;\n                    }\n                }\n            }\n        }\n\n        if (!l2) {\n            if (last_index != null) {\n                for (var i = i2; i >= i1; i--) {\n                    l2 = lstack[i];\n                    if (l2) {\n                        break;\n                    }\n                }\n            }\n        }\n\n        // - detect if an epsilon rule is being processed and act accordingly:\n        if (!l1 && first_index == null) {\n            // epsilon rule span merger. With optional look-ahead in l2.\n            if (!dont_look_back) {\n                for (var i = (i1 || sp) - 1; i >= 0; i--) {\n                    l1 = lstack[i];\n                    if (l1) {\n                        break;\n                    }\n                }\n            }\n            if (!l1) {\n                if (!l2) {\n                    // when we still don't have any valid yylloc info, we're looking at an epsilon rule\n                    // without look-ahead and no preceding terms and/or `dont_look_back` set:\n                    // in that case we ca do nothing but return NULL/UNDEFINED:\n                    return undefined;\n                } else {\n                    // shallow-copy L2: after all, we MAY be looking\n                    // at unconventional yylloc info objects...\n                    rv = shallow_copy(l2);\n                    if (rv.range) {\n                        // shallow copy the yylloc ranges info to prevent us from modifying the original arguments' entries:\n                        rv.range = rv.range.slice(0);\n                    }\n                    return rv;\n                }\n            } else {\n                // shallow-copy L1, then adjust first col/row 1 column past the end.\n                rv = shallow_copy(l1);\n                rv.first_line = rv.last_line;\n                rv.first_column = rv.last_column;\n                if (rv.range) {\n                    // shallow copy the yylloc ranges info to prevent us from modifying the original arguments' entries:\n                    rv.range = rv.range.slice(0);\n                    rv.range[0] = rv.range[1];\n                }\n\n                if (l2) {\n                    // shallow-mixin L2, then adjust last col/row accordingly.\n                    shallow_copy_noclobber(rv, l2);\n                    rv.last_line = l2.last_line;\n                    rv.last_column = l2.last_column;\n                    if (rv.range && l2.range) {\n                        rv.range[1] = l2.range[1];\n                    }\n                }\n                return rv;\n            }\n        }\n\n        if (!l1) {\n            l1 = l2;\n            l2 = null;\n        }\n        if (!l1) {\n            return undefined;\n        }\n\n        // shallow-copy L1|L2, before we try to adjust the yylloc values: after all, we MAY be looking\n        // at unconventional yylloc info objects...\n        rv = shallow_copy(l1);\n\n        // first_line: ...,\n        // first_column: ...,\n        // last_line: ...,\n        // last_column: ...,\n        if (rv.range) {\n            // shallow copy the yylloc ranges info to prevent us from modifying the original arguments' entries:\n            rv.range = rv.range.slice(0);\n        }\n\n        if (l2) {\n            shallow_copy_noclobber(rv, l2);\n            rv.last_line = l2.last_line;\n            rv.last_column = l2.last_column;\n            if (rv.range && l2.range) {\n                rv.range[1] = l2.range[1];\n            }\n        }\n\n        return rv;\n    };\n\n    // NOTE: as this API uses parse() as a closure, it MUST be set again on every parse() invocation,\n    //       or else your `lexer`, `sharedState`, etc. references will be *wrong*!\n    this.constructParseErrorInfo = function parser_constructParseErrorInfo(msg, ex, expected, recoverable) {\n        var pei = {\n            errStr: msg,\n            exception: ex,\n            text: lexer.match,\n            value: lexer.yytext,\n            token: this.describeSymbol(symbol) || symbol,\n            token_id: symbol,\n            line: lexer.yylineno,\n            loc: copy_yylloc(lexer.yylloc),\n            expected: expected,\n            recoverable: recoverable,\n            state: state,\n            action: action,\n            new_state: newState,\n            symbol_stack: stack,\n            state_stack: sstack,\n            value_stack: vstack,\n            location_stack: lstack,\n            stack_pointer: sp,\n            yy: sharedState_yy,\n            lexer: lexer,\n            parser: this,\n\n            // and make sure the error info doesn't stay due to potential\n            // ref cycle via userland code manipulations.\n            // These would otherwise all be memory leak opportunities!\n            //\n            // Note that only array and object references are nuked as those\n            // constitute the set of elements which can produce a cyclic ref.\n            // The rest of the members is kept intact as they are harmless.\n            destroy: function destructParseErrorInfo() {\n                // remove cyclic references added to error info:\n                // info.yy = null;\n                // info.lexer = null;\n                // info.value = null;\n                // info.value_stack = null;\n                // ...\n                var rec = !!this.recoverable;\n                for (var key in this) {\n                    if (this.hasOwnProperty(key) && typeof key === 'object') {\n                        this[key] = undefined;\n                    }\n                }\n                this.recoverable = rec;\n            }\n        };\n        // track this instance so we can `destroy()` it once we deem it superfluous and ready for garbage collection!\n        this.__error_infos.push(pei);\n        return pei;\n    };\n\n\n\n\n\n\n\n\n\n\n\n\n\n    function getNonTerminalFromCode(symbol) {\n        var tokenName = self.getSymbolName(symbol);\n        if (!tokenName) {\n            tokenName = symbol;\n        }\n        return tokenName;\n    }\n\n\n    function stdLex() {\n        var token = lexer.lex();\n        // if token isn't its numeric value, convert\n        if (typeof token !== 'number') {\n            token = self.symbols_[token] || token;\n        }\n\n        return token || EOF;\n    }\n\n    function fastLex() {\n        var token = lexer.fastLex();\n        // if token isn't its numeric value, convert\n        if (typeof token !== 'number') {\n            token = self.symbols_[token] || token;\n        }\n\n        return token || EOF;\n    }\n\n    var lex = stdLex;\n\n\n    var state, action, r, t;\n    var yyval = {\n        $: true,\n        _$: undefined,\n        yy: sharedState_yy\n    };\n    var p;\n    var yyrulelen;\n    var this_production;\n    var newState;\n    var retval = false;\n\n\n    try {\n        this.__reentrant_call_depth++;\n\n        lexer.setInput(input, sharedState_yy);\n\n        // NOTE: we *assume* no lexer pre/post handlers are set up *after* \n        // this initial `setInput()` call: hence we can now check and decide\n        // whether we'll go with the standard, slower, lex() API or the\n        // `fast_lex()` one:\n        if (typeof lexer.canIUse === 'function') {\n            var lexerInfo = lexer.canIUse();\n            if (lexerInfo.fastLex && typeof fastLex === 'function') {\n                lex = fastLex;\n            }\n        } \n\n        yyloc = lexer.yylloc;\n        lstack[sp] = yyloc;\n        vstack[sp] = null;\n        sstack[sp] = 0;\n        stack[sp] = 0;\n        ++sp;\n\n        yytext = lexer.yytext;\n\n\n\n        if (this.pre_parse) {\n            this.pre_parse.call(this, sharedState_yy);\n        }\n        if (sharedState_yy.pre_parse) {\n            sharedState_yy.pre_parse.call(this, sharedState_yy);\n        }\n\n        newState = sstack[sp - 1];\n        for (;;) {\n            // retrieve state number from top of stack\n            state = newState;               // sstack[sp - 1];\n\n            // use default actions if available\n            if (this.defaultActions[state]) {\n                action = 2;\n                newState = this.defaultActions[state];\n            } else {\n                // The single `==` condition below covers both these `===` comparisons in a single\n                // operation:\n                //\n                //     if (symbol === null || typeof symbol === 'undefined') ...\n                if (!symbol) {\n                    symbol = lex();\n                }\n                // read action for current state and first input\n                t = (table[state] && table[state][symbol]) || NO_ACTION;\n                newState = t[1];\n                action = t[0];\n\n\n\n\n\n\n\n\n\n\n\n                // handle parse error\n                if (!action) {\n                    var errStr;\n                    var errSymbolDescr = (this.describeSymbol(symbol) || symbol);\n                    var expected = this.collect_expected_token_set(state);\n\n                    // Report error\n                    if (typeof lexer.yylineno === 'number') {\n                        errStr = 'Parse error on line ' + (lexer.yylineno + 1) + ': ';\n                    } else {\n                        errStr = 'Parse error: ';\n                    }\n                    if (typeof lexer.showPosition === 'function') {\n                        errStr += '\\n' + lexer.showPosition(79 - 10, 10) + '\\n';\n                    }\n                    if (expected.length) {\n                        errStr += 'Expecting ' + expected.join(', ') + ', got unexpected ' + errSymbolDescr;\n                    } else {\n                        errStr += 'Unexpected ' + errSymbolDescr;\n                    }\n                    // we cannot recover from the error!\n                    p = this.constructParseErrorInfo(errStr, null, expected, false);\n                    r = this.parseError(p.errStr, p, this.JisonParserError);\n                    if (typeof r !== 'undefined') {\n                        retval = r;\n                    }\n                    break;\n                }\n\n\n            }\n\n\n\n\n\n\n\n\n\n\n            switch (action) {\n            // catch misc. parse failures:\n            default:\n                // this shouldn't happen, unless resolve defaults are off\n                if (action instanceof Array) {\n                    p = this.constructParseErrorInfo('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol, null, null, false);\n                    r = this.parseError(p.errStr, p, this.JisonParserError);\n                    if (typeof r !== 'undefined') {\n                        retval = r;\n                    }\n                    break;\n                }\n                // Another case of better safe than sorry: in case state transitions come out of another error recovery process\n                // or a buggy LUT (LookUp Table):\n                p = this.constructParseErrorInfo('Parsing halted. No viable error recovery approach available due to internal system failure.', null, null, false);\n                r = this.parseError(p.errStr, p, this.JisonParserError);\n                if (typeof r !== 'undefined') {\n                    retval = r;\n                }\n                break;\n\n            // shift:\n            case 1:\n                stack[sp] = symbol;\n                vstack[sp] = lexer.yytext;\n                lstack[sp] = copy_yylloc(lexer.yylloc);\n                sstack[sp] = newState; // push state\n\n                ++sp;\n                symbol = 0;\n\n\n\n\n                // Pick up the lexer details for the current symbol as that one is not 'look-ahead' any more:\n\n                yytext = lexer.yytext;\n\n                yyloc = lexer.yylloc;\n                continue;\n\n            // reduce:\n            case 2:\n\n\n\n                this_production = this.productions_[newState - 1];  // `this.productions_[]` is zero-based indexed while states start from 1 upwards...\n                yyrulelen = this_production[1];\n\n\n\n\n\n\n\n\n\n\n                r = this.performAction.call(yyval, yytext, yyloc, newState, sp - 1, vstack, lstack);\n\n                if (typeof r !== 'undefined') {\n                    retval = r;\n                    break;\n                }\n\n                // pop off stack\n                sp -= yyrulelen;\n\n                // don't overwrite the `symbol` variable: use a local var to speed things up:\n                var ntsymbol = this_production[0];    // push nonterminal (reduce)\n                stack[sp] = ntsymbol;\n                vstack[sp] = yyval.$;\n                lstack[sp] = yyval._$;\n                // goto new state = table[STATE][NONTERMINAL]\n                newState = table[sstack[sp - 1]][ntsymbol];\n                sstack[sp] = newState;\n                ++sp;\n\n\n\n\n\n\n\n\n\n                continue;\n\n            // accept:\n            case 3:\n                if (sp !== -2) {\n                    retval = true;\n                    // Return the `$accept` rule's `$$` result, if available.\n                    //\n                    // Also note that JISON always adds this top-most `$accept` rule (with implicit,\n                    // default, action):\n                    //\n                    //     $accept: <startSymbol> $end\n                    //                  %{ $$ = $1; @$ = @1; %}\n                    //\n                    // which, combined with the parse kernel's `$accept` state behaviour coded below,\n                    // will produce the `$$` value output of the <startSymbol> rule as the parse result,\n                    // IFF that result is *not* `undefined`. (See also the parser kernel code.)\n                    //\n                    // In code:\n                    //\n                    //                  %{\n                    //                      @$ = @1;            // if location tracking support is included\n                    //                      if (typeof $1 !== 'undefined')\n                    //                          return $1;\n                    //                      else\n                    //                          return true;           // the default parse result if the rule actions don't produce anything\n                    //                  %}\n                    sp--;\n                    if (typeof vstack[sp] !== 'undefined') {\n                        retval = vstack[sp];\n                    }\n                }\n                break;\n            }\n\n            // break out of loop: we accept or fail with error\n            break;\n        }\n    } catch (ex) {\n        // report exceptions through the parseError callback too, but keep the exception intact\n        // if it is a known parser or lexer error which has been thrown by parseError() already:\n        if (ex instanceof this.JisonParserError) {\n            throw ex;\n        }\n        else if (lexer && typeof lexer.JisonLexerError === 'function' && ex instanceof lexer.JisonLexerError) {\n            throw ex;\n        }\n\n        p = this.constructParseErrorInfo('Parsing aborted due to exception.', ex, null, false);\n        retval = false;\n        r = this.parseError(p.errStr, p, this.JisonParserError);\n        if (typeof r !== 'undefined') {\n            retval = r;\n        }\n    } finally {\n        retval = this.cleanupAfterParse(retval, true, true);\n        this.__reentrant_call_depth--;\n    }   // /finally\n\n    return retval;\n}\n};\nparser.originalParseError = parser.parseError;\nparser.originalQuoteName = parser.quoteName;\n\nconst t = require(\"../parsetree\");\n\nfunction Parser() {\n  this.yy = {};\n}\nParser.prototype = parser;\nparser.Parser = Parser;\n\nreturn new Parser();\n})();\n\n        \n\n\nif (typeof require !== 'undefined' && typeof exports !== 'undefined') {\n  exports.parser = c_grammar;\n  exports.Parser = c_grammar.Parser;\n  exports.parse = function () {\n    return c_grammar.parse.apply(c_grammar, arguments);\n  };\n  \n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import type {Location, ParseNode} from \"./parsing\";\n\nexport class CError extends Error {\n    name = \"CError\";\n\n    constructor(message: string, readonly node?: ParseNode, readonly node2?: ParseNode) {\n        super(message);\n\n        if (node?.loc) {\n            this.message += \"\\n\\n\" + locationString(node.loc);\n            if (node2?.loc) this.message += \"\\n\\n\" + locationString(node2.loc, \"Secondary location\");\n        }\n    }\n}\n\nexport function locationString(loc: Location, label: string = \"Location\"): string {\n    const lines = loc.source.split(\"\\n\");\n    if (loc.first_line >= lines.length) return `${label}: [UNKNOWN]`;\n\n    let output = `${label}:\\n`;\n\n    const lnumDigits = Math.ceil(Math.log10(loc.last_line + 4));\n    function outputLine(lnum: number) {\n        output += `L${(lnum + 1).toString().padStart(lnumDigits, '0')}: ${lines[lnum]}\\n`;\n    }\n\n    if (loc.first_line > 1) outputLine(loc.first_line - 2);\n    if (loc.first_line > 0) outputLine(loc.first_line - 1);\n    outputLine(loc.first_line);\n\n    // output ^^^ arrows\n    output += new Array(3 + lnumDigits + loc.first_column).join(\" \");\n    if (loc.first_line === loc.last_line) {\n        output += new Array(1 + loc.last_column - loc.first_column).join(\"^\");\n    } else {\n        output += \"^\";\n    }\n    output += \"\\n\";\n\n    if (loc.first_line + 1 < lines.length) outputLine(loc.first_line + 1);\n    if (loc.first_line + 2 < lines.length) outputLine(loc.first_line + 2);\n    return output;\n}\n","import {CError} from \"../c_error\";\nimport type {TypeSpecifier, TypeQualifier, ParseNode} from \"../parsing/parsetree\";\n\n// types for expressions and declarations in the IR\nexport type CType = CNotFuncType | CFuncType;\nexport type CNotFuncType = CArithmetic | CPointer | CArray | CStruct | CUnion | CVoid;\nexport type CQualifiedType<T extends CType> = T & {qualifier?: TypeQualifier, _base?: T};\n\nexport class CFuncType {\n    readonly typeName = \"function\";\n    readonly bytes = 0;\n    readonly alignment = 1;\n    readonly incomplete = false;\n\n    constructor(readonly node: ParseNode | undefined,\n                readonly returnType: CQualifiedType<CNotFuncType>,\n                readonly parameterTypes: CQualifiedType<CNotFuncType>[],\n                public parameterNames?: string[],\n                readonly variadic: boolean = false) {\n        // return type and parameter types must be complete\n        if (!(returnType instanceof CVoid)) checkTypeComplete(returnType);\n        parameterTypes.forEach(x => checkTypeComplete(x));\n    }\n\n    equals(t: Object): boolean {\n        return t instanceof CFuncType\n            && t.returnType.equals(this.returnType)\n            && t.parameterTypes.length === this.parameterTypes.length\n            && t.parameterTypes.every((other, i) => this.parameterTypes[i].equals(other))\n            && t.variadic === this.variadic;\n    }\n\n    get pointerGeneration(): CPointer {\n        return addQualifier(new CPointer(this.node, this, false, this), getQualifier(this));\n    }\n}\n\nexport class CPointer {\n    readonly bytes = 4;\n    readonly alignment = 4;\n    readonly incomplete = false;\n    readonly qualifier?: TypeQualifier;\n\n    constructor(readonly node: ParseNode | undefined,\n                readonly type: CType,\n                constant: boolean = false,\n                readonly original?: CFuncType | CArray /* used in pointer generation */) {\n        // allow pointers to incomplete types\n        if (constant) this.qualifier = \"const\";\n    }\n\n    equals(t: object): boolean {\n        return t instanceof CPointer && t.qualifier === this.qualifier && this.type.equals(t.type);\n    }\n\n    get pointerGeneration(): this {\n        return this; // no pointer generation (already a pointer!)\n    }\n\n    get typeName(): string {\n        return this.type.typeName + \"*\" + (this.qualifier ? \" \" + this.qualifier : \"\");\n    }\n}\n\nexport class CArray {\n    readonly alignment: number;\n\n    constructor(readonly node: ParseNode | undefined, readonly type: CType, public length?: number) {\n        checkTypeComplete(type);\n        this.alignment = type.alignment;\n    }\n\n    get bytes(): number {\n        if (this.length === undefined) throw new Error(\"Tried to get size of incomplete type\");\n        return this.type.bytes * this.length;\n    }\n\n    get incomplete(): boolean {\n        return this.length === undefined;\n    }\n\n    equals(t: object): boolean {\n        return t instanceof CArray && t.length === this.length && this.type.equals(t.type);\n    }\n\n    get pointerGeneration(): CPointer {\n        return addQualifier(new CPointer(this.node, this.type, false, this), getQualifier(this));\n    }\n\n    get typeName(): string {\n        if (this.length) {\n            return this.type.typeName + \"[\" + this.length + \"]\";\n        } else {\n            return this.type.typeName + \"[]\";\n        }\n    }\n}\n\nexport type CCompound = CStruct | CUnion | CEnum;\n\nexport class CCompoundMember {\n    constructor(readonly node: ParseNode, readonly name: string, readonly type: CQualifiedType<CNotFuncType>) {}\n}\n\nexport class CStruct {\n    private _members: ReadonlyArray<CCompoundMember> | undefined;\n\n    constructor(public node: ParseNode | undefined, readonly name: string | undefined) {\n    }\n\n    get members(): ReadonlyArray<CCompoundMember> {\n        if (this._members === undefined) throw new Error(\"Can't get members of an incomplete struct\");\n        return this._members;\n    }\n\n    set members(children: ReadonlyArray<CCompoundMember>) {\n        if (this._members !== undefined) throw new Error(\"Can't redefine a struct's members\");\n        if (children.length === 0) throw new Error(\"Struct must have one or more member\");\n        this._members = children;\n    }\n\n    get bytes(): number {\n        if (this.incomplete) throw new Error(\"Tried to get size of incomplete type\");\n        return this.members.reduce((total, x) => {\n            // align member type\n            total = Math.ceil(total / x.type.alignment) * x.type.alignment;\n            return total + x.type.bytes;\n        }, 0);\n    }\n\n    get alignment(): number {\n        return Math.max(...this.members.map(x => x.type.alignment));\n    }\n\n    get incomplete(): boolean {\n        return this._members === undefined;\n    }\n\n    equals(t: object): boolean {\n        if (!(t instanceof CStruct)) return false;\n        if (this.name === undefined && t.name === undefined) {\n            /** TODO breaks spec but works around anonymous structure being included in multiple files from a header file\n             *\n             * \"Structures, unions and enumerations with different tags are distinct,\n             * and a tagless union, structure, or enumeration specifies a unique type\" */\n            if (this.members.length !== t.members.length) return false;\n            return this.members.every((x, i) => t.members[i].name === x.name && t.members[i].type.equals(x.type));\n        }\n        return t.name === this.name;\n    }\n\n    memberType(m: string): CType {\n        const member = this.members.find(x => x.name === m);\n        if (member) return member.type;\n        throw new Error(`Struct does not contain member \"${m}\"`);\n    }\n\n    hasConstMember(): boolean { // if the struct contains one or more const members\n        return this.members.find(m =>\n            getQualifier(m.type) || ((m.type instanceof CUnion || m.type instanceof CStruct) && m.type.hasConstMember())\n        ) !== undefined;\n    }\n\n    get pointerGeneration(): this {\n        return this; // no pointer generation\n    }\n\n    get typeName(): string {\n        if (this.name) {\n            return \"struct \" + this.name;\n        } else {\n            return \"struct {\" + this.members.map(x => x.type.typeName + \" \" + x.name + \";\").join(\" \") + \"}\";\n        }\n    }\n}\n\nexport class CUnion {\n    private _members: ReadonlyArray<CCompoundMember> | undefined;\n\n    constructor(public node: ParseNode | undefined, readonly name: string | undefined) {\n    }\n\n    get members(): ReadonlyArray<CCompoundMember> {\n        if (this._members === undefined) throw new Error(\"Can't get members of an incomplete union\");\n        return this._members;\n    }\n\n    set members(children: ReadonlyArray<CCompoundMember>) {\n        if (this._members !== undefined) throw new Error(\"Can't redefine a union's members\");\n        if (children.length === 0) throw new Error(\"Struct must have one or more member\");\n        this._members = children;\n    }\n\n    get bytes(): number {\n        if (this.incomplete) throw new Error(\"Tried to get size of incomplete type\");\n        return this.members.reduce((total, x) => Math.max(total, x.type.bytes), 0);\n    }\n\n    get alignment(): number {\n        return Math.max(...this.members.map(x => x.type.alignment));\n    }\n\n    get incomplete(): boolean {\n        return this._members === undefined;\n    }\n\n    equals(t: object): boolean {\n        if (!(t instanceof CUnion)) return false;\n        if (this.name === undefined && t.name === undefined) {\n            if (this.members.length !== t.members.length) return false;\n            return this.members.every((x, i) => t.members[i].name === x.name && t.members[i].type.equals(x.type));\n        }\n        return t.name === this.name;\n    }\n\n    memberType(m: string): CType {\n        const member = this.members.find(x => x.name === m);\n        if (member) return member.type;\n        throw new Error(`Union does not contain member \"${m}\"`);\n    }\n\n    hasConstMember(): boolean { // if the union has one or more const members\n        return this.members.find(m =>\n            getQualifier(m.type) || ((m.type instanceof CUnion || m.type instanceof CStruct) && m.type.hasConstMember())\n        ) !== undefined;\n    }\n\n    get pointerGeneration(): this {\n        return this; // no pointer generation\n    }\n\n    get typeName(): string {\n        if (this.name) {\n            return \"union \" + this.name;\n        } else {\n            return \"union {\" + this.members.map(x => x.type.typeName + \" \" + x.name + \";\").join(\" \") + \"}\";\n        }\n    }\n}\n\nexport type CEnumValue = {name: string, value: bigint};\nexport class CEnum {\n    readonly typeName = \"enum\";\n    private _values: ReadonlyArray<CEnumValue> | undefined;\n\n    constructor(public node: ParseNode | undefined, readonly name: string | undefined) {\n    }\n\n    get values(): ReadonlyArray<CEnumValue> {\n        if (this._values === undefined) throw new Error(\"Can't get values of an incomplete enum\");\n        return this._values;\n    }\n\n    set values(children: ReadonlyArray<CEnumValue>) {\n        if (this._values !== undefined) throw new Error(\"Can't redefine an enum's values\");\n        if (children.length === 0) throw new Error(\"Enum must have one or more value\");\n        this._values = children;\n    }\n\n    get incomplete(): boolean {\n        return this._values === undefined;\n    }\n\n    equals(t: object): boolean {\n        if (this.name === undefined) return this === t;\n        return t instanceof CEnum && t.name === this.name;\n    }\n}\n\nexport class CVoid {\n    readonly typeName = \"void\";\n    readonly bytes = 0;\n    readonly alignment = 1;\n    readonly incomplete = true;\n    readonly node = undefined;\n\n    equals(t: object): boolean {\n        return t instanceof CVoid;\n    }\n\n    get pointerGeneration(): this {\n        return this; // no pointer generation\n    }\n}\n\nexport class CArithmetic {\n    readonly incomplete = false;\n    readonly node = undefined;\n    readonly alignment: number;\n\n    private constructor(readonly typeName: string, readonly bytes: number, readonly type: \"float\" | \"signed\" | \"unsigned\") {\n        this.alignment = bytes;\n    }\n\n    equals(t: object): boolean {\n        return t instanceof CArithmetic && t.typeName === this.typeName && t.type === this.type && t.bytes === this.bytes;\n    }\n\n    get minValue(): bigint | number {\n        if (CArithmetic.BOOL.equals(this)) return 0;\n\n        switch (this.type) {\n        case \"float\":\n            return -Infinity;\n        case \"unsigned\":\n            return 0;\n        case \"signed\":\n            return -(2n ** (BigInt(this.bytes * 8) - 1n));\n        }\n    }\n\n    get maxValue(): bigint | number {\n        if (CArithmetic.BOOL.equals(this)) return 1;\n\n        switch (this.type) {\n        case \"float\":\n            return Infinity;\n        case \"unsigned\":\n            return 2n ** BigInt(this.bytes * 8) - 1n;\n        case \"signed\":\n            return 2n ** (BigInt(this.bytes * 8) - 1n) - 1n;\n        }\n    }\n\n    get pointerGeneration(): this {\n        return this; // no pointer generation\n    }\n\n    static readonly Fp32 = new CArithmetic(\"float\", 4, \"float\");\n    static readonly Fp64 = new CArithmetic(\"double\", 8, \"float\");\n\n    static readonly U8 = new CArithmetic(\"char\", 1, \"unsigned\");\n    static readonly S8 = new CArithmetic(\"signed char\", 1, \"signed\");\n    static readonly U16 = new CArithmetic(\"unsigned short\", 2, \"unsigned\");\n    static readonly S16 = new CArithmetic(\"short\", 2, \"signed\");\n    static readonly U32 = new CArithmetic(\"unsigned int\", 4, \"unsigned\");\n    static readonly S32 = new CArithmetic(\"int\", 4, \"signed\");\n    static readonly U64 = new CArithmetic(\"unsigned long\", 8, \"unsigned\");\n    static readonly S64 = new CArithmetic(\"long\", 8, \"signed\");\n\n    static readonly BOOL = new CArithmetic(\"bool\", 4, \"signed\");\n}\n\nexport const CSizeT = CArithmetic.U32;\n\n\nconst constType = Symbol(\"const\"); // hidden property key\n\n/**\n * Add a qualifier to a type.\n *\n * This creates a new object with the qualifier attached, using the existing type as its prototype, allowing it to be\n * treated as the existing type. This new object is also cached on the existing type using a field referenced by a\n * symbol, so it can't be accessed when enumerating the fields and doesn't affect existing code.\n */\nexport function addQualifier<T extends CType>(t: T, qualifier?: TypeQualifier): CQualifiedType<T> {\n    if (qualifier === undefined) return t;\n    if (Object.prototype.hasOwnProperty.call(t, \"qualifier\")) {\n        throw new Error(\"Type already has a qualifier\");\n    }\n\n    const baseType = t as Record<typeof constType, any>;\n    if (baseType[constType]) {\n        // const type already exists\n        return baseType[constType];\n    }\n\n    const type = Object.setPrototypeOf({qualifier, _base: t}, t);\n    baseType[constType] = type;\n    return type;\n}\n\nexport function getQualifier(t: CQualifiedType<CType>): TypeQualifier | undefined {\n    return t?.qualifier;\n}\n\n/** integer promotion from the C standard */\nexport function integerPromotion(t: CArithmetic): CArithmetic {\n    if (t.type === \"float\") return t;\n    if (t.bytes < CArithmetic.S32.bytes || t === CArithmetic.BOOL) return CArithmetic.S32;\n    return t;\n}\n\n/** \"The usual arithmetic conversions\" from the C standard */\nexport function usualArithmeticConversion(t1: CArithmetic, t2: CArithmetic): CArithmetic {\n    if (t1 === CArithmetic.Fp64 || t2 === CArithmetic.Fp64) return CArithmetic.Fp64;\n    if (t1 === CArithmetic.Fp32 || t2 === CArithmetic.Fp32) return CArithmetic.Fp32;\n\n    // integer promotion\n    t1 = integerPromotion(t1);\n    t2 = integerPromotion(t2);\n\n    if (t1 === CArithmetic.U64 || t2 === CArithmetic.U64) return CArithmetic.U64;\n    if (t1 === CArithmetic.S64 || t2 === CArithmetic.S64) return CArithmetic.S64;\n    if (t1 === CArithmetic.U32 || t2 === CArithmetic.U32) return CArithmetic.U32;\n    return CArithmetic.S32;\n}\n\n/** Convert a list of specifier strings (e.g. \"signed\", \"int\") into a CType instance. */\nexport function getArithmeticType(specifierList: ReadonlyArray<TypeSpecifier & string>): CArithmetic | CVoid | undefined {\n    const copy = specifierList.slice();\n\n    function remove(s: TypeSpecifier & string) { // remove an item from a list if present, and return whether it was\n        const idx = copy.indexOf(s);\n        if (idx > -1) {\n            copy.splice(idx, 1);\n            return true;\n        }\n        return false;\n    }\n\n    function check<T>(x: T): T | undefined { // check that there are no specifiers left to be processed\n        if (copy.length > 0) return undefined; // extra specifiers so this type is invalid (e.g. \"unsigned signed int\")\n        return x;\n    }\n\n    if (remove(\"void\")) { // if \"void\" in list\n        return check(new CVoid()); // then the type must be void, check no extra specifiers were provided\n    } else if (remove(\"double\")) {\n        remove(\"long\"); // remove \"long\" if present, as treating \"long double\" as normal doubles\n        return check(CArithmetic.Fp64);\n    } else if (remove(\"float\")) {\n        return check(CArithmetic.Fp32);\n    } else if (remove(\"char\")) {\n        if (remove(\"signed\")) return check(CArithmetic.S8);\n        remove(\"unsigned\");\n        return check(CArithmetic.U8);\n    } else if (remove(\"short\")) {\n        remove(\"int\"); // remove optional \"int\" (\"short int\" === \"int\")\n        if (remove(\"unsigned\")) return check(CArithmetic.U16);\n        remove(\"signed\");\n        return check(CArithmetic.S16);\n    } else if (remove(\"long\")) {\n        remove(\"long\"); // remove an 2nd \"long\" if present, as treating \"long long\" as \"long\"\n        remove(\"int\");\n        if (remove(\"unsigned\")) return check(CArithmetic.U64);\n        remove(\"signed\");\n        return check(CArithmetic.S64);\n    } else if (remove(\"int\")) {\n        if (remove(\"unsigned\")) return check(CArithmetic.U32);\n        remove(\"signed\");\n        return check(CArithmetic.S32);\n    } else if (remove(\"unsigned\")) { // support just `unsigned` and `signed`\n        return check(CArithmetic.U32);\n    } else if (remove(\"signed\")) {\n        return check(CArithmetic.S32);\n    } else if (remove(\"bool\")) {\n        return check(CArithmetic.BOOL);\n    }\n    return undefined;\n}\n\n/** Assert that type is complete */\nexport function checkTypeComplete<T extends CType>(type: T, node: ParseNode | undefined = type.node): T {\n    if (type.incomplete) {\n        throw new class extends CError {\n            name = \"IncompleteTypeError\";\n        }(\"Invalid use of an incomplete type\", node);\n    }\n    return type;\n}\n","import {CError} from \"../c_error\";\nimport {getArithmeticType} from \"../ir/types\";\nimport * as pt from \"./parsetree\";\nimport {ParseNode, TypeSpecifier} from \"./parsetree\";\n\nconst validatorMap = new Map<typeof ParseNode, ((node: ParseNode, parents: ParseNode[]) => void)[]>();\n\nexport function validate<T extends Iterable<ParseNode>>(nodeList: T, parents: ParseNode[] = []): T {\n    for (const node of nodeList) {\n        parents.push(node);\n        validate(node.children(), parents);\n        parents.pop();\n\n        for (const validator of validatorMap.get(Object.getPrototypeOf(node).constructor) ?? []) {\n            validator(node, parents);\n        }\n    }\n    return nodeList;\n}\n\nexport class ParseTreeValidationError extends CError {\n    readonly name = \"TreeValidationError\";\n\n    constructor(node: ParseNode | undefined, message: string, node2?: ParseNode) {\n        super(node && node.loc ? `Line ${node.loc.first_line + 1}: ${message}` : message, node, node2);\n    }\n}\n\nfunction validator<T extends ParseNode>(type: { new(...args: any[]): T}, fn: (node: T, parents: ParseNode[]) => void) {\n    const validators = validatorMap.get(type);\n    if (validators) {\n        validators.push(fn as any);\n    } else {\n        validatorMap.set(type, [fn as any]);\n    }\n}\n\n// DeclarationSpecifiers/SpecifierQualifiers validation\nfunction typeLookup(specifierList: ReadonlyArray<pt.TypeSpecifier>, node?: ParseNode) {\n    if (specifierList.every(v => typeof v === 'string')) {\n        if (!getArithmeticType(specifierList as ReadonlyArray<TypeSpecifier & string>)) {\n            throw new ParseTreeValidationError(node, \"Invalid specifiers - \" + specifierList.join(\", \"));\n        }\n    }\n}\n\nconst typeValidation = (d: pt.SpecifierQualifiers | pt.DeclarationSpecifiers) => {\n    if (d.qualifierList.length > 1) throw new ParseTreeValidationError(d, \"Invalid qualifiers.\");\n    typeLookup(d.specifierList, d);\n};\n\nvalidator(pt.SpecifierQualifiers, typeValidation);\nvalidator(pt.DeclarationSpecifiers, typeValidation);\nvalidator(pt.DeclarationSpecifiers, (d, parents) => {\n    if (d.storageList.length > 1) throw new ParseTreeValidationError(d, \"Invalid storage class list.\");\n    if (d.fnSpecifierList.length > 1) throw new ParseTreeValidationError(d, \"Invalid fn specifier list.\");\n\n    if (d.storageList[0] === \"typedef\" && parents.length !== 1) {\n        throw new ParseTreeValidationError(d, \"Nested typedefs are not allowed\");\n    }\n});\n\n// Constant expr validation\nfunction constExprValidation(n: ParseNode, parents: ParseNode[]) {\n    for (let i = parents.length - 1; i >= 0; i--) {\n        if (!(parents[i] instanceof pt.Expression) || parents[i].type === \"sizeof\") return;\n        if (parents[i].type === \"constantExpr\") throw new ParseTreeValidationError(n, \"Invalid constant expr.\");\n    }\n}\n\nvalidator(pt.UnaryExpression, (node, parent) => {\n    switch (node.type) {\n    case \"postfixIncrement\":\n    case \"postfixDecrement\":\n    case \"prefixIncrement\":\n    case \"prefixDecrement\":\n    case \"addressOf\": // If integers are required (believe this is always the case?)\n    case \"dereference\":\n        constExprValidation(node, parent);\n    }\n});\nvalidator(pt.BinaryExpression, (node, parent) => {\n    switch (node.type) {\n    case \"comma\":\n    case \"arraySubscript\": // If int\n        constExprValidation(node, parent);\n    }\n});\nvalidator(pt.FunctionCallExpression, constExprValidation);\n\n// If int\nvalidator(pt.MemberAccessExpression, constExprValidation);\n","import {CError} from \"../c_error\";\nimport {ParseNode} from \"./parsetree\";\n\nexport type Location = {\n    first_line: number,\n    last_line: number,\n    first_column: number,\n    last_column: number,\n    source: string,\n};\n\nconst keywords = Object.fromEntries([\n    \"if\", \"break\", \"case\", \"char\", \"const\", \"continue\", \"default\", \"do\", \"double\", \"else\", \"enum\", \"extern\", \"float\",\n    \"for\", \"inline\", \"int\", \"long\", \"return\", \"short\", \"signed\", \"sizeof\", \"static\", \"struct\", \"switch\", \"typedef\",\n    \"union\", \"unsigned\", \"void\", \"while\", \"_Bool\", \"goto\",\n\n    // currently unsupported (but still lex so parser throws error)\n    \"auto\", \"register\", \"volatile\",\n\n    // special for c2wasm, not on spec\n    \"import\"\n].map(x => [x, x.toUpperCase()]));\n\nconst symbols = [\n    \"...\",\"<<=\",\">>=\",\n    \"!=\",\"%=\",\"&&\",\"&=\",\"*=\",\"++\",\"+=\",\"--\",\"-=\",\"->\",\"/=\",\"<<\",\"<=\",\"==\",\">=\",\">>\",\"^=\",\"|=\",\"||\",\n    \"!\",\"%\",\"&\",\"(\",\")\",\"*\",\"+\",\",\",\"-\",\".\",\"/\",\":\",\";\",\"<\",\"=\",\">\",\"?\",\"[\",\"]\",\"^\",\"{\",\"|\",\"}\",\"~\"\n];\n\nconst rules: {regex: RegExp, type: string | ((s: string) => string), value?: (s: string) => string}[] = [\n    {\n        type: (s) => keywords[s] ?? 'IDENTIFIER',\n        regex: /[a-zA-Z_][a-zA-Z0-9_]*/,\n    },\n    {\n        type: x => x,\n        regex: new RegExp(symbols.map(s => s.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')).join('|')),\n    },\n    {\n        type: 'CONSTANT_FLOAT',\n        regex: /(?:[0-9]+[Ee][+-]?[0-9]+|(?:[0-9]*\\.[0-9]+|[0-9]+\\.[0-9]*)(?:[Ee][+-]?[0-9]+)?)[fFlL]?|(?:[1-9][0-9]*|0)[fF]/,\n    },\n    {\n        type: 'CONSTANT_HEX',\n        regex: /0[xX][a-fA-F0-9]+(?:[uU][lL]{0,2}|[lL]{1,2}[uU]?|)/,\n    },\n    {\n        type: 'CONSTANT_OCTAL',\n        regex: /0[0-7]+(?:[uU][lL]{0,2}|[lL]{1,2}[uU]?|)/,\n    },\n    {\n        type: 'CONSTANT_INT',\n        regex: /(?:[1-9][0-9]*|0)(?:[uU][lL]{0,2}|[lL]{1,2}[uU]?|)/,\n    },\n    {\n        type: 'CONSTANT_CHAR',\n        regex: /'(?:[^\\\\\\n']|\\\\(?:.|x[0-9a-fA-F]{1,2}|[0-7]{1,3}))'/,\n        value: x => x.slice(1, -1),\n    },\n    {\n        type: 'STRING_LITERAL',\n        regex: /\"(?:[^\\\\\\n\"]|\\\\(?:[^x0-7\\n]|x[0-9a-fA-F]{1,2}|[0-7]{1,3}))*\"/,\n        value: x => x.slice(1, -1),\n    },\n];\n\nexport class Lexer {\n    static regex = new RegExp(rules.map(x => '(' + x.regex.source + ')').join('|'), 'ym');\n\n    private source = '';\n    private index = 0;\n    private line = 0;\n    private col = 0;\n\n    next(): {type: string, value: string, text: string, loc: Location} {\n        // Skip whitespace\n        while (this.index < this.source.length && (this.source[this.index] === ' '\n            || this.source[this.index] === '\\t' || this.source[this.index] === '\\v'\n            || this.source[this.index] === '\\f' || this.source[this.index] === '\\n')) {\n\n            if (this.source[this.index] === '\\n') {\n                this.line++;\n                this.col = 1;\n            } else {\n                this.col++;\n            }\n            this.index++;\n        }\n\n        const loc: Location = {\n            first_line: this.line,\n            first_column: this.col,\n            last_line: this.line,\n            last_column: this.col + 1,\n            source: this.source,\n        };\n\n        // Reached end of source\n        if (this.index === this.source.length) {\n            return {type: 'EOF', value: '', text: '', loc};\n        }\n\n        // Match sticky regex from current index\n        Lexer.regex.lastIndex = this.index;\n        const match = Lexer.regex.exec(this.source);\n        if (!match) throw new LexerError(loc);\n\n        // Update location information\n        const text = match[0];\n        this.index += text.length;\n        this.col += text.length;\n        loc.last_column = this.col;\n\n        // group[n+1] !== undefined means that rule[n] matched\n        let groupIdx = 0;\n        while (match[groupIdx + 1] === undefined) groupIdx++;\n        const group = rules[groupIdx];\n\n        return {\n            type: typeof group.type === 'function' ? group.type(text) : group.type,\n            value: group.value?.(text) ?? text,\n            text, loc,\n        };\n    }\n\n    reset(s: string) {\n        this.source = s;\n        this.index = 0;\n        this.line = 0;\n        this.col = 1;\n    }\n}\n\nclass LexerError extends CError {\n    name = \"LexerError\";\n\n    constructor(loc: Location) {\n        super(\"Unknown token\", new class extends ParseNode {\n            type = \"Unknown\";\n        }(loc));\n    }\n}\n\nexport const lexer = new Lexer();\n","import {locationString} from \"../c_error\";\nimport gen from \"./gen/c_grammar\";\nimport {lexer, Location} from \"./lexer\";\nimport * as parsetree from \"./parsetree\";\nimport {validate} from \"./validation\";\n\n// adapt lexer to work with Jison\nclass WrappedLexer {\n    yytext?: string;\n    yylloc?: Location;\n    yylineno?: number;\n\n    private types = new Map<string, boolean>();\n\n    /** return the token type and update yytext, yylloc, yylineno */\n    lex(): string {\n        const token = lexer.next();\n        this.yytext = token.value;\n        this.yylloc = token.loc;\n        this.yylineno = token.loc.first_line;\n\n        if (token.type === \"IDENTIFIER\" && this.types.get(token.text)) {\n            return \"TYPE_NAME\";\n        }\n        return token.type;\n    }\n\n    setInput(input: string): void {\n        this.yytext = undefined;\n        this.yylloc = undefined;\n        this.yylineno = undefined;\n        this.types.clear();\n\n        lexer.reset(input);\n    }\n\n    externalDeclaration(d: parsetree.Declaration) {\n        if (d.typeInfo.storageList[0] !== \"typedef\") return;\n\n        for (let declarator of d.list) {\n            while (!(declarator instanceof parsetree.IdentifierDeclarator)) declarator = declarator.body;\n            this.types.set(declarator.id, true);\n        }\n    }\n}\n\n// provide the generated parser with our custom lexer\nconst generatedParser = gen as any;\ngeneratedParser.parser.lexer = new WrappedLexer();\n\n/**\n * Parse the input string into a parse tree and perform some basic validation\n */\nexport function parse(input: string): parsetree.TranslationUnit {\n    try {\n        const tree = generatedParser.parse(input);\n        return validate(tree);\n    } catch (e) {\n        if (e?.hash?.loc) { // Jison parse errors\n            e.message += \"\\n\\n\" + locationString(e.hash?.loc);\n        }\n        throw e;\n    }\n}\n","import {CError} from \"../c_error\";\nimport type {ParseNode} from \"../parsing\";\nimport type {CExpression} from \"./expressions\";\nimport {CArithmetic, CPointer, CStruct, CUnion, CType, CFuncType, checkTypeComplete} from \"./types\";\n\nexport class ExpressionTypeError extends CError {\n    name = \"ExpressionTypeError\";\n\n    constructor(node: ParseNode, readonly wantedType: string, readonly actualType?: string) {\n        super(actualType ? `Expected ${wantedType} but got ${actualType} instead!` : `Expected ${wantedType}`, node);\n    }\n}\n\n// Basic type checking for expressions, throws an exception if the expression's type is not the expected type\n\nexport function asArithmetic(node: ParseNode, t: CType): CArithmetic {\n    if (t instanceof CArithmetic) return t;\n    throw new ExpressionTypeError(node, \"arithmetic\", t.typeName);\n}\n\nexport function asInteger(node: ParseNode, t: CType): CArithmetic {\n    const arithmetic = asArithmetic(node, t);\n    switch (arithmetic.type) {\n    case \"signed\":\n    case \"unsigned\":\n        return arithmetic;\n    default:\n        throw new ExpressionTypeError(node, \"integer\", t.typeName);\n    }\n}\n\nexport function asPointer(node: ParseNode, t: CType): CPointer {\n    if (t instanceof CPointer) return t;\n    throw new ExpressionTypeError(node, \"pointer\", t.typeName);\n}\n\nexport function asArithmeticOrPointer(node: ParseNode, t: CType): CArithmetic | CPointer {\n    if (t instanceof CArithmetic) return t;\n    if (t instanceof CPointer) return t;\n    throw new ExpressionTypeError(node, \"arithmetic or pointer\", t.typeName);\n}\n\nexport function asNonFunctionPointer<T extends CType>(node: ParseNode, t: T): T {\n    if (t instanceof CPointer && t.type instanceof CFuncType) {\n        throw new ExpressionTypeError(node, \"non-function pointer\", \"function pointer\");\n    }\n    return t;\n}\n\nexport function asFunction(node: ParseNode, t: CType): CFuncType {\n    if (t instanceof CFuncType) return t;\n    if (t instanceof CPointer && t.type instanceof CFuncType) return t.type;\n    throw new ExpressionTypeError(node, \"function\", t.typeName);\n}\n\nexport function asStructOrUnion(node: ParseNode, t: CType): CStruct | CUnion {\n    checkTypeComplete(t);\n    if (t instanceof CStruct) return t;\n    if (t instanceof CUnion) return t;\n    throw new ExpressionTypeError(node, \"struct or union\", t.typeName);\n}\n\nexport function checkLvalue(expression: CExpression, lvalue: boolean): CExpression {\n    if (expression.lvalue === lvalue) return expression;\n    throw new ExpressionTypeError(expression.node, `lvalue=${lvalue}`, `lvalue=${expression.lvalue}`);\n}\n","import type {ParseNode, pt} from \"../parsing\";\nimport type {CDeclaration, CVariable, CArgument} from \"./declarations\";\nimport * as checks from \"./type_checking\";\nimport {\n    CArithmetic, CType, CArray, CPointer, CUnion, CStruct,\n    CSizeT, usualArithmeticConversion, integerPromotion, CFuncType, CVoid, checkTypeComplete, getQualifier\n} from \"./types\";\n\n// Classes to represent all the possible expression types in the IR\n\nexport type CExpression =\n    CConstant | CIdentifier | CStringLiteral |\n    CFunctionCall | CMemberAccess | CIncrDecr | // postfix\n    CAddressOf | CDereference | CUnaryPlusMinus | CBitwiseNot | CLogicalNot | CSizeof | // unary\n    CCast |\n    CMulDiv | CMod | CAddSub | CShift |\n    CRelational | CEquality |\n    CBitwiseAndOr | CLogicalAndOr |\n    CConditional | CAssignment | CComma;\n\n// evaluated expression, value and type pair\nexport type CValue = {readonly value: number | bigint, readonly type: CArithmetic | CPointer};\n\nexport class CConstant {\n    readonly lvalue = false;\n\n    constructor(readonly node: ParseNode, readonly type: CArithmetic, readonly value: bigint | number) {\n    }\n\n    changeType(type: CArithmetic): CConstant {\n        if (this.type.equals(type)) return this;\n\n        let newValue: bigint | number;\n        if (type.equals(CArithmetic.BOOL)) {\n            // eslint-disable-next-line eqeqeq\n            newValue = this.value == 0 ? 0 : 1;\n        } else if (type.type === \"float\") {\n            newValue = Number(this.value);\n        } else {\n            if (this.value > type.maxValue || this.value < type.minValue) {\n                throw new checks.ExpressionTypeError(this.node, `value which fits in ${type.typeName}`, this.value.toString());\n            }\n            newValue = BigInt(this.value);\n        }\n        return new CConstant(this.node, type, newValue);\n    }\n\n    // for analyzing expression dependencies\n    *identifiers(): IterableIterator<CIdentifier> {\n        // no identifier children\n    }\n}\n\nexport class CIdentifier {\n    readonly lvalue: boolean;\n\n    constructor(readonly node: ParseNode, readonly value: CDeclaration) {\n        this.lvalue = !(value.type instanceof CFuncType);\n    }\n\n    get type(): CType {\n        return this.value.type.pointerGeneration;\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield this;\n    }\n}\n\nexport class CStringLiteral {\n    readonly lvalue = false;\n    readonly type: CPointer;\n\n    constructor(readonly node: ParseNode, readonly value: bigint[]) {\n        // currently only supports UTF8\n        if (value.length === 0 || value[value.length - 1] !== 0n) {\n            throw new checks.ExpressionTypeError(node, \"null terminated char[]\", \"char[]\");\n        }\n        this.type = new CArray(node, CArithmetic.U8, value.length).pointerGeneration;\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        // no identifier children\n    }\n}\n\nexport class CFunctionCall {\n    readonly lvalue = false;\n    readonly fnType: CFuncType;\n    readonly type: CType;\n\n    constructor(readonly node: ParseNode, readonly body: CExpression, readonly args: CExpression[]) {\n        this.fnType = checks.asFunction(body.node, body.type);\n        this.type = this.fnType.returnType.pointerGeneration;\n\n        // check arguments correct for the function type\n        if (this.fnType.variadic && this.fnType.parameterTypes.length > args.length) {\n            throw new checks.ExpressionTypeError(node, `at least ${this.fnType.parameterTypes.length} argument(s) to variadic function`);\n        } else if (!this.fnType.variadic && this.fnType.parameterTypes.length !== args.length) {\n            throw new checks.ExpressionTypeError(node, `${this.fnType.parameterTypes.length} argument(s)`, `${args.length}`);\n        }\n        for (let i = 0; i < this.fnType.parameterTypes.length; i++) {\n            CAssignment.checkAssignmentValid(args[i].node, this.fnType.parameterTypes[i], args[i]);\n        }\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.body.identifiers();\n        for (const a of this.args) yield* a.identifiers();\n    }\n}\n\nexport class CMemberAccess {\n    readonly lvalue: boolean;\n    readonly structUnion: CStruct | CUnion;\n    readonly type: CType;\n\n    /** transform `e.member` to `(&e)->member` before calling */\n    constructor(readonly node: ParseNode, readonly body: CExpression, readonly member: string) {\n        const bodyType = body.type instanceof CPointer ? (body.type.original ?? body.type) : body.type; // no pointer gen\n        const pointerType = checks.asPointer(body.node, bodyType);\n        this.structUnion = checks.asStructOrUnion(body.node, pointerType.type);\n\n        const type = this.structUnion.memberType(member);\n        this.type = type.pointerGeneration;\n        this.lvalue = !(this.type instanceof CArray);\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.body.identifiers();\n    }\n}\n\nexport class CIncrDecr {\n    readonly lvalue = false;\n    readonly type: CArithmetic | CPointer;\n\n    constructor(readonly node: ParseNode, readonly body: CExpression,\n                readonly op: \"++\" | \"--\", readonly pos: \"pre\" | \"post\") {\n        checks.checkLvalue(body, true);\n\n        const bodyType = body.type instanceof CPointer ? (body.type.original ?? body.type) : body.type; // no pointer gen\n        this.type = checks.asNonFunctionPointer(body.node, checks.asArithmeticOrPointer(body.node, bodyType));\n        if (this.type instanceof CPointer) checkTypeComplete(this.type.type);\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.body.identifiers();\n    }\n}\n\nexport class CSizeof {\n    readonly lvalue = false;\n    readonly type = CSizeT;\n    readonly body: CType;\n\n    constructor(readonly node: ParseNode, body: CType) {\n        this.body = body instanceof CPointer ? (body.original ?? body) : body; // no pointer gen\n        if (this.body.incomplete || this.body.bytes === 0 || this.body instanceof CFuncType) {\n            throw new checks.ExpressionTypeError(node, \"Complete non-function type\", body.typeName);\n        }\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        // no identifier children\n    }\n}\n\nexport class CAddressOf { // &\n    readonly lvalue = false;\n    readonly type: CPointer;\n    readonly body: CExpression;\n\n    constructor(readonly node: ParseNode, body: CExpression) {\n        const bodyType = body.type instanceof CPointer ? (body.type.original ?? body.type) : body.type; // no pointer gen\n        if (!(body instanceof CIdentifier && bodyType instanceof CFuncType)) checks.checkLvalue(body, true);\n        this.type = new CPointer(node, bodyType);\n\n        if (body instanceof CIdentifier) {\n            // when translating to wasm all variables which have their address taken have to be stored on the shadow stack\n            (body.value as CVariable | CArgument).addressUsed = true;\n        }\n        this.body = body;\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.body.identifiers();\n    }\n}\n\nexport class CDereference { // * or 'indirection'\n    readonly lvalue = true;\n    readonly type: CType;\n\n    constructor(readonly node: ParseNode, readonly body: CExpression) {\n        this.type = checks.asPointer(node, body.type).type.pointerGeneration;\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.body.identifiers();\n    }\n}\n\nexport class CUnaryPlusMinus {\n    readonly lvalue = false;\n    readonly type: CArithmetic;\n    readonly bodyType: CArithmetic;\n\n    constructor(readonly node: ParseNode, readonly body: CExpression, readonly op: \"+\" | \"-\") {\n        this.bodyType = checks.asArithmetic(body.node, body.type);\n        this.type = integerPromotion(this.bodyType);\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.body.identifiers();\n    }\n}\n\nexport class CBitwiseNot {\n    readonly lvalue = false;\n    readonly type: CArithmetic;\n    readonly bodyType: CArithmetic;\n\n    constructor(readonly node: ParseNode, readonly body: CExpression) {\n        this.bodyType = checks.asInteger(body.node, body.type);\n        this.type = this.bodyType.bytes < CArithmetic.S32.bytes ? CArithmetic.S32 : this.bodyType;\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.body.identifiers();\n    }\n}\n\nexport class CLogicalNot {\n    readonly lvalue = false;\n    readonly type = CArithmetic.S32;\n\n    constructor(readonly node: ParseNode, readonly body: CExpression) {\n        checks.asArithmeticOrPointer(body.node, body.type);\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.body.identifiers();\n    }\n}\n\nexport class CCast {\n    readonly lvalue = false;\n    readonly type: CType;\n\n    constructor(readonly node: ParseNode, type: CType, readonly body: CExpression) {\n        this.type = type.pointerGeneration;\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.body.identifiers();\n    }\n}\n\nexport class CMulDiv {\n    readonly lvalue = false;\n    readonly type: CArithmetic;\n\n    constructor(readonly node: ParseNode, readonly lhs: CExpression, readonly rhs: CExpression, readonly op: \"*\" | \"/\") {\n        this.type = usualArithmeticConversion(\n            checks.asArithmetic(lhs.node, lhs.type),\n            checks.asArithmetic(rhs.node, rhs.type));\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.lhs.identifiers();\n        yield* this.rhs.identifiers();\n    }\n}\n\nexport class CMod {\n    readonly lvalue = false;\n    readonly type: CArithmetic;\n\n    constructor(readonly node: ParseNode, readonly lhs: CExpression, readonly rhs: CExpression) {\n        this.type = usualArithmeticConversion(\n            checks.asInteger(lhs.node, lhs.type),\n            checks.asInteger(rhs.node, rhs.type));\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.lhs.identifiers();\n        yield* this.rhs.identifiers();\n    }\n}\n\n// Array subscript a[b] becomes *(a + b)\nexport class CAddSub {\n    readonly lvalue = false;\n    readonly type: CArithmetic | CPointer;\n\n    constructor(readonly node: ParseNode, readonly lhs: CExpression, readonly rhs: CExpression, readonly op: \"+\" | \"-\") {\n        if (lhs.type instanceof CPointer && rhs.type instanceof CPointer) { // both pointers\n            if (!lhs.type.equals(rhs.type)) throw new checks.ExpressionTypeError(node, \"both pointers to have the same type\");\n            checkTypeComplete(lhs.type.type);\n            this.type = checks.asNonFunctionPointer(lhs.node, lhs.type);\n            checks.asNonFunctionPointer(rhs.node, rhs.type);\n\n        } else if (lhs.type instanceof CPointer) { // one pointer, one integral\n            checks.asInteger(rhs.node, rhs.type);\n            checkTypeComplete(lhs.type.type);\n            this.type = checks.asNonFunctionPointer(lhs.node, lhs.type);\n\n        } else if (rhs.type instanceof CPointer) { // one pointer, one integral\n            checks.asInteger(lhs.node, lhs.type);\n            checkTypeComplete(rhs.type.type);\n            this.type = checks.asNonFunctionPointer(rhs.node, rhs.type);\n\n        } else {\n            this.type = usualArithmeticConversion(checks.asArithmetic(lhs.node, lhs.type), checks.asArithmetic(rhs.node, rhs.type));\n        }\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.lhs.identifiers();\n        yield* this.rhs.identifiers();\n    }\n}\n\nexport class CShift {\n    readonly lvalue = false;\n    readonly type: CArithmetic;\n\n    constructor(readonly node: ParseNode, readonly lhs: CExpression, readonly rhs: CExpression, readonly dir: \"left\" | \"right\") {\n        this.type = integerPromotion(checks.asInteger(lhs.node, lhs.type));\n        checks.asInteger(rhs.node, rhs.type);\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.lhs.identifiers();\n        yield* this.rhs.identifiers();\n    }\n}\n\nexport class CRelational {\n    readonly lvalue = false;\n    readonly type = CArithmetic.BOOL;\n    readonly commonType: CArithmetic;\n\n    constructor(readonly node: ParseNode, readonly lhs: CExpression, readonly rhs: CExpression, readonly op: \"LT\" | \"GT\" | \"LEq\" | \"GEq\") {\n        checks.asArithmeticOrPointer(lhs.node, lhs.type);\n        checks.asArithmeticOrPointer(rhs.node, rhs.type);\n\n        this.commonType = usualArithmeticConversion(\n            lhs.type instanceof CArithmetic ? lhs.type : CSizeT,\n            rhs.type instanceof CArithmetic ? rhs.type : CSizeT);\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.lhs.identifiers();\n        yield* this.rhs.identifiers();\n    }\n}\n\nexport class CEquality {\n    readonly lvalue = false;\n    readonly type = CArithmetic.BOOL;\n    readonly commonType: CArithmetic;\n\n    constructor(readonly node: ParseNode, readonly lhs: CExpression, readonly rhs: CExpression, readonly op: \"==\" | \"!=\") {\n        checks.asArithmeticOrPointer(lhs.node, lhs.type);\n        checks.asArithmeticOrPointer(rhs.node, rhs.type);\n\n        this.commonType = usualArithmeticConversion(\n            lhs.type instanceof CArithmetic ? lhs.type : CSizeT,\n            rhs.type instanceof CArithmetic ? rhs.type : CSizeT);\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.lhs.identifiers();\n        yield* this.rhs.identifiers();\n    }\n}\n\nexport class CBitwiseAndOr {\n    readonly lvalue = false;\n    readonly type: CArithmetic;\n\n    constructor(readonly node: ParseNode, readonly lhs: CExpression, readonly rhs: CExpression, readonly op: \"and\" | \"or\" | \"xor\") {\n        this.type = usualArithmeticConversion(\n            checks.asInteger(lhs.node, lhs.type),\n            checks.asInteger(rhs.node, rhs.type));\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.lhs.identifiers();\n        yield* this.rhs.identifiers();\n    }\n}\n\nexport class CLogicalAndOr {\n    readonly lvalue = false;\n    readonly type = CArithmetic.BOOL;\n\n    constructor(readonly node: ParseNode, readonly lhs: CExpression, readonly rhs: CExpression, readonly op: \"and\" | \"or\") {\n        checks.asArithmeticOrPointer(lhs.node, lhs.type);\n        checks.asArithmeticOrPointer(rhs.node, rhs.type);\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.lhs.identifiers();\n        yield* this.rhs.identifiers();\n    }\n}\n\nexport class CConditional { // [test] ? [trueValue] : [falseValue]\n    readonly lvalue = false;\n    readonly type: CType;\n\n    constructor(readonly node: ParseNode, readonly test: CExpression, readonly trueValue: CExpression, readonly falseValue: CExpression) {\n        checks.asArithmeticOrPointer(test.node, test.type);\n\n        if (trueValue.type instanceof CArithmetic && falseValue.type instanceof CArithmetic) {\n            this.type = usualArithmeticConversion(trueValue.type, falseValue.type);\n            return;\n        } else if (trueValue.type.equals(falseValue.type)) {\n            this.type = trueValue.type;\n            return;\n        } else if (trueValue.type instanceof CPointer && falseValue.type instanceof CPointer) {\n            // both pointers - check if either is void* pointer\n            if (trueValue.type.type instanceof CVoid) {\n                this.type = falseValue.type;\n                return;\n            } else if (falseValue.type.type instanceof CVoid) {\n                this.type = trueValue.type;\n                return;\n            }\n        } else if (trueValue.type instanceof CPointer || falseValue.type instanceof CPointer) {\n            // one pointer - check if other null constant\n            const otherValue = trueValue.type instanceof CPointer ? falseValue : trueValue;\n            // eslint-disable-next-line eqeqeq\n            if (otherValue instanceof CConstant && otherValue.value == 0) {\n                this.type = trueValue.type instanceof CPointer ? trueValue.type : falseValue.type;\n                return;\n            }\n        }\n        throw new checks.ExpressionTypeError(node, \"both conditional branches to have the same type\", \"different types\");\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.test.identifiers();\n        yield* this.trueValue.identifiers();\n        yield* this.falseValue.identifiers();\n    }\n}\n\nexport class CAssignment {\n    readonly lvalue = false;\n    readonly type: CType;\n\n    // rhs may require casting\n    constructor(readonly node: ParseNode, readonly lhs: CExpression, readonly rhs: CExpression | CInitializer,\n                readonly assignmentType: pt.AssignmentType, readonly initialAssignment: boolean = false) {\n        // check lvalue\n        const lhsType = lhs.type instanceof CPointer ? (lhs.type.original ?? lhs.type) : lhs.type; // no pointer gen\n        checks.checkLvalue(lhs, true);\n        if ((lhsType instanceof CArray && !initialAssignment) || lhsType instanceof CFuncType || lhs.type.incomplete) {\n            throw new checks.ExpressionTypeError(lhs.node, \"assignable type\");\n        } else if (getQualifier(lhsType) === \"const\" && !initialAssignment) {\n            throw new checks.ExpressionTypeError(lhs.node, \"non-const location\");\n        } else if ((lhsType instanceof CStruct || lhsType instanceof CUnion) && lhsType.hasConstMember() && !initialAssignment) {\n            throw new checks.ExpressionTypeError(lhs.node, \"structure without a const member\");\n        }\n        this.type = lhsType.pointerGeneration;\n\n        // check assignment types are valid\n        if (assignmentType) {\n            if (rhs instanceof CInitializer) {\n                throw new checks.ExpressionTypeError(node,\"simple assignments with structure initializers\");\n            }\n            let rhsType = rhs.type;\n\n            // typecheck `lhs op= rhs` as `lhs = lhs op rhs`\n            // LHS only evaluated once so can't just be transformed: see `a[i++] += 1;`\n            switch (assignmentType) {\n            case \"mul\": rhsType = new CMulDiv(node, lhs, rhs, \"*\").type; break;\n            case \"div\": rhsType = new CMulDiv(node, lhs, rhs, \"/\").type; break;\n            case \"mod\": rhsType = new CMod(node, lhs, rhs).type; break;\n            case \"add\": rhsType = new CAddSub(node, lhs, rhs, \"+\").type; break;\n            case \"sub\": rhsType = new CAddSub(node, lhs, rhs, \"-\").type; break;\n            case \"leftShift\": rhsType = new CShift(node, lhs, rhs, \"left\").type; break;\n            case \"rightShift\": rhsType = new CShift(node, lhs, rhs, \"right\").type; break;\n            case \"bitwiseAnd\": rhsType = new CBitwiseAndOr(node, lhs, rhs, \"and\").type; break;\n            case \"bitwiseOr\": rhsType = new CBitwiseAndOr(node, lhs, rhs, \"or\").type; break;\n            case \"bitwiseXor\": rhsType = new CBitwiseAndOr(node, lhs, rhs, \"xor\").type; break;\n            default: throw new checks.ExpressionTypeError(node, \"valid assignment type\");\n            }\n            CAssignment._checkAssignmentTypeValid(node, lhsType, rhsType);\n        } else {\n            CAssignment.checkAssignmentValid(node, lhsType, rhs);\n        }\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.lhs.identifiers();\n        yield* this.rhs.identifiers();\n    }\n\n    static checkAssignmentValid(node: ParseNode, varType: CType, value: CExpression | CInitializer): void {\n        // also allow constant 0 to be assigned to a pointer\n        if (varType instanceof CPointer && value instanceof CConstant) {\n            if (value.value === 0n) return;\n        }\n        this._checkAssignmentTypeValid(node, varType, value.type);\n    }\n\n    private static _checkAssignmentTypeValid(node: ParseNode, varType: CType, valueType: CType): void {\n        if (varType.equals(valueType)) return;\n        if (varType instanceof CArithmetic && valueType instanceof CArithmetic) {\n            return; // arithmetic types always assignable\n        }\n        if (varType instanceof CPointer && valueType instanceof CPointer) {\n            // void pointers can be assigned to any pointer and any pointer can be assigned to a void pointer\n            if (varType.type instanceof CVoid || valueType.type instanceof CVoid) return;\n            // allow non-constant pointers to be assigned to constant pointers\n            if (varType.type.equals(valueType.type)) return;\n        }\n        if (varType instanceof CPointer && valueType instanceof CFuncType) {\n            // implicit function pointer conversion\n            if (varType.type.equals(valueType)) return;\n        }\n        if (valueType instanceof CPointer && valueType.original) {\n            // pointer generation\n            if (varType.equals(valueType.original)) return;\n\n            if (varType instanceof CArray && valueType.original instanceof CArray && varType.type.equals(valueType.type)) {\n                // allow assigning smaller arrays to larger ones\n                if ((valueType.original.length ?? 0) < (varType.length ?? 0)) return;\n            }\n        }\n\n        throw new checks.ExpressionTypeError(node, varType.typeName, valueType.typeName);\n    }\n}\n\nexport class CComma {\n    readonly lvalue = false;\n    readonly type: CType;\n\n    constructor(readonly node: ParseNode, readonly lhs: CExpression, readonly rhs: CExpression) {\n        this.type = rhs.type;\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.lhs.identifiers();\n        yield* this.rhs.identifiers();\n    }\n}\n\n/** Special type of expression permitted only in declarations */\nexport class CInitializer {\n    private _type: CType;\n    private _memberTypes: CType[] = [];\n\n    constructor(readonly node: ParseNode, readonly body: (CExpression | CInitializer)[], type?: CType) {\n        // default to a void* array which isn't the true type but lets the array size be used when declaring arrays\n        this._type = type ?? new CArray(undefined, new CPointer(undefined, new CVoid()), body.length);\n    }\n\n    get memberTypes(): ReadonlyArray<CType> {\n        return this._memberTypes;\n    }\n\n    get type(): CType {\n        return this._type;\n    }\n\n    /** Once the initializer is recursively constructed and the declaration's type is known, set the type of the\n     * initializer to the type of the declaration, checking that this initializer is valid for the provided type */\n    set type(value: CType) {\n        this._memberTypes = [];\n\n        if (value instanceof CArray) {\n            if (this.body.length > (value.length ?? Infinity)) {\n                throw new checks.ExpressionTypeError(this.node, `at most ${value.length} elements`, `${this.body.length} elements`);\n            }\n            for (let i = 0; i < this.body.length; i++) {\n                this.body[i] = CInitializer.typeCheck(value.type, this.body[i]);\n                this._memberTypes.push(value.type);\n            }\n\n        } else if (value instanceof CStruct) {\n            if (this.body.length > value.members.length) {\n                throw new checks.ExpressionTypeError(this.node, `at most ${value.members.length} elements`, `${this.body.length} elements`);\n            }\n            for (let i = 0; i < this.body.length; i++) {\n                this.body[i] = CInitializer.typeCheck(value.members[i].type, this.body[i]);\n                this._memberTypes.push(value.members[i].type);\n            }\n\n        } else if (value instanceof CUnion) {\n            if (this.body.length > 1) {\n                throw new checks.ExpressionTypeError(this.node, `one element matching first member in union`, `${this.body.length} elements`);\n            } else if (this.body.length === 1) {\n                this.body[0] = CInitializer.typeCheck(value.members[0].type, this.body[0]);\n                this._memberTypes.push(value.members[0].type);\n            }\n\n        } else {\n            throw new checks.ExpressionTypeError(this.node, \"Invalid type for initializer\");\n        }\n        this._type = value;\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        for (const c of this.body) yield* c.identifiers();\n    }\n\n    private static typeCheck(desiredType: CType, expr: CExpression | CInitializer): CExpression | CInitializer {\n        if (expr instanceof CInitializer) {\n            expr.type = desiredType;\n        } else {\n            CAssignment.checkAssignmentValid(expr.node, desiredType, expr);\n\n            if (expr instanceof CConstant && desiredType instanceof CArithmetic && expr.type !== desiredType) {\n                expr = expr.changeType(desiredType);\n            }\n        }\n        return expr;\n    }\n}\n","import {CError} from \"../c_error\";\nimport type {ParseNode} from \"../parsing\";\nimport type {CDeclaration} from \"./declarations\";\nimport {CFuncDeclaration, CFuncDefinition, CVarDeclaration, CVarDefinition} from \"./declarations\";\nimport type {CLabelledStatement} from \"./statements\";\nimport type {CCompound, CType} from \"./types\";\n\n/**\n * Represents a scope storing identifiers (variables & functions) and tags (struct, union & enum names) in the IR.\n * Each one has a parent scope excluding the base scope for the translation unit.\n *\n * e.g. base scope (function declarations) <- function scope (contains parameters) <- compound statement scope (fn locals).\n *\n * If a tag or identifier isn't found in the current scope, parents are checked.\n */\nexport class Scope {\n    private tags = new Map<string, CCompound>(); // names of structs, unions & enums\n    private identifiers = new Map<string, CDeclaration>(); // names of variables and functions\n    private typedefs = new Map<string, CType>();\n    labelledStatement?: CLabelledStatement;\n\n    constructor(readonly node?: ParseNode,\n                readonly parent?: Scope,\n                readonly func: CFuncDefinition | undefined = parent?.func) {\n    }\n\n    private _getTag(tag: string): CCompound | undefined {\n        // perform recursive lookup in parents if not found\n        return this.tags.get(tag) ?? this.parent?._getTag(tag);\n    }\n\n    lookupTag<T extends CCompound>(tag: string, wantedType?: { new(...args: any[]): T }, node?: ParseNode): T | undefined {\n        const result = this._getTag(tag);\n        if (wantedType && result && wantedType.prototype !== Object.getPrototypeOf(result)) {\n            throw new ScopeError(\"`\" + tag + \"` was already declared as a \" + result.typeName, result.node, node);\n        }\n        return result as T | undefined;\n    }\n\n    addTag(value: CCompound): void {\n        if (!value.name) throw new Error(\"Cannot add nameless compound type to scope\"); // shouldn't happen\n        if (this._getTag(value.name)) throw new ScopeError(\"Compound type `\" + value.name + \"` is already defined!\", value.node);\n        this.tags.set(value.name, value);\n    }\n\n    private _getId(name: string): CDeclaration | undefined {\n        return this.identifiers.get(name) ?? this.parent?._getId(name);\n    }\n\n    lookupIdentifier(name: string, node?: ParseNode): CDeclaration {\n        const result = this._getId(name);\n        if (!result) {\n            throw new ScopeError(\"Failed to find `\" + name + \"`\", node);\n        }\n        return result;\n    }\n\n    addIdentifier(value: CDeclaration): void {\n        const existing = this.identifiers.get(value.name); // allowing redefining identifiers defined in parent scopes\n        if (existing) {\n            if (existing.type.equals(value.type) && existing instanceof CFuncDeclaration && value instanceof CFuncDefinition) {\n                // allow replacement of function declaration with definition\n                if (existing.linkage !== \"external\" && value.linkage === \"external\") {\n                    // linkage inherited from first declaration\n                    value.linkage = existing.linkage;\n                }\n                existing.definition = value;\n            } else if (existing.type.equals(value.type) && value instanceof CFuncDeclaration) {\n                // allow functions to be redeclared (but don't override instance in scope)\n                if (existing instanceof CFuncDeclaration) existing.fnImport ||= value.fnImport;\n                return;\n            } else if (existing.type.equals(value.type) && existing instanceof CVarDeclaration && value instanceof CVarDefinition) {\n                // allow replacement of variable declaration with definition\n                if (existing.linkage !== \"external\" && existing.linkage !== value.linkage) {\n                    // check linkage is the same\n                    throw new ScopeError(\"Variable `\" + value.name + \"` is already defined with \" + existing.linkage + \" linkage\", existing.node, value.node);\n                }\n                existing.definition = value;\n            } else if (existing.type.equals(value.type) && value instanceof CVarDeclaration) {\n                // allow variables to be redeclared (but don't override instance in scope)\n                if (existing.linkage !== \"external\" && existing.linkage !== value.linkage) {\n                    // check linkage is the same\n                    throw new ScopeError(\"Variable `\" + value.name + \"` is already defined with \" + existing.linkage + \" linkage\", existing.node, value.node);\n                }\n                return;\n            } else {\n                throw new ScopeError(\"Identifier `\" + value.name + \"` is already defined in this scope!\", existing.node, value.node);\n            }\n        }\n        this.identifiers.set(value.name, value);\n    }\n\n    get declarations(): ReadonlyArray<CDeclaration> {\n        return [...this.identifiers.values()];\n    }\n\n    private _getTypedef(id: string): CType | undefined {\n        // perform recursive lookup in parents if not found\n        return this.typedefs.get(id) ?? this.parent?._getTypedef(id);\n    }\n\n    lookupTypedef(id: string, node?: ParseNode): CType {\n        const result = this._getTypedef(id);\n        if (result === undefined) {\n            throw new ScopeError(\"typedef `\" + id + \"` not found in scope\", node);\n        }\n        return result;\n    }\n\n    addTypedef(id: string, type: CType, node?: ParseNode): void {\n        const existing = this._getTypedef(id);\n        if (existing) {\n            if (existing.equals(type)) return;\n            throw new ScopeError(\"typedef already defined with a different type\", node);\n        }\n        this.typedefs.set(id, type);\n    }\n}\n\nclass ScopeError extends CError {\n    name = \"ScopeError\";\n}\n","import type * as pt from \"../parsing/parsetree\";\nimport {CFuncDefinition} from \"./declarations\";\nimport {CExpression, CAssignment, CValue} from \"./expressions\";\nimport {Scope} from \"./scope\";\nimport {ExpressionTypeError, asArithmeticOrPointer} from \"./type_checking\";\n\n// classes to represent the various C statements in the IR\nexport type CStatement =\n    CCompoundStatement | CExpressionStatement | CNop |\n    CIf | CForLoop | CWhileLoop | CDoLoop | CSwitch |\n    CGoto | CContinue | CBreak | CReturn;\n\nexport class CCompoundStatement {\n    readonly scope: Scope;\n    readonly statements: CStatement[] = [];\n\n    constructor(readonly node: pt.ParseNode, readonly parent: CStatement | CFuncDefinition) {\n        this.scope = new Scope(node, parent.scope, parent instanceof CFuncDefinition ? parent : undefined);\n    }\n}\n\nexport class CExpressionStatement {\n    constructor(readonly node: pt.ParseNode, readonly expression: CExpression, readonly parent: CStatement) {\n    }\n\n    get scope(): Scope {\n        return this.parent.scope;\n    }\n}\n\nexport class CNop {\n    constructor(readonly node: pt.NoOp, readonly parent: CStatement) {\n    }\n\n    get scope(): Scope {\n        return this.parent.scope;\n    }\n}\n\nexport class CIf {\n    ifBody?: CStatement;\n    elseBody?: CStatement;\n\n    constructor(readonly node: pt.IfStatement, readonly test: CExpression, readonly parent: CStatement) {\n        asArithmeticOrPointer(test.node, test.type);\n    }\n\n    get scope(): Scope {\n        return this.parent.scope;\n    }\n}\n\nexport class CForLoop {\n    init?: CExpressionStatement | CExpressionStatement[] | CNop;\n    test?: CExpressionStatement | CNop;\n    update?: CExpression;\n    body?: CStatement;\n\n    readonly scope: Scope; // own scope for init variable\n\n    constructor(readonly node: pt.ForLoop, readonly parent: CStatement) {\n        this.scope = new Scope(node, parent.scope);\n    }\n}\n\nexport class CWhileLoop {\n    body?: CStatement;\n\n    constructor(readonly node: pt.WhileLoop, readonly test: CExpression, readonly parent: CStatement) {\n        asArithmeticOrPointer(test.node, test.type);\n    }\n\n    get scope(): Scope {\n        return this.parent.scope;\n    }\n}\n\nexport class CDoLoop {\n    body?: CStatement;\n\n    constructor(readonly node: pt.DoWhileLoop, readonly test: CExpression, readonly parent: CStatement) {\n        asArithmeticOrPointer(test.node, test.type);\n    }\n\n    get scope(): Scope {\n        return this.parent.scope;\n    }\n}\n\nexport class CGoto {\n    constructor(readonly node: pt.GotoStatement, readonly target: CLabelledStatement, readonly parent: CStatement) {\n    }\n\n    get scope(): Scope {\n        return this.parent.scope;\n    }\n}\n\nexport class CSwitch {\n    children: {cases: CValue[], body: CCompoundStatement, default: boolean}[] = [];\n\n    constructor(readonly node: pt.SwitchStatement, readonly expression: CExpression, readonly parent: CStatement) {\n    }\n\n    get scope(): Scope {\n        return this.parent.scope;\n    }\n}\n\nexport class CContinue {\n    constructor(readonly node: pt.ContinueStatement,\n                readonly loop: CForLoop | CWhileLoop | CDoLoop,\n                readonly parent: CStatement) {\n    }\n\n    get scope(): Scope {\n        return this.parent.scope;\n    }\n}\n\nexport class CBreak {\n    constructor(readonly node: pt.BreakStatement,\n                readonly target: CForLoop | CWhileLoop | CDoLoop | CSwitch,\n                readonly parent: CStatement) {\n    }\n\n    get scope(): Scope {\n        return this.parent.scope;\n    }\n}\n\nexport class CReturn {\n    constructor(readonly node: pt.ReturnStatement,\n                readonly func: CFuncDefinition,\n                public value: CExpression | undefined,\n                readonly parent: CStatement) {\n\n        if (value === undefined) {\n            if (func.type.returnType.bytes > 0) {\n                // function return type is not void but a value was not provided\n                throw new ExpressionTypeError(node, \"`return [expression]`\", \"`return;`\");\n            }\n        } else {\n            if (!func.type.returnType.equals(value.type)) {\n                // check provided return value matches the function's return type\n                CAssignment.checkAssignmentValid(node, func.type.returnType, value);\n            }\n        }\n    }\n\n    get scope(): Scope {\n        return this.parent.scope;\n    }\n}\n\n// not a CStatement, used to store labelled statements in Scopes\nexport class CLabelledStatement {\n    body?: CStatement;\n\n    constructor(readonly node: pt.Statement, readonly label: string) {\n    }\n}\n","import type {FunctionDefinition, ParseNode} from \"../parsing/parsetree\";\nimport type {CInitializer, CExpression} from \"./expressions\";\nimport type {Scope} from \"./scope\";\nimport {CCompoundStatement} from \"./statements\";\nimport type {CFuncType, CNotFuncType, CQualifiedType} from \"./types\";\n\n// classes to represent all the different types of declarations in the IR\nexport type CDeclaration = CVariable | CFunction;\nexport type CVariable = CVarDeclaration | CVarDefinition | CArgument;\nexport type CFunction = CFuncDefinition | CFuncDeclaration;\n\nexport class CVarDeclaration {\n    readonly declType = \"variable\";\n    _addressUsed: boolean = false;\n    _definition?: CVarDefinition;\n\n    constructor(readonly node: ParseNode,\n                readonly name: string,\n                readonly type: CQualifiedType<CNotFuncType>,\n                readonly storage: \"static\" | \"local\",\n                readonly linkage: \"none\" | \"internal\" | \"external\") {\n    }\n\n    set addressUsed(b: boolean) {\n        if (this._definition) this._definition.addressUsed ||= b;\n        else this._addressUsed ||= b;\n    }\n\n    get addressUsed(): boolean {\n        return this._definition ? this._definition.addressUsed : this._addressUsed;\n    }\n\n    set definition(v: CVarDefinition | undefined) {\n        if (v === undefined) throw new Error(\"Cannot set definition to undefined\");\n        v.addressUsed ||= this._addressUsed;\n        this._definition = v;\n    }\n\n    get definition(): CVarDefinition | undefined {\n        return this._definition;\n    }\n}\n\nexport class CVarDefinition {\n    readonly declType = \"variable\";\n    staticValue?: CExpression | CInitializer;\n    addressUsed: boolean = false;\n    readonly dependencies = new Map<CDeclaration, boolean>(); // direct dependencies of initializer only\n\n    constructor(readonly node: ParseNode,\n                readonly name: string,\n                readonly type: CQualifiedType<CNotFuncType>,\n                readonly storage: \"static\" | \"local\",\n                public linkage: \"none\" | \"internal\" | \"external\") {\n    }\n}\n\nexport class CArgument {\n    readonly declType = \"variable\";\n    readonly storage = \"argument\";\n    readonly linkage = \"none\";\n    addressUsed: boolean = false;\n\n    constructor(readonly node: ParseNode,\n                readonly name: string,\n                readonly type: CQualifiedType<CNotFuncType>,\n                readonly index: number) {\n    }\n}\n\nexport class CFuncDeclaration {\n    readonly declType = \"function\";\n    definition?: CFuncDefinition | CFuncImport;\n\n    constructor(readonly node: ParseNode,\n                readonly name: string,\n                readonly type: CQualifiedType<CFuncType>,\n                readonly linkage: \"none\" | \"internal\" | \"external\",\n                public fnImport: boolean = false) {\n    }\n}\n\nexport class CFuncImport {\n    readonly declType = \"import\";\n    readonly node: ParseNode;\n\n    constructor(readonly declaration: CFuncDeclaration) {\n        this.node = declaration.node;\n    }\n\n    getFunction(): CFuncDeclaration {\n        return this.declaration;\n    }\n}\n\nexport class CFuncDefinition {\n    readonly declType = \"function\";\n    readonly body: CCompoundStatement;\n    readonly dependencies = new Map<CDeclaration, boolean>(); // direct dependencies only\n    readonly hints: {inline: boolean} = {inline: false};\n\n    constructor(readonly node: FunctionDefinition,\n                readonly name: string,\n                readonly type: CQualifiedType<CFuncType>,\n                public linkage: \"none\" | \"internal\" | \"external\",\n                readonly translationUnit: Scope) {\n        this.body = new CCompoundStatement(node.body, this);\n    }\n\n    get scope(): Scope {\n        return this.translationUnit;\n    }\n\n    equals(t: object): boolean {\n        return t === this;\n    }\n\n    getFunction(): CFuncDefinition {\n        return this;\n    }\n}\n","import {ParseNode} from \"../parsing\";\nimport {CFuncDeclaration} from \"./declarations\";\nimport {Scope} from \"./scope\";\nimport {CFuncType, CVoid, CArithmetic, CPointer} from \"./types\";\n\nconst fakeParseNode: ParseNode = new class extends ParseNode {\n    readonly type: string = \"__internal__\";\n\n    constructor() {\n        super({first_line: 0, first_column: 0, last_line: 0, last_column: 0, source: \"\"});\n    }\n}();\n\nexport const INTERNAL_FNS = {\n    /** For executing arbitrary Wasm. Should NOT contain control flow as the code will not be processed\n     * by optimisations. Similarly, locals should only be accessed as parameters as they map be remapped.\n     *\n     * __wasm_push__([#parameters], [parameter1], [parameter2], ..., [byte1], [byte2]...);\n     */\n    wasm: new CFuncDeclaration(\n        fakeParseNode,\n        \"__wasm__\",\n        new CFuncType(fakeParseNode, new CVoid(), [CArithmetic.U32], undefined, true),\n        \"internal\"\n    ),\n    /** For executing arbitrary Wasm* returning i32 */\n    wasm_i32: new CFuncDeclaration(\n        fakeParseNode,\n        \"__wasm_i32__\",\n        new CFuncType(fakeParseNode, CArithmetic.U32, [CArithmetic.U32], undefined, true),\n        \"internal\"\n    ),\n    /** For executing arbitrary Wasm* returning i64 */\n    wasm_i64: new CFuncDeclaration(\n        fakeParseNode,\n        \"__wasm_i64__\",\n        new CFuncType(fakeParseNode, CArithmetic.U64, [CArithmetic.U32], undefined, true),\n        \"internal\"\n    ),\n    /** For executing arbitrary Wasm* returning f32 */\n    wasm_f32: new CFuncDeclaration(\n        fakeParseNode,\n        \"__wasm_f32__\",\n        new CFuncType(fakeParseNode, CArithmetic.Fp32, [CArithmetic.U32], undefined, true),\n        \"internal\"\n    ),\n    /** For executing arbitrary Wasm* returning f64 */\n    wasm_f64: new CFuncDeclaration(\n        fakeParseNode,\n        \"__wasm_f64__\",\n        new CFuncType(fakeParseNode, CArithmetic.Fp64, [CArithmetic.U32], undefined, true),\n        \"internal\"\n    ),\n    /** For getting the value of the shadow stack pointer\n     *\n     * __wasm_ssp__();\n     */\n    wasm_ssp: new CFuncDeclaration(\n        fakeParseNode,\n        \"__wasm_ssp__\",\n        new CFuncType(fakeParseNode, new CPointer(fakeParseNode, new CVoid(), true), []),\n        \"internal\"\n    ),\n    /**\n     * Wasm real type load - compensates for conversation/type_conversion.ts realType()\n     * Most C values are directly stored as Wasm values, but CStruct and CUnions have to be stored as pointers.\n     * This isn't directly expressed in the type information, and so this function is needed for any C directly manipulating memory.\n     *\n     * __wasm_rload__([ptr]);\n     */\n    wasm_rload: new CFuncDeclaration(\n        fakeParseNode,\n        \"__wasm_rload__\",\n        new CFuncType(fakeParseNode, new CPointer(fakeParseNode, new CVoid(), true), [new CPointer(fakeParseNode, new CVoid(), true)]),\n        \"internal\"\n    )\n};\n\nexport const INTERNAL_SCOPE = new Scope();\nObject.values(INTERNAL_FNS).forEach(x => INTERNAL_SCOPE.addIdentifier(x));\n","import {CVarDefinition} from \"../declarations\";\nimport {CExpression, CConstant, CIdentifier, CSizeof, CBitwiseNot, CLogicalNot, CCast, CMulDiv, CMod, CAddSub, CShift, CRelational, CEquality, CBitwiseAndOr, CLogicalAndOr, CConditional, CUnaryPlusMinus, CValue, CInitializer} from \"../expressions\";\nimport {ExpressionTypeError} from \"../type_checking\";\nimport {CArithmetic, CSizeT, CPointer} from \"../types\";\n\ntype ExtraFn = (e: CExpression, evalExpr: (e: CExpression) => CValue | undefined, fail: (e: CExpression) => undefined) => CValue | undefined;\n\nconst CONSTANT = Symbol(\"constant\");\n\nexport function constExpression(e: CExpression, extra?: ExtraFn): CValue {\n    const v = evalExpression(e, extra);\n    if (v) return v;\n    throw new ExpressionTypeError(e.node, \"constant expression\");\n}\n\nexport function constInteger(e: CExpression, extra?: ExtraFn): CValue & {readonly value: bigint} {\n    const v = evalInteger(e, extra);\n    if (v) return v;\n    throw new ExpressionTypeError(e.node, \"constant integer expression\");\n}\n\nfunction fail(e: CExpression): undefined {\n    (e as object as {[CONSTANT]: boolean})[CONSTANT] = false;\n    return undefined;\n}\n\nexport function evalExpression(e: CExpression, extra?: ExtraFn): CValue | undefined {\n    if (!((e as object as { [CONSTANT]: boolean })[CONSTANT] ?? true)) {\n        return undefined; // cache on expr if failed previously to speed up flags.generation_try_constant_expr\n    } else if (e instanceof CConstant) {\n        return {value: e.value, type: e.type};\n    } else if (e instanceof CIdentifier && e.value instanceof CVarDefinition && e.value.type.qualifier === \"const\" && e.value.staticValue instanceof CConstant) {\n        return evalExpression(e.value.staticValue, extra);\n\n    } else if (e instanceof CSizeof) {\n        return normalizeType({value: e.body.bytes, type: CSizeT});\n\n    } else if (e instanceof CUnaryPlusMinus) {\n        const v = evalExpression(e.body, extra);\n        if (!v) return fail(e);\n        return e.op === \"+\" ? v : {value: -v.value, type: e.type};\n\n    } else if (e instanceof CBitwiseNot) {\n        const v = evalInteger(e.body, extra);\n        if (!v) return fail(e);\n        return normalizeType({value: ~v.value, type: v.type});\n\n    } else if (e instanceof CLogicalNot) {\n        const v = evalExpression(e.body, extra);\n        if (!v) return fail(e);\n        // eslint-disable-next-line eqeqeq\n        return {value: v.value == 0 ? 1n : 0n, type: CArithmetic.S32};\n\n    } else if (e instanceof CCast && (e.type instanceof CArithmetic || e.type instanceof CPointer)) {\n        const v = evalExpression(e.body, extra);\n        if (!v) return fail(e);\n        return normalizeType({value: v.value, type: e.type});\n\n    } else if (e instanceof CMulDiv) {\n        const lhs = evalExpression(e.lhs, extra), rhs = evalExpression(e.rhs, extra);\n        if (!lhs || !rhs) return fail(e);\n        if (e.op === \"*\") {\n            if (e.type.type === \"float\") {\n                return {value: Number(lhs.value) * Number(rhs.value), type: e.type};\n            }\n            return normalizeType({value: BigInt(lhs.value) * BigInt(rhs.value), type: e.type});\n\n            // eslint-disable-next-line eqeqeq\n        } else if (rhs.value != 0) {\n            if (e.type.type === \"float\") {\n                return {value: Number(lhs.value) / Number(rhs.value), type: e.type};\n            }\n            return normalizeType({value: BigInt(lhs.value) / BigInt(rhs.value), type: e.type});\n        }\n\n    } else if (e instanceof CMod) {\n        const lhs = evalInteger(e.lhs, extra), rhs = evalInteger(e.rhs, extra);\n        if (!lhs || !rhs || rhs.value === 0n) return fail(e);\n        return normalizeType({value: lhs.value % rhs.value, type: e.type});\n\n    } else if (e instanceof CAddSub && e.type instanceof CArithmetic) {\n        const lhs = evalExpression(e.lhs, extra), rhs = evalExpression(e.rhs, extra);\n        if (!lhs || !rhs) return fail(e);\n        if (e.op === \"+\") {\n            if (e.type.type === \"float\") {\n                return {value: Number(lhs.value) + Number(rhs.value), type: e.type};\n            }\n            return normalizeType({value: BigInt(lhs.value) + BigInt(rhs.value), type: e.type});\n        } else {\n            if (e.type.type === \"float\") {\n                return {value: Number(lhs.value) - Number(rhs.value), type: e.type};\n            }\n            return normalizeType({value: BigInt(lhs.value) - BigInt(rhs.value), type: e.type});\n        }\n\n    } else if (e instanceof CShift) {\n        const lhs = evalInteger(e.lhs, extra), rhs = evalInteger(e.rhs, extra);\n        if (!lhs || !rhs) return fail(e);\n        if (e.dir === \"left\") {\n            return normalizeType({value: lhs.value << rhs.value, type: e.type});\n        }\n        return normalizeType({value: lhs.value >> rhs.value, type: e.type});\n\n    } else if (e instanceof CRelational) {\n        const lhs = evalExpression(e.lhs, extra), rhs = evalExpression(e.rhs, extra);\n        if (!lhs || !rhs) return fail(e);\n        if (e.op === \"LT\") {\n            return {value: lhs.value < rhs.value ? 1n : 0n, type: CArithmetic.S32};\n        } else if (e.op === \"GT\") {\n            return {value: lhs.value > rhs.value ? 1n : 0n, type: CArithmetic.S32};\n        } else if (e.op === \"LEq\") {\n            return {value: lhs.value <= rhs.value ? 1n : 0n, type: CArithmetic.S32};\n        } else {\n            return {value: lhs.value >= rhs.value ? 1n : 0n, type: CArithmetic.S32};\n        }\n\n    } else if (e instanceof CEquality) {\n        const lhs = evalExpression(e.lhs, extra), rhs = evalExpression(e.rhs, extra);\n        if (!lhs || !rhs) return fail(e);\n        if (e.op === \"==\") {\n            // eslint-disable-next-line eqeqeq\n            return {value: lhs.value == rhs.value ? 1n : 0n, type: CArithmetic.S32};\n        } else {\n            // eslint-disable-next-line eqeqeq\n            return {value: lhs.value != rhs.value ? 1n : 0n, type: CArithmetic.S32};\n        }\n\n    } else if (e instanceof CBitwiseAndOr) {\n        const lhs = evalInteger(e.lhs, extra), rhs = evalInteger(e.rhs, extra);\n        if (!lhs || !rhs) return fail(e);\n        if (e.op === \"and\") {\n            return normalizeType({value: lhs.value & rhs.value, type: e.type});\n        } else if (e.op === \"or\") {\n            return normalizeType({value: lhs.value | rhs.value, type: e.type});\n        } else {\n            return normalizeType({value: lhs.value ^ rhs.value, type: e.type});\n        }\n\n    } else if (e instanceof CLogicalAndOr) {\n        const lhs = evalExpression(e.lhs, extra);\n        if (!lhs) return fail(e);\n        if (e.op === \"and\") {\n            // eslint-disable-next-line eqeqeq\n            if (lhs.value != 0) {\n                const rhs = evalExpression(e.rhs, extra);\n                if (!rhs) return fail(e);\n                // eslint-disable-next-line eqeqeq\n                if (rhs.value != 0) return {value: 1n, type: CArithmetic.S32};\n            }\n            return {value: 0n, type: CArithmetic.S32};\n        } else {\n            // eslint-disable-next-line eqeqeq\n            if (lhs.value != 0) return {value: 1n, type: CArithmetic.S32};\n            const rhs = evalExpression(e.rhs, extra);\n            if (!rhs) return fail(e);\n            // eslint-disable-next-line eqeqeq\n            if (rhs.value != 0) return {value: 1n, type: CArithmetic.S32};\n            return {value: 0n, type: CArithmetic.S32};\n        }\n\n    } else if (e instanceof CConditional && (e.type instanceof CArithmetic || e.type instanceof CPointer)) {\n        const test = evalExpression(e.test, extra);\n        if (!test) return fail(e);\n        let value: CValue | undefined;\n        // eslint-disable-next-line eqeqeq\n        if (test.value != 0) {\n            value = evalExpression(e.trueValue, extra);\n        } else {\n            value = evalExpression(e.falseValue, extra);\n        }\n        if (!value) return fail(e);\n        return normalizeType({value: value.value, type: e.type});\n\n    }\n\n    // for adding addressof support etc for static initializers\n    if (extra !== undefined) {\n        const v = extra(e, (e2) => evalExpression(e2, extra), fail);\n        if (v) return v;\n    }\n\n    fail(e);\n}\n\nexport function evalInteger(e: CExpression, extra?: ExtraFn): undefined | CValue & {readonly value: bigint} {\n    const v = evalExpression(e, extra);\n    if (v?.type instanceof CArithmetic && v.type.type !== \"float\") return {value: BigInt(v.value), type: v.type};\n    return undefined;\n}\n\nfunction normalizeType(v: CValue): CValue {\n    if (v.type instanceof CArithmetic) {\n        if (CArithmetic.BOOL.equals(v.type)) {\n            // eslint-disable-next-line eqeqeq\n            return {value: v.value == 0 ? 0n : 1n, type: CArithmetic.BOOL};\n        } else if (v.type.type === \"float\") {\n            return {value: typeof v.value === \"number\" ? v.value : Number(v.value), type: v.type};\n        } else {\n            let value: bigint;\n            if (typeof v.value === \"number\") {\n                // need to emulate runtime behaviour - i.e. the use of the trunc_sat instructions\n                if (isNaN(v.value)) {\n                    value = 0n;\n                } else if (v.value > v.type.maxValue) {\n                    value = BigInt(v.type.maxValue);\n                } else if (v.value < v.type.minValue) {\n                    value = BigInt(v.type.minValue);\n                } else {\n                    value = BigInt(Math.trunc(v.value));\n                }\n            } else {\n                value = v.value;\n            }\n\n            const bitmask = 2n ** BigInt(8 * v.type.bytes) - 1n;\n            if (v.type.type === \"unsigned\") {\n                value &= bitmask;\n            } else { // signed\n                const minValue = BigInt(v.type.minValue);\n                value = ((value - minValue) & bitmask) + minValue;\n            }\n\n            return {value, type: v.type};\n        }\n    } else { // instanceof CPointer\n        // normalize as if U32\n        const value = normalizeType({value: v.value, type: CArithmetic.U32}).value;\n        return {value: value, type: v.type};\n    }\n}\n\nexport const normalizeValueType = normalizeType;\n","import {CVarDefinition} from \"../declarations\";\nimport {CConstant} from \"../expressions\";\nimport {Scope} from \"../scope\";\nimport {CType, getArithmeticType, CPointer, addQualifier, CFuncType, CNotFuncType, CArray, CEnum, CStruct, CUnion, CCompoundMember, CVoid, CArithmetic} from \"../types\";\nimport {ParseTreeValidationError, pt} from \"../../parsing/\";\nimport {evalIntegerConstant} from \"./expr_transform\";\n\ntype GeneralTypeDecl = {\n    typeInfo: pt.SpecifierQualifiers | pt.DeclarationSpecifiers,\n    declarator?: pt.Declarator | pt.AbstractDeclarator\n};\n\n/** helper function for specifier & declarator type */\nexport function getType(o: GeneralTypeDecl, scope: Scope): CType {\n    let type = getSpecifierType(o.typeInfo, scope);\n    if (o.typeInfo.qualifierList.length) type = addQualifier(type, o.typeInfo.qualifierList[0]);\n    if (o.declarator) type = getDeclaratorType(type, o.declarator, scope);\n    return type;\n}\n\n/** transform the CType from a type specifier into the declarator type */\nexport function getDeclaratorType(type: CType, declarator: pt.Declarator | pt.AbstractDeclarator, scope: Scope): CType {\n    let d: pt.Declarator | pt.AbstractDeclarator | undefined = declarator;\n\n    while (d && !(d instanceof pt.IdentifierDeclarator)) {\n        if (d instanceof pt.PointerDeclarator || d instanceof pt.AbstractPointerDeclarator) {\n            let ptr: pt.Pointer | undefined = d.pointer;\n            while (ptr) {\n                type = new CPointer(ptr, type, ptr.qualifierList?.includes(\"const\"));\n                ptr = ptr.body;\n            }\n            d = d.body;\n\n        } else if (d instanceof pt.ArrayDeclarator || d instanceof pt.AbstractArrayDeclarator) {\n            type = new CArray(d, type);\n            if (d.length) {\n                type.length = Number(evalIntegerConstant(d.length, scope).value);\n                if (type.length <= 0) throw new ParseTreeValidationError(d.length, \"Invalid array length\");\n            }\n            d = d.body;\n\n        } else { // d instanceof pt.(Abstract)FunctionDeclarator\n            const parameterTypes = [];\n            let parameterNames = undefined;\n\n            for (const param of d.args ?? []) {\n                let type = getType(param, scope);\n                if (type instanceof CArray) {\n                    // in function parameters arrays are equivalent to pointers\n                    type = new CPointer(type.node, type.type);\n                } else if (type instanceof CFuncType) {\n                    throw new ParseTreeValidationError(param, \"Functions cannot be parameters\");\n                }\n                parameterTypes.push(type);\n\n                if (param.declarator && !param.declarator.abstractDeclarator) {\n                    parameterNames ??= [];\n                    parameterNames.push(getDeclaratorName(param.declarator));\n                }\n\n                if (parameterNames && parameterNames.length !== parameterTypes.length) {\n                    throw new ParseTreeValidationError(param, \"Unexpected mix of abstract & non-abstract declarators\");\n                }\n            }\n\n            if (parameterTypes.length === 1 && parameterTypes[0] instanceof CVoid) parameterTypes.shift();\n\n            if (parameterTypes.length === 0) {\n                // ensure parameterNames are always non-null in function definitions\n                parameterNames = [];\n            }\n\n            type = new CFuncType(d, type as CNotFuncType, parameterTypes, parameterNames, d.variadic);\n            d = d.body;\n        }\n    }\n    return type;\n}\n\nexport function getDeclaratorName(declarator: pt.Declarator | pt.InitDeclarator): string {\n    while (!(declarator instanceof pt.IdentifierDeclarator)) {\n        declarator = declarator.body;\n    }\n    return declarator.id;\n}\n\n/** Get the base type from the list of specifiers */\nfunction getSpecifierType(d: pt.SpecifierQualifiers | pt.DeclarationSpecifiers, scope: Scope): CType {\n    const specifiers = d.specifierList;\n    const singleSpecifier = specifiers.length === 1 ? specifiers[0] : undefined;\n\n    if (singleSpecifier instanceof pt.StructUnionSpecifier) {\n        const type = singleSpecifier.structure === \"struct\" ? CStruct : CUnion;\n        let structure = new type(singleSpecifier, singleSpecifier.id);\n        if (singleSpecifier.id) {\n            // lookup tag and if it already exists use the existing instance\n            const existing: CStruct | CUnion = scope.lookupTag(singleSpecifier.id, type as any, singleSpecifier) as any;\n            if (existing) {\n                structure = existing;\n            } else {\n                scope.addTag(structure);\n            }\n        }\n        if (!singleSpecifier.declarations) return structure;\n\n        const values: CCompoundMember[] = []; // populate struct/union members if provided\n        for (const declaration of singleSpecifier.declarations) {\n            const baseType = getType(declaration, scope);\n\n            for (const declarator of declaration.list) {\n                const type = getDeclaratorType(baseType, declarator, scope);\n                const name = getDeclaratorName(declarator);\n                if (type.incomplete || type.bytes === 0 || type instanceof CFuncType) {\n                    throw new ParseTreeValidationError(declarator, \"Type must be complete\");\n                }\n\n                values.push(new CCompoundMember(declaration, name, type));\n            }\n        }\n        structure.members = values;\n        structure.node = singleSpecifier; // set the parse node to point to the node which actually defined the members\n        return structure;\n\n    } else if (singleSpecifier instanceof pt.EnumSpecifier) {\n        let cEnum = new CEnum(singleSpecifier, singleSpecifier.id);\n        if (singleSpecifier.id) {\n            // lookup tag and if it already exists use its instance\n            const existing = scope.lookupTag(singleSpecifier.id, CEnum, singleSpecifier);\n            if (existing) {\n                cEnum = existing;\n            } else {\n                scope.addTag(cEnum);\n            }\n        }\n        if (!singleSpecifier.body) return CArithmetic.S32;\n\n        // enum members either provide their own value or use the last value + 1, starting at 0\n        let nextValue = 0n;\n        const values = [];\n        for (const e of singleSpecifier.body) { // populate enum\n            if (e.value) nextValue = evalIntegerConstant(e.value, scope).value;\n\n            // enum constants are `int`s!!!\n            const enumConstant = new CVarDefinition(e, e.id, addQualifier(CArithmetic.S32, \"const\"), \"static\", \"internal\");\n            enumConstant.staticValue = new CConstant(e, CArithmetic.S32, nextValue);\n\n            scope.addIdentifier(enumConstant); // add the enum member as a constant to the scope\n            values.push({name: e.id, value: nextValue++});\n        }\n        cEnum.values = values;\n        cEnum.node = singleSpecifier;\n        return CArithmetic.S32;\n\n    } else if (specifiers.every(x => typeof x === 'string')) {\n        // arithmetic or void\n        const type = getArithmeticType(specifiers as ReadonlyArray<pt.TypeSpecifier & string>);\n        if (type) return type;\n\n    } else if (specifiers.length === 1 && specifiers[0] instanceof pt.CustomTypeSpecifier) {\n        // typedef\n        return scope.lookupTypedef(specifiers[0].name);\n    }\n\n    throw new ParseTreeValidationError(d, \"Invalid specifier\");\n}\n","import {ParseNode, ParseTreeValidationError, pt} from \"../../parsing\";\nimport {\n    CExpression, CConstant, CIdentifier, CFunctionCall, CMemberAccess, CDereference, CConditional,\n    CAssignment, CStringLiteral, CIncrDecr, CAddressOf, CUnaryPlusMinus, CBitwiseNot, CLogicalNot, CSizeof, CAddSub,\n    CCast, CComma, CMulDiv, CMod, CShift, CRelational, CEquality, CBitwiseAndOr, CLogicalAndOr, CValue\n} from \"../expressions\";\nimport {Scope} from \"../scope\";\nimport {CArithmetic, CArray} from \"../types\";\nimport {constInteger} from \"./constant_expressions\";\nimport {getType} from \"./type_transform\";\n\n/** Transform expressions from the parse tree */\nexport function ptExpression(e: pt.Expression, scope: Scope): CExpression {\n    if (e instanceof pt.ConstantExpression) {\n        // pt.ConstantExpression is a wrapped class in the parse tree denoting where constant expressions are expected.\n        return ptExpression(e.expr, scope);\n\n    } else if (e instanceof pt.Constant) {\n        return ptConstant(e);\n\n    } else if (e instanceof pt.Identifier) {\n        const id = new CIdentifier(e, scope.lookupIdentifier(e.name, e));\n        if (scope.func) scope.func.dependencies.set(id.value, true);\n        return id;\n\n    } else if (e instanceof pt.StringLiteral) {\n        const arr: bigint[] = []; // split the literal into characters taking into account escape sequences\n        const charRegex = /[^\\\\\\n\"]|\\\\(?:[^x0-7\\n]|x[0-9a-fA-F]{1,2}|[0-7]{1,3})/y;\n        while (charRegex.lastIndex < e.value.length) {\n            const match = charRegex.exec(e.value);\n            if (match && charRegex.lastIndex !== 0) {\n                arr.push(BigInt(unescapeChar(match[0], e).codePointAt(0) ?? 0)); // unescape the char if needed\n            } else {\n                // regex didn't match the body for some reason, this shouldn't happen\n                throw new ParseTreeValidationError(e, \"Invalid string literal\");\n            }\n        }\n        arr.push(0n); // null terminator\n        return new CStringLiteral(e, arr);\n\n    } else if (e instanceof pt.UnaryExpression) {\n        return ptUnary(e, scope);\n\n    } else if (e instanceof pt.BinaryExpression) {\n        return ptBinary(e, scope);\n\n    } else if (e instanceof pt.SizeofExpression) {\n        if (e.body instanceof pt.Expression) { // sizeof [expression]\n            return new CSizeof(e, ptExpression(e.body, scope).type);\n        } else { // sizeof [type]\n            return new CSizeof(e, getType(e.body, scope));\n        }\n\n    } else if (e instanceof pt.CastExpression) {\n        return new CCast(e, getType(e.targetType, scope), ptExpression(e.body, scope));\n\n    } else if (e instanceof pt.FunctionCallExpression) {\n        return new CFunctionCall(e, ptExpression(e.fn, scope), (e.args ?? []).map(e => ptExpression(e, scope)));\n\n    } else if (e instanceof pt.MemberAccessExpression) {\n        let body = ptExpression(e.lhs, scope);\n        if (!e.pointer) { // transform into pointer access\n            body = new CAddressOf(e, body);\n        }\n        return new CMemberAccess(e, body, e.rhs);\n\n    } else if (e instanceof pt.ConditionalExpression) {\n        return new CConditional(e, ptExpression(e.condition, scope), ptExpression(e.trueValue, scope), ptExpression(e.falseValue, scope));\n\n    } else if (e instanceof pt.AssignmentExpression) {\n        return new CAssignment(e, ptExpression(e.lhs, scope), ptExpression(e.rhs, scope), e.assignType);\n\n    }\n\n    throw new ParseTreeValidationError(e, \"Invalid expression\");\n}\n\n/** Evaluate an expression at compile time to an integer constant */\nexport function evalIntegerConstant(c: pt.ConstantExpression, scope: Scope): CValue & {value: bigint} {\n    const expr = ptExpression(c.expr, scope);\n    return constInteger(expr);\n}\n\nfunction ptUnary(e: pt.UnaryExpression, scope: Scope): CExpression {\n    // transform unary expressions\n    const body = ptExpression(e.body, scope);\n    if (e.type === \"prefixIncrement\") return new CIncrDecr(e, body, \"++\", \"pre\");\n    if (e.type === \"prefixDecrement\") return new CIncrDecr(e, body, \"--\", \"pre\");\n    if (e.type === \"postfixIncrement\") return new CIncrDecr(e, body, \"++\", \"post\");\n    if (e.type === \"postfixDecrement\") return new CIncrDecr(e, body, \"--\", \"post\");\n    if (e.type === \"addressOf\") return new CAddressOf(e, body);\n    if (e.type === \"dereference\") return new CDereference(e, body);\n    if (e.type === \"unaryPlus\") return new CUnaryPlusMinus(e, body, \"+\");\n    if (e.type === \"unaryMinus\") return new CUnaryPlusMinus(e, body, \"-\");\n    if (e.type === \"bitwiseNot\") return new CBitwiseNot(e, body);\n    if (e.type === \"logicalNot\") return new CLogicalNot(e, body);\n\n    throw new ParseTreeValidationError(e, \"Invalid unary expression\");\n}\n\nfunction ptBinary(e: pt.BinaryExpression, scope: Scope): CExpression {\n    // transform binary expressions\n    const lhs = ptExpression(e.lhs, scope), rhs = ptExpression(e.rhs, scope);\n\n    if (e.type === \"mul\") return new CMulDiv(e, lhs, rhs, \"*\");\n    if (e.type === \"div\") return new CMulDiv(e, lhs, rhs, \"/\");\n    if (e.type === \"mod\") return new CMod(e, lhs, rhs);\n    if (e.type === \"add\") return new CAddSub(e, lhs, rhs, \"+\");\n    if (e.type === \"sub\") return new CAddSub(e, lhs, rhs, \"-\");\n    if (e.type === \"bitwiseShiftLeft\") return new CShift(e, lhs, rhs, \"left\");\n    if (e.type === \"bitwiseShiftRight\") return new CShift(e, lhs, rhs, \"right\");\n\n    if (e.type === \"relationalLT\") return new CRelational(e, lhs, rhs, \"LT\");\n    if (e.type === \"relationalGT\") return new CRelational(e, lhs, rhs, \"GT\");\n    if (e.type === \"relationalLEq\") return new CRelational(e, lhs, rhs, \"LEq\");\n    if (e.type === \"relationalGEq\") return new CRelational(e, lhs, rhs, \"GEq\");\n    if (e.type === \"relationalEq\") return new CEquality(e, lhs, rhs, \"==\");\n    if (e.type === \"relationalNEq\") return new CEquality(e, lhs, rhs, \"!=\");\n\n    if (e.type === \"bitwiseAnd\") return new CBitwiseAndOr(e, lhs, rhs, \"and\");\n    if (e.type === \"bitwiseXor\") return new CBitwiseAndOr(e, lhs, rhs, \"xor\");\n    if (e.type === \"bitwiseOr\") return new CBitwiseAndOr(e, lhs, rhs, \"or\");\n    if (e.type === \"logicalAnd\") return new CLogicalAndOr(e, lhs, rhs, \"and\");\n    if (e.type === \"logicalOr\") return new CLogicalAndOr(e, lhs, rhs, \"or\");\n\n    if (e.type === \"comma\") return new CComma(e, lhs, rhs);\n    if (e.type === \"arraySubscript\") {\n        // transform `a[b]` into `*(a+b)`\n        return new CDereference(e, new CAddSub(e, ptExpression(e.lhs, scope), ptExpression(e.rhs, scope), \"+\"));\n    }\n\n    throw new ParseTreeValidationError(e, \"Invalid binary expression\");\n}\n\n/** Transform a constant\n *\n * This is quite complicated because we have to work out what type to give the constant, following the rules set out in\n * the standard\n */\nexport function ptConstant(e: pt.Constant): CConstant {\n    let value = e.value;\n    let type: CArithmetic;\n\n    if (e.valueType === \"int\" || e.valueType === \"oct\" || e.valueType === \"hex\") {\n        let unsigned = false, long = false;\n        value = value.toLowerCase();\n        if (value.endsWith(\"u\")) {\n            value = value.slice(0, -1);\n            unsigned = true;\n        }\n        if (value.endsWith(\"l\")) {\n            value = value.slice(0, -1);\n            long = true;\n            // may be a second l for long long\n            if (value.endsWith(\"l\")) value = value.slice(0, -1);\n        }\n        if (!unsigned && value.endsWith(\"u\")) {\n            // check u again as u and l can appear in either order\n            value = value.slice(0, -1);\n            unsigned = true;\n        }\n\n        let num: bigint; // all integer constants are stored as BigInt\n        if (e.valueType !== \"oct\") {\n            // BigInt constructor natively handles decimal values and hexadecimal values prefixed with 0x\n            num = BigInt(value);\n        } else {\n            // Have to manually construct octal constants\n            num = 0n;\n            for (let i = 0; i < value.length - 1; i++) { // ignore the leading 0\n                num += BigInt(value[value.length - 1 - i]) * (8n ** BigInt(i));\n            }\n        }\n\n        // Choose the list of possible types from the suffixes and the constant type used (decimal, hex, octal)\n        let possibleTypes;\n        if (e.valueType === \"int\" && !unsigned && !long) {\n            possibleTypes = [CArithmetic.S32, CArithmetic.S64, CArithmetic.U64];\n        } else if (e.valueType !== \"int\" && !unsigned && !long) {\n            possibleTypes = [CArithmetic.S32, CArithmetic.U32, CArithmetic.S64, CArithmetic.U64];\n        } else if (unsigned && long) {\n            possibleTypes = [CArithmetic.U64];\n        } else if (long) {\n            possibleTypes = [CArithmetic.S64, CArithmetic.U64];\n        } else { // if (unsigned)\n            possibleTypes = [CArithmetic.U32, CArithmetic.U64];\n        }\n\n        // find smallest acceptable type which fits the value\n        for (const type of possibleTypes) {\n            if (num >= type.minValue && num <= type.maxValue) {\n                return new CConstant(e, type, num);\n            }\n        }\n        throw new ParseTreeValidationError(e, \"Integer constant too large for its type\");\n\n    } else if (e.valueType === \"float\") {\n        // floats default to double unless suffixed with \"f\"\n        if (value.endsWith(\"f\")) {\n            value = value.slice(0, -1);\n            type = CArithmetic.Fp32;\n        } else {\n            type = CArithmetic.Fp64;\n        }\n        return new CConstant(e, type, parseFloat(value));\n\n    } else if (e.valueType === \"char\") {\n        value = unescapeChar(value, e);\n        return new CConstant(e, CArithmetic.U8, BigInt(value.codePointAt(0)));\n    }\n\n    throw new ParseTreeValidationError(e, \"Invalid constant type?\");\n}\n\n/** Unescape strings as defined in the C standard */\nfunction unescapeChar(s: string, node?: ParseNode): string {\n    if (s.startsWith(\"\\\\\")) {\n        if (s === \"\\\\n\") return \"\\n\";\n        if (s === \"\\\\t\") return \"\\t\";\n        if (s === \"\\\\v\") return \"\\v\";\n        if (s === \"\\\\b\") return \"\\b\";\n        if (s === \"\\\\r\") return \"\\r\";\n        if (s === \"\\\\f\") return \"\\f\";\n        if (s === \"\\\\a\") return \"\\x07\";\n        if (s === \"\\\\\\\\\") return \"\\\\\";\n        if (s === \"\\\\?\") return \"?\";\n        if (s === \"\\\\'\") return \"'\";\n        if (s === '\\\\\"') return '\"';\n\n        let value: number;\n        if (s.startsWith(\"\\\\x\")) {\n            // hex constant\n            value = parseInt(s.slice(2), 16);\n        } else {\n            // octal constant\n            value = parseInt(s.slice(1), 8);\n        }\n\n        if (!isNaN(value) && value >= 0 && value <= 255) {\n            return String.fromCharCode(value);\n        }\n        throw new ParseTreeValidationError(node, \"Invalid character escape\");\n    }\n\n    const codePoint = s.codePointAt(0);\n    if (s.length !== 1 || codePoint === undefined || codePoint > 255) {\n        throw new ParseTreeValidationError(node, \"Invalid character\");\n    }\n    return s;\n}\n","import {ParseTreeValidationError, pt} from \"../../parsing\";\nimport {CFuncDefinition, CArgument, CFuncDeclaration, CVarDefinition, CVarDeclaration} from \"../declarations\";\nimport {CAssignment, CIdentifier, CExpression, CInitializer, CStringLiteral, CConstant} from \"../expressions\";\nimport {INTERNAL_SCOPE} from \"../internal_scope\";\nimport {Scope} from \"../scope\";\nimport {CStatement, CCompoundStatement, CExpressionStatement, CNop, CIf, CForLoop, CWhileLoop, CDoLoop, CSwitch, CBreak, CContinue, CReturn, CGoto, CLabelledStatement} from \"../statements\";\nimport {ExpressionTypeError} from \"../type_checking\";\nimport {CFuncType, CVoid, CArray, CArithmetic, CPointer} from \"../types\";\nimport {ptExpression, evalIntegerConstant} from \"./expr_transform\";\nimport {getDeclaratorName, getDeclaratorType, getType} from \"./type_transform\";\n\n/** Main function, transform a parse tree translation unit into a root scope */\nexport function ptTransform(translationUnit: pt.TranslationUnit): Scope {\n    const fileScope = new Scope(undefined, INTERNAL_SCOPE);\n    for (const decl of translationUnit) {\n        if (decl instanceof pt.FunctionDefinition) {\n            ptFunction(decl, fileScope);\n        } else {\n            ptDeclaration(decl, fileScope, false);\n        }\n    }\n    return fileScope;\n}\n\n/** Add the pt declarations to the scope, and either store their static initializer on the variables or return a\n * list of assignments to add to the body of the current function to set their initial values */\nfunction ptDeclaration(declaration: pt.Declaration, scope: Scope, inFunction: boolean): CAssignment[] {\n    if (declaration.typeInfo.storageList[0] === \"typedef\") {\n        ptTypedef(declaration, scope);\n        return [];\n    }\n\n    const declType = getType(declaration, scope);\n    const assignments = [];\n    for (let entry of declaration.list) {\n        const name = getDeclaratorName(entry);\n\n        let initialValue: CExpression | CInitializer | undefined;\n        if (entry instanceof pt.InitDeclarator) {\n            initialValue = ptInitializer(entry, entry.initializer, scope);\n            entry = entry.body;\n        }\n\n        const type = getDeclaratorType(declType, entry, scope);\n        const initialType = initialValue?.type instanceof CPointer ? initialValue.type.original ?? initialValue.type : initialValue?.type;\n        if (initialType instanceof CArray && type instanceof CArray && type.incomplete) {\n            // initialize array length from initializer if incomplete\n            type.length = initialType.length;\n        }\n\n        if (type.incomplete) {\n            throw new ExpressionTypeError(type.node ?? entry, \"complete type\", \"incomplete type\");\n        } else if (type instanceof CFuncType) {\n            // function declarations\n            const linkage = declaration.typeInfo.storageList[0] === \"static\" ? \"internal\" : \"external\";\n            const fnImport = declaration.typeInfo.fnSpecifierList[0] === \"import\";\n            scope.addIdentifier(new CFuncDeclaration(entry, name, type, linkage, fnImport));\n        } else {\n            if (declaration.typeInfo.fnSpecifierList.length > 0) {\n                throw new ExpressionTypeError(entry, \"variable declaration with function specifier\");\n            }\n\n            // work out storage, linkage and if definition or declaration\n            let storage: \"static\" | \"local\";\n            let linkage: \"none\" | \"internal\" | \"external\";\n            let declType: typeof CVarDefinition | typeof CVarDeclaration;\n            if (declaration.typeInfo.storageList[0] === \"static\") {\n                storage = \"static\";\n                linkage = inFunction ? \"none\" : \"internal\";\n                declType = inFunction ? CVarDefinition : (initialValue !== undefined ? CVarDefinition : CVarDeclaration);\n            } else if (declaration.typeInfo.storageList[0] === \"extern\") {\n                storage = \"static\";\n                linkage = \"external\";\n                declType = CVarDeclaration;\n            } else {\n                storage = inFunction ? \"local\" : \"static\";\n                linkage = inFunction ? \"none\" : \"external\";\n                declType = inFunction ? CVarDefinition : (initialValue !== undefined ? CVarDefinition : CVarDeclaration);\n            }\n            const cvar = new declType(entry, name, type, storage, linkage);\n            scope.addIdentifier(cvar);\n\n            // if definition with initializer\n            if (initialValue) {\n                if (cvar instanceof CVarDeclaration) {\n                    throw new ExpressionTypeError(entry, \"declaration\", \"declaration with initializer\");\n                }\n                if (initialValue instanceof CInitializer) {\n                    initialValue.type = type;\n                }\n                if (initialValue instanceof CConstant && type instanceof CArithmetic && type !== initialValue.type) {\n                    // force constants to take the correct type\n                    initialValue = initialValue.changeType(type);\n                }\n\n                if (inFunction && cvar.storage !== \"static\") {\n                    const id: CExpression = new CIdentifier(entry, cvar);\n                    assignments.push(new CAssignment(entry, id, initialValue, undefined, true));\n                } else {\n                    // static initialization, must be constant and evaluated at compile time\n                    cvar.staticValue = initialValue;\n                    CAssignment.checkAssignmentValid(entry, type, cvar.staticValue);\n\n                    // setup variable dependencies\n                    for (const identifier of initialValue.identifiers()) {\n                        cvar.dependencies.set(identifier.value, true);\n                    }\n                }\n            }\n        }\n    }\n    return assignments;\n}\n\nfunction ptTypedef(node: pt.Declaration, scope: Scope) {\n    if (node.list.length === 0) throw new ParseTreeValidationError(node, \"typedef must define at least one identifier\");\n    const baseType = getType(node, scope);\n\n    for (const decl of node.list) {\n        if (decl instanceof pt.InitDeclarator) throw new ParseTreeValidationError(node, \"cannot initialize a typedef\");\n        const type = getDeclaratorType(baseType, decl, scope);\n        const name = getDeclaratorName(decl);\n        scope.addTypedef(name, type, decl);\n    }\n}\n\n/** Transform an initializer to either a CInitializer (for arrays, structs & unions) or a CExpression */\nfunction ptInitializer(node: pt.ParseNode, initializer: pt.Initializer, scope: Scope): CExpression | CInitializer {\n    if (Array.isArray(initializer)) {\n        return new CInitializer(node, initializer.map(x => ptInitializer(node, x, scope)));\n    } else {\n        return ptExpression(initializer as pt.Expression, scope);\n    }\n}\n\n/** Transform a function */\nfunction ptFunction(fn: pt.FunctionDefinition, scope: Scope): void {\n    if (fn.typeInfo.fnSpecifierList[0] === \"import\") {\n        throw new ExpressionTypeError(fn, \"function definition to not be marked `import`\");\n    }\n\n    // get and check the function's type\n    const type = getType(fn, scope);\n    if (!(type instanceof CFuncType)) throw new ParseTreeValidationError(fn, \"Unexpected declarator\");\n    // get the function name\n    const name = getDeclaratorName(fn.declarator);\n\n    let linkage: \"internal\" | \"external\";\n    if (fn.typeInfo.storageList[0] === \"static\") linkage = \"internal\";\n    else if (fn.typeInfo.storageList[0] === \"typedef\") throw new ParseTreeValidationError(fn, \"Invalid typedef\");\n    else linkage = \"external\";\n\n    const cfn = new CFuncDefinition(fn, name, type, linkage, scope);\n    cfn.hints.inline = fn.typeInfo.fnSpecifierList[0] === \"inline\";\n    scope.addIdentifier(cfn);\n\n    // add arguments as parameters to function's scope\n    if (!type.parameterNames) throw new ParseTreeValidationError(fn, \"Expected parameter names\");\n    for (let i = 0; i < type.parameterTypes.length; i++) {\n        cfn.body.scope.addIdentifier(new CArgument(fn, type.parameterNames[i], type.parameterTypes[i], i));\n    }\n\n    // parse function body body\n    ptCompound(fn.body, cfn);\n\n    // check function always returns\n    if (!(type.returnType instanceof CVoid) && !checkReturns(cfn.body)) {\n        throw new ParseTreeValidationError(fn.body, \"Non-void function may not return\");\n    }\n}\n\n/** Checks every branch through a function will definitely return */\nfunction checkReturns(statement: CStatement | undefined): boolean {\n    if (statement instanceof CReturn) {\n        return true;\n    } else if (statement instanceof CCompoundStatement) {\n        for (let i = 0; i < statement.statements.length; i++) {\n            if (checkReturns(statement.statements[i])) {\n                if (i + 1 < statement.statements.length) {\n                    // statements after return\n\n                    if (statement.statements[i + 1] === statement.scope.labelledStatement?.body) {\n                        // this is okay as the following statement is labelled, so can jump there\n                        continue; // check code after jumping to the label returns\n                    }\n\n                    // not okay - no way to reach statements after return\n                    throw new ParseTreeValidationError(statement.statements[i + 1].node, \"Statement after return\");\n                }\n                return true;\n            }\n        }\n    } else if (statement instanceof CIf) {\n        return checkReturns(statement.ifBody) && checkReturns(statement.elseBody);\n    } else if (statement instanceof CDoLoop) {\n        return checkReturns(statement.body);\n    } else if (statement instanceof CSwitch) {\n        // if every child returns and there's a default statement then switch is safe\n        return statement.children.every(x => checkReturns(x.body)) &&\n            statement.children.find(x => x.default) !== undefined;\n    }\n    return false;\n}\n\n/** Transform statements from the parse tree */\nfunction ptStatement(node: pt.Statement, parent: CStatement): CStatement {\n    if (node instanceof pt.CompoundStatement) {\n        return ptCompound(node, parent);\n\n    } else if (node instanceof pt.ExpressionStatement) {\n        return new CExpressionStatement(node, ptExpression(node.expression, parent.scope), parent);\n\n    } else if (node instanceof pt.IfStatement) {\n        const s = new CIf(node, ptExpression(node.expression, parent.scope), parent);\n        s.ifBody = ptStatement(node.ifBody, s);\n        if (node.elseBody) s.elseBody = ptStatement(node.elseBody, s);\n        return s;\n\n    } else if (node instanceof pt.ForLoop) {\n        const s = new CForLoop(node, parent);\n        if (node.init instanceof pt.ExpressionStatement || node.init instanceof pt.NoOp) {\n            s.init = ptStatement(node.init, s) as CExpressionStatement | CNop;\n        } else {\n            s.init = ptDeclaration(node.init, s.scope, true)\n                .map(e => new CExpressionStatement(e.node, e, s));\n        }\n        s.test = ptStatement(node.test, s) as CExpressionStatement | CNop;\n        if (node.update) s.update = ptExpression(node.update, s.scope);\n        s.body = ptStatement(node.body, s);\n        return s;\n\n    } else if (node instanceof pt.WhileLoop) {\n        const s = new CWhileLoop(node, ptExpression(node.test, parent.scope), parent);\n        s.body = ptStatement(node.body, s);\n        return s;\n\n    } else if (node instanceof pt.DoWhileLoop) {\n        const s = new CDoLoop(node, ptExpression(node.test, parent.scope), parent);\n        s.body = ptStatement(node.body, s);\n        return s;\n\n    } else if (node instanceof pt.GotoStatement) {\n        let p: CStatement | CFuncDefinition = parent; // find which statement this goto is targeting\n        while (p.scope.labelledStatement?.label !== node.target) {\n            if (p.parent instanceof CFuncDefinition) {\n                throw new ParseTreeValidationError(node, \"No properly structured control flow target for goto statement\");\n            }\n            p = p.parent;\n        }\n        return new CGoto(node, p.scope.labelledStatement, parent);\n\n    } else if (node instanceof pt.ContinueStatement) {\n        let p: CStatement = parent; // find which statement this node is continuing\n        while (!(p instanceof CForLoop || p instanceof CWhileLoop || p instanceof CDoLoop)) {\n            if (p.parent instanceof CFuncDefinition) {\n                throw new ParseTreeValidationError(node, \"No target for continue statement\");\n            }\n            p = p.parent;\n        }\n        return new CContinue(node, p, parent);\n\n    } else if (node instanceof pt.BreakStatement) {\n        let p: CStatement = parent;\n        while (!(p instanceof CForLoop || p instanceof CWhileLoop || p instanceof CDoLoop || p instanceof CSwitch)) {\n            if (p.parent instanceof CFuncDefinition) {\n                throw new ParseTreeValidationError(node, \"No target for break statement\");\n            }\n            p = p.parent;\n        }\n        return new CBreak(node, p, parent);\n\n    } else if (node instanceof pt.SwitchStatement) {\n        const s = new CSwitch(node, ptExpression(node.expression, parent.scope), parent);\n        ptSwitchBody(s, node, parent.scope);\n        return s;\n\n    } else if (node instanceof pt.ReturnStatement) {\n        let p: CStatement | CFuncDefinition = parent;\n        while (!(p instanceof CFuncDefinition)) p = p.parent;\n\n        const value = node.value ? ptExpression(node.value, parent.scope) : undefined;\n        return new CReturn(node, p, value, parent);\n\n    } else if (node instanceof pt.NoOp) {\n        return new CNop(node, parent);\n\n    } else if (node instanceof pt.CaseStatement) {\n        // allowed case/default statements handled in ptSwitchBody\n        throw new ParseTreeValidationError(node, \"Unexpected case statement\");\n    } else if (node instanceof pt.DefaultStatement) {\n        throw new ParseTreeValidationError(node, \"Unexpected default statement\");\n    }\n\n    throw new ParseTreeValidationError(node, \"Unknown statement type\");\n}\n\n/** Transform compound statements */\nfunction ptCompound(node: pt.CompoundStatement, parent: CStatement | CFuncDefinition): CCompoundStatement {\n    const c = parent instanceof CFuncDefinition ? parent.body : new CCompoundStatement(node, parent);\n\n    // need to check for labelled statements first to allow jumping forward\n    const labelled = node.body.filter(x => x instanceof pt.Statement && x.label !== undefined) as pt.Statement[];\n    if (labelled.length > 1) {\n        throw new ParseTreeValidationError(labelled[0], \"Only one labelled statement is supported per block\", labelled[1]);\n    } else if (labelled.length === 1) {\n        c.scope.labelledStatement = new CLabelledStatement(labelled[0], labelled[0].label as string);\n    }\n\n    for (const child of node.body) {\n        _compoundBody(child, c);\n    }\n    return c;\n}\n\n/** Transform a declaration or statement inside a compound statement */\nfunction _compoundBody(child: pt.Declaration | pt.Statement, c: CCompoundStatement) {\n    if (child instanceof pt.Declaration) {\n        for (const assignment of ptDeclaration(child, c.scope, true)) {\n            // add initializers to body of the statement to ensure they happen in the correct order\n            c.statements.push(new CExpressionStatement(assignment.node, assignment, c));\n        }\n    } else {\n        const statement = ptStatement(child, c);\n        c.statements.push(statement);\n\n        if (child.label !== undefined && c.scope.labelledStatement?.node === child) {\n            // now store the statement\n            c.scope.labelledStatement.body = statement;\n        }\n    }\n}\n\n/** Transform the body of a switch statement.\n *\n * This is quite complicated as case & default statements both absorb the following statement.\n * Furthermore, these statements are limited to being used at the top level inside the switch statement, whereas in C\n * you can place them inside other statements inside the switch block, creating arbitrary goto which is out of scope.\n */\nfunction ptSwitchBody(s: CSwitch, node: pt.SwitchStatement, scope: Scope) {\n    if (!(node.body instanceof pt.CompoundStatement)) {\n        throw new ParseTreeValidationError(node, \"Expected switch statement to have a compound statement body\");\n    }\n    const children = node.body.body.slice();\n    while (children.length > 0) { // iterate over the body of the switch statement\n        const child = children.shift();\n        if (child instanceof pt.CaseStatement || child instanceof pt.DefaultStatement) {\n            let block;\n            if (s.children.length > 0 && s.children[s.children.length - 1].body.statements.length === 0) {\n                // multiple cases in a row, use the last defined block\n                block = s.children[s.children.length - 1];\n            } else {\n                // last block already has children, make a new block\n                block = {cases: [], default: false, body: new CCompoundStatement(node, s)};\n                s.children.push(block);\n            }\n\n            if (child instanceof pt.CaseStatement) { // add the case or mark this block as accepting default\n                block.cases.push(evalIntegerConstant(child.value, scope));\n            } else {\n                block.default = true;\n            }\n\n            // case and default statements eat a statement\n            children.unshift(child.body);\n        } else if (child) {\n            // handle other statements as if this was a compound statement\n            if (s.children.length === 0) {\n                throw new ParseTreeValidationError(child, \"Unexpected first statement inside a switch statement\");\n            }\n            const compound = s.children[s.children.length - 1].body;\n            _compoundBody(child, compound);\n        }\n    }\n}\n","import {parse} from \"../parsing\";\nimport {Scope} from \"./scope\";\nimport {ptTransform} from \"./transform/transform\";\n\nexport function toIR(source: string): Scope {\n    const translationUnit = parse(source);\n    return ptTransform(translationUnit);\n}\n","import {toIR} from \"../src/ir\";\nimport {CArithmetic} from \"../src/ir/types\";\n\nconst testInput = `\nstatic const struct Node {\n  enum NodeType {TYPE_A = 3, TYPE_B} type;\n  char tag[8];\n  struct Node* child;\n} myPair = {TYPE_B, \"testing\"};\n\nint getTag(struct Node *node) {\n  return node->type;\n}\n`.trimStart();\n\nlet currentId = 0;\nlet displayedMap: WeakMap<any, number> = new WeakMap();\n\nfunction getId(obj: object): [id: number, isNew: boolean] {\n    let id = displayedMap.get(obj);\n    if (id === undefined) {\n        id = currentId++;\n        displayedMap.set(obj, id);\n        return [id, true];\n    }\n    return [id, false];\n}\n\nfunction displayObject(parent: HTMLElement, key: string, obj: any): void {\n    const li = document.createElement(\"li\");\n    parent.appendChild(li);\n    if (typeof obj !== \"object\") {\n        li.innerHTML = `<span class=\"key\">${key}:</span> ${obj}`;\n        return;\n    }\n\n    // body for this element\n    const [id, idNew] = getId(obj);\n    li.classList.add(`objID${id}`);\n    if (idNew) li.id = `objID${id}`;\n    li.innerHTML = `<span class=\"key\">${key}:</span> <code>${obj instanceof CArithmetic ? obj.typeName : Object.getPrototypeOf(obj).constructor.name}</code>`;\n    if (obj instanceof CArithmetic && !(obj as any).qualifier) return; // reduce tree clutter\n\n    if (idNew) {\n        li.innerHTML += ` <span class=\"id\">[${id}]</span>`;\n    } else {\n        li.innerHTML += ` <a class=\"id\" href=\"#objID${id}\">${id}</a>`;\n    }\n\n    // add children\n    if (idNew) {\n        // tree setup\n        li.classList.add(\"expandable\");\n        li.addEventListener(\"click\", e => {\n            e.stopPropagation();\n            const rect = li.getBoundingClientRect();\n            if (e.clientX < rect.left + 20 && e.clientY < rect.top + 20) {\n                li.classList.toggle(\"hidden\");\n            }\n        });\n\n        const ul = document.createElement(\"ul\");\n        li.appendChild(ul);\n\n        if (obj instanceof Map) {\n            for (const [key, value] of obj.entries()) {\n                displayObject(ul, key, value);\n            }\n        } else {\n            for (const [key, value] of Object.entries(obj)) {\n                if (key === \"node\") continue;\n                displayObject(ul, key, value);\n            }\n        }\n\n        if (ul.children.length === 0) {\n            // no children found - remove sublist\n            ul.remove();\n            li.classList.remove(\"expandable\");\n        }\n    }\n}\n\nfunction update(input: string) {\n    const identifiers = window.document.getElementById(\"identifiers\");\n    const tags = window.document.getElementById(\"tags\");\n    const typedefs = window.document.getElementById(\"typedefs\");\n    const errors = window.document.getElementById(\"errors\");\n    if (!identifiers || !tags || !errors || !typedefs) throw new Error(\"Element not found\");\n    identifiers.innerHTML = tags.innerText = typedefs.innerText = \"\";\n    currentId = 0;\n    displayedMap = new WeakMap<any, number>();\n\n    let ir;\n    try {\n        ir = toIR(input);\n    } catch (e) {\n        errors.innerText = e.toString();\n        throw e;\n    }\n\n    errors.innerHTML = \"\";\n    getId(ir);\n    for (const [key, value] of (ir as any).identifiers) {\n        displayObject(identifiers, key, value);\n    }\n    for (const [key, value] of (ir as any).tags) {\n        displayObject(tags, key, value);\n    }\n    for (const [key, value] of (ir as any).typedefs) {\n        displayObject(typedefs, key, value);\n    }\n}\n\n\nif (typeof window !== 'undefined' && window.document) {\n    window.document.write(`\n        <h1>c2wasm ctree</h1>\n        <div>\n            <textarea id=\"textInput\" rows=\"20\" style=\"width: 100%; resize: vertical\">${testInput}</textarea>\n\n            <pre id=\"errors\"></pre>\n            <div id=\"objID0\"></div>\n            <h3>Identifiers:</h3>\n            <ul id=\"identifiers\" class=\"treelist\"></ul>\n            <h3>Tags:</h3>\n            <ul id=\"tags\" class=\"treelist\"></ul>\n            <h3>Typedefs:</h3>\n            <ul id=\"typedefs\" class=\"treelist\"></ul>\n        </div>\n\n        <style>\n            ul.treelist {\n                padding: 0;\n            }\n\n            ul.treelist ul {\n              padding-inline-start: 18px;\n              border-left: 1px dashed black;\n              margin-left: 6px;\n            }\n\n            ul.treelist li {\n              list-style-type: none;\n              position: relative;\n            }\n\n            ul.treelist li::before {\n              content: \"\\\\25BB\";\n              font-size: 0.8em;\n              color: black;\n              user-select: none;\n              pointer-events: auto;\n              display: inline-block;\n              width: 20px;\n            }\n\n            ul.treelist li.expandable::before {\n              content: \"\\\\25BC\";\n              cursor: pointer;\n            }\n\n            ul.treelist li.expandable.hidden::before {\n              content: \"\\\\25B6\";\n              transform: none;\n            }\n\n            ul.treelist li.expandable.hidden ul {\n              display: none;\n            }\n        </style>\n    `);\n\n    const textInput = window.document.getElementById(\"textInput\") as HTMLTextAreaElement;\n    textInput.addEventListener(\"input\", () => update(textInput.value));\n    update(textInput.value);\n} else {\n    console.log(toIR(testInput));\n}\n"],"names":["ParseNode","constructor","loc","Expression","_expression","Identifier","name","super","type","Constant","value","valueType","StringLiteral","UnaryOperations","UnaryExpression","body","_unaryExpr","this","BinaryOperations","BinaryExpression","lhs","rhs","_binaryExpr","SizeofExpression","CastExpression","targetType","FunctionCallExpression","fn","args","MemberAccessExpression","pointer","ConditionalExpression","condition","trueValue","falseValue","AssignmentExpression","assignType","ConstantExpression","expr","CustomTypeSpecifier","SpecifierQualifiers","specifierList","qualifierList","specifier","DeclarationSpecifiers","storageList","fnSpecifierList","EnumSpecifier","id","Enumerator","Declaration","typeInfo","list","InitDeclarator","initializer","exploreInitializer","Array","isArray","x","StructUnionSpecifier","structure","declarations","StructDeclaration","PointerDeclarator","abstractDeclarator","IdentifierDeclarator","ArrayDeclarator","length","FunctionDeclarator","variadic","ParameterDeclaration","declarator","Pointer","TypeName","AbstractPointerDeclarator","AbstractArrayDeclarator","AbstractFunctionDeclarator","Statement","_statement","setLabel","label","IfStatement","expression","ifBody","elseBody","SwitchStatement","CaseStatement","DefaultStatement","CompoundStatement","ExpressionStatement","NoOp","ForLoop","init","test","update","WhileLoop","DoWhileLoop","GotoStatement","target","ContinueStatement","BreakStatement","ReturnStatement","FunctionDefinition","c_grammar","JisonParserError","msg","hash","stacktrace","Object","defineProperty","enumerable","writable","exception","Error","ex2","message","stack","hasOwnProperty","captureStackTrace","s","c","l","a","i","push","u","rv","e","apply","setPrototypeOf","prototype","create","parser","trace","yy","options","hasPartialLrUpgradeOnConflict","errorRecoveryTokenDiscardCount","symbols_","terminals_","TERROR","EOF","originalQuoteName","originalParseError","cleanupAfterParse","constructParseErrorInfo","yyMergeLocationInfo","__reentrant_call_depth","__error_infos","__error_recovery_infos","quoteName","id_str","getSymbolName","symbol","key","describeSymbol","terminal_descriptions_","collect_expected_token_set","state","do_not_describe","tokenset","check","state_descriptions_","p","table","d","productions_","pop","r","rule","bp","performAction","yytext","yyloc","yystate","yysp","yyvstack","yylstack","yyparser","yylexer","lexer","$","undefined","_$","t","externalDeclaration","len","y","m","mode","g","goto","n","q","j","z","shift","bt","defaultActions","idx","bda","parseError","str","ExceptionClass","recoverable","destroy","parse","input","self","sstack","vstack","lstack","sp","NO_ACTION","__lexer__","sharedState_yy","pre_parse","post_parse","pre_lex","post_lex","shallow_copy","src","dst","k","call","shallow_copy_noclobber","copy_yylloc","range","slice","fastLex","token","assert","yyGetSharedState","resultValue","invoke_post_methods","do_not_nuke_errorinfos","cleanupAfterLex","el","first_index","last_index","first_yylloc","last_yylloc","dont_look_back","i1","i2","l1","l2","first_line","last_line","first_column","last_column","ex","expected","pei","errStr","text","match","token_id","line","yylineno","yylloc","action","new_state","newState","symbol_stack","state_stack","value_stack","location_stack","stack_pointer","rec","yyrulelen","this_production","lex","yyval","retval","setInput","canIUse","errSymbolDescr","showPosition","join","ntsymbol","JisonLexerError","Parser","exports","arguments","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","module","__webpack_modules__","definition","o","get","obj","prop","Symbol","toStringTag","CError","node","node2","locationString","lines","source","split","output","lnumDigits","Math","ceil","log10","outputLine","lnum","toString","padStart","CFuncType","returnType","parameterTypes","parameterNames","typeName","bytes","alignment","incomplete","CVoid","checkTypeComplete","forEach","equals","every","other","pointerGeneration","addQualifier","CPointer","getQualifier","constant","original","qualifier","CArray","CCompoundMember","CStruct","members","_members","children","reduce","total","max","map","memberType","member","find","hasConstMember","CUnion","CEnum","values","_values","CArithmetic","minValue","BOOL","Infinity","BigInt","maxValue","Fp32","Fp64","U8","S8","U16","S16","U32","S32","U64","S64","CSizeT","constType","baseType","_base","integerPromotion","usualArithmeticConversion","t1","t2","getArithmeticType","copy","remove","indexOf","splice","validatorMap","Map","validate","nodeList","parents","validator","getPrototypeOf","ParseTreeValidationError","validators","set","typeValidation","v","typeLookup","constExprValidation","parent","keywords","fromEntries","toUpperCase","rules","regex","RegExp","replace","Lexer","index","col","next","lastIndex","exec","LexerError","groupIdx","group","reset","generatedParser","WrappedLexer","types","clear","parsetree","wantedType","actualType","asArithmetic","asInteger","arithmetic","asPointer","asArithmeticOrPointer","asNonFunctionPointer","checkLvalue","lvalue","CConstant","changeType","newValue","Number","CIdentifier","CStringLiteral","CFunctionCall","fnType","CAssignment","checkAssignmentValid","identifiers","CMemberAccess","bodyType","pointerType","structUnion","CIncrDecr","op","pos","CSizeof","CAddressOf","addressUsed","CDereference","CUnaryPlusMinus","CBitwiseNot","CLogicalNot","CCast","CMulDiv","CMod","CAddSub","CShift","dir","CRelational","commonType","CEquality","CBitwiseAndOr","CLogicalAndOr","CConditional","otherValue","assignmentType","initialAssignment","lhsType","CInitializer","rhsType","_checkAssignmentTypeValid","static","varType","CComma","_memberTypes","_type","memberTypes","typeCheck","desiredType","Scope","func","tags","typedefs","_getTag","tag","lookupTag","result","ScopeError","addTag","_getId","lookupIdentifier","addIdentifier","existing","CFuncDeclaration","CFuncDefinition","linkage","fnImport","CVarDeclaration","CVarDefinition","_getTypedef","lookupTypedef","addTypedef","CCompoundStatement","statements","scope","CExpressionStatement","CNop","CIf","CForLoop","CWhileLoop","CDoLoop","CGoto","CSwitch","CContinue","loop","CBreak","CReturn","CLabelledStatement","storage","declType","_addressUsed","b","_definition","dependencies","CArgument","translationUnit","hints","inline","getFunction","fakeParseNode","INTERNAL_FNS","wasm","wasm_i32","wasm_i64","wasm_f32","wasm_f64","wasm_ssp","wasm_rload","INTERNAL_SCOPE","CONSTANT","fail","evalExpression","extra","staticValue","normalizeType","evalInteger","e2","isNaN","trunc","bitmask","getType","specifiers","singleSpecifier","declaration","getDeclaratorType","getDeclaratorName","cEnum","nextValue","evalIntegerConstant","enumConstant","getSpecifierType","ptr","includes","param","ptExpression","num","possibleTypes","unsigned","long","toLowerCase","endsWith","parseFloat","unescapeChar","codePointAt","ptConstant","arr","charRegex","ptUnary","ptBinary","constInteger","startsWith","parseInt","String","fromCharCode","codePoint","ptDeclaration","inFunction","decl","ptTypedef","assignments","entry","initialValue","ptInitializer","initialType","cvar","identifier","ptFunction","cfn","ptCompound","checkReturns","statement","labelledStatement","default","ptStatement","child","block","cases","unshift","_compoundBody","ptSwitchBody","labelled","filter","assignment","toIR","fileScope","ptTransform","testInput","trimStart","currentId","displayedMap","WeakMap","getId","displayObject","li","document","createElement","appendChild","innerHTML","idNew","classList","add","addEventListener","stopPropagation","rect","getBoundingClientRect","clientX","left","clientY","top","toggle","ul","entries","window","getElementById","errors","ir","innerText","write","textInput","console","log"],"sourceRoot":""}