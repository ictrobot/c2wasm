(()=>{var e={428:(e,n,t)=>{"use strict";t.r(n),t.d(n,{AbstractArrayDeclarator:()=>AbstractArrayDeclarator,AbstractFunctionDeclarator:()=>AbstractFunctionDeclarator,AbstractPointerDeclarator:()=>AbstractPointerDeclarator,ArrayDeclarator:()=>ArrayDeclarator,AssignmentExpression:()=>AssignmentExpression,BinaryExpression:()=>BinaryExpression,BinaryOperations:()=>s,BreakStatement:()=>BreakStatement,CaseStatement:()=>CaseStatement,CastExpression:()=>CastExpression,CompoundStatement:()=>CompoundStatement,ConditionalExpression:()=>ConditionalExpression,Constant:()=>Constant,ConstantExpression:()=>ConstantExpression,ContinueStatement:()=>ContinueStatement,CustomTypeSpecifier:()=>CustomTypeSpecifier,Declaration:()=>Declaration,DeclarationSpecifiers:()=>DeclarationSpecifiers,DefaultStatement:()=>DefaultStatement,DoWhileLoop:()=>DoWhileLoop,EnumSpecifier:()=>EnumSpecifier,Enumerator:()=>Enumerator,Expression:()=>Expression,ExpressionStatement:()=>ExpressionStatement,ForLoop:()=>ForLoop,FunctionCallExpression:()=>FunctionCallExpression,FunctionDeclarator:()=>FunctionDeclarator,FunctionDefinition:()=>FunctionDefinition,GotoStatement:()=>GotoStatement,Identifier:()=>Identifier,IdentifierDeclarator:()=>IdentifierDeclarator,IfStatement:()=>IfStatement,InitDeclarator:()=>InitDeclarator,MemberAccessExpression:()=>MemberAccessExpression,NoOp:()=>NoOp,ParameterDeclaration:()=>ParameterDeclaration,ParseNode:()=>ParseNode,Pointer:()=>Pointer,PointerDeclarator:()=>PointerDeclarator,ReturnStatement:()=>ReturnStatement,SizeofExpression:()=>SizeofExpression,SpecifierQualifiers:()=>SpecifierQualifiers,Statement:()=>Statement,StringLiteral:()=>StringLiteral,StructDeclaration:()=>StructDeclaration,StructUnionSpecifier:()=>StructUnionSpecifier,SwitchStatement:()=>SwitchStatement,TypeName:()=>TypeName,UnaryExpression:()=>UnaryExpression,UnaryOperations:()=>i,WhileLoop:()=>WhileLoop});class ParseNode{constructor(e){this.loc=e}*children(){}}class Expression extends ParseNode{constructor(){super(...arguments),this._expression=!0}}class Identifier extends Expression{constructor(e,n){super(e),this.name=n,this.type="identifier"}}class Constant extends Expression{constructor(e,n,t){super(e),this.value=n,this.valueType=t,this.type="constant"}}class StringLiteral extends Expression{constructor(e,n){super(e),this.value=n,this.type="stringLiteral"}}const i=["postfixIncrement","postfixDecrement","prefixIncrement","prefixDecrement","addressOf","dereference","unaryPlus","unaryMinus","bitwiseNot","logicalNot"];class UnaryExpression extends Expression{constructor(e,n,t){super(e),this.type=n,this.body=t,this._unaryExpr=!0}*children(){yield this.body}}const s=["arraySubscript","comma","mul","div","mod","add","sub","bitwiseShiftLeft","bitwiseShiftRight","relationalLT","relationalGT","relationalLEq","relationalGEq","relationalEq","relationalNEq","bitwiseAnd","bitwiseXor","bitwiseOr","logicalAnd","logicalOr"];class BinaryExpression extends Expression{constructor(e,n,t,i){super(e),this.type=n,this.lhs=t,this.rhs=i,this._binaryExpr=!0}*children(){yield this.lhs,yield this.rhs}}class SizeofExpression extends Expression{constructor(e,n){super(e),this.body=n,this.type="sizeof"}*children(){yield this.body}}class CastExpression extends Expression{constructor(e,n,t){super(e),this.targetType=n,this.body=t,this.type="cast"}*children(){yield this.targetType,yield this.body}}class FunctionCallExpression extends Expression{constructor(e,n,t=[]){super(e),this.fn=n,this.args=t,this.type="functionCall"}*children(){yield this.fn,yield*this.args}}class MemberAccessExpression extends Expression{constructor(e,n,t,i){super(e),this.pointer=n,this.lhs=t,this.rhs=i,this.type="access"}*children(){yield this.lhs}}class ConditionalExpression extends Expression{constructor(e,n,t,i){super(e),this.condition=n,this.trueValue=t,this.falseValue=i,this.type="conditional"}*children(){yield this.condition,yield this.trueValue,yield this.falseValue}}class AssignmentExpression extends Expression{constructor(e,n,t,i){super(e),this.assignType=n,this.lhs=t,this.rhs=i,this.type="assign"}*children(){yield this.lhs,yield this.rhs}}class ConstantExpression extends Expression{constructor(e,n){super(e),this.expr=n,this.type="constantExpr"}*children(){yield this.expr}}class CustomTypeSpecifier extends ParseNode{constructor(e,n){super(e),this.name=n,this.type="customType"}}class SpecifierQualifiers extends ParseNode{constructor(e,n,t){super(e),this.specifierList=n,this.qualifierList=t,this.type="specifiersAndQualifiers"}*children(){for(const e of this.specifierList)e instanceof ParseNode&&(yield e)}}class DeclarationSpecifiers extends ParseNode{constructor(e,n,t,i,s){super(e),this.specifierList=n,this.qualifierList=t,this.storageList=i,this.fnSpecifierList=s,this.type="declarationSpecifiers"}*children(){for(const e of this.specifierList)e instanceof ParseNode&&(yield e)}}class EnumSpecifier extends ParseNode{constructor(e,n,t){super(e),this.id=n,this.body=t,this.type="enum"}*children(){this.body&&(yield*this.body)}}class Enumerator extends ParseNode{constructor(e,n,t){super(e),this.id=n,this.value=t,this.type="enumerator"}*children(){this.value&&(yield this.value)}}class Declaration extends ParseNode{constructor(e,n,t=[]){super(e),this.typeInfo=n,this.list=t,this.type="declaration"}*children(){yield this.typeInfo,yield*this.list}}class InitDeclarator extends ParseNode{constructor(e,n,t){super(e),this.body=n,this.initializer=t,this.type="initDeclarator"}*children(){yield this.body,yield*this.exploreInitializer()}*exploreInitializer(e=this.initializer){if(e instanceof AssignmentExpression)yield e;else if(Array.isArray(e))for(const n of e)yield*this.exploreInitializer(n)}}class StructUnionSpecifier extends ParseNode{constructor(e,n,t,i){super(e),this.structure=n,this.id=t,this.declarations=i,this.type="structUnionSpecifier"}*children(){this.declarations&&(yield*this.declarations)}}class StructDeclaration extends ParseNode{constructor(e,n,t=[]){super(e),this.typeInfo=n,this.list=t,this.type="structDeclaration"}*children(){yield this.typeInfo,yield*this.list}}class PointerDeclarator extends ParseNode{constructor(e,n,t){super(e),this.pointer=n,this.body=t,this.type="pointerDeclarator",this.abstractDeclarator=!1}*children(){yield this.pointer,yield this.body}}class IdentifierDeclarator extends ParseNode{constructor(e,n){super(e),this.id=n,this.type="identifierDeclarator",this.abstractDeclarator=!1}}class ArrayDeclarator extends ParseNode{constructor(e,n,t){super(e),this.body=n,this.length=t,this.type="arrayDeclarator",this.abstractDeclarator=!1}*children(){yield this.body,this.length&&(yield this.length)}}class FunctionDeclarator extends ParseNode{constructor(e,n,t,i=!1){super(e),this.body=n,this.args=t,this.variadic=i,this.type="functionDeclarator",this.abstractDeclarator=!1}*children(){yield this.body;for(const e of this.args??[])e instanceof ParseNode&&(yield e)}}class ParameterDeclaration extends ParseNode{constructor(e,n,t){super(e),this.typeInfo=n,this.declarator=t,this.type="parameterDeclaration"}*children(){yield this.typeInfo,this.declarator&&(yield this.declarator)}}class Pointer extends ParseNode{constructor(e,n,t){super(e),this.qualifierList=n,this.body=t,this.type="pointer"}*children(){this.body&&(yield this.body)}}class TypeName extends ParseNode{constructor(e,n,t){super(e),this.typeInfo=n,this.declarator=t,this.type="typeName"}*children(){yield this.typeInfo,this.declarator&&(yield this.declarator)}}class AbstractPointerDeclarator extends ParseNode{constructor(e,n,t){super(e),this.pointer=n,this.body=t,this.type="abstractPointerDeclarator",this.abstractDeclarator=!0}*children(){yield this.pointer,this.body&&(yield this.body)}}class AbstractArrayDeclarator extends ParseNode{constructor(e,n,t){super(e),this.body=n,this.length=t,this.type="abstractArrayDeclarator",this.abstractDeclarator=!0}*children(){this.body&&(yield this.body),this.length&&(yield this.length)}}class AbstractFunctionDeclarator extends ParseNode{constructor(e,n,t,i=!1){super(e),this.body=n,this.args=t,this.variadic=i,this.type="abstractFunctionDeclarator",this.abstractDeclarator=!0}*children(){this.body&&(yield this.body),this.args&&(yield*this.args)}}class Statement extends ParseNode{constructor(){super(...arguments),this._statement=!0}setLabel(e){return this.label=e,this}}class IfStatement extends Statement{constructor(e,n,t,i){super(e),this.expression=n,this.ifBody=t,this.elseBody=i,this.type="ifStatement"}*children(){yield this.expression,yield this.ifBody,this.elseBody&&(yield this.elseBody)}}class SwitchStatement extends Statement{constructor(e,n,t){super(e),this.expression=n,this.body=t,this.type="switchStatement"}*children(){yield this.expression,yield this.body}}class CaseStatement extends Statement{constructor(e,n,t){super(e),this.value=n,this.body=t,this.type="caseStatement"}*children(){yield this.value,yield this.body}}class DefaultStatement extends Statement{constructor(e,n){super(e),this.body=n,this.type="defaultStatement"}*children(){yield this.body}}class CompoundStatement extends Statement{constructor(e,n){super(e),this.body=n,this.type="compoundStatement"}*children(){yield*this.body}}class ExpressionStatement extends Statement{constructor(e,n){super(e),this.expression=n,this.type="expressionStatement"}*children(){yield this.expression}}class NoOp extends Statement{constructor(e){super(e),this.type="nopStatement"}}class ForLoop extends Statement{constructor(e,n,t,i,s){super(e),this.init=n,this.test=t,this.update=i,this.body=s,this.type="forStatement"}*children(){yield this.init,yield this.test,this.update&&(yield this.update),yield this.body}}class WhileLoop extends Statement{constructor(e,n,t){super(e),this.test=n,this.body=t,this.type="whileStatement"}*children(){yield this.test,yield this.body}}class DoWhileLoop extends Statement{constructor(e,n,t){super(e),this.body=n,this.test=t,this.type="doWhileStatement"}*children(){yield this.body,yield this.test}}class GotoStatement extends Statement{constructor(e,n){super(e),this.target=n,this.type="gotoStatement"}}class ContinueStatement extends Statement{constructor(){super(...arguments),this.type="continueStatement"}}class BreakStatement extends Statement{constructor(){super(...arguments),this.type="breakStatement"}}class ReturnStatement extends Statement{constructor(e,n){super(e),this.value=n,this.type="returnStatement"}*children(){this.value&&(yield this.value)}}class FunctionDefinition extends ParseNode{constructor(e,n,t,i){super(e),this.typeInfo=n,this.declarator=t,this.body=i,this.type="functionDefinition"}*children(){yield this.typeInfo,yield this.declarator,yield this.body}}},347:(e,n,t)=>{var i=function(){function e(e,n){var t;if(Object.defineProperty(this,"name",{enumerable:!1,writable:!1,value:"JisonParserError"}),null==e&&(e="???"),Object.defineProperty(this,"message",{enumerable:!1,writable:!0,value:e}),this.hash=n,n&&n.exception instanceof Error){var i=n.exception;this.message=i.message||e,t=i.stack}t||(Error.hasOwnProperty("captureStackTrace")?Error.captureStackTrace(this,this.constructor):t=new Error(e).stack),t&&Object.defineProperty(this,"stack",{enumerable:!1,writable:!1,value:t})}function n(e,n,t){t=t||0;for(var i=0;i<n;i++)this.push(e),e+=t}function i(e,n){for(n+=e=this.length-e;e<n;e++)this.push(this[e])}function s(e){for(var n=[],t=0,i=e.length;t<i;t++){var s=e[t];"function"==typeof s?(t++,s.apply(n,e[t])):n.push(s)}return n}"function"==typeof Object.setPrototypeOf?Object.setPrototypeOf(e.prototype,Error.prototype):e.prototype=Object.create(Error.prototype),e.prototype.constructor=e,e.prototype.name="JisonParserError";var r={trace:function(){},JisonParserError:e,yy:{},options:{type:"lalr",hasPartialLrUpgradeOnConflict:!0,errorRecoveryTokenDiscardCount:3},symbols_:{"!":14,"!=":43,$accept:0,$end:1,"%":16,"%=":48,"&":9,"&&":44,"&=":53,"(":3,")":4,"*":10,"*=":46,"+":11,"++":35,"+=":49,",":8,"-":12,"--":36,"-=":50,"->":34,".":7,"...":76,"/":15,"/=":47,":":22,";":24,"<":17,"<<":38,"<<=":51,"<=":40,"=":23,"==":42,">":18,">=":41,">>":39,">>=":52,"?":21,BREAK:87,CASE:77,CHAR:60,CONST:73,CONSTANT_CHAR:32,CONSTANT_FLOAT:28,CONSTANT_HEX:29,CONSTANT_INT:31,CONSTANT_OCTAL:30,CONTINUE:86,DEFAULT:78,DO:83,DOUBLE:65,ELSE:80,ENUM:72,EOF:1,EXTERN:57,FLOAT:64,FOR:84,GOTO:85,IDENTIFIER:27,IF:79,IMPORT:75,INLINE:74,INT:62,LONG:63,RETURN:88,SHORT:61,SIGNED:66,SIZEOF:37,STATIC:58,STRING_LITERAL:33,STRUCT:70,SWITCH:81,TYPEDEF:56,TYPE_NAME:69,UNION:71,UNSIGNED:67,VOID:59,WHILE:82,"[":5,"]":6,"^":19,"^=":54,_BOOL:68,abstract_declarator:141,additive_expression:101,and_expression:105,argument_expression_list:96,assignment_expression:111,assignment_operator:112,ast_tree:89,block_item:149,block_item_list:148,cast_expression:99,compound_statement:147,concat_string_literals:93,conditional_expression:110,constant:91,constant_expression:114,declaration:115,declaration_specifiers:116,declarator:133,direct_abstract_declarator:142,direct_declarator:134,enum_specifier:128,enumerator:130,enumerator_list:129,equality_expression:104,error:2,exclusive_or_expression:106,expression:113,expression_statement:150,external_declaration:155,function_definition:156,function_specifier:132,identifier:90,inclusive_or_expression:107,init_declarator:118,init_declarator_list:117,initializer:143,initializer_list:144,iteration_statement:152,jump_statement:153,labeled_statement:146,logical_and_expression:108,logical_or_expression:109,multiplicative_expression:100,parameter_declaration:139,parameter_list:138,parameter_type_list:137,pointer:135,postfix_expression:95,primary_expression:94,relational_expression:103,selection_statement:151,shift_expression:102,specifier_qualifier_list:125,statement:145,storage_class_specifier:119,string_literal:92,struct_declaration:124,struct_declaration_list:123,struct_declarator:127,struct_declarator_list:126,struct_or_union:122,struct_or_union_specifier:121,translation_unit:154,type_name:140,type_qualifier:131,type_qualifier_list:136,type_specifier:120,unary_expression:97,unary_operator:98,"{":25,"|":20,"|=":55,"||":45,"}":26,"~":13},terminals_:{1:"EOF",2:"error",3:"(",4:")",5:"[",6:"]",7:".",8:",",9:"&",10:"*",11:"+",12:"-",13:"~",14:"!",15:"/",16:"%",17:"<",18:">",19:"^",20:"|",21:"?",22:":",23:"=",24:";",25:"{",26:"}",27:"IDENTIFIER",28:"CONSTANT_FLOAT",29:"CONSTANT_HEX",30:"CONSTANT_OCTAL",31:"CONSTANT_INT",32:"CONSTANT_CHAR",33:"STRING_LITERAL",34:"->",35:"++",36:"--",37:"SIZEOF",38:"<<",39:">>",40:"<=",41:">=",42:"==",43:"!=",44:"&&",45:"||",46:"*=",47:"/=",48:"%=",49:"+=",50:"-=",51:"<<=",52:">>=",53:"&=",54:"^=",55:"|=",56:"TYPEDEF",57:"EXTERN",58:"STATIC",59:"VOID",60:"CHAR",61:"SHORT",62:"INT",63:"LONG",64:"FLOAT",65:"DOUBLE",66:"SIGNED",67:"UNSIGNED",68:"_BOOL",69:"TYPE_NAME",70:"STRUCT",71:"UNION",72:"ENUM",73:"CONST",74:"INLINE",75:"IMPORT",76:"...",77:"CASE",78:"DEFAULT",79:"IF",80:"ELSE",81:"SWITCH",82:"WHILE",83:"DO",84:"FOR",85:"GOTO",86:"CONTINUE",87:"BREAK",88:"RETURN"},TERROR:2,EOF:1,originalQuoteName:null,originalParseError:null,cleanupAfterParse:null,constructParseErrorInfo:null,yyMergeLocationInfo:null,__reentrant_call_depth:0,__error_infos:[],__error_recovery_infos:[],quoteName:function(e){return'"'+e+'"'},getSymbolName:function(e){if(this.terminals_[e])return this.terminals_[e];var n=this.symbols_;for(var t in n)if(n[t]===e)return t;return null},describeSymbol:function(e){if(e!==this.EOF&&this.terminal_descriptions_&&this.terminal_descriptions_[e])return this.terminal_descriptions_[e];if(e===this.EOF)return"end of input";var n=this.getSymbolName(e);return n?this.quoteName(n):null},collect_expected_token_set:function(e,n){var t=this.TERROR,i=[],s={};if(!n&&this.state_descriptions_&&this.state_descriptions_[e])return[this.state_descriptions_[e]];for(var r in this.table[e])if((r=+r)!==t){var o=n?r:this.describeSymbol(r);o&&!s[o]&&(i.push(o),s[o]=!0)}return i},productions_:function(e){for(var n=[],t=e.pop,i=e.rule,s=0,r=t.length;s<r;s++)n.push([t[s],i[s]]);return n}({pop:s([89,89,90,n,[91,5],92,93,93,n,[94,4],n,[95,8],96,96,n,[97,6],n,[98,6],99,99,n,[100,4],n,[101,3],n,[102,3],n,[103,5],n,[104,3],105,105,106,106,107,107,108,108,109,109,110,110,111,111,n,[112,11],113,113,114,115,115,n,[116,8],117,117,118,118,n,[119,3],n,[120,13],n,[121,3],122,122,123,123,124,n,[125,4],126,126,127,n,[128,5],129,129,130,130,131,132,132,133,133,n,[134,6],n,[135,4],136,136,137,137,138,138,n,[139,3],140,140,n,[141,3],n,[142,9],n,[143,3],144,144,n,[145,6],n,[146,3],147,147,148,148,149,149,150,150,n,[151,3],n,[152,6],n,[153,5],154,154,155,155,156]),rule:s([2,n,[1,9],i,[10,4],3,1,4,3,4,3,3,2,2,i,[10,3],n,[2,4],4,n,[1,7],4,1,n,[3,3],i,[4,3],i,[3,6],i,[8,7],i,[36,3],i,[4,6],5,i,[4,3],n,[1,11],i,[59,3],i,[3,3],i,[80,3],i,[4,4],i,[32,4],n,[1,15],5,4,i,[107,4],2,3,i,[31,4],i,[114,4],5,5,6,i,[40,8],i,[17,4],i,[130,4],i,[125,3],i,[67,4],i,[21,3],i,[139,3],i,[22,4],i,[46,3],3,3,4,i,[4,4],i,[33,3],i,[83,8],i,[41,3],i,[39,5],i,[31,3],5,7,5,5,7,6,7,6,7,i,[49,3],i,[20,6],3])}),performAction:function(e,n,t,i,s,r){var a=this.yy,c=a.parser,l=a.lexer;switch(t){case 0:this.$=void 0,this._$=r[i-1];break;case 1:return this.$=void 0,this._$=c.yyMergeLocationInfo(i-1,i),s[i-1];case 2:return this.$=void 0,this._$=r[i],[];case 3:case 9:case 100:case 101:case 102:case 103:case 104:case 105:case 106:case 107:case 108:case 109:case 110:case 111:case 142:this._$=r[i],this.$=e;break;case 4:this._$=r[i],this.$=new o.Constant(this._$,e,"float");break;case 5:this._$=r[i],this.$=new o.Constant(this._$,e,"hex");break;case 6:this._$=r[i],this.$=new o.Constant(this._$,e,"oct");break;case 7:this._$=r[i],this.$=new o.Constant(this._$,e,"int");break;case 8:this._$=r[i],this.$=new o.Constant(this._$,e,"char");break;case 10:case 13:case 16:case 26:case 38:case 40:case 44:case 47:case 50:case 55:case 58:case 60:case 62:case 64:case 66:case 68:case 70:case 83:case 98:case 113:case 114:case 130:case 144:case 167:case 178:case 183:case 184:case 185:case 186:case 187:case 188:case 196:case 197:case 216:this._$=r[i],this.$=s[i];break;case 11:this._$=c.yyMergeLocationInfo(i-1,i),this.$=s[i-1]+s[i];break;case 12:this._$=r[i],this.$=new o.Identifier(this._$,e);break;case 14:this._$=r[i],this.$=new o.StringLiteral(this._$,s[i]);break;case 15:case 146:case 169:case 179:this._$=c.yyMergeLocationInfo(i-2,i),this.$=s[i-1];break;case 17:this._$=c.yyMergeLocationInfo(i-3,i),this.$=new o.BinaryExpression(this._$,"arraySubscript",s[i-3],s[i-1]);break;case 18:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new o.FunctionCallExpression(this._$,s[i-2]);break;case 19:this._$=c.yyMergeLocationInfo(i-3,i),this.$=new o.FunctionCallExpression(this._$,s[i-3],s[i-1]);break;case 20:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new o.MemberAccessExpression(this._$,!1,s[i-2],s[i]);break;case 21:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new o.MemberAccessExpression(this._$,!0,s[i-2],s[i]);break;case 22:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new o.UnaryExpression(this._$,"postfixIncrement",s[i-1]);break;case 23:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new o.UnaryExpression(this._$,"postfixDecrement",s[i-1]);break;case 24:case 96:case 121:case 128:case 136:case 155:case 159:case 181:case 194:case 214:this._$=r[i],this.$=[s[i]];break;case 25:case 97:case 129:case 137:case 160:case 182:this._$=c.yyMergeLocationInfo(i-2,i),this.$=(s[i-2].push(s[i]),s[i-2]);break;case 27:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new o.UnaryExpression(this._$,"prefixIncrement",s[i]);break;case 28:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new o.UnaryExpression(this._$,"prefixDecrement",s[i]);break;case 29:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new o.UnaryExpression(this._$,s[i-1],s[i]);break;case 30:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new o.SizeofExpression(this._$,s[i]);break;case 31:this._$=c.yyMergeLocationInfo(i-3,i),this.$=new o.SizeofExpression(this._$,s[i-1]);break;case 32:this._$=r[i],this.$="addressOf";break;case 33:this._$=r[i],this.$="dereference";break;case 34:this._$=r[i],this.$="unaryPlus";break;case 35:this._$=r[i],this.$="unaryMinus";break;case 36:this._$=r[i],this.$="bitwiseNot";break;case 37:this._$=r[i],this.$="logicalNot";break;case 39:this._$=c.yyMergeLocationInfo(i-3,i),this.$=new o.CastExpression(this._$,s[i-2],s[i]);break;case 41:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new o.BinaryExpression(this._$,"mul",s[i-2],s[i]);break;case 42:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new o.BinaryExpression(this._$,"div",s[i-2],s[i]);break;case 43:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new o.BinaryExpression(this._$,"mod",s[i-2],s[i]);break;case 45:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new o.BinaryExpression(this._$,"add",s[i-2],s[i]);break;case 46:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new o.BinaryExpression(this._$,"sub",s[i-2],s[i]);break;case 48:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new o.BinaryExpression(this._$,"bitwiseShiftLeft",s[i-2],s[i]);break;case 49:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new o.BinaryExpression(this._$,"bitwiseShiftRight",s[i-2],s[i]);break;case 51:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new o.BinaryExpression(this._$,"relationalLT",s[i-2],s[i]);break;case 52:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new o.BinaryExpression(this._$,"relationalGT",s[i-2],s[i]);break;case 53:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new o.BinaryExpression(this._$,"relationalLEq",s[i-2],s[i]);break;case 54:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new o.BinaryExpression(this._$,"relationalGEq",s[i-2],s[i]);break;case 56:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new o.BinaryExpression(this._$,"relationalEq",s[i-2],s[i]);break;case 57:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new o.BinaryExpression(this._$,"relationalNEq",s[i-2],s[i]);break;case 59:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new o.BinaryExpression(this._$,"bitwiseAnd",s[i-2],s[i]);break;case 61:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new o.BinaryExpression(this._$,"bitwiseXor",s[i-2],s[i]);break;case 63:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new o.BinaryExpression(this._$,"bitwiseOr",s[i-2],s[i]);break;case 65:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new o.BinaryExpression(this._$,"logicalAnd",s[i-2],s[i]);break;case 67:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new o.BinaryExpression(this._$,"logicalOr",s[i-2],s[i]);break;case 69:this._$=c.yyMergeLocationInfo(i-4,i),this.$=new o.ConditionalExpression(this._$,s[i-4],s[i-2],s[i]);break;case 71:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new o.AssignmentExpression(this._$,s[i-1],s[i-2],s[i]);break;case 72:this._$=r[i],this.$=void 0;break;case 73:this._$=r[i],this.$="mul";break;case 74:this._$=r[i],this.$="div";break;case 75:this._$=r[i],this.$="mod";break;case 76:this._$=r[i],this.$="add";break;case 77:this._$=r[i],this.$="sub";break;case 78:this._$=r[i],this.$="leftShift";break;case 79:this._$=r[i],this.$="rightShift";break;case 80:this._$=r[i],this.$="bitwiseAnd";break;case 81:this._$=r[i],this.$="bitwiseXor";break;case 82:this._$=r[i],this.$="bitwiseOr";break;case 84:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new o.BinaryExpression(this._$,"comma",s[i-2],s[i]);break;case 85:this._$=r[i],this.$=new o.ConstantExpression(this._$,s[i]);break;case 86:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new o.Declaration(this._$,s[i-1]);break;case 87:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new o.Declaration(this._$,s[i-2],s[i-1]);break;case 88:this._$=r[i],this.$=new o.DeclarationSpecifiers(this._$,[],[],[s[i]],[]);break;case 89:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new o.DeclarationSpecifiers(this._$,s[i].specifierList,s[i].qualifierList,[s[i-1],...s[i].storageList],s[i].fnSpecifierList);break;case 90:this._$=r[i],this.$=new o.DeclarationSpecifiers(this._$,[s[i]],[],[],[]);break;case 91:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new o.DeclarationSpecifiers(this._$,[s[i-1],...s[i].specifierList],s[i].qualifierList,s[i].storageList,s[i].fnSpecifierList);break;case 92:this._$=r[i],this.$=new o.DeclarationSpecifiers(this._$,[],[s[i]],[],[]);break;case 93:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new o.DeclarationSpecifiers(this._$,s[i].specifierList,[s[i-1],...s[i].qualifierList],s[i].storageList,s[i].fnSpecifierList);break;case 94:this._$=r[i],this.$=new o.DeclarationSpecifiers(this._$,[],[],[],[s[i]]);break;case 95:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new o.DeclarationSpecifiers(this._$,s[i].specifierList,s[i].qualifierList,s[i].storageList,[s[i-1],...s[i].fnSpecifierList]);break;case 99:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new o.InitDeclarator(this._$,s[i-2],s[i]);break;case 112:this._$=r[i],this.$="bool";break;case 115:this._$=r[i],this.$=new o.CustomTypeSpecifier(this._$,s[i]);break;case 116:this._$=c.yyMergeLocationInfo(i-4,i),this.$=new o.StructUnionSpecifier(this._$,s[i-4],s[i-3],s[i-1]);break;case 117:this._$=c.yyMergeLocationInfo(i-3,i),this.$=new o.StructUnionSpecifier(this._$,s[i-3],void 0,s[i-1]);break;case 118:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new o.StructUnionSpecifier(this._$,s[i-1],s[i]);break;case 119:this._$=r[i],this.$="struct";break;case 120:this._$=r[i],this.$="union";break;case 122:case 156:case 195:case 215:this._$=c.yyMergeLocationInfo(i-1,i),this.$=(s[i-1].push(s[i]),s[i-1]);break;case 123:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new o.StructDeclaration(this._$,s[i-2],s[i-1]);break;case 124:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new o.SpecifierQualifiers(this._$,[s[i-1],...s[i].specifierList],s[i].qualifierList);break;case 125:this._$=r[i],this.$=new o.SpecifierQualifiers(this._$,[s[i]],[]);break;case 126:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new o.SpecifierQualifiers(this._$,s[i].specifierList,[s[i-1],...s[i].qualifierList]);break;case 127:this._$=r[i],this.$=new o.SpecifierQualifiers(this._$,[],[s[i]]);break;case 131:this._$=c.yyMergeLocationInfo(i-3,i),this.$=new o.EnumSpecifier(this._$,void 0,s[i-1]);break;case 132:this._$=c.yyMergeLocationInfo(i-4,i),this.$=new o.EnumSpecifier(this._$,s[i-3],s[i-1]);break;case 133:this._$=c.yyMergeLocationInfo(i-4,i),this.$=new o.EnumSpecifier(this._$,void 0,s[i-2]);break;case 134:this._$=c.yyMergeLocationInfo(i-5,i),this.$=new o.EnumSpecifier(this._$,s[i-4],s[i-2]);break;case 135:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new o.EnumSpecifier(this._$,s[i]);break;case 138:this._$=r[i],this.$=new o.Enumerator(this._$,s[i]);break;case 139:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new o.Enumerator(this._$,s[i-2],s[i]);break;case 140:this._$=r[i],this.$="const";break;case 141:this._$=r[i],this.$="inline";break;case 143:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new o.PointerDeclarator(this._$,s[i-1],s[i]);break;case 145:this._$=r[i],this.$=new o.IdentifierDeclarator(this._$,s[i]);break;case 147:this._$=c.yyMergeLocationInfo(i-3,i),this.$=new o.ArrayDeclarator(this._$,s[i-3],s[i-1]);break;case 148:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new o.ArrayDeclarator(this._$,s[i-2]);break;case 149:this._$=c.yyMergeLocationInfo(i-3,i),this.$=new o.FunctionDeclarator(this._$,s[i-3],s[i-1],s[i-1].variadic);break;case 150:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new o.FunctionDeclarator(this._$,s[i-2]);break;case 151:this._$=r[i],this.$=new o.Pointer(this._$);break;case 152:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new o.Pointer(this._$,s[i]);break;case 153:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new o.Pointer(this._$,void 0,s[i]);break;case 154:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new o.Pointer(this._$,s[i-1],s[i]);break;case 157:this._$=r[i],this.$=(s[i].variadic=!1,s[i]);break;case 158:this._$=c.yyMergeLocationInfo(i-2,i),this.$=(s[i-2].variadic=!0,s[i-2]);break;case 161:case 162:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new o.ParameterDeclaration(this._$,s[i-1],s[i]);break;case 163:this._$=r[i],this.$=new o.ParameterDeclaration(this._$,s[i]);break;case 164:this._$=r[i],this.$=new o.TypeName(this._$,s[i]);break;case 165:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new o.TypeName(this._$,s[i-1],s[i]);break;case 166:this._$=r[i],this.$=new o.AbstractPointerDeclarator(this._$,s[i]);break;case 168:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new o.AbstractPointerDeclarator(this._$,s[i-1],s[i]);break;case 170:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new o.AbstractArrayDeclarator(this._$);break;case 171:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new o.AbstractArrayDeclarator(this._$,void 0,s[i-1]);break;case 172:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new o.AbstractArrayDeclarator(this._$,s[i-2]);break;case 173:this._$=c.yyMergeLocationInfo(i-3,i),this.$=new o.AbstractArrayDeclarator(this._$,s[i-3],s[i-1]);break;case 174:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new o.AbstractFunctionDeclarator(this._$);break;case 175:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new o.AbstractFunctionDeclarator(this._$,void 0,s[i-1],s[i-1].variadic);break;case 176:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new o.AbstractFunctionDeclarator(this._$,s[i-2]);break;case 177:this._$=c.yyMergeLocationInfo(i-3,i),this.$=new o.AbstractFunctionDeclarator(this._$,s[i-3],s[i-1],s[i-1].variadic);break;case 180:this._$=c.yyMergeLocationInfo(i-3,i),this.$=s[i-2];break;case 189:this._$=c.yyMergeLocationInfo(i-2,i),this.$=s[i].setLabel(s[i-2]);break;case 190:this._$=c.yyMergeLocationInfo(i-3,i),this.$=new o.CaseStatement(this._$,s[i-2],s[i]);break;case 191:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new o.DefaultStatement(this._$,s[i]);break;case 192:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new o.CompoundStatement(this._$,[]);break;case 193:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new o.CompoundStatement(this._$,s[i-1]);break;case 198:this._$=r[i],this.$=new o.NoOp(this._$);break;case 199:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new o.ExpressionStatement(this._$,s[i-1]);break;case 200:this._$=c.yyMergeLocationInfo(i-4,i),this.$=new o.IfStatement(this._$,s[i-2],s[i]);break;case 201:this._$=c.yyMergeLocationInfo(i-6,i),this.$=new o.IfStatement(this._$,s[i-4],s[i-2],s[i]);break;case 202:this._$=c.yyMergeLocationInfo(i-4,i),this.$=new o.SwitchStatement(this._$,s[i-2],s[i]);break;case 203:this._$=c.yyMergeLocationInfo(i-4,i),this.$=new o.WhileLoop(this._$,s[i-2],s[i]);break;case 204:this._$=c.yyMergeLocationInfo(i-6,i),this.$=new o.DoWhileLoop(this._$,s[i-5],s[i-2]);break;case 205:case 207:this._$=c.yyMergeLocationInfo(i-5,i),this.$=new o.ForLoop(this._$,s[i-3],s[i-2],void 0,s[i]);break;case 206:case 208:this._$=c.yyMergeLocationInfo(i-6,i),this.$=new o.ForLoop(this._$,s[i-4],s[i-3],s[i-2],s[i]);break;case 209:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new o.GotoStatement(this._$,s[i-1]);break;case 210:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new o.ContinueStatement(this._$);break;case 211:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new o.BreakStatement(this._$);break;case 212:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new o.ReturnStatement(this._$);break;case 213:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new o.ReturnStatement(this._$,s[i-1]);break;case 217:this._$=r[i],this.$=(l.externalDeclaration(s[i]),s[i]);break;case 218:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new o.FunctionDefinition(this._$,s[i-2],s[i-1],s[i])}},table:function(e){for(var n=[],t=e.len,i=e.symbol,s=e.type,r=e.state,o=e.mode,a=e.goto,c=0,l=t.length;c<l;c++){for(var f=t[c],u={},d=0;d<f;d++){var h=i.shift();switch(s.shift()){case 2:u[h]=[o.shift(),a.shift()];break;case 0:u[h]=r.shift();break;default:u[h]=[3]}}n.push(u)}return n}({len:s([34,1,32,n,[0,4],10,n,[35,4],n,[0,19],3,3,n,[0,4],5,0,2,4,7,0,10,0,7,n,[0,5],28,23,4,28,0,40,91,0,8,7,39,32,9,0,0,1,23,23,0,9,26,26,2,0,3,4,0,0,41,0,37,8,42,25,25,26,25,i,[25,3],n,[0,5],10,0,0,44,61,11,n,[0,6],12,0,14,18,20,22,25,0,0,90,i,[25,6],n,[0,4],39,38,1,0,2,n,[1,3],59,1,i,[6,3],40,i,[113,3],1,n,[0,3],i,[19,3],i,[45,3],0,0,23,0,i,[9,3],n,[0,4],4,38,2,2,0,38,n,[0,11],39,35,39,40,i,[19,3],i,[9,3],n,[0,3],61,34,33,i,[68,3],7,32,31,30,30,n,[29,4],28,28,27,27,n,[26,3],0,0,59,1,59,0,38,n,[39,3],1,70,i,[85,4],i,[46,3],30,0,0,8,4,42,i,[51,3],8,i,[85,5],i,[174,3],2,9,2,i,[99,5],1,10,11,0,26,i,[103,3],12,14,18,18,n,[20,4],22,22,25,i,[168,3],i,[67,3],i,[56,3],2,2,1,41,41,i,[49,5],39,32,1,i,[156,3],i,[77,4],0,37,0,i,[144,5],n,[59,3],39,40,40,i,[21,8],0,52,i,[47,3],59,2,59,i,[82,3],59,1,i,[60,3],i,[62,3],0,0]),symbol:s([1,n,[56,20,1],89,115,116,n,[119,4,1],128,131,132,154,155,156,1,i,[35,21],i,[34,9],155,156,3,10,24,27,90,117,118,133,134,135,3,4,5,8,i,[13,3],i,[48,20],i,[47,8],i,[35,105],25,27,90,i,[3,3],8,23,24,25,147,8,24,3,27,90,134,i,[52,4],i,[14,3],i,[59,5],27,73,131,135,136,3,10,27,90,i,[181,9],25,i,[77,21],i,[17,15],n,[120,6,1],128,131,27,90,129,130,i,[55,28],3,n,[9,6,1],25,n,[27,7,1],35,36,37,n,[90,6,1],n,[97,15,1],143,i,[40,7],n,[24,10,1],i,[42,3],i,[80,20],77,78,79,n,[81,8,1],i,[73,21],113,i,[398,9],n,[145,9,1],i,[221,4],i,[403,8],i,[246,4],6,i,[107,6],i,[146,30],114,4,i,[338,28],137,138,139,i,[317,9],4,i,[282,23],26,i,[24,18],i,[23,4],i,[142,4],126,127,i,[143,6],10,27,i,[36,18],i,[35,4],i,[26,25],8,26,8,23,26,i,[371,5],i,[343,39],144,4,6,n,[8,5,1],n,[15,10,1],26,n,[38,18,1],112,i,[37,3],21,22,24,26,45,n,[3,10,1],i,[48,11],34,35,36,i,[51,18],i,[128,7],i,[127,18],i,[25,50],99,i,[26,25],i,[151,7],44,45,i,[9,3],i,[140,3],i,[10,4],i,[162,21],n,[33,4,1],i,[163,18],92,i,[88,17],i,[339,15],i,[576,22],i,[361,6],140,i,[115,3],i,[94,4],i,[126,7],9,i,[12,18],i,[109,4],i,[14,4],i,[134,6],24,26,i,[127,6],i,[18,12],i,[147,8],i,[20,4],11,12,i,[22,20],i,[199,11],i,[25,10],i,[778,85],i,[777,7],i,[1182,9],5,i,[325,16],i,[486,46],i,[810,13],22,i,[1109,3],n,[3,3],i,[183,8],i,[46,10],i,[162,33],i,[153,3],i,[152,5],27,90,24,24,i,[64,8],i,[722,31],113,i,[963,3],6,4,4,8,i,[895,6],i,[1205,4],141,142,i,[874,23],8,24,i,[811,3],i,[810,8],i,[196,31],i,[857,3],26,i,[42,37],111,i,[38,38],113,i,[39,35],i,[74,40],4,i,[40,22],n,[96,16,1],27,90,27,90,i,[157,56],i,[794,44],i,[100,34],i,[34,33],4,8,4,i,[1252,4],i,[443,3],i,[43,32],i,[32,31],i,[31,30],i,[30,59],i,[29,115],i,[28,55],i,[27,53],i,[26,59],i,[993,52],22,i,[1053,60],i,[918,111],i,[39,43],82,i,[1204,18],i,[1449,20],i,[1438,31],150,24,8,24,n,[56,21,1],i,[33,8],i,[2155,5],i,[2486,3],142,i,[8,4],i,[2076,5],i,[102,21],i,[47,8],i,[1299,3],i,[2207,3],i,[859,3],i,[2280,38],i,[2192,4],i,[2191,4],i,[1324,11],i,[1658,12],i,[2135,22],8,22,i,[1948,9],6,8,i,[974,3],i,[1953,10],i,[1848,11],i,[587,27],4,5,i,[205,4],10,i,[2403,28],i,[197,6],i,[1916,56],i,[1934,30],i,[20,60],i,[1994,22],i,[2016,43],i,[2041,34],i,[805,50],i,[387,3],i,[391,3],i,[1924,9],i,[697,32],150,i,[41,42],i,[627,4],i,[2865,70],i,[549,3],i,[856,37],i,[1009,45],i,[1106,59],i,[59,118],i,[2030,56],i,[40,56],6,4,i,[2640,43],n,[80,9,1],i,[588,3],i,[653,60],i,[61,120],i,[2629,9],i,[475,110]]),type:s([n,[2,21],n,[0,13],1,i,[35,32],i,[15,10],n,[2,27],i,[45,12],i,[35,103],i,[3,6],i,[5,8],i,[52,15],i,[69,6],i,[76,31],i,[92,25],i,[55,46],i,[338,16],i,[314,13],n,[2,47],n,[0,40],i,[43,8],i,[73,46],i,[491,36],i,[333,19],i,[409,26],i,[142,15],i,[97,21],i,[26,38],i,[35,21],i,[253,26],i,[329,34],n,[2,67],i,[112,25],i,[25,33],i,[51,43],i,[146,46],i,[576,61],n,[2,173],i,[777,42],i,[1182,34],i,[105,50],i,[162,65],i,[428,23],i,[409,35],i,[874,32],i,[927,19],i,[1006,54],i,[42,27],i,[576,39],i,[74,74],i,[40,24],i,[1420,3],i,[1389,71],i,[794,46],i,[34,50],i,[1657,13],i,[43,29],i,[32,31],i,[31,30],i,[30,59],i,[29,115],i,[28,55],i,[27,53],i,[26,69],i,[1357,73],i,[623,63],i,[918,78],i,[922,61],i,[1438,53],i,[56,33],i,[2037,26],i,[902,45],i,[314,25],i,[1413,8],i,[97,20],i,[1822,76],i,[116,13],i,[200,38],n,[2,266],i,[865,54],i,[48,41],i,[89,45],i,[2865,60],i,[73,33],i,[2165,68],i,[1166,59],i,[59,105],i,[2030,63],i,[938,93],i,[2875,93],i,[61,121],i,[475,88]]),state:s([1,n,[6,4,1],25,31,26,10,11,2,n,[4,6,1],i,[12,5],36,5,44,39,42,37,41,40,47,i,[16,7],48,i,[8,7],49,i,[8,7],50,i,[8,7],51,54,55,44,60,65,64,63,44,66,41,40,71,25,31,68,69,70,26,72,75,73,74,97,98,107,99,89,83,81,86,n,[115,6,-1],108,101,96,88,82,80,78,77,128,i,[22,19],142,132,119,121,i,[76,7],120,122,123,117,118,n,[124,4,1],44,143,144,41,40,i,[67,6],148,i,[45,12],147,145,153,i,[43,7],149,151,152,155,154,i,[112,3],157,i,[112,4],i,[8,3],159,i,[7,3],44,160,161,162,i,[133,5],163,i,[19,5],164,i,[137,3],168,i,[137,22],170,169,171,i,[24,6],191,86,i,[8,6],193,i,[8,7],148,86,194,i,[9,6],195,86,199,i,[58,20],142,200,i,[89,3],202,26,72,201,i,[202,34],219,i,[201,5],39,42,i,[202,23],221,i,[66,22],228,n,[122,6,1],230,i,[125,21],234,44,238,41,240,239,241,i,[239,7],75,248,i,[88,20],249,i,[58,20],254,i,[79,21],255,i,[64,17],256,i,[40,21],257,i,[22,6],259,i,[23,14],260,261,262,i,[290,22],i,[312,28],263,i,[115,16],264,i,[17,15],265,269,268,241,i,[19,14],271,i,[15,13],272,i,[14,12],273,i,[13,12],274,i,[13,11],275,i,[12,11],276,i,[12,11],277,i,[12,11],278,i,[12,10],279,i,[11,10],280,i,[11,9],281,i,[10,9],282,i,[10,8],283,i,[9,8],284,i,[9,8],285,i,[454,22],286,n,[122,7,1],i,[29,21],288,i,[29,6],i,[295,20],289,i,[316,21],290,i,[22,21],291,i,[22,21],292,i,[22,21],132,295,i,[665,8],294,i,[833,8],299,44,60,300,44,i,[13,8],66,41,240,305,151,152,303,i,[378,15],i,[593,6],307,44,308,i,[854,3],i,[621,8],i,[841,15],311,i,[50,8],317,300,i,[76,8],269,i,[74,5],i,[251,22],318,i,[251,26],142,132,323,i,[23,22],324,i,[149,20],326,i,[110,8],328,151,152,i,[32,19],332,i,[75,20],333,i,[148,22],334,i,[428,28],335,i,[29,28],336,i,[206,27],337,i,[22,21],339,i,[22,21],341,i,[95,22],346,i,[124,28],348,i,[29,28],350,i,[29,28],352,i,[29,28],353,i,[29,6]]),mode:s([n,[1,46],n,[2,7],i,[27,101],i,[31,5],1,i,[27,7],i,[9,3],i,[43,8],i,[18,5],i,[12,8],n,[2,20],i,[100,22],i,[44,38],n,[1,57],i,[96,6],i,[327,43],i,[218,8],i,[369,35],i,[20,35],i,[299,11],i,[352,20],i,[317,10],i,[250,19],i,[24,7],i,[67,6],i,[289,19],i,[310,86],i,[146,12],i,[412,22],i,[440,60],i,[236,15],i,[65,20],i,[8,22],i,[34,18],i,[30,22],i,[87,7],i,[55,20],i,[271,60],i,[246,30],i,[688,75],i,[561,7],i,[502,7],n,[1,217],i,[219,219],n,[1,232],i,[680,7],i,[458,70],i,[1605,13],i,[1062,14],i,[1676,26],i,[123,26],i,[1116,48],i,[1134,38],i,[20,60],i,[1194,23],i,[1216,42],i,[1241,80],i,[2006,28],i,[690,216],n,[2,42],i,[538,11],n,[1,155]]),goto:s([3,n,[12,13,1],27,33,34,32,28,29,30,35,i,[21,20],45,43,38,46,n,[88,7],i,[31,20],n,[90,7],i,[27,20],n,[92,7],i,[27,20],n,[94,7],i,[27,20],52,46,53,46,98,56,98,57,59,58,45,46,62,144,61,n,[144,4],n,[151,4],43,151,28,45,43,46,n,[118,6],67,n,[118,21],i,[74,15],46,n,[135,6],76,n,[135,21],100,n,[90,6,1],79,46,n,[102,5,1],109,84,85,87,i,[18,7],131,57,116,i,[20,10],i,[159,20],129,130,n,[133,9,1],i,[144,3],62,143,61,n,[143,4],100,146,i,[62,6],i,[59,10],150,i,[60,20],n,[152,4],43,152,28,156,i,[25,15],158,i,[16,15],i,[88,3],n,[125,5],i,[23,15],n,[127,5],i,[20,15],166,165,138,167,138,46,i,[206,18],n,[38,15],172,n,[38,10],n,[173,10,1],n,[68,3],183,n,[68,3],184,186,26,185,26,187,n,[26,16],188,189,190,n,[26,18],192,i,[230,16],i,[17,17],i,[138,7],i,[17,10],196,i,[17,16],n,[66,7],197,66,n,[64,3],198,n,[64,6],n,[14,21],109,n,[14,21],i,[96,17],i,[272,15],n,[62,3],203,n,[62,7],n,[60,3],204,n,[60,8],n,[58,10],205,206,58,58,n,[55,4],207,208,n,[55,6],209,210,n,[55,4],n,[50,12],211,212,n,[50,6],n,[47,4],213,214,n,[47,16],n,[44,4],215,44,44,216,217,n,[44,16],i,[576,9],218,i,[576,43],38,46,n,[12,15],220,n,[12,23],i,[248,17],222,224,223,225,226,227,i,[117,9],i,[25,10],i,[96,11],229,46,231,232,i,[34,7],233,i,[33,10],i,[860,3],235,236,157,237,242,163,243,163,43,46,244,i,[160,15],246,245,247,i,[590,8],i,[50,10],251,250,253,252,i,[21,17],i,[17,52],258,i,[18,16],46,i,[109,18],i,[482,32],i,[49,34],266,224,267,270,164,243,43,i,[178,69],i,[17,193],i,[539,23],287,i,[31,30],i,[129,68],293,i,[99,8],i,[784,30],296,224,297,i,[23,20],298,242,166,243,166,46,302,167,301,167,242,304,243,43,46,i,[35,20],100,306,i,[115,16],i,[1337,3],309,i,[1293,9],310,i,[24,10],224,312,n,[67,7],197,67,313,224,314,315,316,n,[65,3],198,n,[65,6],n,[63,3],203,n,[63,7],i,[193,17],270,166,243,270,i,[124,3],i,[123,20],n,[61,3],204,n,[61,8],n,[59,10],205,206,59,59,n,[56,4],207,208,n,[56,6],209,210,n,[56,4],n,[57,4],207,208,n,[57,6],209,210,n,[57,4],n,[51,12],211,212,n,[51,6],n,[52,12],211,212,n,[52,6],n,[53,12],211,212,n,[53,6],n,[54,12],211,212,n,[54,6],n,[48,4],213,214,n,[48,16],n,[49,4],213,214,n,[49,16],n,[45,4],215,45,45,216,217,n,[45,16],n,[46,4],215,46,46,216,217,n,[46,16],i,[554,30],319,224,320,224,321,224,322,i,[492,18],i,[18,18],302,168,301,168,100,325,i,[358,16],327,i,[352,20],329,330,331,i,[738,64],i,[30,67],i,[107,11],338,i,[18,17],340,i,[18,16],342,343,n,[200,43],344,n,[200,8],345,224,i,[139,30],347,i,[32,31],349,i,[32,31],351,i,[264,60]])}),defaultActions:function(e){for(var n={},t=e.idx,i=e.goto,s=0,r=t.length;s<r;s++){n[t[s]]=i[s]}return n}({idx:s([n,[3,4,1],n,[12,19,1],n,[33,4,1],38,42,44,n,[46,5,1],55,58,64,65,69,74,77,78,80,n,[89,7,1],97,98,n,[102,6,1],109,115,116,118,119,120,n,[122,6,1],131,142,143,146,147,n,[148,4,2],155,156,158,159,n,[161,5,1],170,n,[172,11,1],189,190,191,193,194,195,199,218,219,223,231,232,233,235,236,238,239,244,245,n,[247,4,1],252,254,258,260,261,262,266,268,n,[283,4,1],288,289,n,[296,4,1],304,306,n,[308,4,1],313,314,316,317,318,325,327,n,[329,5,1],335,336,342,343,346,348,n,[350,4,1]]),goto:s([2,214,216,217,n,[100,16,1],140,141,142,119,120,1,215,86,96,145,3,n,[89,4,2],218,87,153,155,121,136,99,178,70,16,n,[32,6,1],12,13,n,[4,5,1],10,9,40,192,194,196,197,n,[183,6,1],198,83,97,148,85,38,150,159,154,156,146,117,122,128,130,124,126,131,181,n,[72,11,1],22,23,n,[27,4,1],11,193,195,199,210,211,212,147,149,161,162,116,123,133,137,139,132,179,71,18,24,20,21,15,165,41,42,43,189,191,84,209,213,158,160,174,170,129,134,180,182,17,19,31,39,190,172,176,169,175,171,69,25,202,203,173,177,205,207,201,204,206,208])}),parseError:function(e,n,t){if(!n.recoverable)throw"function"==typeof this.trace&&this.trace(e),t||(t=this.JisonParserError),new t(e,n);"function"==typeof this.trace&&this.trace(e),n.destroy()},parse:function(e){var n,t,i,s=this,r=new Array(128),o=new Array(128),a=new Array(128),c=new Array(128),l=this.table,f=0,u=0,d=(this.TERROR,this.EOF),h=(this.options.errorRecoveryTokenDiscardCount,[0,354]);i=this.__lexer__?this.__lexer__:this.__lexer__=Object.create(this.lexer);var p={parseError:void 0,quoteName:void 0,lexer:void 0,parser:void 0,pre_parse:void 0,post_parse:void 0,pre_lex:void 0,post_lex:void 0};function _(e){if("object"==typeof e){var n={};for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&(n[t]=e[t]);return n}return e}function m(e,n){for(var t in n)void 0===e[t]&&Object.prototype.hasOwnProperty.call(n,t)&&(e[t]=n[t])}function y(e){var n=_(e);return n&&n.range&&(n.range=n.range.slice(0)),n}function g(){var e=i.fastLex();return"number"!=typeof e&&(e=s.symbols_[e]||e),e||d}"function"!=typeof assert||assert,this.yyGetSharedState=function(){return p},m(p,this.yy),p.lexer=i,p.parser=this,"function"==typeof p.parseError?this.parseError=function(e,n,t){return t||(t=this.JisonParserError),p.parseError.call(this,e,n,t)}:this.parseError=this.originalParseError,"function"==typeof p.quoteName?this.quoteName=function(e){return p.quoteName.call(this,e)}:this.quoteName=this.originalQuoteName,this.cleanupAfterParse=function(e,n,t){var s,l;n&&((p.post_parse||this.post_parse)&&(l=this.constructParseErrorInfo(null,null,null,!1)),p.post_parse&&void 0!==(s=p.post_parse.call(this,p,e,l))&&(e=s),this.post_parse&&void 0!==(s=this.post_parse.call(this,p,e,l))&&(e=s),l&&l.destroy&&l.destroy());if(this.__reentrant_call_depth>1)return e;if(i.cleanupAfterLex&&i.cleanupAfterLex(t),p&&(p.lexer=void 0,p.parser=void 0,i.yy===p&&(i.yy=void 0)),p=void 0,this.parseError=this.originalParseError,this.quoteName=this.originalQuoteName,r.length=0,o.length=0,c.length=0,a.length=0,f=0,!t){for(var u=this.__error_infos.length-1;u>=0;u--){var d=this.__error_infos[u];d&&"function"==typeof d.destroy&&d.destroy()}this.__error_infos.length=0}return e},this.yyMergeLocationInfo=function(e,n,t,i,s){var r,o=0|e,a=0|n,l=t,u=i;if(!l&&null!=e)for(var d=o;d<=a&&!(l=c[d]);d++);if(!u&&null!=n)for(d=a;d>=o&&!(u=c[d]);d--);if(!l&&null==e){if(!s)for(d=(o||f)-1;d>=0&&!(l=c[d]);d--);return l?((r=_(l)).first_line=r.last_line,r.first_column=r.last_column,r.range&&(r.range=r.range.slice(0),r.range[0]=r.range[1]),u&&(m(r,u),r.last_line=u.last_line,r.last_column=u.last_column,r.range&&u.range&&(r.range[1]=u.range[1])),r):u?((r=_(u)).range&&(r.range=r.range.slice(0)),r):void 0}if(l||(l=u,u=null),l)return(r=_(l)).range&&(r.range=r.range.slice(0)),u&&(m(r,u),r.last_line=u.last_line,r.last_column=u.last_column,r.range&&u.range&&(r.range[1]=u.range[1])),r},this.constructParseErrorInfo=function(e,n,t,s){var l={errStr:e,exception:n,text:i.match,value:i.yytext,token:this.describeSymbol(u)||u,token_id:u,line:i.yylineno,loc:y(i.yylloc),expected:t,recoverable:s,state:b,action:w,new_state:I,symbol_stack:r,state_stack:o,value_stack:a,location_stack:c,stack_pointer:f,yy:p,lexer:i,parser:this,destroy:function(){var e=!!this.recoverable;for(var n in this)this.hasOwnProperty(n)&&"object"==typeof n&&(this[n]=void 0);this.recoverable=e}};return this.__error_infos.push(l),l};var b,w,v,x,C,L,E,I,A=function(){var e=i.lex();return"number"!=typeof e&&(e=s.symbols_[e]||e),e||d},S={$:!0,_$:void 0,yy:p},T=!1;try{if(this.__reentrant_call_depth++,i.setInput(e,p),"function"==typeof i.canIUse)i.canIUse().fastLex&&(A=g);for(n=i.yylloc,c[f]=n,a[f]=null,o[f]=0,r[f]=0,++f,t=i.yytext,this.pre_parse&&this.pre_parse.call(this,p),p.pre_parse&&p.pre_parse.call(this,p),I=o[f-1];;){if(b=I,this.defaultActions[b])w=2,I=this.defaultActions[b];else if(u||(u=A()),x=l[b]&&l[b][u]||h,I=x[1],!(w=x[0])){var F,N=this.describeSymbol(u)||u,k=this.collect_expected_token_set(b);F="number"==typeof i.yylineno?"Parse error on line "+(i.yylineno+1)+": ":"Parse error: ","function"==typeof i.showPosition&&(F+="\n"+i.showPosition(69,10)+"\n"),k.length?F+="Expecting "+k.join(", ")+", got unexpected "+N:F+="Unexpected "+N,C=this.constructParseErrorInfo(F,null,k,!1),void 0!==(v=this.parseError(C.errStr,C,this.JisonParserError))&&(T=v);break}switch(w){default:if(w instanceof Array){C=this.constructParseErrorInfo("Parse Error: multiple actions possible at state: "+b+", token: "+u,null,null,!1),void 0!==(v=this.parseError(C.errStr,C,this.JisonParserError))&&(T=v);break}C=this.constructParseErrorInfo("Parsing halted. No viable error recovery approach available due to internal system failure.",null,null,!1),void 0!==(v=this.parseError(C.errStr,C,this.JisonParserError))&&(T=v);break;case 1:r[f]=u,a[f]=i.yytext,c[f]=y(i.yylloc),o[f]=I,++f,u=0,t=i.yytext,n=i.yylloc;continue;case 2:if(L=(E=this.productions_[I-1])[1],void 0!==(v=this.performAction.call(S,t,n,I,f-1,a,c))){T=v;break}f-=L;var O=E[0];r[f]=O,a[f]=S.$,c[f]=S._$,I=l[o[f-1]][O],o[f]=I,++f;continue;case 3:-2!==f&&(T=!0,f--,void 0!==a[f]&&(T=a[f]))}break}}catch(e){if(e instanceof this.JisonParserError)throw e;if(i&&"function"==typeof i.JisonLexerError&&e instanceof i.JisonLexerError)throw e;C=this.constructParseErrorInfo("Parsing aborted due to exception.",e,null,!1),T=!1,void 0!==(v=this.parseError(C.errStr,C,this.JisonParserError))&&(T=v)}finally{T=this.cleanupAfterParse(T,!0,!0),this.__reentrant_call_depth--}return T}};r.originalParseError=r.parseError,r.originalQuoteName=r.quoteName;const o=t(428);function a(){this.yy={}}return a.prototype=r,r.Parser=a,new a}();n.parser=i,n.Parser=i.Parser,n.parse=function(){return i.parse.apply(i,arguments)}}},n={};function t(i){var s=n[i];if(void 0!==s)return s.exports;var r=n[i]={exports:{}};return e[i](r,r.exports,t),r.exports}t.d=(e,n)=>{for(var i in n)t.o(n,i)&&!t.o(e,i)&&Object.defineProperty(e,i,{enumerable:!0,get:n[i]})},t.o=(e,n)=>Object.prototype.hasOwnProperty.call(e,n),t.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},(()=>{"use strict";const e=JSON.parse("{\"ctype.h\":\"#pragma once\\nint isalnum(int chr);\\nint isalpha(int chr);\\nint iscntrl(int chr);\\nint isdigit(int chr);\\nint islower(int chr);\\nint isupper(int chr);\\nint isgraph(int chr);\\nint isprint(int chr);\\nint ispunct(int chr);\\nint isspace(int chr);\\nint isxdigit(int chr);\\nint tolower(int chr);\\nint toupper(int chr);\\n\",\"custom/alloc.c\":\"#include <stdlib.h>\\n#define PAGE_SIZE 65536\\n#define ALLOC_OFFSET (sizeof(struct node))\\n#define BLOCK_START(b) ((char*) (b) + ALLOC_OFFSET)\\nstatic struct node {\\nstruct node *prev;\\nstruct node *next;\\nsize_t size;\\nint padding;  \\n} alloc_list;\\nstatic void merge_blocks(struct node* node) {\\nstruct node* last = NULL;\\nwhile(node && node->next) {\\nsize_t end = (size_t) node + ALLOC_OFFSET + node->size;\\nstruct node* next = node->next;\\nif (end == (size_t) next) {\\nnode->size += ALLOC_OFFSET + next->size;\\nnode->next = next->next;\\nif (node->next->prev) node->next->prev = node;\\nnext->prev = NULL;\\nnext->next = NULL;\\nnext->size = 0;\\n} else {\\nnode = next;\\n}\\n}\\n}\\nvoid* malloc(size_t size) {\\nif(size > 0) {\\nsize = (size + 31) & ~31;  \\nstruct node *block = &alloc_list, *last = block;\\nwhile (block) {\\nif (block->size >= size) {\\nif (block->size - size >= 48) {\\nstruct node *new_block = (struct node*) (BLOCK_START(block) + size);\\nnew_block->size = block->size - size - ALLOC_OFFSET;\\nnew_block->prev = block;\\nnew_block->next = block->next;\\nblock->size = size;\\nif (block->next) block->next->prev = new_block;\\nblock->next = new_block;\\n}\\nstruct node *prev = block->prev, *next = block->next;\\nif (prev) prev->next = next;\\nif (next) next->prev = prev;\\nblock->next = (struct node *) -1;\\nblock->prev = (struct node *) 7;\\nreturn BLOCK_START(block);\\n}\\nlast = block;\\nblock = block->next;\\n}\\nint pages = 1 + ((size + ALLOC_OFFSET) / PAGE_SIZE);\\nint result = __wasm_i32__(1, pages, 0x40, 0);  \\nif (result < 0) {\\nreturn NULL;\\n} else {\\nlast->next = (struct node*) (result * PAGE_SIZE);\\nlast->next->size = (pages * PAGE_SIZE) - ALLOC_OFFSET;\\nlast->next->prev = last;\\nmerge_blocks(last);\\nreturn malloc(size);\\n}\\n}\\nreturn NULL;\\n}\\nvoid free(void* ptr) {\\nif (ptr) {\\nstruct node* block = (struct node*) ((char*)ptr - ALLOC_OFFSET);\\nif ((int) block->next != -1 || (int) block->prev != 7) {\\nreturn;\\n}\\n__wasm__(3, ptr, 0, block->size, 0xFC, 0x0B, 0x00);  \\nstruct node* list = &alloc_list;\\nwhile (list->next && list->next < block) {\\nlist = list->next;\\n}\\nblock->prev = list;\\nblock->next = list->next;\\nif (list->next && list->next->prev) list->next->prev = block;\\nlist->next = block;\\nmerge_blocks(&alloc_list);\\n}\\n}\\nvoid* realloc(void* ptr, size_t size) {\\nif (ptr) {\\nstruct node* block = (struct node*) ((char*)ptr - ALLOC_OFFSET);\\nif ((int) block->next != -1 || (int) block->prev != 7) {\\nreturn NULL;\\n}\\nif (block->size > size) {\\nreturn ptr;\\n}\\nvoid* new_ptr = malloc(size);\\n__wasm__(3, new_ptr, ptr, block->size, 0xFC, 0x0A, 0x00, 0x00);  \\nfree(ptr);\\nreturn new_ptr;\\n}\\nreturn NULL;\\n}\\nvoid* calloc(size_t nobj, size_t size) {\\nif (nobj && size) {\\nsize *= nobj;\\nvoid* ptr = malloc(size);\\nif (ptr) {\\n__wasm__(3, ptr, 0, size, 0xFC, 0x0B, 0x00);  \\n}\\nreturn ptr;\\n}\\nreturn NULL;\\n}\\n\",\"custom/ctype.c\":\"#include <ctype.h>\\nint isalnum(int chr) {\\nreturn isalpha(chr) || isdigit(chr);\\n}\\nint isalpha(int chr) {\\nreturn islower(chr) || isupper(chr);\\n}\\nint iscntrl(int chr) {\\nreturn chr < 0x20 || chr == 0x7f;\\n}\\nint isdigit(int chr) {\\nreturn chr >= '0' && chr <= '9';\\n}\\nint islower(int chr) {\\nreturn chr >= 'a' && chr <= 'z';\\n}\\nint isupper(int chr) {\\nreturn chr >= 'A' && chr <= 'Z';\\n}\\nint isgraph(int chr) {\\nreturn chr >= ' ' && chr <= '~';\\n}\\nint isprint(int chr) {\\nreturn chr > ' ' && chr <= '~';\\n}\\nint ispunct(int chr) {\\nreturn chr >= 'a' && chr <= 'z';\\n}\\nint isspace(int chr) {\\nreturn chr == ' ' || (chr >= '\\\\t' && chr <= '\\\\r');\\n}\\nint isxdigit(int chr) {\\nreturn isdigit(chr) || (chr >= 'a' && chr <= 'f') || (chr >= 'A' && chr <= 'F');\\n}\\nint tolower(int chr) {\\nreturn isupper(chr) ? chr + 32 : chr;\\n}\\nint toupper(int chr) {\\nreturn islower(chr) ? chr - 32 : chr;\\n}\\n\",\"custom/math.c\":\"#include <math.h>\\n#include <wasm/f64.h>\\ndouble sqrt(double d) {\\nreturn f64_sqrt(d);\\n}\\ndouble ceil(double d) {\\nreturn f64_ceil(d);\\n}\\ndouble fabs(double d) {\\nreturn f64_abs(d);\\n}\\ndouble floor(double d) {\\nreturn f64_floor(d);\\n}\\ndouble fmax(double d1, double d2) {\\nreturn f64_max(d1, d2);\\n}\\ndouble fmin(double d1, double d2) {\\nreturn f64_min(d1, d2);\\n}\\ndouble trunc(double d) {\\nreturn f64_trunc(d);\\n}\\ndouble copysign(double d1, double d2) {\\nreturn f64_copysign(d1, d2);\\n}\\ndouble round(double d) {\\nreturn f64_nearest(d);\\n}\\ndouble exp(double d) {\\ndouble sum = 1 + d, factorial = 1, power = d;\\nfor (int k = 2; k <= 5; k++) {\\npower *= d;\\nfactorial *= k;\\nsum += power / factorial;\\n}\\nreturn sum;\\n}\\n\",\"custom/stdio.c\":\"#include <stdio.h>\\n#ifndef FILES\\nint putchar(int chr) {\\n__put_char(chr);\\nreturn chr;\\n}\\nint puts(const char *s) {\\nchar *x = s;\\nwhile (*x) {\\n__put_char(*x);\\nx++;\\n}\\n__put_char('\\\\n');\\nreturn 0;\\n}\\n#else\\n#include <stdlib.h>\\n#include <string.h>\\n#include <stdbool.h>\\n#define __fhandle_stdin 0\\n#define __fhandle_stdout 1\\n#define __fhandle_stderr 2\\n#define __fhandle_fname 3\\nstatic FILE __stdin = {__fhandle_stdin, -1, false, false};\\nFILE* stdin = &__stdin;\\nstatic FILE __stdout = {__fhandle_stdout, -1, false, false};\\nFILE* stdout = &__stdout;\\nstatic FILE __stderr = {__fhandle_stderr, -1, false, false};\\nFILE* stderr = &__stderr;\\n#define __fhandle_flag_str 1\\nstatic void store_fname(const char *s) {\\nchar *x = s;\\nwhile (*x) {\\n__put_char(__fhandle_fname, *x);\\nx++;\\n}\\n__put_char(__fhandle_fname, 0);\\n}\\nFILE *fopen(const char *filename, const char *mode) {\\nreturn freopen(filename, mode, NULL);\\n}\\nFILE *freopen(const char *filename, const char *mode, FILE* stream) {\\nstore_fname(filename);\\nif (!__exists() && strchr(mode, 'r')) {\\nreturn NULL;\\n}\\nif (stream == NULL) {\\nstream = malloc(sizeof(struct __stdio_file));\\n}\\nstore_fname(filename);\\nstream->handle = __get_fhandle();\\nstream->unget = -1;\\nstream->len = 0;\\nstream->flags = 0;\\nstream->error = false;\\nstream->eof = false;\\nif (strchr(mode, 'a')) {\\nfseek(stream, 0, SEEK_END);\\n}\\nreturn stream;\\n}\\nvoid __str2file(FILE *stream, const char *data) {\\nstream->handle = (int) data;\\nstream->unget = -1;\\nstream->len = 0;\\nstream->flags = __fhandle_flag_str;\\nstream->error = false;\\nstream->eof = false;\\n}\\nint fflush(FILE* stream) {\\nreturn 0;  \\n}\\nint fclose(FILE* stream) {\\nfree(stream);\\nreturn 0;\\n}\\nint remove(const char *filename) {\\nreturn rename(filename, \\\"\\\");\\n}\\nint rename(const char *oldname, const char *newname) {\\nstore_fname(oldname);\\nstore_fname(newname);\\nreturn __move();\\n}\\nstatic char __tmpnam[L_tmpnam];\\nstatic int __tmpcount;\\nchar *tmpnam(char *s) {\\nif (s == NULL) s = __tmpnam;\\nsnprintf(s, L_tmpnam, \\\"$tmp/%d\\\", ++__tmpcount);\\nreturn s;\\n}\\nFILE *tmpfile(void) {\\nreturn fopen(tmpnam(NULL), \\\"wb+\\\");\\n}\\nint setvbuf(FILE *stream, char *buf, int mode, size_t size) {\\nreturn -1;  \\n}\\nvoid setbuf(FILE *stream, char *buf) {\\n}\\nint fgetc(FILE *stream) {\\nint c;\\nif (stream->unget >= 0) {\\nc = (unsigned char) stream->unget;\\nstream->unget = -1;\\n} else if (stream->flags & __fhandle_flag_str) {\\nchar* s = (char*) stream->handle;\\nc = *(s++);\\nif (c) {\\nstream->handle = (int) s;\\n} else {\\nstream->eof = true;\\nc = EOF;\\n}\\nstream->error = false;\\nstream->len++;\\n} else {\\nc = __get_char(stream->handle);\\nstream->eof = c == EOF;\\nstream->error = c < 0 && c != EOF;\\nstream->len++;\\n}\\nreturn c;\\n}\\nchar *fgets(char *s, int n, FILE *stream) {\\nint i = 0;\\nwhile (i < n - 1) {\\nint c = fgetc(stream);\\nif (c < 0) return NULL;\\ns[i++] = c;\\nif (c == '\\\\n') break;\\n}\\ns[i] = 0;\\nreturn s;\\n}\\nint fputc(int c, FILE *stream) {\\nif (stream->flags & __fhandle_flag_str) return EOF;\\nint result = __put_char(stream->handle, c);\\nif (result >= 0) return c;\\nreturn result;\\n}\\nint fputs(const char *s, FILE *stream) {\\nif (stream->flags & __fhandle_flag_str) return EOF;\\nchar *x = s;\\nwhile (*x) {\\nif (__put_char(stream->handle, *x) < 0) return EOF;\\nx++;\\n}\\nreturn 0;\\n}\\nint getchar(void) {\\nreturn fgetc(stdin);\\n}\\nchar *gets(char *s) {\\nwhile (true) {\\nint c = fgetc(stdin);\\nif (c == '\\\\n') {\\n*s = 0;\\nreturn s;\\n} else if (c < 0) {\\nbreak;\\n} else {\\n*s = c;\\n}\\ns++;\\n}\\nreturn NULL;\\n}\\nint putchar(int c) {\\nreturn fputc(c, stdout);\\n}\\nint puts(const char *s) {\\nif (fputs(s, stdout) < 0) return EOF;\\nif (fputc('\\\\n', stdout) < 0) return EOF;\\nreturn 0;\\n}\\nint ungetc(int c, FILE *stream) {\\nif (c < 0 || stream->unget >= 0) return EOF;\\nstream->unget = c;\\nreturn c;\\n}\\nsize_t fread(void *ptr, size_t size, size_t nobj, FILE *stream) {\\nint n;\\nfor (n = 0; n < nobj; n++) {\\nfor (int i = 0; i < size; i++) {\\nint c = fgetc(stream);\\nif (c < 0) return n;\\n((char*) ptr)[(n * size) + i] = c;\\n}\\n}\\nreturn n;\\n}\\nsize_t fwrite(const void *ptr, size_t size, size_t nobj, FILE* stream) {\\nint n;\\nfor (n = 0; n < nobj; n++) {\\nfor (int i = 0; i < size; i++) {\\nif (fputc(((char*) ptr)[(n * size) + i], stream) < 0) {\\nreturn n;\\n}\\n}\\n}\\nreturn n;\\n}\\nint fseek(FILE *stream, long offset, int origin) {\\nif (stream->flags & __fhandle_flag_str) return -1;\\nlong pos;\\nif (origin == SEEK_SET) {\\npos = offset;\\n} else if (origin == SEEK_CUR) {\\npos = __get_pos(stream->handle) + offset;\\n} else if (origin == SEEK_END) {\\npos = __get_len(stream->handle) + offset;\\n} else {\\nreturn -1;\\n}\\nreturn fsetpos(stream, &pos);\\n}\\nlong ftell(FILE *stream) {\\nif (stream->flags & __fhandle_flag_str) return -1;\\nlong pos = __get_pos(stream->handle);\\nif (pos < 0) return -1;\\nreturn pos;\\n}\\nvoid rewind(FILE *stream) {\\nfseek(stream, 0L, SEEK_SET);\\nclearerr(stream);\\n}\\nint fgetpos(FILE *stream, fpos_t *ptr) {\\nif (stream->flags & __fhandle_flag_str) return -1;\\nlong pos = __get_pos(stream->handle);\\nif (pos < 0) return -1;\\n*ptr = pos;\\nreturn 0;\\n}\\nint fsetpos(FILE *stream, const fpos_t *ptr) {\\nif (stream->flags & __fhandle_flag_str || __set_pos(stream->handle, *ptr) != 0) {\\nreturn -1;\\n}\\nreturn 0;\\n}\\nvoid clearerr(FILE *stream) {\\nstream->eof = false;\\nstream->error = false;\\n}\\nint feof(FILE *stream) {\\nreturn stream->eof;\\n}\\nint ferror(FILE *stream) {\\nreturn stream->error;\\n}\\nvoid perror(const char *s) {\\nfputs(s, stderr);\\nfputs(\\\": error\\\\n\\\", stderr);\\n}\\nint fscanf(FILE *stream, const char *fmt, ...) {\\nva_list va;\\nva_start(va, fmt);\\nint result = vfscanf(stream, fmt, va);\\nva_end(va);\\nreturn result;\\n}\\nint scanf(const char *fmt, ...) {\\nva_list va;\\nva_start(va, fmt);\\nint result = vfscanf(stdin, fmt, va);\\nva_end(va);\\nreturn result;\\n}\\nint sscanf(char *s, const char *fmt, ...) {\\nFILE f;\\n__str2file(&f, s);\\nva_list va;\\nva_start(va, fmt);\\nint result = vfscanf(&f, fmt, va);\\nva_end(va);\\nreturn result;\\n}\\n#endif\\n\",\"custom/stdlib.c\":\"#include <stdlib.h>\\nvoid abort() {\\n__wasm__(0, 0x00);\\n}\\nvoid exit(int code) {\\n__wasm__(0, 0x00);\\n}\\nint atexit(void (*fcn)(void)) {\\nreturn 1;\\n}\\nint system(const char *s) {\\nreturn s == NULL ? 0 : 1;\\n}\\nchar *getenv(const char *name) {\\nreturn NULL;\\n}\\ndouble atof(const char *s) {\\nreturn strtod(s, (char**) NULL);\\n}\\nint atoi(const char *s) {\\nreturn (int) strtol(s, (char**) NULL, 10);\\n}\\nint atol(const char *s) {\\nreturn strtol(s, (char**) NULL, 10);\\n}\\nint abs(int n) {\\nreturn n >= 0 ? n : -n;\\n}\\nint labs(long n) {\\nreturn n >= 0 ? n : -n;\\n}\\ndiv_t div(int num, int denom) {\\ndiv_t result;\\nresult.quot = num / denom;\\nresult.rem = num % denom;\\nreturn result;\\n}\\nldiv_t ldiv(long num, long denom) {\\nldiv_t result;\\nresult.quot = num / denom;\\nresult.rem = num % denom;\\nreturn result;\\n}\\n\",\"custom/string.c\":\"#include <string.h>\\nchar* strcpy(char* destination, const char* source) {\\nmemcpy(destination, source, strlen(source) + 1);  \\nreturn destination;\\n}\\nchar* strncpy(char* destination, const char* source, size_t n) {\\nconst size_t len = strnlen(source, n);\\nif (len < n) {\\nmemcpy(destination, source, len);\\nmemset(destination + len, 0, n - len);\\n} else {\\nmemcpy(destination, source, n);\\n}\\nreturn destination;\\n}\\nvoid* memcpy(void* destination, const void* source, size_t n) {\\n__wasm__(3, destination, source, n, 0xFC, 0x0A, 0, 0);  \\nreturn destination;\\n}\\nvoid* memset(void* destination, int c, size_t n) {\\n__wasm__(3, destination, c, n, 0xFC, 0x0B, 0);  \\nreturn destination;\\n}\\n\",\"custom/time.c\":\"#include <time.h>\\nclock_t clock() {\\nreturn __time();\\n}\\n\",\"errno.h\":\"extern int errno;\\n#define EDOM 10\\n#define ERANGE 11\\n#define EILSEQ 12\\n\",\"float.h\":\"#pragma once\\n#define FLT_RADIX 2\\n#define FLT_ROUNDS 1\\n#define FLT_DIG 6\\n#define FLT_EPSILON 1.192092896e-07F\\n#define FLT_MANT_DIG 24\\n#define FLT_MAX 3.402823466e+38F\\n#define FLT_MAX_EXP 128\\n#define FLT_MIN 1.175494351e-38F\\n#define FLT_MIN_EXP (-125)\\n#define DBL_DIG 15\\n#define DBL_EPSILON 2.2204460492503131e-016\\n#define DBL_MANT_DIG 53\\n#define DBL_MAX 1.7976931348623158e+308\\n#define DBL_MAX_EXP 1024\\n#define DBL_MIN 2.2250738585072014e-308\\n#define DBL_MIN_EXP (-1021)\\n#define LDBL_DIG 15\\n#define LDBL_EPSILON 2.2204460492503131e-016\\n#define LDBL_MANT_DIG 53\\n#define LDBL_MAX 1.7976931348623158e+308\\n#define LDBL_MAX_EXP 1024\\n#define LDBL_MIN 2.2250738585072014e-308\\n#define LDBL_MIN_EXP (-1021)\\n\",\"libraries/avrlibc/LICENSE\":\"The contents of avr-libc are licensed with a Modified BSD License.\\n\\nAll of this is supposed to be Free Software, Open Source, DFSG-free,\\nGPL-compatible, and OK to use in both free and proprietary applications.\\n\\nSee the license information in the individual source files for details.\\n\\nAdditions and corrections to this file are welcome.\\n\\n*******************************************************************************\\nPortions of avr-libc are Copyright (c) 1999-2010\\nKeith Gudger,\\nBjoern Haase,\\nSteinar Haugen,\\nPeter Jansen,\\nReinhard Jessich,\\nMagnus Johansson,\\nArtur Lipowski,\\nMarek Michalkiewicz,\\nColin O'Flynn,\\nBob Paddock,\\nReiner Patommel,\\nMichael Rickman,\\nTheodore A. Roth,\\nJuergen Schilling,\\nPhilip Soeberg,\\nAnatoly Sokolov,\\nNils Kristian Strom,\\nMichael Stumpf,\\nStefan Swanepoel,\\nEric B. Weddington,\\nJoerg Wunsch,\\nDmitry Xmelkov,\\nThe Regents of the University of California.\\nAll rights reserved.\\n\\n   Redistribution and use in source and binary forms, with or without\\n   modification, are permitted provided that the following conditions are met:\\n\\n   * Redistributions of source code must retain the above copyright\\n     notice, this list of conditions and the following disclaimer.\\n\\n   * Redistributions in binary form must reproduce the above copyright\\n     notice, this list of conditions and the following disclaimer in\\n     the documentation and/or other materials provided with the\\n     distribution.\\n\\n   * Neither the name of the copyright holders nor the names of\\n     contributors may be used to endorse or promote products derived\\n     from this software without specific prior written permission.\\n\\n   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \\\"AS IS\\\"\\n   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\\n   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\\n   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\\n   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\\n   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\\n   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\\n   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\\n   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\\n   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\\n   POSSIBILITY OF SUCH DAMAGE.\\n\\n*******************************************************************************\\n\",\"libraries/avrlibc/src/bsearch.c\":\"#include <stddef.h>\\n#include <stdlib.h>\\nvoid *\\nbsearch(const void *key, const void *base0, size_t nmemb,\\nsize_t size, int (*compar)(const void *, const void *))\\n{\\nconst char *base = base0;\\nsize_t lim;\\nint cmp;\\nconst void *p;\\nfor (lim = nmemb; lim != 0; lim >>= 1) {\\np = base + (lim >> 1) * size;\\ncmp = (*compar)(key, p);\\nif (cmp == 0)\\nreturn ((void *)p);\\nif (cmp > 0) {\\t \\nbase = (char *)p + size;\\nlim--;\\n}\\t\\t \\n}\\nreturn (NULL);\\n}\",\"libraries/avrlibc/src/qsort.c\":\"#include <stdlib.h>\\ntypedef int cmp_t(const void *, const void *);\\nstatic char *med3(char *, char *, char *, cmp_t *);\\nstatic void swapfunc(char *, char *, int);\\n#define min(a, b)\\t((a) < (b) ? (a) : (b))\\n#define swapcode(TYPE, parmi, parmj, n) { \\t\\t\\\\\\nint i = (n) / sizeof (TYPE); \\t\\t\\t\\\\\\nTYPE *pi = (TYPE *) (parmi); \\t\\t\\t\\\\\\nTYPE *pj = (TYPE *) (parmj); \\t\\t\\t\\\\\\ndo { \\t\\t\\t\\t  \\t\\t\\\\\\nTYPE\\tt = *pi;\\t\\t\\t\\\\\\n*pi++ = *pj;\\t\\t\\t\\t\\\\\\n*pj++ = t;\\t\\t\\t\\t\\\\\\n} while (--i > 0);\\t\\t\\t\\t\\\\\\n}\\nstatic void\\nswapfunc(char *a, char *b, int n)\\n{\\nswapcode(char, a, b, n)\\n}\\n#define swap(a, b) swapfunc(a, b, es)\\n#define vecswap(a, b, n) \\tif ((n) > 0) swapfunc(a, b, n)\\nstatic char *\\nmed3(char *a, char *b, char *c, cmp_t *cmp)\\n{\\nreturn cmp(a, b) < 0 ?\\n(cmp(b, c) < 0 ? b : (cmp(a, c) < 0 ? c : a ))\\n:(cmp(b, c) > 0 ? b : (cmp(a, c) < 0 ? a : c ));\\n}\\nvoid\\nqsort(void *a, size_t n, size_t es, cmp_t *cmp)\\n{\\nchar *pa, *pb, *pc, *pd, *pl, *pm, *pn;\\nint d, r, swap_cnt;\\nloop:\\nswap_cnt = 0;\\nif (n < 7) {\\nfor (pm = (char *)a + es; pm < (char *)a + n * es; pm += es)\\nfor (pl = pm; pl > (char *)a && cmp(pl - es, pl) > 0;\\npl -= es)\\nswap(pl, pl - es);\\nreturn;\\n}\\npm = (char *)a + (n / 2) * es;\\nif (n > 7) {\\npl = a;\\npn = (char *)a + (n - 1) * es;\\nif (n > 40) {\\nd = (n / 8) * es;\\npl = med3(pl, pl + d, pl + 2 * d, cmp);\\npm = med3(pm - d, pm, pm + d, cmp);\\npn = med3(pn - 2 * d, pn - d, pn, cmp);\\n}\\npm = med3(pl, pm, pn, cmp);\\n}\\nswap(a, pm);\\npa = pb = (char *)a + es;\\npc = pd = (char *)a + (n - 1) * es;\\nfor (;;) {\\nwhile (pb <= pc && (r = cmp(pb, a)) <= 0) {\\nif (r == 0) {\\nswap_cnt = 1;\\nswap(pa, pb);\\npa += es;\\n}\\npb += es;\\n}\\nwhile (pb <= pc && (r = cmp(pc, a)) >= 0) {\\nif (r == 0) {\\nswap_cnt = 1;\\nswap(pc, pd);\\npd -= es;\\n}\\npc -= es;\\n}\\nif (pb > pc)\\nbreak;\\nswap(pb, pc);\\nswap_cnt = 1;\\npb += es;\\npc -= es;\\n}\\nif (swap_cnt == 0) {   \\nfor (pm = (char *)a + es; pm < (char *)a + n * es; pm += es)\\nfor (pl = pm; pl > (char *)a && cmp(pl - es, pl) > 0;\\npl -= es)\\nswap(pl, pl - es);\\nreturn;\\n}\\npn = (char *)a + n * es;\\nr = (int) min(pa - (char *)a, pb - pa);\\nvecswap(a, pb - r, r);\\nr = (int) min(pd - pc, pn - pd - es);\\nvecswap(pb, pn - r, r);\\nif ((r = (int) (pb - pa)) > es)\\nqsort(a, r / es, es, cmp);\\nif ((r = (int) (pd - pc)) > es) {\\na = pn - r;\\nn = r / es;\\ngoto loop;\\n}\\n}\\n\",\"libraries/avrlibc/src/strtod.c\":\"#include <ctype.h>\\n#include <limits.h>\\n#include <math.h>         \\n#include <stdlib.h>\\n#include <strings.h>\\nstatic const double pwr_p10 [6] = {\\n1e+1, 1e+2, 1e+4, 1e+8, 1e+16, 1e+32\\n};\\nstatic const double pwr_m10 [6] = {\\n1e-1, 1e-2, 1e-4, 1e-8, 1e-16, 1e-32\\n};\\ndouble\\nstrtod (const char * nptr, char ** endptr)\\n{\\nunion {\\nunsigned long u32;\\ndouble flt;\\n} x;\\nunsigned char c;\\nint exp;\\nunsigned char flag;\\n#define FL_MINUS    0x01     \\n#define FL_ANY      0x02     \\n#define FL_OVFL     0x04     \\n#define FL_DOT      0x08     \\n#define FL_MEXP     0x10     \\nif (endptr)\\n*endptr = (char *)nptr;\\ndo {\\nc = *nptr++;\\n} while (isspace (c));\\nflag = 0;\\nif (c == '-') {\\nflag = FL_MINUS;\\nc = *nptr++;\\n} else if (c == '+') {\\nc = *nptr++;\\n}\\nif (!strncasecmp (nptr - 1, \\\"inf\\\", 3)) {\\nnptr += 2;\\nif (!strncasecmp (nptr, \\\"inity\\\", 5))\\nnptr += 5;\\nif (endptr)\\n*endptr = (char *)nptr;\\nreturn flag & FL_MINUS ? -INFINITY : +INFINITY;\\n}\\nif (!strncasecmp (nptr - 1, \\\"nan\\\", 3)) {\\nif (endptr)\\n*endptr = (char *)nptr + 2;\\nreturn NAN;\\n}\\nx.u32 = 0;\\nexp = 0;\\nwhile (1) {\\nc -= '0';\\nif (c <= 9) {\\nflag |= FL_ANY;\\nif (flag & FL_OVFL) {\\nif (!(flag & FL_DOT))\\nexp += 1;\\n} else {\\nif (flag & FL_DOT)\\nexp -= 1;\\nx.u32 = x.u32 * 10 + c;\\nif (x.u32 >= (ULONG_MAX - 9) / 10)\\nflag |= FL_OVFL;\\n}\\n} else if (c == (('.'-'0') & 0xff)  &&  !(flag & FL_DOT)) {\\nflag |= FL_DOT;\\n} else {\\nbreak;\\n}\\nc = *nptr++;\\n}\\nif (c == (('e'-'0') & 0xff) || c == (('E'-'0') & 0xff)) {\\nint i;\\nc = *nptr++;\\ni = 2;\\nif (c == '-') {\\nflag |= FL_MEXP;\\nc = *nptr++;\\n} else if (c == '+') {\\nc = *nptr++;\\n} else {\\ni = 1;\\n}\\nc -= '0';\\nif (c > 9) {\\nnptr -= i;\\n} else {\\ni = 0;\\ndo {\\nif (i < 3200)\\ni = (((i << 2) + i) << 1) + c;     \\nc = *nptr++ - '0';\\n} while (c <= 9);\\nif (flag & FL_MEXP)\\ni = -i;\\nexp += i;\\n}\\n}\\nif ((flag & FL_ANY) && endptr)\\n*endptr = (char *)nptr - 1;\\nx.flt = (double) (x.u32);         \\nif ((flag & FL_MINUS) && (flag & FL_ANY))\\nx.flt = -x.flt;\\nif (x.flt != 0) {\\nint pwr;\\nif (exp < 0) {\\nnptr = (void *)(pwr_m10 + 5);\\nexp = -exp;\\n} else {\\nnptr = (void *)(pwr_p10 + 5);\\n}\\nfor (pwr = 32; pwr; pwr >>= 1) {\\nfor (; exp >= pwr; exp -= pwr) {\\nx.flt *= *((double *)nptr);\\n}\\nnptr -= sizeof(double);\\n}\\n}\\nreturn x.flt;\\n}\",\"libraries/avrlibc/src/strtol.c\":\"#include <limits.h>\\n#include <ctype.h>\\n#include <errno.h>\\n#include <stdlib.h>\\nlong\\nstrtol(const char *nptr, char **endptr, int base)\\n{\\nunsigned long acc;\\nunsigned char c;\\nunsigned long cutoff;\\nsigned char any;\\nunsigned char flag = 0;\\n#define FL_NEG\\t0x01\\t\\t \\n#define FL_0X\\t0x02\\t\\t \\nif (endptr)\\n*endptr = (char *)nptr;\\nif (base != 0 && (base < 2 || base > 36))\\nreturn 0;\\ndo {\\nc = *nptr++;\\n} while (isspace(c));\\nif (c == '-') {\\nflag = FL_NEG;\\nc = *nptr++;\\n} else if (c == '+')\\nc = *nptr++;\\nif ((base == 0 || base == 16) &&\\nc == '0' && (*nptr == 'x' || *nptr == 'X')) {\\nc = nptr[1];\\nnptr += 2;\\nbase = 16;\\nflag |= FL_0X;\\n}\\nif (base == 0)\\nbase = c == '0' ? 8 : 10;\\n#if  LONG_MIN != -LONG_MAX - 1\\n#  error \\\"This implementation of strtol() does not work on this platform.\\\"\\n#endif\\nswitch (base) {\\ncase 10:\\ncutoff = ((unsigned long)LONG_MAX + 1) / 10;\\nbreak;\\ncase 16:\\ncutoff = ((unsigned long)LONG_MAX + 1) / 16;\\nbreak;\\ncase 8:\\ncutoff = ((unsigned long)LONG_MAX + 1) / 8;\\nbreak;\\ncase 2:\\ncutoff = ((unsigned long)LONG_MAX + 1) / 2;\\nbreak;\\ndefault:\\ncutoff = ((unsigned long)LONG_MAX + 1) / base;\\n}\\nfor (acc = 0, any = 0;; c = *nptr++) {\\nif (c >= '0' && c <= '9')\\nc -= '0';\\nelse if (c >= 'A' && c <= 'Z')\\nc -= 'A' - 10;\\nelse if (c >= 'a' && c <= 'z')\\nc -= 'a' - 10;\\nelse\\nbreak;\\nif (c >= base)\\nbreak;\\nif (any < 0)\\ncontinue;\\nif (acc > cutoff) {\\nany = -1;\\ncontinue;\\n}\\nacc = acc * base + c;\\nif (acc > (unsigned long)LONG_MAX + 1)\\nany = -1;\\nelse\\nany = 1;\\n}\\nif (endptr) {\\nif (any)\\n*endptr = (char *)nptr - 1;\\nelse if (flag & FL_0X)\\n*endptr = (char *)nptr - 2;\\n}\\nif (any < 0) {\\nacc = (flag & FL_NEG) ? LONG_MIN : LONG_MAX;\\nerrno = ERANGE;\\n} else if (flag & FL_NEG) {\\nacc = -acc;\\n} else if ((signed long)acc < 0) {\\nacc = LONG_MAX;\\nerrno = ERANGE;\\n}\\nreturn (acc);\\n}\",\"libraries/avrlibc/src/strtoul.c\":\"#include <limits.h>\\n#include <ctype.h>\\n#include <errno.h>\\n#include <stdlib.h>\\nunsigned long\\nstrtoul(const char *nptr, char **endptr, int base)\\n{\\nunsigned long acc;\\nunsigned char c;\\nunsigned long cutoff;\\nsigned char any;\\nunsigned char flag = 0;\\n#define FL_NEG\\t0x01\\t\\t \\n#define FL_0X\\t0x02\\t\\t \\nif (endptr)\\n*endptr = (char *)nptr;\\nif (base != 0 && (base < 2 || base > 36))\\nreturn 0;\\ndo {\\nc = *nptr++;\\n} while (isspace(c));\\nif (c == '-') {\\nflag = FL_NEG;\\nc = *nptr++;\\n} else if (c == '+')\\nc = *nptr++;\\nif ((base == 0 || base == 16) &&\\nc == '0' && (*nptr == 'x' || *nptr == 'X')) {\\nc = nptr[1];\\nnptr += 2;\\nbase = 16;\\nflag |= FL_0X;\\n}\\nif (base == 0)\\nbase = c == '0' ? 8 : 10;\\nswitch (base) {\\ncase 16:    cutoff = ULONG_MAX / 16;  break;\\ncase 10:    cutoff = ULONG_MAX / 10;  break;\\ncase 8:     cutoff = ULONG_MAX / 8;   break;\\ndefault:    cutoff = ULONG_MAX / base;\\n}\\nfor (acc = 0, any = 0;; c = *nptr++) {\\nif (c >= '0' && c <= '9')\\nc -= '0';\\nelse if (c >= 'A' && c <= 'Z')\\nc -= 'A' - 10;\\nelse if (c >= 'a' && c <= 'z')\\nc -= 'a' - 10;\\nelse\\nbreak;\\nif (c >= base)\\nbreak;\\nif (any < 0)\\ncontinue;\\nif (acc > cutoff) {\\nany = -1;\\ncontinue;\\n}\\nacc = acc * base + c;\\nany = (c > acc) ? -1 : 1;\\n}\\nif (endptr) {\\nif (any)\\n*endptr = (char *)nptr - 1;\\nelse if (flag & FL_0X)\\n*endptr = (char *)nptr - 2;\\n}\\nif (flag & FL_NEG)\\nacc = -acc;\\nif (any < 0) {\\nacc = ULONG_MAX;\\nerrno = ERANGE;\\n}\\nreturn (acc);\\n}\",\"libraries/avrlibc/src/vfscanf.c\":\"#ifdef FILES\\n#include <ctype.h>\\n#include <limits.h>\\n#include <math.h>\\n#include <stdarg.h>\\n#include <stddef.h>\\n#include <stdio.h>\\n#include <stdlib.h>\\n#include <string.h>\\n#define FL_STAR        0x01     \\n#define FL_WIDTH       0x02     \\n#define FL_LONG        0x04     \\n#define FL_CHAR        0x08     \\n#define FL_OCT         0x10     \\n#define FL_DEC         0x20     \\n#define FL_HEX         0x40     \\n#define FL_MINUS       0x80     \\n#define FL_SHORT       0x100\\nstatic void putval(char *addr, long val, unsigned char flags) {\\nif (!(flags & FL_STAR)) {\\nif (flags & FL_CHAR)\\n*(char *) addr = (char) val;\\nelse if (flags & FL_LONG)\\n*(long *) addr = (long) val;\\nelse if (flags & FL_SHORT)\\n*(short *) addr = (short) val;\\nelse\\n*(int *) addr = (int) val;\\n}\\n}\\nstatic unsigned char conv_int(FILE *stream, int width, void *addr, unsigned char flags) {\\nunsigned long val;\\nint i;\\ni = getc(stream);             \\nswitch ((unsigned char) i) {\\ncase '-':\\nflags |= FL_MINUS;\\ncase '+':\\nif (!--width || (i = getc(stream)) < 0)\\ngoto err;\\n}\\n{\\nval = 0;\\nflags &= ~FL_WIDTH;\\nif (!(flags & (FL_DEC | FL_OCT)) && (unsigned char) i == '0') {\\nif (!--width || (i = getc(stream)) < 0)\\ngoto putval;\\nflags |= FL_WIDTH;\\nif ((unsigned char) (i) == 'x' || (unsigned char) (i) == 'X') {\\nflags |= FL_HEX;\\nif (!--width || (i = getc(stream)) < 0)\\ngoto putval;\\n} else {\\nif (!(flags & FL_HEX))\\nflags |= FL_OCT;\\n}\\n}\\ndo {\\nunsigned char c = i;\\nc -= '0';\\nif (flags & FL_OCT) {\\nif (c > 7) {\\nungetc(i, stream);\\nbreak;\\n}\\nval = val * 8 + c;\\n} else if (flags & FL_HEX) {\\nif (c > 9) {\\nc &= ~('A' ^ 'a');\\nc += '0' - 'A';\\nif (c > 5) {\\nungetc(i, stream);\\nbreak;\\n}\\nc += 10;\\n}\\nval = val * 16 + c;\\n} else {\\nif (c > 9) {\\nungetc(i, stream);\\nbreak;\\n}\\nval = val * 10 + c;\\n}\\nflags |= FL_WIDTH;\\nif (!--width) goto putval;\\n} while ((i = getc(stream)) >= 0);\\nif (!(flags & FL_WIDTH))\\ngoto err;\\nputval:\\nif (flags & FL_MINUS) val = -(long) val;\\nputval(addr, val, flags);\\nreturn 1;\\n}\\nerr:\\nreturn 0;\\n}\\nstatic const char *conv_brk(FILE *stream, int width, char *addr, const char *fmt) {\\nunsigned char msk[32];\\nunsigned char fnegate;\\nunsigned char frange;\\nunsigned char cabove;\\nint i;\\nmemset(msk, 0, sizeof(msk));\\nfnegate = 0;\\nfrange = 0;\\ncabove = 0;             \\nfor (i = 0;; i++) {\\nunsigned char c = *(fmt++);\\nif (c == 0) {\\nreturn 0;\\n} else if (c == '^' && !i) {\\nfnegate = 1;\\ncontinue;\\n} else if (i > fnegate) {\\nif (c == ']') break;\\nif (c == '-' && !frange) {\\nfrange = 1;\\ncontinue;\\n}\\n}\\nif (!frange) cabove = c;\\nfor (;;) {\\nmsk[c >> 3] |= 1 << (c & 7);\\nif (c == cabove) break;\\nif (c < cabove)\\nc++;\\nelse\\nc--;\\n}\\nfrange = 0;\\n}\\nif (frange)\\nmsk['-' / 8] |= 1 << ('-' & 7);\\nif (fnegate) {\\nunsigned char *p = msk;\\ndo {\\nunsigned char c = *p;\\n*p++ = ~c;\\n} while (p != msk + sizeof(msk));\\n}\\nfnegate = 1;\\ndo {\\ni = getc(stream);\\nif (i < 0) break;\\nif (!((msk[(unsigned char) i >> 3] >> (i & 7)) & 1)) {\\nungetc(i, stream);\\nbreak;\\n}\\nif (addr) *addr++ = i;\\nfnegate = 0;\\n} while (--width);\\nif (fnegate) {\\nreturn 0;\\n} else {\\nif (addr) *addr = 0;\\nreturn fmt;\\n}\\n}\\nstatic const double pwr_p10[6] = {\\n1e+1, 1e+2, 1e+4, 1e+8, 1e+16, 1e+32\\n};\\nstatic const double pwr_m10[6] = {\\n1e-1, 1e-2, 1e-4, 1e-8, 1e-16, 1e-32\\n};\\nstatic const char pstr_nfinity[] = \\\"nfinity\\\";\\nstatic const char pstr_an[] = \\\"an\\\";\\nstatic unsigned char conv_flt(FILE *stream, int width, double *addr) {\\nunion {\\nunsigned long u32;\\ndouble flt;\\n} x;\\nint i;\\nconst char *p = 0;\\nint exp;\\nunsigned char flag;\\n#define FL_MINUS   0x80     \\n#define FL_ANY     0x02     \\n#define FL_OVFL    0x04     \\n#define FL_DOT     0x08     \\n#define FL_MEXP    0x10     \\ni = getc(stream);         \\nflag = 0;\\nswitch ((unsigned char) i) {\\ncase '-':\\nflag = FL_MINUS;\\ncase '+':\\nif (!--width || (i = getc(stream)) < 0)\\ngoto err;\\n}\\nswitch (tolower(i)) {\\ncase 'n':\\np = pstr_an;\\ncase 'i':\\nif (!p) p = pstr_nfinity;\\nunsigned char c;\\nwhile ((c = *(p++)) != 0) {\\nif (!--width || (i = getc(stream)) < 0 || (!((unsigned char) tolower(i) == c || !(ungetc(i, stream), 1)))) {\\nif (p == pstr_nfinity + 3) break;\\ngoto err;\\n}\\n}\\nx.flt = (p == pstr_an + 3) ? NAN : INFINITY;\\nbreak;\\ndefault:\\nexp = 0;\\nx.u32 = 0;\\ndo {\\nunsigned char c = i - '0';\\nif (c <= 9) {\\nflag |= FL_ANY;\\nif (flag & FL_OVFL) {\\nif (!(flag & FL_DOT))\\nexp += 1;\\n} else {\\nif (flag & FL_DOT)\\nexp -= 1;\\nx.u32 = x.u32 * 10 + c;\\nif (x.u32 >= (ULONG_MAX - 9) / 10)\\nflag |= FL_OVFL;\\n}\\n} else if (c == (('.' - '0') & 0xff) && !(flag & FL_DOT)) {\\nflag |= FL_DOT;\\n} else {\\nbreak;\\n}\\n} while (--width && (i = getc(stream)) >= 0);\\nif (!(flag & FL_ANY))\\ngoto err;\\nif ((unsigned char) i == 'e' || (unsigned char) i == 'E') {\\nint expacc;\\nif (!--width || (i = getc(stream)) < 0) goto err;\\nswitch ((unsigned char) i) {\\ncase '-':\\nflag |= FL_MEXP;\\ncase '+':\\nif (!--width) goto err;\\ni = getc(stream);         \\n}\\nif (!isdigit(i)) goto err;\\nexpacc = 0;\\ndo {\\nexpacc = expacc * 10 + (i - '0');\\n} while (--width && isdigit(i = getc(stream)));\\nif (flag & FL_MEXP)\\nexpacc = -expacc;\\nexp += expacc;\\n}\\nif (width && i >= 0) ungetc(i, stream);\\nx.flt = (double) (x.u32);\\nif (exp < 0) {\\np = (void *) (pwr_m10 + 5);\\nexp = -exp;\\n} else {\\np = (void *) (pwr_p10 + 5);\\n}\\nfor (width = 32; width; width >>= 1) {\\nfor (; (unsigned) exp >= width; exp -= width) {\\nx.flt *= *((double *)p);\\n}\\np = p - sizeof(double);\\n}\\n}  \\nif (flag & FL_MINUS)\\nx.flt = -x.flt;\\nif (addr) *addr = x.flt;\\nreturn 1;\\nerr:\\nreturn 0;\\n}\\nstatic int skip_spaces(FILE *stream) {\\nint i;\\ndo {\\nif ((i = getc(stream)) < 0)\\nreturn i;\\n} while (isspace(i));\\nungetc(i, stream);\\nreturn i;\\n}\\nint vfscanf(FILE *stream, const char *fmt, va_list ap) {\\nint nconvs;\\nunsigned char c;\\nint width;\\nchar *addr;\\nunsigned char flags;\\nint i;\\nnconvs = 0;\\nstream->len = 0;\\nwhile ((c = *(fmt++)) != 0) {\\nif (isspace(c)) {\\nskip_spaces(stream);\\n} else if (c != '%' || (c = *(fmt++)) == '%') {\\nif ((i = getc(stream)) < 0)\\ngoto eof;\\nif ((unsigned char) i != c) {\\nungetc(i, stream);\\nbreak;\\n}\\n} else {\\nflags = 0;\\nif (c == '*') {\\nflags = FL_STAR;\\nc = *(fmt++);\\n}\\nwidth = 0;\\nwhile ((c -= '0') < 10) {\\nflags |= FL_WIDTH;\\nwidth = width * 10 + c;\\nc = *(fmt++);\\n}\\nc += '0';\\nif (flags & FL_WIDTH) {\\nif (!width) break;\\n} else {\\nwidth = ~0;\\n}\\nswitch (c) {\\ncase 'h':\\nflags |= FL_SHORT;\\nif ((c = *(fmt++)) != 'h')\\nbreak;\\nflags |= FL_CHAR;\\nc = *(fmt++);\\nbreak;\\ncase 'l':\\nflags |= FL_LONG;\\nif ((c = *fmt++) != 'l')\\nbreak;\\nc = *(fmt++);\\n}\\nif (!c || !strchr(\\\"cdinopsuxX[efgEFG\\\", c))\\nbreak;\\naddr = (flags & FL_STAR) ? 0 : va_arg (ap, char *);\\nif (c == 'n') {\\nputval(addr, (unsigned) (stream->len), flags);\\ncontinue;\\n}\\nif (c == 'c') {\\nif (!(flags & FL_WIDTH)) width = 1;\\ndo {\\nif ((i = getc(stream)) < 0)\\ngoto eof;\\nif (addr) *(addr++) = i;\\n} while (--width);\\nc = 1;             \\n} else if (c == '[') {\\nfmt = conv_brk(stream, width, addr, fmt);\\nc = (fmt != 0);\\n} else {\\nif (skip_spaces(stream) < 0)\\ngoto eof;\\nswitch (c) {\\ncase 's':\\ndo {\\nif ((i = getc(stream)) < 0)\\nbreak;\\nif (isspace(i)) {\\nungetc(i, stream);\\nbreak;\\n}\\nif (addr) *(addr++) = i;\\n} while (--width);\\nif (addr) *(addr) = 0;\\nc = 1;         \\nbreak;\\ncase 'p':\\ncase 'x':\\ncase 'X':\\nflags |= FL_HEX;\\nc = conv_int(stream, width, (void *) addr, flags);\\nbreak;\\ncase 'd':\\ncase 'u':\\nflags |= FL_DEC;\\nc = conv_int(stream, width, (void *) addr, flags);\\nbreak;\\ncase 'o':\\nflags |= FL_OCT;\\nc = conv_int(stream, width, (void *) addr, flags);\\nbreak;\\ncase 'i':\\nc = conv_int(stream, width, (void *) addr, flags);\\nbreak;\\ndefault:         \\nif (flags & FL_LONG) {\\nc = conv_flt(stream, width, (void *) addr);\\n} else if (addr) {\\ndouble d;\\nc = conv_flt(stream, width, &d);\\n*((float*) addr) = d;\\n} else {\\nc = conv_flt(stream, width, 0);\\n}\\n}\\n}  \\nif (!c) {\\nif (feof(stream) || ferror(stream))\\ngoto eof;\\nbreak;\\n}\\nif (!(flags & FL_STAR)) nconvs += 1;\\n}  \\n}  \\nreturn nconvs;\\neof:\\nreturn nconvs ? nconvs : EOF;\\n}\\n#endif\\n\",\"libraries/musl/README.md\":\"Original: https://musl.libc.org/\\n\\nVersion used: `v1.2.1`\\n\\nLicense (for files used): MIT\\n\\n\",\"libraries/musl/src/string/memchr.c\":\"#include <string.h>\\n#include <stdint.h>\\n#include <limits.h>\\n#define SS (sizeof(size_t))\\n#define ALIGN (sizeof(size_t)-1)\\n#define ONES ((size_t)-1/UCHAR_MAX)\\n#define HIGHS (ONES * (UCHAR_MAX/2+1))\\n#define HASZERO(x) ((x)-ONES & ~(x) & HIGHS)\\nvoid *memchr(const void *src, int c, size_t n)\\n{\\nconst unsigned char *s = src;\\nc = (unsigned char)c;\\nfor (; n && *s != c; s++, n--);\\nreturn n ? (void *)s : (void *)0;\\n}\\n\",\"libraries/musl/src/string/memcmp.c\":\"#include <string.h>\\nint memcmp(const void *vl, const void *vr, size_t n)\\n{\\nconst unsigned char *l=vl, *r=vr;\\nfor (; n && *l == *r; n--, l++, r++);\\nreturn n ? *l-*r : 0;\\n}\\n\",\"libraries/musl/src/string/memmove.c\":\"#include <string.h>\\n#include <stdint.h>\\nvoid *memmove(void *dest, const void *src, size_t n)\\n{\\nchar *d = dest;\\nconst char *s = src;\\nif (d==s) return d;\\nif ((uintptr_t)s-(uintptr_t)d-n <= -2*n) return memcpy(d, s, n);\\nif (d<s) {\\nfor (; n; n--) *d++ = *s++;\\n} else {\\nwhile (n) n--, d[n] = s[n];\\n}\\nreturn dest;\\n}\\n\",\"libraries/musl/src/string/strcasecmp.c\":\"#include <strings.h>\\n#include <ctype.h>\\nint strcasecmp(const char *_l, const char *_r)\\n{\\nconst unsigned char *l=(void *)_l, *r=(void *)_r;\\nfor (; *l && *r && (*l == *r || tolower(*l) == tolower(*r)); l++, r++);\\nreturn tolower(*l) - tolower(*r);\\n}\",\"libraries/musl/src/string/strcat.c\":\"#include <string.h>\\nchar *strcat(char *dest, const char *src)\\n{\\nstrcpy(dest + strlen(dest), src);\\nreturn dest;\\n}\\n\",\"libraries/musl/src/string/strchr.c\":\"#include <string.h>\\nchar *__strchrnul(const char *s, int c);\\nchar *strchr(const char *s, int c)\\n{\\nchar *r = __strchrnul(s, c);\\nreturn *(unsigned char *)r == (unsigned char)c ? r : (char *)0;\\n}\\n\",\"libraries/musl/src/string/strchrnul.c\":\"#include <string.h>\\n#include <stdint.h>\\n#include <limits.h>\\n#define ALIGN (sizeof(size_t))\\n#define ONES ((size_t)-1/UCHAR_MAX)\\n#define HIGHS (ONES * (UCHAR_MAX/2+1))\\n#define HASZERO(x) ((x)-ONES & ~(x) & HIGHS)\\nchar *__strchrnul(const char *s, int c)\\n{\\nc = (unsigned char)c;\\nif (!c) return (char *)s + strlen(s);\\nfor (; *s && *(unsigned char *)s != c; s++);\\nreturn (char *)s;\\n}\\n\",\"libraries/musl/src/string/strcmp.c\":\"#include <string.h>\\nint strcmp(const char *l, const char *r)\\n{\\nfor (; *l==*r && *l; l++, r++);\\nreturn *(unsigned char *)l - *(unsigned char *)r;\\n}\\n\",\"libraries/musl/src/string/strcspn.c\":\"#include <string.h>\\n#define BITOP(a,b,op) \\\\\\n((a)[(size_t)(b)/(8*sizeof *(a))] op (size_t)1<<((size_t)(b)%(8*sizeof *(a))))\\nchar *__strchrnul(const char *s, int c);\\nsize_t strcspn(const char *s, const char *c)\\n{\\nconst char *a = s;\\nsize_t byteset[8];  \\nif (!c[0] || !c[1]) return (size_t) (__strchrnul(s, *c)-a);\\nmemset(byteset, 0, sizeof byteset);\\nfor (; *c && BITOP(byteset, *(unsigned char *)c, |=); c++);\\nfor (; *s && !BITOP(byteset, *(unsigned char *)s, &); s++);\\nreturn (size_t) (s-a);\\n}\\n\",\"libraries/musl/src/string/strlen.c\":\"#include <string.h>\\n#include <stdint.h>\\n#include <limits.h>\\n#define ALIGN (sizeof(size_t))\\n#define ONES ((size_t)-1/UCHAR_MAX)\\n#define HIGHS (ONES * (UCHAR_MAX/2+1))\\n#define HASZERO(x) ((x)-ONES & ~(x) & HIGHS)\\nsize_t strlen(const char *s)\\n{\\nconst char *a = s;\\nfor (; *s; s++);\\nreturn (size_t) (s-a);\\n}\\n\",\"libraries/musl/src/string/strncasecmp.c\":\"#include <strings.h>\\n#include <ctype.h>\\nint strncasecmp(const char *_l, const char *_r, size_t n)\\n{\\nconst unsigned char *l=(void *)_l, *r=(void *)_r;\\nif (!n--) return 0;\\nfor (; *l && *r && n && (*l == *r || tolower(*l) == tolower(*r)); l++, r++, n--);\\nreturn tolower(*l) - tolower(*r);\\n}\",\"libraries/musl/src/string/strncat.c\":\"#include <string.h>\\nchar *strncat(char *d, const char *s, size_t n)\\n{\\nchar *a = d;\\nd += strlen(d);\\nwhile (n && *s) n--, *d++ = *s++;\\n*d++ = 0;\\nreturn a;\\n}\\n\",\"libraries/musl/src/string/strncmp.c\":\"#include <string.h>\\nint strncmp(const char *_l, const char *_r, size_t n)\\n{\\nconst unsigned char *l=(void *)_l, *r=(void *)_r;\\nif (!n--) return 0;\\nfor (; *l && *r && n && *l == *r ; l++, r++, n--);\\nreturn *l - *r;\\n}\\n\",\"libraries/musl/src/string/strnlen.c\":\"#include <string.h>\\nsize_t strnlen(const char *s, size_t n)\\n{\\nconst char *p = memchr(s, 0, n);\\nreturn p ? (size_t) (p-s) : n;\\n}\\n\",\"libraries/musl/src/string/strpbrk.c\":\"#include <string.h>\\nchar *strpbrk(const char *s, const char *b)\\n{\\ns += strcspn(s, b);\\nreturn *s ? (char *)s : (char *) 0;\\n}\\n\",\"libraries/musl/src/string/strrchr.c\":\"#include <string.h>\\nvoid *__memrchr(const void *m, int c, size_t n)\\n{\\nconst unsigned char *s = m;\\nc = (unsigned char)c;\\nwhile (n--) if (s[n]==c) return (void *)(s+n);\\nreturn 0;\\n}\\nchar *strrchr(const char *s, int c)\\n{\\nreturn __memrchr(s, c, strlen(s) + 1);\\n}\\n\",\"libraries/musl/src/string/strspn.c\":\"#include <string.h>\\n#define BITOP(a,b,op) \\\\\\n((a)[(size_t)(b)/(8*sizeof *(a))] op (size_t)1<<((size_t)(b)%(8*sizeof *(a))))\\nsize_t strspn(const char *s, const char *c)\\n{\\nconst char *a = s;\\nsize_t byteset[8] = { 0 };\\nif (!c[0]) return 0;\\nif (!c[1]) {\\nfor (; *s == *c; s++);\\nreturn (size_t) (s-a);\\n}\\nfor (; *c && BITOP(byteset, *(unsigned char *)c, |=); c++);\\nfor (; *s && BITOP(byteset, *(unsigned char *)s, &); s++);\\nreturn (size_t) (s-a);\\n}\\n\",\"libraries/musl/src/string/strstr.c\":\"#include <string.h>\\n#include <stdint.h>\\nstatic char *twobyte_strstr(const unsigned char *h, const unsigned char *n)\\n{\\nuint16_t nw = n[0]<<8 | n[1], hw = h[0]<<8 | h[1];\\nfor (h++; *h && hw != nw; hw = hw<<8 | *++h);\\nreturn *h ? (char *)h-1 : (char *) 0;\\n}\\nstatic char *threebyte_strstr(const unsigned char *h, const unsigned char *n)\\n{\\nuint32_t nw = (uint32_t)n[0]<<24 | n[1]<<16 | n[2]<<8;\\nuint32_t hw = (uint32_t)h[0]<<24 | h[1]<<16 | h[2]<<8;\\nfor (h+=2; *h && hw != nw; hw = (hw|*++h)<<8);\\nreturn *h ? (char *)h-2 : (char *) 0;\\n}\\nstatic char *fourbyte_strstr(const unsigned char *h, const unsigned char *n)\\n{\\nuint32_t nw = (uint32_t)n[0]<<24 | n[1]<<16 | n[2]<<8 | n[3];\\nuint32_t hw = (uint32_t)h[0]<<24 | h[1]<<16 | h[2]<<8 | h[3];\\nfor (h+=3; *h && hw != nw; hw = hw<<8 | *++h);\\nreturn *h ? (char *)h-3 : (char *) 0;\\n}\\n#define MAX(a,b) ((a)>(b)?(a):(b))\\n#define MIN(a,b) ((a)<(b)?(a):(b))\\n#define BITOP(a,b,op) \\\\\\n((a)[(size_t)(b)/(8*sizeof *(a))] op (size_t)1<<((size_t)(b)%(8*sizeof *(a))))\\nstatic char *twoway_strstr(const unsigned char *h, const unsigned char *n)\\n{\\nconst unsigned char *z;\\nsize_t l, ip, jp, k, p, ms, p0, mem, mem0;\\nsize_t byteset[8] = { 0 };\\nsize_t shift[256];\\nfor (l=0; n[l] && h[l]; l++)\\nBITOP(byteset, n[l], |=), shift[n[l]] = l+1;\\nif (n[l]) return 0;  \\nip = -1; jp = 0; k = p = 1;\\nwhile (jp+k<l) {\\nif (n[ip+k] == n[jp+k]) {\\nif (k == p) {\\njp += p;\\nk = 1;\\n} else k++;\\n} else if (n[ip+k] > n[jp+k]) {\\njp += k;\\nk = 1;\\np = jp - ip;\\n} else {\\nip = jp++;\\nk = p = 1;\\n}\\n}\\nms = ip;\\np0 = p;\\nip = -1; jp = 0; k = p = 1;\\nwhile (jp+k<l) {\\nif (n[ip+k] == n[jp+k]) {\\nif (k == p) {\\njp += p;\\nk = 1;\\n} else k++;\\n} else if (n[ip+k] < n[jp+k]) {\\njp += k;\\nk = 1;\\np = jp - ip;\\n} else {\\nip = jp++;\\nk = p = 1;\\n}\\n}\\nif (ip+1 > ms+1) ms = ip;\\nelse p = p0;\\nif (memcmp(n, n+p, ms+1)) {\\nmem0 = 0;\\np = MAX(ms, l-ms-1) + 1;\\n} else mem0 = l-p;\\nmem = 0;\\nz = h;\\nfor (;;) {\\nif (z-h < l) {\\nsize_t grow = l | 63;\\nconst unsigned char *z2 = memchr(z, 0, grow);\\nif (z2) {\\nz = z2;\\nif (z-h < l) return 0;\\n} else z += grow;\\n}\\nif (BITOP(byteset, h[l-1], &)) {\\nk = l-shift[h[l-1]];\\nif (k) {\\nif (k < mem) k = mem;\\nh += k;\\nmem = 0;\\ncontinue;\\n}\\n} else {\\nh += l;\\nmem = 0;\\ncontinue;\\n}\\nfor (k=MAX(ms+1,mem); n[k] && n[k] == h[k]; k++);\\nif (n[k]) {\\nh += k-ms;\\nmem = 0;\\ncontinue;\\n}\\nfor (k=ms+1; k>mem && n[k-1] == h[k-1]; k--);\\nif (k <= mem) return (char *)h;\\nh += p;\\nmem = mem0;\\n}\\nreturn 0;\\n}\\nchar *strstr(const char *h, const char *n)\\n{\\nif (!n[0]) return (char *)h;\\nh = strchr(h, *n);\\nif (!h || !n[1]) return (char *)h;\\nif (!h[1]) return 0;\\nif (!n[2]) return twobyte_strstr((void *)h, (void *)n);\\nif (!h[2]) return 0;\\nif (!n[3]) return threebyte_strstr((void *)h, (void *)n);\\nif (!h[3]) return 0;\\nif (!n[4]) return fourbyte_strstr((void *)h, (void *)n);\\nreturn twoway_strstr((void *)h, (void *)n);\\n}\\n\",\"libraries/musl/src/string/strtok.c\":\"#include <string.h>\\nchar *strtok(char *s, const char *sep)\\n{\\nstatic char *p;\\nif (!s && !(s = p)) return NULL;\\ns += strspn(s, sep);\\nif (!*s) return p = 0;\\np = s + strcspn(s, sep);\\nif (*p) *p++ = 0;\\nelse p = 0;\\nreturn s;\\n}\\n\",\"libraries/printf/LICENSE\":\"The MIT License (MIT)\\n\\nCopyright (c) 2014 Marco Paland\\n\\nPermission is hereby granted, free of charge, to any person obtaining a copy\\nof this software and associated documentation files (the \\\"Software\\\"), to deal\\nin the Software without restriction, including without limitation the rights\\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\ncopies of the Software, and to permit persons to whom the Software is\\nfurnished to do so, subject to the following conditions:\\n\\nThe above copyright notice and this permission notice shall be included in all\\ncopies or substantial portions of the Software.\\n\\nTHE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\nSOFTWARE.\\n\",\"libraries/printf/README.md\":\"Original: https://github.com/mpaland/printf\\n\\nCommit used: `d3b984684bb8a8bdc48cc7a1abecb93ce59bbe3e`\\n\\nLicense: MIT\\n\\nFiles:\\n- `printf.c` custom fprintf implementation added to the end of the file, but otherwise unmodified\\n- `printf.h` custom\\n\\n\",\"libraries/printf/printf.c\":\"#include <stdbool.h>\\n#include <stdint.h>\\n#include \\\"printf.h\\\"\\n#ifdef PRINTF_INCLUDE_CONFIG_H\\n#include \\\"printf_config.h\\\"\\n#endif\\n#ifndef PRINTF_NTOA_BUFFER_SIZE\\n#define PRINTF_NTOA_BUFFER_SIZE    32U\\n#endif\\n#ifndef PRINTF_FTOA_BUFFER_SIZE\\n#define PRINTF_FTOA_BUFFER_SIZE    32U\\n#endif\\n#ifndef PRINTF_DISABLE_SUPPORT_FLOAT\\n#define PRINTF_SUPPORT_FLOAT\\n#endif\\n#ifndef PRINTF_DISABLE_SUPPORT_EXPONENTIAL\\n#define PRINTF_SUPPORT_EXPONENTIAL\\n#endif\\n#ifndef PRINTF_DEFAULT_FLOAT_PRECISION\\n#define PRINTF_DEFAULT_FLOAT_PRECISION  6U\\n#endif\\n#ifndef PRINTF_MAX_FLOAT\\n#define PRINTF_MAX_FLOAT  1e9\\n#endif\\n#ifndef PRINTF_DISABLE_SUPPORT_LONG_LONG\\n#define PRINTF_SUPPORT_LONG_LONG\\n#endif\\n#ifndef PRINTF_DISABLE_SUPPORT_PTRDIFF_T\\n#define PRINTF_SUPPORT_PTRDIFF_T\\n#endif\\n#define FLAGS_ZEROPAD   (1U <<  0U)\\n#define FLAGS_LEFT      (1U <<  1U)\\n#define FLAGS_PLUS      (1U <<  2U)\\n#define FLAGS_SPACE     (1U <<  3U)\\n#define FLAGS_HASH      (1U <<  4U)\\n#define FLAGS_UPPERCASE (1U <<  5U)\\n#define FLAGS_CHAR      (1U <<  6U)\\n#define FLAGS_SHORT     (1U <<  7U)\\n#define FLAGS_LONG      (1U <<  8U)\\n#define FLAGS_LONG_LONG (1U <<  9U)\\n#define FLAGS_PRECISION (1U << 10U)\\n#define FLAGS_ADAPT_EXP (1U << 11U)\\n#if defined(PRINTF_SUPPORT_FLOAT)\\n#include <float.h>\\n#endif\\ntypedef void (*out_fct_type)(char character, void* buffer, size_t idx, size_t maxlen);\\ntypedef struct {\\nvoid  (*fct)(char character, void* arg);\\nvoid* arg;\\n} out_fct_wrap_type;\\nstatic inline void _out_buffer(char character, void* buffer, size_t idx, size_t maxlen)\\n{\\nif (idx < maxlen) {\\n((char*)buffer)[idx] = character;\\n}\\n}\\nstatic inline void _out_null(char character, void* buffer, size_t idx, size_t maxlen)\\n{\\n(void)character; (void)buffer; (void)idx; (void)maxlen;\\n}\\nstatic inline void _out_char(char character, void* buffer, size_t idx, size_t maxlen)\\n{\\n(void)buffer; (void)idx; (void)maxlen;\\nif (character) {\\n_putchar(character);\\n}\\n}\\nstatic inline void _out_fct(char character, void* buffer, size_t idx, size_t maxlen)\\n{\\n(void)idx; (void)maxlen;\\nif (character) {\\n((out_fct_wrap_type*)buffer)->fct(character, ((out_fct_wrap_type*)buffer)->arg);\\n}\\n}\\nstatic inline unsigned int _strnlen_s(const char* str, size_t maxsize)\\n{\\nconst char* s;\\nfor (s = str; *s && maxsize--; ++s);\\nreturn (unsigned int)(s - str);\\n}\\nstatic inline bool _is_digit(char ch)\\n{\\nreturn (ch >= '0') && (ch <= '9');\\n}\\nstatic unsigned int _atoi(const char** str)\\n{\\nunsigned int i = 0U;\\nwhile (_is_digit(**str)) {\\ni = i * 10U + (unsigned int)(*((*str)++) - '0');\\n}\\nreturn i;\\n}\\nstatic size_t _out_rev(out_fct_type out, char* buffer, size_t idx, size_t maxlen, const char* buf, size_t len, unsigned int width, unsigned int flags)\\n{\\nconst size_t start_idx = idx;\\nif (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {\\nfor (size_t i = len; i < width; i++) {\\nout(' ', buffer, idx++, maxlen);\\n}\\n}\\nwhile (len) {\\nout(buf[--len], buffer, idx++, maxlen);\\n}\\nif (flags & FLAGS_LEFT) {\\nwhile (idx - start_idx < width) {\\nout(' ', buffer, idx++, maxlen);\\n}\\n}\\nreturn idx;\\n}\\nstatic size_t _ntoa_format(out_fct_type out, char* buffer, size_t idx, size_t maxlen, char* buf, size_t len, bool negative, unsigned int base, unsigned int prec, unsigned int width, unsigned int flags)\\n{\\nif (!(flags & FLAGS_LEFT)) {\\nif (width && (flags & FLAGS_ZEROPAD) && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {\\nwidth--;\\n}\\nwhile ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {\\nbuf[len++] = '0';\\n}\\nwhile ((flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {\\nbuf[len++] = '0';\\n}\\n}\\nif (flags & FLAGS_HASH) {\\nif (!(flags & FLAGS_PRECISION) && len && ((len == prec) || (len == width))) {\\nlen--;\\nif (len && (base == 16U)) {\\nlen--;\\n}\\n}\\nif ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {\\nbuf[len++] = 'x';\\n}\\nelse if ((base == 16U) && (flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {\\nbuf[len++] = 'X';\\n}\\nelse if ((base == 2U) && (len < PRINTF_NTOA_BUFFER_SIZE)) {\\nbuf[len++] = 'b';\\n}\\nif (len < PRINTF_NTOA_BUFFER_SIZE) {\\nbuf[len++] = '0';\\n}\\n}\\nif (len < PRINTF_NTOA_BUFFER_SIZE) {\\nif (negative) {\\nbuf[len++] = '-';\\n}\\nelse if (flags & FLAGS_PLUS) {\\nbuf[len++] = '+';   \\n}\\nelse if (flags & FLAGS_SPACE) {\\nbuf[len++] = ' ';\\n}\\n}\\nreturn _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);\\n}\\nstatic size_t _ntoa_long(out_fct_type out, char* buffer, size_t idx, size_t maxlen, unsigned long value, bool negative, unsigned long base, unsigned int prec, unsigned int width, unsigned int flags)\\n{\\nchar buf[PRINTF_NTOA_BUFFER_SIZE];\\nsize_t len = 0U;\\nif (!value) {\\nflags &= ~FLAGS_HASH;\\n}\\nif (!(flags & FLAGS_PRECISION) || value) {\\ndo {\\nconst char digit = (char)(value % base);\\nbuf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;\\nvalue /= base;\\n} while (value && (len < PRINTF_NTOA_BUFFER_SIZE));\\n}\\nreturn _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int)base, prec, width, flags);\\n}\\n#if defined(PRINTF_SUPPORT_LONG_LONG)\\nstatic size_t _ntoa_long_long(out_fct_type out, char* buffer, size_t idx, size_t maxlen, unsigned long long value, bool negative, unsigned long long base, unsigned int prec, unsigned int width, unsigned int flags)\\n{\\nchar buf[PRINTF_NTOA_BUFFER_SIZE];\\nsize_t len = 0U;\\nif (!value) {\\nflags &= ~FLAGS_HASH;\\n}\\nif (!(flags & FLAGS_PRECISION) || value) {\\ndo {\\nconst char digit = (char)(value % base);\\nbuf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;\\nvalue /= base;\\n} while (value && (len < PRINTF_NTOA_BUFFER_SIZE));\\n}\\nreturn _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int)base, prec, width, flags);\\n}\\n#endif   \\n#if defined(PRINTF_SUPPORT_FLOAT)\\n#if defined(PRINTF_SUPPORT_EXPONENTIAL)\\nstatic size_t _etoa(out_fct_type out, char* buffer, size_t idx, size_t maxlen, double value, unsigned int prec, unsigned int width, unsigned int flags);\\n#endif\\nstatic size_t _ftoa(out_fct_type out, char* buffer, size_t idx, size_t maxlen, double value, unsigned int prec, unsigned int width, unsigned int flags)\\n{\\nchar buf[PRINTF_FTOA_BUFFER_SIZE];\\nsize_t len  = 0U;\\ndouble diff = 0.0;\\nstatic const double pow10[] = { 1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000 };\\nif (value != value)\\nreturn _out_rev(out, buffer, idx, maxlen, \\\"nan\\\", 3, width, flags);\\nif (value < -DBL_MAX)\\nreturn _out_rev(out, buffer, idx, maxlen, \\\"fni-\\\", 4, width, flags);\\nif (value > DBL_MAX)\\nreturn _out_rev(out, buffer, idx, maxlen, (flags & FLAGS_PLUS) ? \\\"fni+\\\" : \\\"fni\\\", (flags & FLAGS_PLUS) ? 4U : 3U, width, flags);\\nif ((value > PRINTF_MAX_FLOAT) || (value < -PRINTF_MAX_FLOAT)) {\\n#if defined(PRINTF_SUPPORT_EXPONENTIAL)\\nreturn _etoa(out, buffer, idx, maxlen, value, prec, width, flags);\\n#else\\nreturn 0U;\\n#endif\\n}\\nbool negative = false;\\nif (value < 0) {\\nnegative = true;\\nvalue = 0 - value;\\n}\\nif (!(flags & FLAGS_PRECISION)) {\\nprec = PRINTF_DEFAULT_FLOAT_PRECISION;\\n}\\nwhile ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {\\nbuf[len++] = '0';\\nprec--;\\n}\\nint whole = (int)value;\\ndouble tmp = (value - whole) * pow10[prec];\\nunsigned long frac = (unsigned long)tmp;\\ndiff = tmp - frac;\\nif (diff > 0.5) {\\n++frac;\\nif (frac >= pow10[prec]) {\\nfrac = 0;\\n++whole;\\n}\\n}\\nelse if (diff < 0.5) {\\n}\\nelse if ((frac == 0U) || (frac & 1U)) {\\n++frac;\\n}\\nif (prec == 0U) {\\ndiff = value - (double)whole;\\nif ((!(diff < 0.5) || (diff > 0.5)) && (whole & 1)) {\\n++whole;\\n}\\n}\\nelse {\\nunsigned int count = prec;\\nwhile (len < PRINTF_FTOA_BUFFER_SIZE) {\\n--count;\\nbuf[len++] = (char)(48U + (frac % 10U));\\nif (!(frac /= 10U)) {\\nbreak;\\n}\\n}\\nwhile ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {\\nbuf[len++] = '0';\\n}\\nif (len < PRINTF_FTOA_BUFFER_SIZE) {\\nbuf[len++] = '.';\\n}\\n}\\nwhile (len < PRINTF_FTOA_BUFFER_SIZE) {\\nbuf[len++] = (char)(48 + (whole % 10));\\nif (!(whole /= 10)) {\\nbreak;\\n}\\n}\\nif (!(flags & FLAGS_LEFT) && (flags & FLAGS_ZEROPAD)) {\\nif (width && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {\\nwidth--;\\n}\\nwhile ((len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {\\nbuf[len++] = '0';\\n}\\n}\\nif (len < PRINTF_FTOA_BUFFER_SIZE) {\\nif (negative) {\\nbuf[len++] = '-';\\n}\\nelse if (flags & FLAGS_PLUS) {\\nbuf[len++] = '+';   \\n}\\nelse if (flags & FLAGS_SPACE) {\\nbuf[len++] = ' ';\\n}\\n}\\nreturn _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);\\n}\\n#if defined(PRINTF_SUPPORT_EXPONENTIAL)\\nstatic size_t _etoa(out_fct_type out, char* buffer, size_t idx, size_t maxlen, double value, unsigned int prec, unsigned int width, unsigned int flags)\\n{\\nif ((value != value) || (value > DBL_MAX) || (value < -DBL_MAX)) {\\nreturn _ftoa(out, buffer, idx, maxlen, value, prec, width, flags);\\n}\\nconst bool negative = value < 0;\\nif (negative) {\\nvalue = -value;\\n}\\nif (!(flags & FLAGS_PRECISION)) {\\nprec = PRINTF_DEFAULT_FLOAT_PRECISION;\\n}\\nunion {\\nuint64_t U;\\ndouble   F;\\n} conv;\\nconv.F = value;\\nint exp2 = (int)((conv.U >> 52U) & 0x07FFU) - 1023;            \\nconv.U = (conv.U & ((1ULL << 52U) - 1U)) | (1023ULL << 52U);   \\nint expval = (int)(0.1760912590558 + exp2 * 0.301029995663981 + (conv.F - 1.5) * 0.289529654602168);\\nexp2 = (int)(expval * 3.321928094887362 + 0.5);\\nconst double z  = expval * 2.302585092994046 - exp2 * 0.6931471805599453;\\nconst double z2 = z * z;\\nconv.U = (uint64_t)(exp2 + 1023) << 52U;\\nconv.F *= 1 + 2 * z / (2 - z + (z2 / (6 + (z2 / (10 + z2 / 14)))));\\nif (value < conv.F) {\\nexpval--;\\nconv.F /= 10;\\n}\\nunsigned int minwidth = ((expval < 100) && (expval > -100)) ? 4U : 5U;\\nif (flags & FLAGS_ADAPT_EXP) {\\nif ((value >= 1e-4) && (value < 1e6)) {\\nif ((int)prec > expval) {\\nprec = (unsigned)((int)prec - expval - 1);\\n}\\nelse {\\nprec = 0;\\n}\\nflags |= FLAGS_PRECISION;    \\nminwidth = 0U;\\nexpval   = 0;\\n}\\nelse {\\nif ((prec > 0) && (flags & FLAGS_PRECISION)) {\\n--prec;\\n}\\n}\\n}\\nunsigned int fwidth = width;\\nif (width > minwidth) {\\nfwidth -= minwidth;\\n} else {\\nfwidth = 0U;\\n}\\nif ((flags & FLAGS_LEFT) && minwidth) {\\nfwidth = 0U;\\n}\\nif (expval) {\\nvalue /= conv.F;\\n}\\nconst size_t start_idx = idx;\\nidx = _ftoa(out, buffer, idx, maxlen, negative ? -value : value, prec, fwidth, flags & ~FLAGS_ADAPT_EXP);\\nif (minwidth) {\\nout((flags & FLAGS_UPPERCASE) ? 'E' : 'e', buffer, idx++, maxlen);\\nidx = _ntoa_long(out, buffer, idx, maxlen, (expval < 0) ? -expval : expval, expval < 0, 10, 0, minwidth-1, FLAGS_ZEROPAD | FLAGS_PLUS);\\nif (flags & FLAGS_LEFT) {\\nwhile (idx - start_idx < width) out(' ', buffer, idx++, maxlen);\\n}\\n}\\nreturn idx;\\n}\\n#endif   \\n#endif   \\nstatic int _vsnprintf(out_fct_type out, char* buffer, const size_t maxlen, const char* format, va_list va)\\n{\\nunsigned int flags, width, precision, n;\\nsize_t idx = 0U;\\nif (!buffer) {\\nout = _out_null;\\n}\\nwhile (*format)\\n{\\nif (*format != '%') {\\nout(*format, buffer, idx++, maxlen);\\nformat++;\\ncontinue;\\n}\\nelse {\\nformat++;\\n}\\nflags = 0U;\\ndo {\\nswitch (*format) {\\ncase '0': flags |= FLAGS_ZEROPAD; format++; n = 1U; break;\\ncase '-': flags |= FLAGS_LEFT;    format++; n = 1U; break;\\ncase '+': flags |= FLAGS_PLUS;    format++; n = 1U; break;\\ncase ' ': flags |= FLAGS_SPACE;   format++; n = 1U; break;\\ncase '#': flags |= FLAGS_HASH;    format++; n = 1U; break;\\ndefault :                                   n = 0U; break;\\n}\\n} while (n);\\nwidth = 0U;\\nif (_is_digit(*format)) {\\nwidth = _atoi(&format);\\n}\\nelse if (*format == '*') {\\nconst int w = va_arg(va, int);\\nif (w < 0) {\\nflags |= FLAGS_LEFT;     \\nwidth = (unsigned int)-w;\\n}\\nelse {\\nwidth = (unsigned int)w;\\n}\\nformat++;\\n}\\nprecision = 0U;\\nif (*format == '.') {\\nflags |= FLAGS_PRECISION;\\nformat++;\\nif (_is_digit(*format)) {\\nprecision = _atoi(&format);\\n}\\nelse if (*format == '*') {\\nconst int prec = (int)va_arg(va, int);\\nprecision = prec > 0 ? (unsigned int)prec : 0U;\\nformat++;\\n}\\n}\\nswitch (*format) {\\ncase 'l' :\\nflags |= FLAGS_LONG;\\nformat++;\\nif (*format == 'l') {\\nflags |= FLAGS_LONG_LONG;\\nformat++;\\n}\\nbreak;\\ncase 'h' :\\nflags |= FLAGS_SHORT;\\nformat++;\\nif (*format == 'h') {\\nflags |= FLAGS_CHAR;\\nformat++;\\n}\\nbreak;\\n#if defined(PRINTF_SUPPORT_PTRDIFF_T)\\ncase 't' :\\nflags |= (sizeof(ptrdiff_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);\\nformat++;\\nbreak;\\n#endif\\ncase 'j' :\\nflags |= (sizeof(intmax_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);\\nformat++;\\nbreak;\\ncase 'z' :\\nflags |= (sizeof(size_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);\\nformat++;\\nbreak;\\ndefault :\\nbreak;\\n}\\nswitch (*format) {\\ncase 'd' :\\ncase 'i' :\\ncase 'u' :\\ncase 'x' :\\ncase 'X' :\\ncase 'o' :\\ncase 'b' : {\\nunsigned int base;\\nif (*format == 'x' || *format == 'X') {\\nbase = 16U;\\n}\\nelse if (*format == 'o') {\\nbase =  8U;\\n}\\nelse if (*format == 'b') {\\nbase =  2U;\\n}\\nelse {\\nbase = 10U;\\nflags &= ~FLAGS_HASH;    \\n}\\nif (*format == 'X') {\\nflags |= FLAGS_UPPERCASE;\\n}\\nif ((*format != 'i') && (*format != 'd')) {\\nflags &= ~(FLAGS_PLUS | FLAGS_SPACE);\\n}\\nif (flags & FLAGS_PRECISION) {\\nflags &= ~FLAGS_ZEROPAD;\\n}\\nif ((*format == 'i') || (*format == 'd')) {\\nif (flags & FLAGS_LONG_LONG) {\\n#if defined(PRINTF_SUPPORT_LONG_LONG)\\nconst long long value = va_arg(va, long long);\\nidx = _ntoa_long_long(out, buffer, idx, maxlen, (unsigned long long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);\\n#endif\\n}\\nelse if (flags & FLAGS_LONG) {\\nconst long value = va_arg(va, long);\\nidx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);\\n}\\nelse {\\nconst int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);\\nidx = _ntoa_long(out, buffer, idx, maxlen, (unsigned int)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);\\n}\\n}\\nelse {\\nif (flags & FLAGS_LONG_LONG) {\\n#if defined(PRINTF_SUPPORT_LONG_LONG)\\nidx = _ntoa_long_long(out, buffer, idx, maxlen, va_arg(va, unsigned long long), false, base, precision, width, flags);\\n#endif\\n}\\nelse if (flags & FLAGS_LONG) {\\nidx = _ntoa_long(out, buffer, idx, maxlen, va_arg(va, unsigned long), false, base, precision, width, flags);\\n}\\nelse {\\nconst unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);\\nidx = _ntoa_long(out, buffer, idx, maxlen, value, false, base, precision, width, flags);\\n}\\n}\\nformat++;\\nbreak;\\n}\\n#if defined(PRINTF_SUPPORT_FLOAT)\\ncase 'f' :\\ncase 'F' :\\nif (*format == 'F') flags |= FLAGS_UPPERCASE;\\nidx = _ftoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);\\nformat++;\\nbreak;\\n#if defined(PRINTF_SUPPORT_EXPONENTIAL)\\ncase 'e':\\ncase 'E':\\ncase 'g':\\ncase 'G':\\nif ((*format == 'g')||(*format == 'G')) flags |= FLAGS_ADAPT_EXP;\\nif ((*format == 'E')||(*format == 'G')) flags |= FLAGS_UPPERCASE;\\nidx = _etoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);\\nformat++;\\nbreak;\\n#endif   \\n#endif   \\ncase 'c' : {\\nunsigned int l = 1U;\\nif (!(flags & FLAGS_LEFT)) {\\nwhile (l++ < width) {\\nout(' ', buffer, idx++, maxlen);\\n}\\n}\\nout((char)va_arg(va, int), buffer, idx++, maxlen);\\nif (flags & FLAGS_LEFT) {\\nwhile (l++ < width) {\\nout(' ', buffer, idx++, maxlen);\\n}\\n}\\nformat++;\\nbreak;\\n}\\ncase 's' : {\\nconst char* p = va_arg(va, char*);\\nunsigned int l = _strnlen_s(p, precision ? precision : (size_t)-1);\\nif (flags & FLAGS_PRECISION) {\\nl = (l < precision ? l : precision);\\n}\\nif (!(flags & FLAGS_LEFT)) {\\nwhile (l++ < width) {\\nout(' ', buffer, idx++, maxlen);\\n}\\n}\\nwhile ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {\\nout(*(p++), buffer, idx++, maxlen);\\n}\\nif (flags & FLAGS_LEFT) {\\nwhile (l++ < width) {\\nout(' ', buffer, idx++, maxlen);\\n}\\n}\\nformat++;\\nbreak;\\n}\\ncase 'p' : {\\nwidth = sizeof(void*) * 2U;\\nflags |= FLAGS_ZEROPAD | FLAGS_UPPERCASE;\\n#if defined(PRINTF_SUPPORT_LONG_LONG)\\nconst bool is_ll = sizeof(uintptr_t) == sizeof(long long);\\nif (is_ll) {\\nidx = _ntoa_long_long(out, buffer, idx, maxlen, (uintptr_t)va_arg(va, void*), false, 16U, precision, width, flags);\\n}\\nelse {\\n#endif\\nidx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)((uintptr_t)va_arg(va, void*)), false, 16U, precision, width, flags);\\n#if defined(PRINTF_SUPPORT_LONG_LONG)\\n}\\n#endif\\nformat++;\\nbreak;\\n}\\ncase '%' :\\nout('%', buffer, idx++, maxlen);\\nformat++;\\nbreak;\\ndefault :\\nout(*format, buffer, idx++, maxlen);\\nformat++;\\nbreak;\\n}\\n}\\nout((char)0, buffer, idx < maxlen ? idx : maxlen - 1U, maxlen);\\nreturn (int)idx;\\n}\\nint printf_(const char* format, ...)\\n{\\nva_list va;\\nva_start(va, format);\\nchar buffer[1];\\nconst int ret = _vsnprintf(_out_char, buffer, (size_t)-1, format, va);\\nva_end(va);\\nreturn ret;\\n}\\nint sprintf_(char* buffer, const char* format, ...)\\n{\\nva_list va;\\nva_start(va, format);\\nconst int ret = _vsnprintf(_out_buffer, buffer, (size_t)-1, format, va);\\nva_end(va);\\nreturn ret;\\n}\\nint snprintf_(char* buffer, size_t count, const char* format, ...)\\n{\\nva_list va;\\nva_start(va, format);\\nconst int ret = _vsnprintf(_out_buffer, buffer, count, format, va);\\nva_end(va);\\nreturn ret;\\n}\\nint vprintf_(const char* format, va_list va)\\n{\\nchar buffer[1];\\nreturn _vsnprintf(_out_char, buffer, (size_t)-1, format, va);\\n}\\nint vsnprintf_(char* buffer, size_t count, const char* format, va_list va)\\n{\\nreturn _vsnprintf(_out_buffer, buffer, count, format, va);\\n}\\nint fctprintf(void (*out)(char character, void* arg), void* arg, const char* format, ...)\\n{\\nva_list va;\\nva_start(va, format);\\nconst out_fct_wrap_type out_fct_wrap = { out, arg };\\nconst int ret = _vsnprintf(_out_fct, (char*)(uintptr_t)&out_fct_wrap, (size_t)-1, format, va);\\nva_end(va);\\nreturn ret;\\n}\\n#include <stdio.h>\\n#ifdef FILES\\nstatic void _fprintf_out(char character, void* arg) {\\nfputc(character, (FILE*) arg);\\n}\\nint fprintf(FILE *stream, const char *format, ...) {\\nva_list va;\\nva_start(va, format);\\nconst out_fct_wrap_type out_fct_wrap = { _fprintf_out, stream};\\nconst int ret = _vsnprintf(_out_fct, (char*)(uintptr_t)&out_fct_wrap, (size_t)-1, format, va);\\nva_end(va);\\nreturn ret;\\n}\\n#endif\\n\",\"libraries/printf/printf.h\":\"#include <stdio.h>\\n#define _putchar putchar\\n#define printf_ printf\\n#define sprintf_ sprintf\\n#define snprintf_ snprintf\\n#define vprintf_ vprintf\\n#define vsnprintf_ vsnprintf\\n\",\"limits.h\":\"#pragma once\\n#define CHAR_BIT 8\\n#define CHAR_MAX 255\\n#define CHAR_MIN 0\\n#define INT_MAX 2147483647\\n#define INT_MIN -2147483648\\n#define LONG_MAX 9223372036854775807\\n#define LONG_MIN -9223372036854775808\\n#define LLONG_MAX 9223372036854775807\\n#define LLONG_MIN -9223372036854775808\\n#define SCHAR_MAX 127\\n#define SCHAR_MIN -128\\n#define SHRT_MAX 32767\\n#define SHRT_MIN -32768\\n#define UCHAR_MAX 255\\n#define USHRT_MAX 65535\\n#define UINT_MAX 4294967295\\n#define ULONG_MAX 18446744073709551615\\n#define ULLONG_MAX 18446744073709551615\\n\",\"math.h\":\"#pragma once\\ndouble sqrt(double);\\ndouble ceil(double);\\ndouble fabs(double);\\ndouble floor(double);\\ndouble fmax(double, double);\\ndouble fmin(double, double);\\ndouble trunc(double);\\ndouble copysign(double, double);\\ndouble round(double);  \\ndouble exp(double);\\n#define INFINITY (1./0)\\n#define NAN (0./0)\\n\",\"stdarg.h\":\"#pragma once\\ntypedef char *va_list;\\n#define va_start(ap, parmN) ( ap = (char*) __wasm_ssp__() )\\n#define va_arg(ap, T) ( ap -= 8, *((T*) __wasm_rload__((T *) ap)) )\\n#define va_copy(dst, src) ( dst = src )\\n#define va_end(ap) \\\"va_end\\\"\\n\",\"stdbool.h\":\"#pragma once\\n#define __bool_true_false_are_defined 1\\n#define bool _Bool\\n#define false 0\\n#define true 1\\n\",\"stddef.h\":\"#pragma once\\n#define NULL ((void *) 0)\\n#define offsetof(st, m) ((size_t)&(((st *)0)->m))\\n#ifndef __type_size\\n#define __type_size\\ntypedef unsigned int size_t;\\n#endif\\n#ifndef __type_ptrdiff\\n#define __type_ptrdiff\\ntypedef signed long ptrdiff_t;\\n#endif\\n\",\"stdint.h\":\"#pragma once\\n#ifndef __type_int8\\n#define __type_int8\\ntypedef signed char int8_t;\\n#define INT8_MAX 127\\n#define INT8_MIN -128\\n#endif\\n#ifndef __type_uint8\\n#define __type_uint8\\ntypedef unsigned char uint8_t;\\n#define UINT8_MAX 255\\n#endif\\n#ifndef __type_int16\\n#define __type_int16\\ntypedef signed short int16_t;\\n#define INT16_MAX 32767\\n#define INT16_MIN -32768\\n#endif\\n#ifndef __type_uint16\\n#define __type_uint16\\ntypedef unsigned short uint16_t;\\n#define UINT16_MAX 65535\\n#endif\\n#ifndef __type_int32\\n#define __type_int32\\ntypedef signed int int32_t;\\n#define INT32_MAX 2147483647\\n#define INT32_MIN -2147483648\\n#endif\\n#ifndef __type_uint32\\n#define __type_uint32\\ntypedef unsigned int uint32_t;\\n#define UINT32_MAX 4294967295\\n#endif\\n#ifndef __type_int64\\n#define __type_int64\\ntypedef signed long int64_t;\\n#define INT64_MAX 9223372036854775807\\n#define INT64_MIN -9223372036854775808\\n#endif\\n#ifndef __type_uint64\\n#define __type_uint64\\ntypedef unsigned long uint64_t;\\n#define UINT64_MAX 18446744073709551615\\n#endif\\n#ifndef __type_int_least8\\n#define __type_int_least8\\ntypedef signed char int_least8_t;\\n#define INT_LEAST8_MAX 127\\n#define INT_LEAST8_MIN -128\\n#endif\\n#ifndef __type_uint_least8\\n#define __type_uint_least8\\ntypedef unsigned char uint_least8_t;\\n#define UINT_LEAST8_MAX 255\\n#endif\\n#ifndef __type_int_least16\\n#define __type_int_least16\\ntypedef signed short int_least16_t;\\n#define INT_LEAST16_MAX 32767\\n#define INT_LEAST16_MIN -32768\\n#endif\\n#ifndef __type_uint_least16\\n#define __type_uint_least16\\ntypedef unsigned short uint_least16_t;\\n#define UINT_LEAST16_MAX 65535\\n#endif\\n#ifndef __type_int_least32\\n#define __type_int_least32\\ntypedef signed int int_least32_t;\\n#define INT_LEAST32_MAX 2147483647\\n#define INT_LEAST32_MIN -2147483648\\n#endif\\n#ifndef __type_uint_least32\\n#define __type_uint_least32\\ntypedef unsigned int uint_least32_t;\\n#define UINT_LEAST32_MAX 4294967295\\n#endif\\n#ifndef __type_int_least64\\n#define __type_int_least64\\ntypedef signed long int_least64_t;\\n#define INT_LEAST64_MAX 9223372036854775807\\n#define INT_LEAST64_MIN -9223372036854775808\\n#endif\\n#ifndef __type_uint_least64\\n#define __type_uint_least64\\ntypedef unsigned long uint_least64_t;\\n#define UINT_LEAST64_MAX 18446744073709551615\\n#endif\\n#ifndef __type_int_fast8\\n#define __type_int_fast8\\ntypedef signed int int_fast8_t;\\n#define INT_FAST8_MAX 2147483647\\n#define INT_FAST8_MIN -2147483648\\n#endif\\n#ifndef __type_uint_fast8\\n#define __type_uint_fast8\\ntypedef unsigned int uint_fast8_t;\\n#define UINT_FAST8_MAX 4294967295\\n#endif\\n#ifndef __type_int_fast16\\n#define __type_int_fast16\\ntypedef signed int int_fast16_t;\\n#define INT_FAST16_MAX 2147483647\\n#define INT_FAST16_MIN -2147483648\\n#endif\\n#ifndef __type_uint_fast16\\n#define __type_uint_fast16\\ntypedef unsigned int uint_fast16_t;\\n#define UINT_FAST16_MAX 4294967295\\n#endif\\n#ifndef __type_int_fast32\\n#define __type_int_fast32\\ntypedef signed int int_fast32_t;\\n#define INT_FAST32_MAX 2147483647\\n#define INT_FAST32_MIN -2147483648\\n#endif\\n#ifndef __type_uint_fast32\\n#define __type_uint_fast32\\ntypedef unsigned int uint_fast32_t;\\n#define UINT_FAST32_MAX 4294967295\\n#endif\\n#ifndef __type_int_fast64\\n#define __type_int_fast64\\ntypedef signed long int_fast64_t;\\n#define INT_FAST64_MAX 9223372036854775807\\n#define INT_FAST64_MIN -9223372036854775808\\n#endif\\n#ifndef __type_uint_fast64\\n#define __type_uint_fast64\\ntypedef unsigned long uint_fast64_t;\\n#define UINT_FAST64_MAX 18446744073709551615\\n#endif\\n#ifndef __type_intptr\\n#define __type_intptr\\ntypedef signed int intptr_t;\\n#define INTPTR_MAX 2147483647\\n#define INTPTR_MIN -2147483648\\n#endif\\n#ifndef __type_uintptr\\n#define __type_uintptr\\ntypedef unsigned int uintptr_t;\\n#define UINTPTR_MAX 4294967295\\n#endif\\n#ifndef __type_intmax\\n#define __type_intmax\\ntypedef signed int intmax_t;\\n#define INTMAX_MAX 9223372036854775807\\n#define INTMAX_MIN -9223372036854775808\\n#endif\\n#ifndef __type_uintmax\\n#define __type_uintmax\\ntypedef unsigned int uintmax_t;\\n#define UINTMAX_MAX 18446744073709551615\\n#endif\\n\",\"stdio.h\":\"#pragma once\\n#include <stddef.h>\\n#include <stdarg.h>\\nint printf(const char* format, ...);\\nint sprintf(char* buffer, const char* format, ...);\\nint snprintf(char* buffer, size_t count, const char* format, ...);\\nint vsnprintf(char* buffer, size_t count, const char* format, va_list va);\\nint vprintf(const char* format, va_list va);\\nint fctprintf(void (*out)(char character, void* arg), void* arg, const char* format, ...);\\nint putchar(int chr);\\nint puts(const char *s);\\n#ifndef FILES\\nimport void __put_char(char);\\n#else\\nimport int __get_char(int handle);\\nimport int __put_char(int handle, int c);\\nimport long __get_pos(int handle);\\nimport long __get_len(int handle);\\nimport int __set_pos(int handle, long pos);\\nimport int __exists();\\nimport int __move();\\nimport int __get_fhandle();\\ntypedef struct __stdio_file {\\nint handle, unget, len, flags;\\n_Bool error, eof;\\n} FILE;\\ntypedef long fpos_t;\\nFILE *fopen(const char *filename, const char *mode);\\nFILE *freopen(const char *filename, const char *mode, FILE* stream);\\nint fflush(FILE* stream);\\nint fclose(FILE* stream);\\nint remove(const char *filename);\\nint rename(const char *oldname, const char *newname);\\nchar *tmpnam(char *s);\\nFILE *tmpfile(void);\\nint setvbuf(FILE *stream, char *buf, int mode, size_t size);\\nvoid setbuf(FILE *stream, char *buf);\\nint fprintf(FILE *stream, const char *format, ...);\\nint vfscanf(FILE *stream, const char *fmt, va_list ap);\\nint fscanf(FILE *stream, const char *fmt, ...);\\nint sscanf(char *s, const char *fmt, ...);\\nint scanf(const char *fmt, ...);\\nint fgetc(FILE *stream);\\nchar *fgets(char *s, int n, FILE *stream);\\nint fputc(int c, FILE *stream);\\nint fputs(const char *s, FILE *stream);\\n#define getc(s) fgetc(s)\\nint getchar(void);\\nchar *gets(char *s);\\n#define putc(c, s) fputc(c, s)\\nint putchar(int c);\\nint puts(const char *s);\\nint ungetc(int c, FILE *stream);\\nsize_t fread(void *ptr, size_t size, size_t nobj, FILE *stream);\\nsize_t fwrite(const void *ptr, size_t size, size_t nobj, FILE* stream);\\nint fseek(FILE *stream, long offset, int origin);\\nlong ftell(FILE *stream);\\nvoid rewind(FILE *stream);\\nint fgetpos(FILE *stream, fpos_t *ptr);\\nint fsetpos(FILE *stream, const fpos_t *ptr);\\nvoid clearerr(FILE *stream);\\nint feof(FILE *stream);\\nint ferror(FILE *stream);\\nvoid perror(const char *s);\\n#define EOF -1\\n#define BUFSIZ 16\\n#define FILENAME_MAX 2048\\n#define FOPEN_MAX 1073741824\\n#define _IONBF 0\\n#define _IOLBF 1\\n#define _IOFBF 2\\n#define L_tmpnam 32\\n#define SEEK_SET 0\\n#define SEEK_CUR 1\\n#define SEEK_END 2\\n#define TMP_MAX 1073741824\\nextern FILE *stdin, *stdout, *stderr;\\n#endif\\n\",\"stdlib.h\":\"#pragma once\\n#include <stddef.h>\\n#include <stdarg.h>\\nvoid* malloc(size_t size);\\nvoid free(void* ptr);\\nvoid* realloc(void* ptr, size_t size);\\nvoid* calloc(size_t nobj, size_t size);\\nvoid abort(void);\\nvoid exit(int code);\\nint atexit(void (*fcn)(void));\\nint system(const char *s);\\nchar *getenv(const char *name);\\ndouble strtod(const char *s, char **endp);\\nlong strtol(const char *s, char **endp, int base);\\nunsigned long strtoul(const char *s, char **endp, int base);\\nvoid *bsearch(const void * key, const void * base, size_t nmemb, size_t size, int (*cmp)(const void *, const void *));\\nvoid qsort(void * base, size_t nmemb, size_t size, int (*cmp)(const void *, const void *));\\ntypedef struct __sdiv_t{\\nint quot, rem;\\n} div_t;\\ntypedef struct __ldiv_t {\\nlong quot, rem;\\n} ldiv_t;\\ndouble atof(const char *s);\\nint atoi(const char *s);\\nint atol(const char *s);\\nint abs(int n);\\nint labs(long n);\\ndiv_t div(int num, int denom);\\nldiv_t ldiv(long num, long denom);\\n\",\"string.h\":\"#pragma once\\n#include <stddef.h>\\nchar* strcpy(char* s1, const char* s2);\\nchar* strncpy(char* s1, const char* s2, size_t n);\\nchar* strcat(char* s1, const char* s2);\\nchar* strncat(char* s1, const char* s2, size_t n);\\nint strcmp(const char* s1, const char* s2);\\nint strncmp(const char* s1, const char* s2, size_t n);\\nchar* strchr(const char* s, int c);\\nchar* strrchr(const char* s, int c);\\nsize_t strspn(const char* s1, const char* s2);\\nsize_t strcspn(const char* s1, const char* s2);\\nchar* strpbrk(const char* s1, const char* s2);\\nchar* strstr(const char* s1, const char* s2);\\nsize_t strlen(const char* s);\\nsize_t strnlen(const char* s, size_t n);\\nchar* strtok(char* s1, const char* s2);\\nvoid* memcpy(void* s1, const void* s2, size_t n);\\nvoid* memmove(void* s1, const void* s2, size_t n);\\nint memcmp(const void* s1, const void* s2, size_t n);\\nvoid* memchr(const void* s, int c, size_t n);\\nvoid* memset(void* s, int c, size_t n);\\n\",\"strings.h\":\"#pragma once\\n#include <stddef.h>\\n#include <string.h>\\nint strcasecmp(const char *l, const char *r);\\nint strncasecmp(const char *_l, const char *_r, size_t n);\",\"time.h\":\"#pragma once\\n#include <stddef.h>\\nimport double __time();\\ntypedef double clock_t;\\nclock_t clock();\\n#define CLOCKS_PER_SEC 1000\\n\",\"wasm/f32.h\":\"#pragma once\\n#define f32_abs(x)          (__wasm_f32__(1, (float) x, 0x8B))\\n#define f32_neg(x)          (__wasm_f32__(1, (float) x, 0x8C))\\n#define f32_ceil(x)         (__wasm_f32__(1, (float) x, 0x8D))\\n#define f32_floor(x)        (__wasm_f32__(1, (float) x, 0x8E))\\n#define f32_trunc(x)        (__wasm_f32__(1, (float) x, 0x8F))\\n#define f32_nearest(x)      (__wasm_f32__(1, (float) x, 0x90))\\n#define f32_sqrt(x)         (__wasm_f32__(1, (float) x, 0x91))\\n#define f32_min(x,y)        (__wasm_f32__(2, (float) x, (float) y, 0x96))\\n#define f32_max(x,y)        (__wasm_f32__(2, (float) x, (float) y, 0x97))\\n#define f32_copysign(x,y)   (__wasm_f32__(2, (float) x, (float) y, 0x98))\\n\",\"wasm/f64.h\":\"#pragma once\\n#define f64_abs(x)          (__wasm_f64__(1, (double) x, 0x99))\\n#define f64_neg(x)          (__wasm_f64__(1, (double) x, 0x9A))\\n#define f64_ceil(x)         (__wasm_f64__(1, (double) x, 0x9B))\\n#define f64_floor(x)        (__wasm_f64__(1, (double) x, 0x9C))\\n#define f64_trunc(x)        (__wasm_f64__(1, (double) x, 0x9D))\\n#define f64_nearest(x)      (__wasm_f64__(1, (double) x, 0x9E))\\n#define f64_sqrt(x)         (__wasm_f64__(1, (double) x, 0x9F))\\n#define f64_min(x,y)        (__wasm_f64__(2, (double) x, (double) y, 0xA4))\\n#define f64_max(x,y)        (__wasm_f64__(2, (double) x, (double) y, 0xA5))\\n#define f64_copysign(x,y)   (__wasm_f64__(2, (double) x, (double) y, 0xA6))\\n\"}"),n=new Map(Object.entries(e)),i=(()=>{const e=new Map;for(const[t,i]of n.entries())t.endsWith(".h")&&e.set(t,i);return e})(),s={generation_try_constant_expr:!0,generation_zero_shadow_stack:!1,generation_switch_br_table:!1,peephole_local_tee:!0,peephole_i32_constants_ops:!0,peephole_constants_add_mul:!0,peephole_add_0:!0,peephole_combine_adds:!0,peephole_load_offset:!0,peephole_constant_if:!0,peephole_unused_blocks:!0,partial_redundancy_elimination:!0,copy_propagation:!0,live_range_splitting:!0,dead_code_elimination:!0,reallocate_locals:!0,unused_locals:!0,peephole_2nd_pass:!0,inlining:!1};let r=s;function o(e){"object"==typeof e?r={...r,...e}:"default"===e?r=s:"none"===e&&(r={...r,...Object.fromEntries(Object.keys(s).map((e=>[e,!1])))}),r.reallocate_locals&&!r.copy_propagation&&(r={...r,copy_propagation:!0})}function a(){return{...r}}function c(e){const n=new ArrayBuffer(4);return new DataView(n).setFloat32(0,e,!0),[...new Uint8Array(n)]}function l(e){const n=new ArrayBuffer(8);return new DataView(n).setFloat64(0,e,!0),[...new Uint8Array(n)]}function f(e){if(e>2n**32n-1n||e<0n)throw new Error(`Value ${e} outside of range for u32`);return function(e){const n=[];for(;;){const t=Number(0x7fn&e);if(0n===(e>>=7n))return n.push(t),n;n.push(128|t)}}(e)}function u(e){if("number"==typeof e&&(e=BigInt(e)),e<2n**32n&&e>2n**31n-1n)e-=2n**32n;else if(e>2n**31n-1n||e<-(2n**31n))throw new Error(`Value ${e} outside of range for 32bit uninterpreted int`);return _(e)}function d(e){if(e<2n**64n&&e>2n**63n-1n)e-=2n**64n;else if(e>2n**63n-1n||e<-(2n**63n))throw new Error(`Value ${e} outside of range for 64bit uninterpreted int`);return _(e)}function h(e,n){if(n===m)return[65,...u(e)];if(n===y&&"bigint"==typeof e)return[66,...d(e)];if(n===g&&"number"==typeof e)return[67,...c(e)];if(n===b&&"number"==typeof e)return[68,...l(e)];throw new Error(`Invalid value type (${n.toString(16)}) or initial value (${e})`)}function p(e){const n=[];for(let t=0,i=0,s=0;s<e.length;){if(t=e.charCodeAt(s++),t>=55296&&t<=56319){if(s===e.length){n.push(239,191,189);break}if(i=e.charCodeAt(s),!(i>=56320&&i<=57343)){n.push(239,191,189);continue}if(t=1024*(t-55296)+i-56320+65536,s+=1,t>65535){n.push(240|t>>>18,128|t>>>12&63,128|t>>>6&63,128|63&t);continue}}t<=127?n.push(0|t):t<=2047?n.push(192|t>>>6,128|63&t):n.push(224|t>>>12,128|t>>>6&63,128|63&t)}return n.unshift(...f(BigInt(n.length))),n}function _(e){const n=[];for(;;){const t=Number(0x7fn&e);if(0n===(e>>=7n)&&0==(64&t)||-1n===e&&0!=(64&t))return n.push(t),n;n.push(128|t)}}const m=127,y=126,g=125,b=124;function w(e){return C(e.map((e=>[e])))}function v(e){return[96,...w(e[0]),...w(e[1])]}function x(e){return void 0===e[1]?[0,...f(e[0])]:[1,...f(e[0]),...f(e[1])]}function C(e){return[...f(BigInt(e.length)),...e.flat()]}function L(e,n,t,i,s=[],r=[]){const o={name:e,type:"zeroArg",immediate:{},encoded:n,parameters:t,result:i,reads:s,writes:r,copy(){return()=>this}};return()=>()=>o}function E(e,n,t){return()=>i=>{const{parameters:s,result:r,reads:o,writes:a}=t(i);return{name:e,type:"zeroArg",immediate:{},encoded:n,parameters:s,result:r,reads:o,writes:a,copy(){return()=>this}}}}function I(e,n,t,i,s){return r=>()=>({name:e,type:"constant",immediate:{value:i(r)},encoded:[...n,...t(r)],parameters:[],result:s,reads:[],writes:[],copy(){return()=>this}})}function A(e,n,t,i){return(s,r)=>{"number"==typeof s&&(s=BigInt(s)),"number"==typeof r&&(r=BigInt(r));const o=[...n,...f(s),...f(r)],a={align:s,offset:r};return()=>({name:e,encoded:o,type:"memory",immediate:a,parameters:"load"===t?[m]:[m,i],result:"load"===t?i:null,reads:"load"===t?["memory"]:[],writes:"load"===t?[]:["memory"],copy(){return()=>this}})}}function S(e,n){let t;return t="number"==typeof e?BigInt(e):"bigint"==typeof e?e:e.getIndex(n),t}function T(e,n,t,i){return(s,...r)=>o=>{const a=S(s,o.depth),c=[...n,...f(a),...t],{parameters:l,result:u,reads:d,writes:h}=i({value:a,extra:r,...o});return{name:e,encoded:c,type:"index",immediate:{value:a},parameters:l,result:u,reads:d,writes:h,copy(){return()=>this}}}}function F(e){return null===e?[64]:[e]}function N(e,n){const t=(i,s,r)=>o=>{r&&r(o);const a={name:n,type:"structured",parameters:[],result:i,get encoded(){return[e,...F(i),...c.encoded]},get immediate(){return{type:i,expression:c,expression2:void 0}},get reads(){return c.reads},get writes(){return c.writes},copy:()=>e=>{const n=t(i,[])(e);return c.copyInto(n.immediate.expression),n}},c=new WExpression(a,o.depth+1,o.builder);return c.push(...s),a};return t}class WExpression{constructor(e,n,t){this.parent=e,this.depth=n,this.builder=t,this._stack=[],this._instructions=[]}push(...e){for(const n of e)this._instructions.push(this.createInstr(n,this._stack))}get(e){return e<0&&(e+=this.instructions.length),this._instructions[e]}pop(){const e=this._instructions.pop();if(e)return e.result&&this._stack.pop(),this._stack.push(...e.parameters),e}replace(e,n,...t){if(e<0||n<e||e>this._instructions.length)throw new Error("Invalid replacement indices");const i=[],s=this._instructions.slice(0,e);s.forEach((e=>this.stackManipulation(e,i))),t.forEach((e=>s.push(this.createInstr(e,i))));try{for(let e,t=n;t<this._instructions.length;t++)this.stackManipulation(e=this._instructions[t],i),s.push(e);if(this._stack.length!==i.length||this._stack.some(((e,n)=>e!==i[n])))throw new Error("Stack different");this._instructions=s}catch(e){throw new Error(`Invalid replacement due to: \n\n${e.stack}\n`)}}copyInto(e){for(const n of this.instructions)e.push(n.copy())}*instructionsRecursive(){for(const e of this.instructions)yield e,"structured"===e.type&&(yield*e.immediate.expression.instructionsRecursive(),e.immediate.expression2&&(yield*e.immediate.expression2.instructionsRecursive()))}stackManipulation(e,n){for(let t=e.parameters.length-1;t>=0;t--)if(e.parameters[t]!==n.pop())throw new Error(`Stack does not match Wasm instruction (${e.name}) parameters\nPrevious instructions: ${this._instructions.map((e=>e.name)).reverse().join(", ")}`);e.result&&n.push(e.result)}createInstr(e,n){return"function"==typeof e&&(e=e({depth:this.depth,builder:this.builder,stack:n})),this.stackManipulation(e,n),e}get instructions(){return this._instructions}get stack(){return this._stack}get encoded(){const e=this._instructions.flatMap((e=>e.encoded));return e.push(11),e}get reads(){const e=this._instructions.flatMap((e=>e.reads));return[...new Set(e)]}get writes(){const e=this._instructions.flatMap((e=>e.writes));return[...new Set(e)]}}const k={unreachable:L("unreachable",[0],[],null),nop:L("nop",[1],[],null),block:N(2,"block"),loop:N(3,"loop"),if:function(e,n){const t=(i,s,r,o)=>a=>{o&&o(a);const c={name:"if",type:"structured",parameters:[m],result:i,get encoded(){const t=[e,...F(i),...l.encoded];return f&&(t.pop(),t.push(n,...f.encoded)),t},get immediate(){return{type:i,expression:l,expression2:f}},get reads(){return f?[...new Set([...l.reads,...f.reads])]:l.reads},get writes(){return f?[...new Set([...l.writes,...f.writes])]:l.writes},copy:()=>e=>{const n=t(i,[],f?[]:void 0)(e);return l.copyInto(n.immediate.expression),f&&f.copyInto(n.immediate.expression2),n}},l=new WExpression(c,a.depth+1,a.builder);let f;return l.push(...s),r&&(f=new WExpression(c,a.depth+1,a.builder),f.push(...r)),c};return t}(4,5),br:T("br",[12],[],(({extra:e})=>({parameters:e,result:null,reads:[],writes:["jump"]}))),br_if:T("br_if",[13],[],(()=>({parameters:[],result:null,reads:[],writes:["jump"]}))),br_table:(O=14,(e,n)=>t=>{const i=S(e,t.depth),s=n.map((e=>S(e,t.depth)));return{name:"br_table",encoded:[O,...C(s.map(f)),...f(i)],type:"table",immediate:{defaultValue:i,valueTable:s},parameters:[m],result:null,reads:[],writes:["jump"],copy(){return()=>this}}}),return:E("return",[15],(({builder:e})=>({parameters:e.type[1],result:null,reads:[],writes:["jump"]}))),call:T("call",[16],[],(({builder:e,value:n})=>{const t=e.fn.parent._functionLookup(n);return{parameters:t.type[0],result:t.type[1][0]??null,reads:[],writes:["jump","memory"]}})),call_indirect:T("call_indirect",[17],[0],(({builder:e,value:n})=>{const t=e.fn.parent._typeLookup(n);return{parameters:[...t[0],m],result:t[1][0]??null,reads:[],writes:["jump","memory"]}})),drop:E("drop",[26],(({stack:e})=>{if(e.length<=0)throw new Error("Drop on empty stack");return{parameters:[e[e.length-1]],result:null,reads:[],writes:[]}})),local:{get:T("local.get",[32],[],(({builder:e,value:n})=>{const t=e.getLocal(n);return{parameters:[],result:t.type,reads:[t],writes:[]}})),set:T("local.set",[33],[],(({builder:e,value:n})=>{const t=e.getLocal(n);return{parameters:[t.type],result:null,reads:[],writes:[t]}})),tee:T("local.tee",[34],[],(({builder:e,value:n})=>{const t=e.getLocal(n);return{parameters:[t.type],result:t.type,reads:[],writes:[t]}}))},global:{get:T("global.get",[35],[],(({builder:e,value:n})=>{const t=e.fn.parent._globalLookup(n);return{parameters:[],result:t.type,reads:[t],writes:[]}})),set:T("global.set",[36],[],(({builder:e,value:n})=>{const t=e.fn.parent._globalLookup(n);return{parameters:[t.type],result:null,reads:[],writes:[t]}}))},memory:{size:L("memory.size",[63,0],[],m,["memory"],[]),grow:L("memory.grow",[64,0],[m],m,["memory"],["memory"]),copy:L("memory.copy",[252,10,0,0],[m,m,m],null,["memory"],["memory"]),fill:L("memory.fill",[252,11,0],[m,m,m],null,[],["memory"])},i32:{load:A("i32.load",[40],"load",m),load8_s:A("i32.load8_s",[44],"load",m),load8_u:A("i32.load8_u",[45],"load",m),load16_s:A("i32.load16_s",[46],"load",m),load16_u:A("i32.load16_u",[47],"load",m),store:A("i32.store",[54],"store",m),store8:A("i32.store8",[58],"store",m),store16:A("i32.store16",[59],"store",m),const:I("i32.const",[65],u,BigInt,m),eqz:L("i32.eqz",[69],[m],m),eq:L("i32.eq",[70],[m,m],m),ne:L("i32.ne",[71],[m,m],m),lt_s:L("i32.lt_s",[72],[m,m],m),lt_u:L("i32.lt_u",[73],[m,m],m),gt_s:L("i32.gt_s",[74],[m,m],m),gt_u:L("i32.gt_u",[75],[m,m],m),le_s:L("i32.le_s",[76],[m,m],m),le_u:L("i32.le_u",[77],[m,m],m),ge_s:L("i32.ge_s",[78],[m,m],m),ge_u:L("i32.ge_u",[79],[m,m],m),clz:L("i32.clz",[103],[m],m),ctz:L("i32.ctz",[104],[m],m),popcnt:L("i32.popcnt",[105],[m],m),add:L("i32.add",[106],[m,m],m),sub:L("i32.sub",[107],[m,m],m),mul:L("i32.mul",[108],[m,m],m),div_s:L("i32.div_s",[109],[m,m],m),div_u:L("i32.div_u",[110],[m,m],m),rem_s:L("i32.rem_s",[111],[m,m],m),rem_u:L("i32.rem_u",[112],[m,m],m),and:L("i32.and",[113],[m,m],m),or:L("i32.or",[114],[m,m],m),xor:L("i32.xor",[115],[m,m],m),shl:L("i32.shl",[116],[m,m],m),shr_s:L("i32.shr_s",[117],[m,m],m),shr_u:L("i32.shr_u",[118],[m,m],m),rotl:L("i32.rotl",[119],[m,m],m),rotr:L("i32.rotr",[120],[m,m],m),wrap_i64:L("i32.wrap_i64",[167],[y],m),trunc_f32_s:L("i32.trunc_f32_s",[168],[g],m),trunc_f32_u:L("i32.trunc_f32_u",[169],[g],m),trunc_f64_s:L("i32.trunc_f64_s",[170],[b],m),trunc_f64_u:L("i32.trunc_f64_u",[171],[b],m),reinterpret_f32:L("i32.reinterpret_f32",[188],[g],m),extend8_s:L("i32.extend8_s",[192],[m],m),extend16_s:L("i32.extend16_s",[193],[m],m),trunc_sat_f32_s:L("i32.trunc_sat_f32_s",[252,0],[g],m),trunc_sat_f32_u:L("i32.trunc_sat_f32_u",[252,1],[g],m),trunc_sat_f64_s:L("i32.trunc_sat_f64_s",[252,2],[b],m),trunc_sat_f64_u:L("i32.trunc_sat_f64_u",[252,3],[b],m)},i64:{load:A("i64.load",[41],"load",y),load8_s:A("i64.load8_s",[48],"load",y),load8_u:A("i64.load8_u",[49],"load",y),load16_s:A("i64.load16_s",[50],"load",y),load16_u:A("i64.load16_u",[51],"load",y),load32_s:A("i64.load32_s",[52],"load",y),load32_u:A("i64.load32_u",[53],"load",y),store:A("i64.store",[55],"store",y),store8:A("i64.store8",[60],"store",y),store16:A("i64.store16",[61],"store",y),store32:A("i64.store32",[62],"store",y),const:I("i64.const",[66],d,BigInt,y),eqz:L("i64.eqz",[80],[y],m),eq:L("i64.eq",[81],[y,y],m),ne:L("i64.ne",[82],[y,y],m),lt_s:L("i64.lt_s",[83],[y,y],m),lt_u:L("i64.lt_u",[84],[y,y],m),gt_s:L("i64.gt_s",[85],[y,y],m),gt_u:L("i64.gt_u",[86],[y,y],m),le_s:L("i64.le_s",[87],[y,y],m),le_u:L("i64.le_u",[88],[y,y],m),ge_s:L("i64.ge_s",[89],[y,y],m),ge_u:L("i64.ge_u",[90],[y,y],m),clz:L("i64.clz",[121],[y],y),ctz:L("i64.ctz",[122],[y],y),popcnt:L("i64.popcnt",[123],[y],y),add:L("i64.add",[124],[y,y],y),sub:L("i64.sub",[125],[y,y],y),mul:L("i64.mul",[126],[y,y],y),div_s:L("i64.div_s",[127],[y,y],y),div_u:L("i64.div_u",[128],[y,y],y),rem_s:L("i64.rem_s",[129],[y,y],y),rem_u:L("i64.rem_u",[130],[y,y],y),and:L("i64.and",[131],[y,y],y),or:L("i64.or",[132],[y,y],y),xor:L("i64.xor",[133],[y,y],y),shl:L("i64.shl",[134],[y,y],y),shr_s:L("i64.shr_s",[135],[y,y],y),shr_u:L("i64.shr_u",[136],[y,y],y),rotl:L("i64.rotl",[137],[y,y],y),rotr:L("i64.rotr",[138],[y,y],y),extend_i32_s:L("i64.extend_i32_s",[172],[m],y),extend_i32_u:L("i64.extend_i32_u",[173],[m],y),trunc_f32_s:L("i64.trunc_f32_s",[174],[g],y),trunc_f32_u:L("i64.trunc_f32_u",[175],[g],y),trunc_f64_s:L("i64.trunc_f64_s",[176],[b],y),trunc_f64_u:L("i64.trunc_f64_u",[177],[b],y),reinterpret_f64:L("i64.reinterpret_f64",[189],[b],y),extend8_s:L("i64.extend8_s",[194],[y],y),extend16_s:L("i64.extend16_s",[195],[y],y),extend32_s:L("i64.extend32_s",[196],[y],y),trunc_sat_f32_s:L("i32.trunc_sat_f32_s",[252,4],[g],y),trunc_sat_f32_u:L("i32.trunc_sat_f32_u",[252,5],[g],y),trunc_sat_f64_s:L("i32.trunc_sat_f64_s",[252,6],[b],y),trunc_sat_f64_u:L("i32.trunc_sat_f64_u",[252,7],[b],y)},f32:{load:A("f32.load",[42],"load",g),store:A("f32.store",[56],"store",g),const:I("f32.const",[67],c,Number,g),eq:L("f32.eq",[91],[g,g],m),ne:L("f32.ne",[92],[g,g],m),lt:L("f32.lt",[93],[g,g],m),gt:L("f32.gt",[94],[g,g],m),le:L("f32.le",[95],[g,g],m),ge:L("f32.ge",[96],[g,g],m),abs:L("f32.abs",[139],[g],g),neg:L("f32.neg",[140],[g],g),ceil:L("f32.ceil",[141],[g],g),floor:L("f32.floor",[142],[g],g),trunc:L("f32.trunc",[143],[g],g),nearest:L("f32.nearest",[144],[g],g),sqrt:L("f32.sqrt",[145],[g],g),add:L("f32.add",[146],[g,g],g),sub:L("f32.sub",[147],[g,g],g),mul:L("f32.mul",[148],[g,g],g),div:L("f32.div",[149],[g,g],g),min:L("f32.min",[150],[g,g],g),max:L("f32.max",[151],[g,g],g),copysign:L("f32.copysign",[152],[g,g],g),convert_i32_s:L("f32.convert_i32_s",[178],[m],g),convert_i32_u:L("f32.convert_i32_u",[179],[m],g),convert_i64_s:L("f32.convert_i64_s",[180],[y],g),convert_i64_u:L("f32.convert_i64_u",[181],[y],g),demote_f64:L("f32.demote_f64",[182],[b],g),reinterpret_i32:L("f32.reinterpret_i32",[190],[m],g)},f64:{load:A("f64.load",[43],"load",b),store:A("f64.store",[57],"store",b),const:I("f64.const",[68],l,Number,b),eq:L("f64.eq",[97],[b,b],m),ne:L("f64.ne",[98],[b,b],m),lt:L("f64.lt",[99],[b,b],m),gt:L("f64.gt",[100],[b,b],m),le:L("f64.le",[101],[b,b],m),ge:L("f64.ge",[102],[b,b],m),abs:L("f64.abs",[153],[b],b),neg:L("f64.neg",[154],[b],b),ceil:L("f64.ceil",[155],[b],b),floor:L("f64.floor",[156],[b],b),trunc:L("f64.trunc",[157],[b],b),nearest:L("f64.nearest",[158],[b],b),sqrt:L("f64.sqrt",[159],[b],b),add:L("f64.add",[160],[b,b],b),sub:L("f64.sub",[161],[b,b],b),mul:L("f64.mul",[162],[b,b],b),div:L("f64.div",[163],[b,b],b),min:L("f64.min",[164],[b,b],b),max:L("f64.max",[165],[b,b],b),copysign:L("f64.copysign",[166],[b,b],b),convert_i32_s:L("f64.convert_i32_s",[183],[m],b),convert_i32_u:L("f64.convert_i32_u",[184],[m],b),convert_i64_s:L("f64.convert_i64_s",[185],[y],b),convert_i64_u:L("f64.convert_i64_u",[186],[y],b),promote_f32:L("f64.promote_f32",[187],[g],b),reinterpret_i64:L("f64.reinterpret_i64",[191],[y],b)}};var O;function P(e,n=new Set){const[t,i]=function(e){const n=e.instructions.map((e=>({instr:e,produces:void 0,consumes:[]}))),t=[],i=[];for(const e of n){for(let n=0;n<e.instr.parameters.length;n++){const n=i.pop();n.consumedBy=e,e.consumes.push(n)}null!==e.instr.result&&(e.produces={type:e.instr.result,producedBy:e,index:t.length},i.push(e.produces),t.push(e.produces))}for(const e of i)e.needed=!0;return[n,t]}(e);for(const e of t)e.instr.writes.some((e=>!(e instanceof WLocal)))&&$(e);U(i);for(let e=t.length-1;e>=0;e--){const s=t[e],r=s.instr;if(!s.needed)for(const e of r.writes)if(e instanceof WLocal&&n.has(e)){$(s),U(i);break}if(s.needed){if("structured"===r.type){if("loop"===r.name)for(const e of r.reads)e instanceof WLocal&&n.add(e);if(P(r.immediate.expression,n),r.immediate.expression2&&P(r.immediate.expression2,n),"loop"===r.name)continue}for(const e of r.reads)e instanceof WLocal&&n.add(e)}}if(t.some((e=>!e.needed))){const n=[];for(const e of t)(e.needed||"unreachable"===e.instr.name)&&(n.push(e.instr),e.produces&&!e.produces.needed&&n.push(k.drop()));e.replace(0,e.instructions.length,...n)}}function $(e){e.needed=!0;for(const n of e.consumes)n.needed=!0}function U(e){let n=1;for(;n;){n=0;for(const t of e.filter((e=>e.needed&&!e.producedBy.needed)))$(t.producedBy),n++}}const M=[];function D(e,n,t,i=0){for(let s=0;s<=e.instructions.length-t;s++){const r=n(e.instructions.slice(s,s+t),i);void 0!==r&&e.replace(s,s+t,...r)}for(const s of e.instructions)"structured"===s.type&&(D(s.immediate.expression,n,t,i+1),s.immediate.expression2&&D(s.immediate.expression2,n,t,i+1))}function R(e,n,t=0){const i=n.map((e=>e[1])).reduce(((e,n)=>Math.max(e,n)),1);for(const i of e.instructions)"structured"===i.type&&(R(i.immediate.expression,n,t+1),i.immediate.expression2&&R(i.immediate.expression2,n,t+1));for(let s=0;s<e.instructions.length;s++)for(const[r,o]of n){if(s+o>e.instructions.length)continue;const n=r(e.instructions.slice(s,s+o),t);if(void 0!==n){e.replace(s,s+o,...n),s-=i,s<-1&&(s=-1);break}}}function z(e,n){return n&2n**e-1n}function G(e,n=-1n){if("index"===e.type&&e.name.startsWith("br"))return e.immediate.value===n;if("table"===e.type&&"br_table"===e.name)return e.immediate.defaultValue===n||e.immediate.valueTable.some((e=>e===n));if("structured"!==e.type)return!1;const{expression:t,expression2:i}=e.immediate;return!!t.instructions.some((e=>G(e,n+1n)))||void 0!==i&&i.instructions.some((e=>G(e,n+1n)))}function B(e){const n={type:"entry",instr:void 0,flowPrevious:[],flowNext:[]},t={type:"exit",instr:void 0,flowPrevious:[],flowNext:[]},i=[n,t],s=[];!function e(n,r,o){const a=n.instructions,c=[];for(const[e,t]of a.entries())c.push({instr:t,instrIndex:e,expr:n,type:"instr",flowPrevious:[],flowNext:[]});i.push(...c),c.push(o);for(let n=0;n<a.length;n++){const i=a[n],r=c[n],o=c[n+1];if("structured"===i.type&&"if"===i.name){s.unshift(o);const n=e(i.immediate.expression,r,o),t=i.immediate.expression2&&e(i.immediate.expression2,r,o);if(s.shift(),n&&t)continue}else if("structured"===i.type){s.unshift("loop"===i.name?r:o);const n=e(i.immediate.expression,r,o);if(s.shift(),n)continue}else if("index"===i.type&&i.name.startsWith("br")){const e=s[Number(i.immediate.value)];if(!e)throw new Error("No such target for br?");if(r.flowNext.push(e),"br_if"!==i.name)continue}else{if("table"===i.type&&"br_table"===i.name){for(const e of[i.immediate.defaultValue,...i.immediate.valueTable]){const n=s[Number(e)];if(!n)throw new Error("No such target for br_table?");r.flowNext.push(n)}continue}if("return"===i.name){r.flowNext.push(t);continue}}r.flowNext.push(c[n+1])}const l=c.find((e=>"instr"===e.type));return l&&r.flowNext.push(l),!!l}(e,n,t);for(const e of i)for(const n of e.flowNext)n.flowPrevious.push(e);return{entry:n,exit:t,all:i.filter((e=>"instr"===e.type))}}function q(e,n){const{entry:t,exit:i,all:s}=B(e),r=[];for(const e of s)if(1!==e.flowPrevious.length||1!==e.flowNext.length||n(e.instr))r.push(e);else{const n=e.flowPrevious[0],t=e.flowNext[0];n.flowNext[n.flowNext.indexOf(e)]=t,t.flowPrevious[t.flowPrevious.indexOf(e)]=n}return{entry:t,exit:i,all:r}}function V(e,n,t,i,s,r,o){const a=("forwards"===i?e.entry.flowNext:e.exit.flowPrevious).filter((e=>e.instr));let c;for(;void 0!==(c=a.shift());){let e="union"===s?0n:-1n;for(const n of"forwards"===i?c.flowPrevious:c.flowNext){const i=t.get(n)??0n;"union"===s?e|=i:e&=i}if(o&&(e=o(c,e)),n&&n.set(c,e),e=r(c,e),e!==t.get(c)){t.set(c,e);for(const e of"forwards"===i?c.flowNext:c.flowPrevious)e.instr&&a.push(e)}}}function X(e,n){D(e,(([e])=>{if("index"!==e.type||!e.name.startsWith("local."))return;const t=n[Number(e.immediate.value)];return"local.get"===e.name?[k.local.get(t)]:"local.set"===e.name?[k.local.set(t)]:"local.tee"===e.name?[k.local.tee(t)]:void 0}),1)}M.push({name:"[local.set, local.get] => [local.tee]",enabled:e=>e.peephole_local_tee,run:([e,n])=>{if("local.set"===e.name&&"local.get"===n.name){const t=e.writes[0];if(!(t instanceof WLocal)||n.reads[0]!==t)return;return[k.local.tee(t)]}if("local.tee"===e.name&&"drop"===n.name){const n=e.writes[0];if(!(n instanceof WLocal))return;return[k.local.set(n)]}},peepholeSize:2}),M.push({name:"?.const 0, ?.add",enabled:e=>e.peephole_add_0,run:([e,n])=>{if("constant"===e.type&&0==e.immediate.value)return n.name.endsWith(".add")?[]:void 0},peepholeSize:2}),M.push({name:"i32.const, i32.const, i32.[op]",enabled:e=>e.peephole_i32_constants_ops,run:([e,n,t])=>{if("constant"!==e.type||"constant"!==n.type||!t.name.startsWith("i32."))return;if(e.result!==m||n.result!==m)return;const i=Number(e.immediate.value),s=Number(n.immediate.value),r=(BigInt(i)+2n**32n)%2n**32n,o=(BigInt(s)+2n**32n)%2n**32n;switch(t.name){case"i32.eq":return[k.i32.const(i===s?1:0)];case"i32.ne":return[k.i32.const(i!==s?1:0)];case"i32.lt_s":return[k.i32.const(i<s?1:0)];case"i32.lt_u":return[k.i32.const(r<o?1:0)];case"i32.gt_s":return[k.i32.const(i>s?1:0)];case"i32.gt_u":return[k.i32.const(r>o?1:0)];case"i32.le_s":return[k.i32.const(i<=s?1:0)];case"i32.le_u":return[k.i32.const(r<=o?1:0)];case"i32.ge_s":return[k.i32.const(i>=s?1:0)];case"i32.ge_u":return[k.i32.const(r>=o?1:0)];case"i32.add":return[k.i32.const(i+s|0)];case"i32.sub":return[k.i32.const(i-s|0)];case"i32.mul":return[k.i32.const(r*o&2n**32n-1n)];case"i32.div_s":if(0===s)return;return[k.i32.const(i/s|0)];case"i32.div_u":if(0===s)return;return[k.i32.const(r/o)];case"i32.rem_s":if(0===s)return;return[k.i32.const(i%s)];case"i32.rem_u":if(0===s)return;return[k.i32.const(r%o)];case"i32.and":return[k.i32.const(i&s)];case"i32.or":return[k.i32.const(i|s)];case"i32.xor":return[k.i32.const(i^s)];case"i32.shl":return[k.i32.const(i<<s)];case"i32.shr_s":return[k.i32.const(i>>s)];case"i32.shr_u":return[k.i32.const(i>>>s)]}},peepholeSize:3}),M.push({name:"i32.const, i32.eqz",enabled:e=>e.peephole_i32_constants_ops,run:([e,n])=>{if("constant"===e.type&&n.name.endsWith(".eqz"))return[k.i32.const(0==e.immediate.value?1:0)]},peepholeSize:2}),M.push({name:"?.const, ?.const, ?.add/mul",enabled:e=>e.peephole_constants_add_mul,run:([e,n,t])=>{if("constant"!==e.type||"constant"!==n.type)return;let i;if(t.name.endsWith(".add")){if(e.result===g)return[k.f32.const(Number(e.immediate.value)+Number(n.immediate.value))];if(e.result===b)return[k.f64.const(Number(e.immediate.value)+Number(n.immediate.value))];i=BigInt(e.immediate.value)+BigInt(n.immediate.value)}else{if(!t.name.endsWith(".mul"))return;if(e.result===g)return[k.f32.const(Number(e.immediate.value)*Number(n.immediate.value))];if(e.result===b)return[k.f64.const(Number(e.immediate.value)*Number(n.immediate.value))];i=BigInt(e.immediate.value)*BigInt(n.immediate.value)}return e.result===m?[k.i32.const(z(32n,i))]:[k.i64.const(z(64n,i))]},peepholeSize:3}),M.push({name:"i32.const, i32.add, i32.const, i32.add",enabled:e=>e.peephole_combine_adds,run:([e,n,t,i])=>{if("constant"===e.type&&"constant"===t.type&&"i32.add"===n.name&&"i32.add"===i.name)return[k.i32.const(z(32n,BigInt(e.immediate.value)+BigInt(t.immediate.value))),k.i32.add()]},peepholeSize:4}),M.push({name:"..., i32.const, i32.add, *.load offset",enabled:e=>e.peephole_load_offset,run:([e,n,t])=>{if("constant"!==e.type||e.result!==m)return;if("i32.add"!==n.name)return;if("memory"!==t.type||!t.name.includes(".load"))return;const i=t.immediate.offset+BigInt(e.immediate.value);if(!(i>127))if(t.result===m){if("i32.load"===t.name)return[k.i32.load(t.immediate.align,i)];if("i32.load8_s"===t.name)return[k.i32.load8_s(t.immediate.align,i)];if("i32.load8_u"===t.name)return[k.i32.load8_u(t.immediate.align,i)];if("i32.load16_s"===t.name)return[k.i32.load16_s(t.immediate.align,i)];if("i32.load16_u"===t.name)return[k.i32.load16_u(t.immediate.align,i)]}else if(t.result===y){if("i64.load"===t.name)return[k.i64.load(t.immediate.align,i)];if("i64.load8_s"===t.name)return[k.i64.load8_s(t.immediate.align,i)];if("i64.load16_s"===t.name)return[k.i64.load16_s(t.immediate.align,i)];if("i64.load16_u"===t.name)return[k.i64.load16_u(t.immediate.align,i)];if("i64.load32_s"===t.name)return[k.i64.load32_s(t.immediate.align,i)];if("i64.load32_u"===t.name)return[k.i64.load32_u(t.immediate.align,i)]}else{if(t.result===g)return[k.f32.load(t.immediate.align,i)];if(t.result===b)return[k.f64.load(t.immediate.align,i)]}},peepholeSize:3}),M.push({name:"remove unused blocks and loops",enabled:e=>e.peephole_unused_blocks,run:([e])=>{var n;if("structured"===e.type&&"if"!==e.name&&!G(e))return D(n=e.immediate.expression,(([e],n)=>{if("index"===e.type){if(e.immediate.value<n)return;if("br"===e.name)return[k.br(e.immediate.value-1n,...e.parameters)];if("br_if"===e.name)return[k.br_if(e.immediate.value-1n)]}else if("table"===e.type&&"br_table"===e.name){const{defaultValue:t,valueTable:i}=e.immediate;return[k.br_table(t<n?t:t-1n,i.map((e=>e<n?e:e-1n)))]}}),1),n.instructions.slice()},peepholeSize:1}),M.push({name:"remove constant ifs",enabled:e=>e.peephole_constant_if,run:([e,n])=>{if("constant"!==e.type||e.result!==m)return;if("structured"!==n.type||"if"!==n.name)return;let t;if(0!=e.immediate.value)t=n.immediate.expression;else{if(!n.immediate.expression2)return[];t=n.immediate.expression2}return[k.block(n.immediate.type,t.instructions.slice())]},peepholeSize:2});class WGlobal{constructor(e,n,t,i,s){this.module=e,this.type=n,this.mutable=t,this.initialValue=i,this.exportName=s}getIndex(){return this.module._globalIndex(this)}toBytes(){return[...(e=[this.type,this.mutable],[e[0],e[1]?1:0]),...h(this.initialValue,this.type),11];var e}}class InstrSplicer{constructor(){this.offsetsMap=new Map}splice(e,n,t,i){let s=this.offsetsMap.get(e.expr);s||this.offsetsMap.set(e.expr,s=[]);let r=e.instrIndex+(i??0);for(const{index:e,offset:n}of s)r>e&&(r+=n);e.expr.replace(r,r+n,...t);const o=t.length-n;o&&s.push({index:r,offset:o})}realIndex(e){const n=this.offsetsMap.get(e.expr);if(!n)return e.instrIndex;let t=e.instrIndex;for(const{index:e,offset:i}of n)t>e&&(t+=i);return t}}function W(e,n){const t=function(e,n){const t=(1n<<BigInt(n.length))-1n,i=new Map;for(const s of e.all){let e=t;if("structured"!==s.instr.type)for(const t of s.instr.writes)if("memory"===t||t instanceof WGlobal||t instanceof WLocal)for(const[i,s]of n.entries())s.resources.has(t)&&(e&=~(1n<<BigInt(i)));i.set(s,e)}return e=>i.get(e)??t}(e,n),i=function(e,n){const t=new Map;for(const i of e.all){let e=0n;for(const[t,s]of n.entries())s.positions.find((({expr:e,end:n})=>e===i.expr&&n===i.instrIndex))&&(e|=1n<<BigInt(t));t.set(i,e)}return e=>t.get(e)??0n}(e,n),s=i,r=new Map,o=new Map;V(e,r,o,"forwards","intersection",((e,n)=>i(e)|n&t(e)));const a=new Map,c=new Map;V(e,a,c,"backwards","intersection",((e,n)=>s(e)|n&t(e)));const l=new Map,f=new Map;for(const n of e.all)l.set(n,(r.get(n)??0n)|(c.get(n)??0n)),f.set(n,(o.get(n)??0n)|(a.get(n)??0n));const u=new Map,d=new Map;V(e,u,d,"forwards","union",((e,n)=>(i(e)|n&t(e))&(f.get(e)??0n)),((e,n)=>n&(l.get(e)??0n)));const h=new Map,p=new Map;V(e,h,p,"backwards","union",((e,n)=>(s(e)|n&t(e))&(l.get(e)??0n)),((e,n)=>n&(f.get(e)??0n)));const _=new Map,m=new Map,y=new Map;for(const n of[e.entry,...e.all]){const e=i(n),t=u.get(n)??0n,r=h.get(n)??0n,o=e&~t&r;0n!==o&&_.set(n,o);const a=s(n)&t|e&r;0n!==a&&m.set(n,a);const c=d.get(n)??0n,l=[];for(const e of n.flowNext){if(!e.instr)continue;const n=~c&(u.get(e)??0n)&(p.get(e)??0n);0n!==n&&l.push([e,n])}l.length&&y.set(n,l)}return{INSERT:_,INSERT_EDGE:y,REPLACE:m}}let H=0;class LocalRange{constructor(e){this.type=e,this.id=H++}merge(e){return this===e?this.get():this.target?this.target.merge(e):e.id<this.id?(e.merge(this),this.get()):(this.target=e,e.get())}get(){return this.target?this.target.get():this}getNewLocal(){if(this.target)return this.target.getNewLocal();if(!this.newLocal)throw new Error("No new local assigned?");return this.newLocal}}class CError extends Error{constructor(e,n,t){super(e),this.node=n,this.node2=t,this.name="CError",n?.loc&&(this.message+="\n\n"+j(n.loc),t?.loc&&(this.message+="\n\n"+j(t.loc,"Secondary location")))}}function j(e,n="Location"){const t=e.source.split("\n");if(e.first_line>=t.length)return`${n}: [UNKNOWN]`;let i=`${n}:\n`;const s=Math.ceil(Math.log10(e.last_line+4));function r(e){i+=`L${(e+1).toString().padStart(s,"0")}: ${t[e]}\n`}return e.first_line>1&&r(e.first_line-2),e.first_line>0&&r(e.first_line-1),r(e.first_line),i+=new Array(3+s+e.first_column).join(" "),e.first_line===e.last_line?i+=new Array(1+e.last_column-e.first_column).join("^"):i+="^",i+="\n",e.first_line+1<t.length&&r(e.first_line+1),e.first_line+2<t.length&&r(e.first_line+2),i}class CFuncType{constructor(e,n,t,i,s=!1){this.node=e,this.returnType=n,this.parameterTypes=t,this.parameterNames=i,this.variadic=s,this.typeName="function",this.bytes=0,this.alignment=1,this.incomplete=!1,n instanceof CVoid||te(n),t.forEach((e=>te(e)))}equals(e){return e instanceof CFuncType&&e.returnType.equals(this.returnType)&&e.parameterTypes.length===this.parameterTypes.length&&e.parameterTypes.every(((e,n)=>this.parameterTypes[n].equals(e)))&&e.variadic===this.variadic}get pointerGeneration(){return J(new CPointer(this.node,this,!1,this),K(this))}}class CPointer{constructor(e,n,t=!1,i){this.node=e,this.type=n,this.original=i,this.bytes=4,this.alignment=4,this.incomplete=!1,t&&(this.qualifier="const")}equals(e){return e instanceof CPointer&&e.qualifier===this.qualifier&&this.type.equals(e.type)}get pointerGeneration(){return this}get typeName(){return this.type.typeName+"*"+(this.qualifier?" "+this.qualifier:"")}}class CArray{constructor(e,n,t){this.node=e,this.type=n,this.length=t,te(n),this.alignment=n.alignment}get bytes(){if(void 0===this.length)throw new Error("Tried to get size of incomplete type");return this.type.bytes*this.length}get incomplete(){return void 0===this.length}equals(e){return e instanceof CArray&&e.length===this.length&&this.type.equals(e.type)}get pointerGeneration(){return J(new CPointer(this.node,this.type,!1,this),K(this))}get typeName(){return this.length?this.type.typeName+"["+this.length+"]":this.type.typeName+"[]"}}class CCompoundMember{constructor(e,n,t){this.node=e,this.name=n,this.type=t}}class CStruct{constructor(e,n){this.node=e,this.name=n}get members(){if(void 0===this._members)throw new Error("Can't get members of an incomplete struct");return this._members}set members(e){if(void 0!==this._members)throw new Error("Can't redefine a struct's members");if(0===e.length)throw new Error("Struct must have one or more member");this._members=e}get bytes(){if(this.incomplete)throw new Error("Tried to get size of incomplete type");return this.members.reduce(((e,n)=>(e=Math.ceil(e/n.type.alignment)*n.type.alignment)+n.type.bytes),0)}get alignment(){return Math.max(...this.members.map((e=>e.type.alignment)))}get incomplete(){return void 0===this._members}equals(e){return e instanceof CStruct&&(void 0===this.name&&void 0===e.name?this.members.length===e.members.length&&this.members.every(((n,t)=>e.members[t].name===n.name&&e.members[t].type.equals(n.type))):e.name===this.name)}memberType(e){const n=this.members.find((n=>n.name===e));if(n)return n.type;throw new Error(`Struct does not contain member "${e}"`)}hasConstMember(){return void 0!==this.members.find((e=>K(e.type)||(e.type instanceof CUnion||e.type instanceof CStruct)&&e.type.hasConstMember()))}get pointerGeneration(){return this}get typeName(){return this.name?"struct "+this.name:"struct {"+this.members.map((e=>e.type.typeName+" "+e.name+";")).join(" ")+"}"}}class CUnion{constructor(e,n){this.node=e,this.name=n}get members(){if(void 0===this._members)throw new Error("Can't get members of an incomplete union");return this._members}set members(e){if(void 0!==this._members)throw new Error("Can't redefine a union's members");if(0===e.length)throw new Error("Struct must have one or more member");this._members=e}get bytes(){if(this.incomplete)throw new Error("Tried to get size of incomplete type");return this.members.reduce(((e,n)=>Math.max(e,n.type.bytes)),0)}get alignment(){return Math.max(...this.members.map((e=>e.type.alignment)))}get incomplete(){return void 0===this._members}equals(e){return e instanceof CUnion&&(void 0===this.name&&void 0===e.name?this.members.length===e.members.length&&this.members.every(((n,t)=>e.members[t].name===n.name&&e.members[t].type.equals(n.type))):e.name===this.name)}memberType(e){const n=this.members.find((n=>n.name===e));if(n)return n.type;throw new Error(`Union does not contain member "${e}"`)}hasConstMember(){return void 0!==this.members.find((e=>K(e.type)||(e.type instanceof CUnion||e.type instanceof CStruct)&&e.type.hasConstMember()))}get pointerGeneration(){return this}get typeName(){return this.name?"union "+this.name:"union {"+this.members.map((e=>e.type.typeName+" "+e.name+";")).join(" ")+"}"}}class CEnum{constructor(e,n){this.node=e,this.name=n,this.typeName="enum"}get values(){if(void 0===this._values)throw new Error("Can't get values of an incomplete enum");return this._values}set values(e){if(void 0!==this._values)throw new Error("Can't redefine an enum's values");if(0===e.length)throw new Error("Enum must have one or more value");this._values=e}get incomplete(){return void 0===this._values}equals(e){return void 0===this.name?this===e:e instanceof CEnum&&e.name===this.name}}class CVoid{constructor(){this.typeName="void",this.bytes=0,this.alignment=1,this.incomplete=!0,this.node=void 0}equals(e){return e instanceof CVoid}get pointerGeneration(){return this}}class CArithmetic{constructor(e,n,t){this.typeName=e,this.bytes=n,this.type=t,this.incomplete=!1,this.node=void 0,this.alignment=n}equals(e){return e instanceof CArithmetic&&e.typeName===this.typeName&&e.type===this.type&&e.bytes===this.bytes}get minValue(){if(CArithmetic.BOOL.equals(this))return 0;switch(this.type){case"float":return-1/0;case"unsigned":return 0;case"signed":return-(2n**(BigInt(8*this.bytes)-1n))}}get maxValue(){if(CArithmetic.BOOL.equals(this))return 1;switch(this.type){case"float":return 1/0;case"unsigned":return 2n**BigInt(8*this.bytes)-1n;case"signed":return 2n**(BigInt(8*this.bytes)-1n)-1n}}get pointerGeneration(){return this}}CArithmetic.Fp32=new CArithmetic("float",4,"float"),CArithmetic.Fp64=new CArithmetic("double",8,"float"),CArithmetic.U8=new CArithmetic("char",1,"unsigned"),CArithmetic.S8=new CArithmetic("signed char",1,"signed"),CArithmetic.U16=new CArithmetic("unsigned short",2,"unsigned"),CArithmetic.S16=new CArithmetic("short",2,"signed"),CArithmetic.U32=new CArithmetic("unsigned int",4,"unsigned"),CArithmetic.S32=new CArithmetic("int",4,"signed"),CArithmetic.U64=new CArithmetic("unsigned long",8,"unsigned"),CArithmetic.S64=new CArithmetic("long",8,"signed"),CArithmetic.BOOL=new CArithmetic("bool",4,"signed");const Z=CArithmetic.U32,Y=Symbol("const");function J(e,n){if(void 0===n)return e;if(Object.prototype.hasOwnProperty.call(e,"qualifier"))throw new Error("Type already has a qualifier");const t=e;if(t[Y])return t[Y];const i=Object.setPrototypeOf({qualifier:n,_base:e},e);return t[Y]=i,i}function K(e){return e?.qualifier}function Q(e){return"float"===e.type?e:e.bytes<CArithmetic.S32.bytes||e===CArithmetic.BOOL?CArithmetic.S32:e}function ee(e,n){return e===CArithmetic.Fp64||n===CArithmetic.Fp64?CArithmetic.Fp64:e===CArithmetic.Fp32||n===CArithmetic.Fp32?CArithmetic.Fp32:(e=Q(e),n=Q(n),e===CArithmetic.U64||n===CArithmetic.U64?CArithmetic.U64:e===CArithmetic.S64||n===CArithmetic.S64?CArithmetic.S64:e===CArithmetic.U32||n===CArithmetic.U32?CArithmetic.U32:CArithmetic.S32)}function ne(e){const n=e.slice();function t(e){const t=n.indexOf(e);return t>-1&&(n.splice(t,1),!0)}function i(e){if(!(n.length>0))return e}return t("void")?i(new CVoid):t("double")?(t("long"),i(CArithmetic.Fp64)):t("float")?i(CArithmetic.Fp32):t("char")?t("signed")?i(CArithmetic.S8):(t("unsigned"),i(CArithmetic.U8)):t("short")?(t("int"),t("unsigned")?i(CArithmetic.U16):(t("signed"),i(CArithmetic.S16))):t("long")?(t("long"),t("int"),t("unsigned")?i(CArithmetic.U64):(t("signed"),i(CArithmetic.S64))):t("int")?t("unsigned")?i(CArithmetic.U32):(t("signed"),i(CArithmetic.S32)):t("unsigned")?i(CArithmetic.U32):t("signed")?i(CArithmetic.S32):t("bool")?i(CArithmetic.BOOL):void 0}function te(e,n=e.node){if(e.incomplete)throw new class extends CError{constructor(){super(...arguments),this.name="IncompleteTypeError"}}("Invalid use of an incomplete type",n);return e}class ExpressionTypeError extends CError{constructor(e,n,t){super(t?`Expected ${n} but got ${t} instead!`:`Expected ${n}`,e),this.wantedType=n,this.actualType=t,this.name="ExpressionTypeError"}}function ie(e,n){if(n instanceof CArithmetic)return n;throw new ExpressionTypeError(e,"arithmetic",n.typeName)}function se(e,n){const t=ie(e,n);switch(t.type){case"signed":case"unsigned":return t;default:throw new ExpressionTypeError(e,"integer",n.typeName)}}function re(e,n){if(n instanceof CPointer)return n;throw new ExpressionTypeError(e,"pointer",n.typeName)}function oe(e,n){if(n instanceof CArithmetic)return n;if(n instanceof CPointer)return n;throw new ExpressionTypeError(e,"arithmetic or pointer",n.typeName)}function ae(e,n){if(n instanceof CPointer&&n.type instanceof CFuncType)throw new ExpressionTypeError(e,"non-function pointer","function pointer");return n}function ce(e,n){if(e.lvalue===n)return e;throw new ExpressionTypeError(e.node,`lvalue=${n}`,`lvalue=${e.lvalue}`)}class CConstant{constructor(e,n,t){this.node=e,this.type=n,this.value=t,this.lvalue=!1}changeType(e){if(this.type.equals(e))return this;let n;if(e.equals(CArithmetic.BOOL))n=0==this.value?0:1;else if("float"===e.type)n=Number(this.value);else{if(this.value>e.maxValue||this.value<e.minValue)throw new ExpressionTypeError(this.node,`value which fits in ${e.typeName}`,this.value.toString());n=BigInt(this.value)}return new CConstant(this.node,e,n)}*identifiers(){}}class CIdentifier{constructor(e,n){this.node=e,this.value=n,this.lvalue=!(n.type instanceof CFuncType)}get type(){return this.value.type.pointerGeneration}*identifiers(){yield this}}class CStringLiteral{constructor(e,n){if(this.node=e,this.value=n,this.lvalue=!1,0===n.length||0n!==n[n.length-1])throw new ExpressionTypeError(e,"null terminated char[]","char[]");this.type=new CArray(e,CArithmetic.U8,n.length).pointerGeneration}*identifiers(){}}class CFunctionCall{constructor(e,n,t){if(this.node=e,this.body=n,this.args=t,this.lvalue=!1,this.fnType=function(e,n){if(n instanceof CFuncType)return n;if(n instanceof CPointer&&n.type instanceof CFuncType)return n.type;throw new ExpressionTypeError(e,"function",n.typeName)}(n.node,n.type),this.type=this.fnType.returnType.pointerGeneration,this.fnType.variadic&&this.fnType.parameterTypes.length>t.length)throw new ExpressionTypeError(e,`at least ${this.fnType.parameterTypes.length} argument(s) to variadic function`);if(!this.fnType.variadic&&this.fnType.parameterTypes.length!==t.length)throw new ExpressionTypeError(e,`${this.fnType.parameterTypes.length} argument(s)`,`${t.length}`);for(let e=0;e<this.fnType.parameterTypes.length;e++)CAssignment.checkAssignmentValid(t[e].node,this.fnType.parameterTypes[e],t[e])}*identifiers(){yield*this.body.identifiers();for(const e of this.args)yield*e.identifiers()}}class CMemberAccess{constructor(e,n,t){this.node=e,this.body=n,this.member=t;const i=n.type instanceof CPointer?n.type.original??n.type:n.type,s=re(n.node,i);this.structUnion=function(e,n){if(te(n),n instanceof CStruct)return n;if(n instanceof CUnion)return n;throw new ExpressionTypeError(e,"struct or union",n.typeName)}(n.node,s.type);const r=this.structUnion.memberType(t);this.type=r.pointerGeneration,this.lvalue=!(this.type instanceof CArray)}*identifiers(){yield*this.body.identifiers()}}class CIncrDecr{constructor(e,n,t,i){this.node=e,this.body=n,this.op=t,this.pos=i,this.lvalue=!1,ce(n,!0);const s=n.type instanceof CPointer?n.type.original??n.type:n.type;this.type=ae(n.node,oe(n.node,s)),this.type instanceof CPointer&&te(this.type.type)}*identifiers(){yield*this.body.identifiers()}}class CSizeof{constructor(e,n){if(this.node=e,this.lvalue=!1,this.type=Z,this.body=n instanceof CPointer?n.original??n:n,this.body.incomplete||0===this.body.bytes||this.body instanceof CFuncType)throw new ExpressionTypeError(e,"Complete non-function type",n.typeName)}*identifiers(){}}class CAddressOf{constructor(e,n){this.node=e,this.lvalue=!1;const t=n.type instanceof CPointer?n.type.original??n.type:n.type;n instanceof CIdentifier&&t instanceof CFuncType||ce(n,!0),this.type=new CPointer(e,t),n instanceof CIdentifier&&(n.value.addressUsed=!0),this.body=n}*identifiers(){yield*this.body.identifiers()}}class CDereference{constructor(e,n){this.node=e,this.body=n,this.lvalue=!0,this.type=re(e,n.type).type.pointerGeneration}*identifiers(){yield*this.body.identifiers()}}class CUnaryPlusMinus{constructor(e,n,t){this.node=e,this.body=n,this.op=t,this.lvalue=!1,this.bodyType=ie(n.node,n.type),this.type=Q(this.bodyType)}*identifiers(){yield*this.body.identifiers()}}class CBitwiseNot{constructor(e,n){this.node=e,this.body=n,this.lvalue=!1,this.bodyType=se(n.node,n.type),this.type=this.bodyType.bytes<CArithmetic.S32.bytes?CArithmetic.S32:this.bodyType}*identifiers(){yield*this.body.identifiers()}}class CLogicalNot{constructor(e,n){this.node=e,this.body=n,this.lvalue=!1,this.type=CArithmetic.S32,oe(n.node,n.type)}*identifiers(){yield*this.body.identifiers()}}class CCast{constructor(e,n,t){this.node=e,this.body=t,this.lvalue=!1,this.type=n.pointerGeneration}*identifiers(){yield*this.body.identifiers()}}class CMulDiv{constructor(e,n,t,i){this.node=e,this.lhs=n,this.rhs=t,this.op=i,this.lvalue=!1,this.type=ee(ie(n.node,n.type),ie(t.node,t.type))}*identifiers(){yield*this.lhs.identifiers(),yield*this.rhs.identifiers()}}class CMod{constructor(e,n,t){this.node=e,this.lhs=n,this.rhs=t,this.lvalue=!1,this.type=ee(se(n.node,n.type),se(t.node,t.type))}*identifiers(){yield*this.lhs.identifiers(),yield*this.rhs.identifiers()}}class CAddSub{constructor(e,n,t,i){if(this.node=e,this.lhs=n,this.rhs=t,this.op=i,this.lvalue=!1,n.type instanceof CPointer&&t.type instanceof CPointer){if(!n.type.equals(t.type))throw new ExpressionTypeError(e,"both pointers to have the same type");te(n.type.type),this.type=ae(n.node,n.type),ae(t.node,t.type)}else n.type instanceof CPointer?(se(t.node,t.type),te(n.type.type),this.type=ae(n.node,n.type)):t.type instanceof CPointer?(se(n.node,n.type),te(t.type.type),this.type=ae(t.node,t.type)):this.type=ee(ie(n.node,n.type),ie(t.node,t.type))}*identifiers(){yield*this.lhs.identifiers(),yield*this.rhs.identifiers()}}class CShift{constructor(e,n,t,i){this.node=e,this.lhs=n,this.rhs=t,this.dir=i,this.lvalue=!1,this.type=Q(se(n.node,n.type)),se(t.node,t.type)}*identifiers(){yield*this.lhs.identifiers(),yield*this.rhs.identifiers()}}class CRelational{constructor(e,n,t,i){this.node=e,this.lhs=n,this.rhs=t,this.op=i,this.lvalue=!1,this.type=CArithmetic.BOOL,oe(n.node,n.type),oe(t.node,t.type),this.commonType=ee(n.type instanceof CArithmetic?n.type:Z,t.type instanceof CArithmetic?t.type:Z)}*identifiers(){yield*this.lhs.identifiers(),yield*this.rhs.identifiers()}}class CEquality{constructor(e,n,t,i){this.node=e,this.lhs=n,this.rhs=t,this.op=i,this.lvalue=!1,this.type=CArithmetic.BOOL,oe(n.node,n.type),oe(t.node,t.type),this.commonType=ee(n.type instanceof CArithmetic?n.type:Z,t.type instanceof CArithmetic?t.type:Z)}*identifiers(){yield*this.lhs.identifiers(),yield*this.rhs.identifiers()}}class CBitwiseAndOr{constructor(e,n,t,i){this.node=e,this.lhs=n,this.rhs=t,this.op=i,this.lvalue=!1,this.type=ee(se(n.node,n.type),se(t.node,t.type))}*identifiers(){yield*this.lhs.identifiers(),yield*this.rhs.identifiers()}}class CLogicalAndOr{constructor(e,n,t,i){this.node=e,this.lhs=n,this.rhs=t,this.op=i,this.lvalue=!1,this.type=CArithmetic.BOOL,oe(n.node,n.type),oe(t.node,t.type)}*identifiers(){yield*this.lhs.identifiers(),yield*this.rhs.identifiers()}}class CConditional{constructor(e,n,t,i){if(this.node=e,this.test=n,this.trueValue=t,this.falseValue=i,this.lvalue=!1,oe(n.node,n.type),t.type instanceof CArithmetic&&i.type instanceof CArithmetic)this.type=ee(t.type,i.type);else{if(!t.type.equals(i.type)){if(t.type instanceof CPointer&&i.type instanceof CPointer){if(t.type.type instanceof CVoid)return void(this.type=i.type);if(i.type.type instanceof CVoid)return void(this.type=t.type)}else if(t.type instanceof CPointer||i.type instanceof CPointer){const e=t.type instanceof CPointer?i:t;if(e instanceof CConstant&&0==e.value)return void(this.type=t.type instanceof CPointer?t.type:i.type)}throw new ExpressionTypeError(e,"both conditional branches to have the same type","different types")}this.type=t.type}}*identifiers(){yield*this.test.identifiers(),yield*this.trueValue.identifiers(),yield*this.falseValue.identifiers()}}class CAssignment{constructor(e,n,t,i,s=!1){this.node=e,this.lhs=n,this.rhs=t,this.assignmentType=i,this.initialAssignment=s,this.lvalue=!1;const r=n.type instanceof CPointer?n.type.original??n.type:n.type;if(ce(n,!0),r instanceof CArray&&!s||r instanceof CFuncType||n.type.incomplete)throw new ExpressionTypeError(n.node,"assignable type");if("const"===K(r)&&!s)throw new ExpressionTypeError(n.node,"non-const location");if((r instanceof CStruct||r instanceof CUnion)&&r.hasConstMember()&&!s)throw new ExpressionTypeError(n.node,"structure without a const member");if(this.type=r.pointerGeneration,i){if(t instanceof CInitializer)throw new ExpressionTypeError(e,"simple assignments with structure initializers");let s=t.type;switch(i){case"mul":s=new CMulDiv(e,n,t,"*").type;break;case"div":s=new CMulDiv(e,n,t,"/").type;break;case"mod":s=new CMod(e,n,t).type;break;case"add":s=new CAddSub(e,n,t,"+").type;break;case"sub":s=new CAddSub(e,n,t,"-").type;break;case"leftShift":s=new CShift(e,n,t,"left").type;break;case"rightShift":s=new CShift(e,n,t,"right").type;break;case"bitwiseAnd":s=new CBitwiseAndOr(e,n,t,"and").type;break;case"bitwiseOr":s=new CBitwiseAndOr(e,n,t,"or").type;break;case"bitwiseXor":s=new CBitwiseAndOr(e,n,t,"xor").type;break;default:throw new ExpressionTypeError(e,"valid assignment type")}CAssignment._checkAssignmentTypeValid(e,r,s)}else CAssignment.checkAssignmentValid(e,r,t)}*identifiers(){yield*this.lhs.identifiers(),yield*this.rhs.identifiers()}static checkAssignmentValid(e,n,t){n instanceof CPointer&&t instanceof CConstant&&0n===t.value||this._checkAssignmentTypeValid(e,n,t.type)}static _checkAssignmentTypeValid(e,n,t){if(!(n.equals(t)||n instanceof CArithmetic&&t instanceof CArithmetic)){if(n instanceof CPointer&&t instanceof CPointer){if(n.type instanceof CVoid||t.type instanceof CVoid)return;if(n.type.equals(t.type))return}if(!(n instanceof CPointer&&t instanceof CFuncType&&n.type.equals(t))){if(t instanceof CPointer&&t.original){if(n.equals(t.original))return;if(n instanceof CArray&&t.original instanceof CArray&&n.type.equals(t.type)&&(t.original.length??0)<(n.length??0))return}throw new ExpressionTypeError(e,n.typeName,t.typeName)}}}}class CComma{constructor(e,n,t){this.node=e,this.lhs=n,this.rhs=t,this.lvalue=!1,this.type=t.type}*identifiers(){yield*this.lhs.identifiers(),yield*this.rhs.identifiers()}}class CInitializer{constructor(e,n,t){this.node=e,this.body=n,this._memberTypes=[],this._type=t??new CArray(void 0,new CPointer(void 0,new CVoid),n.length)}get memberTypes(){return this._memberTypes}get type(){return this._type}set type(e){if(this._memberTypes=[],e instanceof CArray){if(this.body.length>(e.length??1/0))throw new ExpressionTypeError(this.node,`at most ${e.length} elements`,`${this.body.length} elements`);for(let n=0;n<this.body.length;n++)this.body[n]=CInitializer.typeCheck(e.type,this.body[n]),this._memberTypes.push(e.type)}else if(e instanceof CStruct){if(this.body.length>e.members.length)throw new ExpressionTypeError(this.node,`at most ${e.members.length} elements`,`${this.body.length} elements`);for(let n=0;n<this.body.length;n++)this.body[n]=CInitializer.typeCheck(e.members[n].type,this.body[n]),this._memberTypes.push(e.members[n].type)}else{if(!(e instanceof CUnion))throw new ExpressionTypeError(this.node,"Invalid type for initializer");if(this.body.length>1)throw new ExpressionTypeError(this.node,"one element matching first member in union",`${this.body.length} elements`);1===this.body.length&&(this.body[0]=CInitializer.typeCheck(e.members[0].type,this.body[0]),this._memberTypes.push(e.members[0].type))}this._type=e}*identifiers(){for(const e of this.body)yield*e.identifiers()}static typeCheck(e,n){return n instanceof CInitializer?n.type=e:(CAssignment.checkAssignmentValid(n.node,e,n),n instanceof CConstant&&e instanceof CArithmetic&&n.type!==e&&(n=n.changeType(e))),n}}class Scope{constructor(e,n,t=n?.func){this.node=e,this.parent=n,this.func=t,this.tags=new Map,this.identifiers=new Map,this.typedefs=new Map}_getTag(e){return this.tags.get(e)??this.parent?._getTag(e)}lookupTag(e,n,t){const i=this._getTag(e);if(n&&i&&n.prototype!==Object.getPrototypeOf(i))throw new ScopeError("`"+e+"` was already declared as a "+i.typeName,i.node,t);return i}addTag(e){if(!e.name)throw new Error("Cannot add nameless compound type to scope");if(this._getTag(e.name))throw new ScopeError("Compound type `"+e.name+"` is already defined!",e.node);this.tags.set(e.name,e)}_getId(e){return this.identifiers.get(e)??this.parent?._getId(e)}lookupIdentifier(e,n){const t=this._getId(e);if(!t)throw new ScopeError("Failed to find `"+e+"`",n);return t}addIdentifier(e){const n=this.identifiers.get(e.name);if(n)if(n.type.equals(e.type)&&n instanceof CFuncDeclaration&&e instanceof CFuncDefinition)"external"!==n.linkage&&"external"===e.linkage&&(e.linkage=n.linkage),n.definition=e;else{if(n.type.equals(e.type)&&e instanceof CFuncDeclaration)return void(n instanceof CFuncDeclaration&&(n.fnImport||(n.fnImport=e.fnImport)));if(!(n.type.equals(e.type)&&n instanceof CVarDeclaration&&e instanceof CVarDefinition)){if(n.type.equals(e.type)&&e instanceof CVarDeclaration){if("external"!==n.linkage&&n.linkage!==e.linkage)throw new ScopeError("Variable `"+e.name+"` is already defined with "+n.linkage+" linkage",n.node,e.node);return}throw new ScopeError("Identifier `"+e.name+"` is already defined in this scope!",n.node,e.node)}if("external"!==n.linkage&&n.linkage!==e.linkage)throw new ScopeError("Variable `"+e.name+"` is already defined with "+n.linkage+" linkage",n.node,e.node);n.definition=e}this.identifiers.set(e.name,e)}get declarations(){return[...this.identifiers.values()]}_getTypedef(e){return this.typedefs.get(e)??this.parent?._getTypedef(e)}lookupTypedef(e,n){const t=this._getTypedef(e);if(void 0===t)throw new ScopeError("typedef `"+e+"` not found in scope",n);return t}addTypedef(e,n,t){const i=this._getTypedef(e);if(i){if(i.equals(n))return;throw new ScopeError("typedef already defined with a different type",t)}this.typedefs.set(e,n)}}class ScopeError extends CError{constructor(){super(...arguments),this.name="ScopeError"}}class CCompoundStatement{constructor(e,n){this.node=e,this.parent=n,this.statements=[],this.scope=new Scope(e,n.scope,n instanceof CFuncDefinition?n:void 0)}}class CExpressionStatement{constructor(e,n,t){this.node=e,this.expression=n,this.parent=t}get scope(){return this.parent.scope}}class CNop{constructor(e,n){this.node=e,this.parent=n}get scope(){return this.parent.scope}}class CIf{constructor(e,n,t){this.node=e,this.test=n,this.parent=t,oe(n.node,n.type)}get scope(){return this.parent.scope}}class CForLoop{constructor(e,n){this.node=e,this.parent=n,this.scope=new Scope(e,n.scope)}}class CWhileLoop{constructor(e,n,t){this.node=e,this.test=n,this.parent=t,oe(n.node,n.type)}get scope(){return this.parent.scope}}class CDoLoop{constructor(e,n,t){this.node=e,this.test=n,this.parent=t,oe(n.node,n.type)}get scope(){return this.parent.scope}}class CGoto{constructor(e,n,t){this.node=e,this.target=n,this.parent=t}get scope(){return this.parent.scope}}class CSwitch{constructor(e,n,t){this.node=e,this.expression=n,this.parent=t,this.children=[]}get scope(){return this.parent.scope}}class CContinue{constructor(e,n,t){this.node=e,this.loop=n,this.parent=t}get scope(){return this.parent.scope}}class CBreak{constructor(e,n,t){this.node=e,this.target=n,this.parent=t}get scope(){return this.parent.scope}}class CReturn{constructor(e,n,t,i){if(this.node=e,this.func=n,this.value=t,this.parent=i,void 0===t){if(n.type.returnType.bytes>0)throw new ExpressionTypeError(e,"`return [expression]`","`return;`")}else n.type.returnType.equals(t.type)||CAssignment.checkAssignmentValid(e,n.type.returnType,t)}get scope(){return this.parent.scope}}class CLabelledStatement{constructor(e,n){this.node=e,this.label=n}}class CVarDeclaration{constructor(e,n,t,i,s){this.node=e,this.name=n,this.type=t,this.storage=i,this.linkage=s,this.declType="variable",this._addressUsed=!1}set addressUsed(e){var n;this._definition?(n=this._definition).addressUsed||(n.addressUsed=e):this._addressUsed||(this._addressUsed=e)}get addressUsed(){return this._definition?this._definition.addressUsed:this._addressUsed}set definition(e){if(void 0===e)throw new Error("Cannot set definition to undefined");e.addressUsed||(e.addressUsed=this._addressUsed),this._definition=e}get definition(){return this._definition}}class CVarDefinition{constructor(e,n,t,i,s){this.node=e,this.name=n,this.type=t,this.storage=i,this.linkage=s,this.declType="variable",this.addressUsed=!1,this.dependencies=new Map}}class CArgument{constructor(e,n,t,i){this.node=e,this.name=n,this.type=t,this.index=i,this.declType="variable",this.storage="argument",this.linkage="none",this.addressUsed=!1}}class CFuncDeclaration{constructor(e,n,t,i,s=!1){this.node=e,this.name=n,this.type=t,this.linkage=i,this.fnImport=s,this.declType="function"}}class CFuncImport{constructor(e){this.declaration=e,this.declType="import",this.node=e.node}getFunction(){return this.declaration}}class CFuncDefinition{constructor(e,n,t,i,s){this.node=e,this.name=n,this.type=t,this.linkage=i,this.translationUnit=s,this.declType="function",this.dependencies=new Map,this.hints={inline:!1},this.body=new CCompoundStatement(e.body,this)}get scope(){return this.translationUnit}equals(e){return e===this}getFunction(){return this}}const le=Symbol("constant");function fe(e){e[le]=!1}function ue(e,n){if(e[le]??1){if(e instanceof CConstant)return{value:e.value,type:e.type};if(e instanceof CIdentifier&&e.value instanceof CVarDefinition&&"const"===e.value.type.qualifier&&e.value.staticValue instanceof CConstant)return ue(e.value.staticValue,n);if(e instanceof CSizeof)return he({value:e.body.bytes,type:Z});if(e instanceof CUnaryPlusMinus){const t=ue(e.body,n);return t?"+"===e.op?t:{value:-t.value,type:e.type}:fe(e)}if(e instanceof CBitwiseNot){const t=de(e.body,n);return t?he({value:~t.value,type:t.type}):fe(e)}if(e instanceof CLogicalNot){const t=ue(e.body,n);return t?{value:0==t.value?1n:0n,type:CArithmetic.S32}:fe(e)}if(e instanceof CCast&&(e.type instanceof CArithmetic||e.type instanceof CPointer)){const t=ue(e.body,n);return t?he({value:t.value,type:e.type}):fe(e)}if(e instanceof CMulDiv){const t=ue(e.lhs,n),i=ue(e.rhs,n);if(!t||!i)return fe(e);if("*"===e.op)return"float"===e.type.type?{value:Number(t.value)*Number(i.value),type:e.type}:he({value:BigInt(t.value)*BigInt(i.value),type:e.type});if(0!=i.value)return"float"===e.type.type?{value:Number(t.value)/Number(i.value),type:e.type}:he({value:BigInt(t.value)/BigInt(i.value),type:e.type})}else{if(e instanceof CMod){const t=de(e.lhs,n),i=de(e.rhs,n);return t&&i&&0n!==i.value?he({value:t.value%i.value,type:e.type}):fe(e)}if(e instanceof CAddSub&&e.type instanceof CArithmetic){const t=ue(e.lhs,n),i=ue(e.rhs,n);return t&&i?"+"===e.op?"float"===e.type.type?{value:Number(t.value)+Number(i.value),type:e.type}:he({value:BigInt(t.value)+BigInt(i.value),type:e.type}):"float"===e.type.type?{value:Number(t.value)-Number(i.value),type:e.type}:he({value:BigInt(t.value)-BigInt(i.value),type:e.type}):fe(e)}if(e instanceof CShift){const t=de(e.lhs,n),i=de(e.rhs,n);return t&&i?"left"===e.dir?he({value:t.value<<i.value,type:e.type}):he({value:t.value>>i.value,type:e.type}):fe(e)}if(e instanceof CRelational){const t=ue(e.lhs,n),i=ue(e.rhs,n);return t&&i?"LT"===e.op?{value:t.value<i.value?1n:0n,type:CArithmetic.S32}:"GT"===e.op?{value:t.value>i.value?1n:0n,type:CArithmetic.S32}:"LEq"===e.op?{value:t.value<=i.value?1n:0n,type:CArithmetic.S32}:{value:t.value>=i.value?1n:0n,type:CArithmetic.S32}:fe(e)}if(e instanceof CEquality){const t=ue(e.lhs,n),i=ue(e.rhs,n);return t&&i?"=="===e.op?{value:t.value==i.value?1n:0n,type:CArithmetic.S32}:{value:t.value!=i.value?1n:0n,type:CArithmetic.S32}:fe(e)}if(e instanceof CBitwiseAndOr){const t=de(e.lhs,n),i=de(e.rhs,n);return t&&i?"and"===e.op?he({value:t.value&i.value,type:e.type}):"or"===e.op?he({value:t.value|i.value,type:e.type}):he({value:t.value^i.value,type:e.type}):fe(e)}if(e instanceof CLogicalAndOr){const t=ue(e.lhs,n);if(!t)return fe(e);if("and"===e.op){if(0!=t.value){const t=ue(e.rhs,n);if(!t)return fe(e);if(0!=t.value)return{value:1n,type:CArithmetic.S32}}return{value:0n,type:CArithmetic.S32}}{if(0!=t.value)return{value:1n,type:CArithmetic.S32};const i=ue(e.rhs,n);return i?0!=i.value?{value:1n,type:CArithmetic.S32}:{value:0n,type:CArithmetic.S32}:fe(e)}}if(e instanceof CConditional&&(e.type instanceof CArithmetic||e.type instanceof CPointer)){const t=ue(e.test,n);if(!t)return fe(e);let i;return i=0!=t.value?ue(e.trueValue,n):ue(e.falseValue,n),i?he({value:i.value,type:e.type}):fe(e)}}if(void 0!==n){const t=n(e,(e=>ue(e,n)),fe);if(t)return t}fe(e)}}function de(e,n){const t=ue(e,n);if(t?.type instanceof CArithmetic&&"float"!==t.type.type)return{value:BigInt(t.value),type:t.type}}function he(e){if(e.type instanceof CArithmetic){if(CArithmetic.BOOL.equals(e.type))return{value:0==e.value?0n:1n,type:CArithmetic.BOOL};if("float"===e.type.type)return{value:"number"==typeof e.value?e.value:Number(e.value),type:e.type};{let n;n="number"==typeof e.value?isNaN(e.value)?0n:e.value>e.type.maxValue?BigInt(e.type.maxValue):e.value<e.type.minValue?BigInt(e.type.minValue):BigInt(Math.trunc(e.value)):e.value;const t=2n**BigInt(8*e.type.bytes)-1n;if("unsigned"===e.type.type)n&=t;else{const i=BigInt(e.type.minValue);n=(n-i&t)+i}return{value:n,type:e.type}}}return{value:he({value:e.value,type:CArithmetic.U32}).value,type:e.type}}const pe=he;class GenError extends CError{constructor(e,n,t){super(void 0!==n?`In function '${n.fnName}': ${e}`:e,t),this.name="GenerationError"}}function _e(e,n,t){if(n instanceof CInitializer){if(t&&!n.type.equals(t))throw new GenError("Static initializer type mismatch",void 0,n.node);return function(e,n){let t;if(n.type instanceof CArray){if(void 0===n.type.length)throw new GenError("Array length still unknown?",void 0,n.node);t=n.body.flatMap(((t,i)=>be(_e(e,t,n.memberTypes[i]),n.memberTypes[i].bytes)))}else if(n.type instanceof CUnion)t=_e(e,n.body[0],n.memberTypes[0]);else{if(!(n.type instanceof CStruct))throw new GenError("Invalid initializer",void 0,n.node);t=[];for(let i=0;i<n.body.length;i++){we(t,n.memberTypes[i].alignment);const s=_e(e,n.body[i],n.memberTypes[i]);be(s,n.memberTypes[i].bytes),t.push(...s)}}return t}(e,n)}if(n instanceof CStringLiteral&&t instanceof CPointer)return function(e,n){const t=e.nextStaticAddr,i=ge(n);return e.nextStaticAddr+=i.length,e.module.dataSegment(t,i),ye(new CConstant(n.node,Z,BigInt(t)))}(e,n);if(n instanceof CStringLiteral)return ge(n);{t&&!n.type.equals(t)&&(n=new CCast(n.node,t,n));const i=function(e,n){const t=ue(e,n);if(t)return t;throw new ExpressionTypeError(e.node,"constant expression")}(n,((n,t,i)=>{if(n instanceof CAddressOf&&n.body instanceof CIdentifier){let t;if(t="variable"===n.body.value.declType?Oe(n.body.value):e.indirectIndex(n.body.value),void 0!==t)return pe({value:t,type:n.type})}else{if(n instanceof CAddressOf&&n.body instanceof CDereference){const e=t(n.body.body);return e?pe({value:e.value,type:n.type}):i(n)}if(n instanceof CIdentifier&&"function"===n.value.declType){const t=e.indirectIndex(n.value);return pe({value:t,type:new CPointer(n.node,n.type)})}if(n instanceof CIdentifier){const e=Oe(n.value);if(void 0!==e)return pe({value:e,type:new CPointer(n.node,n.type)})}else{if(n instanceof CStringLiteral){const t=e.nextStaticAddr,i=ge(n);return e.nextStaticAddr+=i.length,e.module.dataSegment(t,i),pe({value:t,type:n.type})}if(n instanceof CAddSub&&n.type instanceof CPointer){const e=t(n.lhs),s=t(n.rhs);if(!e||!s)return i(n);const r=e.type instanceof CPointer?BigInt(e.value):BigInt(n.type.type.bytes)*BigInt(e.value),o=s.type instanceof CPointer?BigInt(s.value):BigInt(n.type.type.bytes)*BigInt(s.value);return pe({value:r+o,type:n.type})}}}}));return ye(i,n.node)}}function me(e,n){const t=new ArrayBuffer(e);return n(new DataView(t)),[...new Uint8Array(t)]}function ye(e,n){if(CArithmetic.S64.equals(e.type))return me(8,(n=>n.setBigInt64(0,BigInt(e.value),!0)));if(CArithmetic.U64.equals(e.type))return me(8,(n=>n.setBigUint64(0,BigInt(e.value),!0)));if(CArithmetic.S32.equals(e.type))return me(4,(n=>n.setInt32(0,Number(e.value),!0)));if(CArithmetic.U32.equals(e.type)||e.type instanceof CPointer)return me(4,(n=>n.setUint32(0,Number(e.value),!0)));if(CArithmetic.S16.equals(e.type))return me(2,(n=>n.setInt16(0,Number(e.value),!0)));if(CArithmetic.U16.equals(e.type))return me(2,(n=>n.setUint16(0,Number(e.value),!0)));if(CArithmetic.S8.equals(e.type))return me(1,(n=>n.setInt8(0,Number(e.value))));if(CArithmetic.U8.equals(e.type))return me(1,(n=>n.setUint8(0,Number(e.value))));if(CArithmetic.Fp64.equals(e.type))return me(8,(n=>n.setFloat64(0,Number(e.value),!0)));if(CArithmetic.Fp32.equals(e.type))return me(4,(n=>n.setFloat32(0,Number(e.value),!0)));if(CArithmetic.BOOL.equals(e.type))return me(4,(n=>n.setInt32(0,0==e.value?0:1,!0)));throw new GenError("Unknown value type?",void 0,n)}function ge(e){return e.value.map(Number)}function be(e,n){for(;e.length<n;)e.push(0);return e}function we(e,n){for(;e.length%n!=0;)e.push(0);return e}function ve(e){return e instanceof CArithmetic?Le(e):e}function xe(e){if(e instanceof CArithmetic)return Le(e);if(e instanceof CPointer)return m;if(e instanceof CStruct||e instanceof CUnion)return m;if(e instanceof CVoid)throw new Error("Void cannot be stored");throw new Error(e.typeName+" doesn't have a real type")}function Ce(e,n){if(e.equals(n))return[];if(e instanceof CArithmetic&&n instanceof CArithmetic)return function(e,n){if(CArithmetic.BOOL.equals(n))return CArithmetic.Fp64.equals(e)?[k.f64.const(0),k.f64.ne()]:CArithmetic.Fp32.equals(e)?[k.f32.const(0),k.f32.ne()]:8===e.bytes?[k.i64.const(0n),k.i64.ne()]:[k.i32.const(0),k.i32.ne()];if(CArithmetic.Fp64.equals(n)){if(CArithmetic.Fp32.equals(e))return[k.f64.promote_f32()];if("signed"===e.type&&8===e.bytes)return[k.f64.convert_i64_s()];if("unsigned"===e.type&&8===e.bytes)return[k.f64.convert_i64_u()];if("signed"===e.type&&e.bytes<=4)return[k.f64.convert_i32_s()];if("unsigned"===e.type&&e.bytes<=4)return[k.f64.convert_i32_u()]}else if(CArithmetic.Fp32.equals(n)){if(CArithmetic.Fp64.equals(e))return[k.f32.demote_f64()];if("signed"===e.type&&8===e.bytes)return[k.f32.convert_i64_s()];if("unsigned"===e.type&&8===e.bytes)return[k.f32.convert_i64_u()];if("signed"===e.type&&e.bytes<=4)return[k.f32.convert_i32_s()];if("unsigned"===e.type&&e.bytes<=4)return[k.f32.convert_i32_u()]}else if(CArithmetic.U64.equals(n)){if(CArithmetic.Fp64.equals(e))return[k.i64.trunc_sat_f64_u()];if(CArithmetic.Fp32.equals(e))return[k.i64.trunc_sat_f32_u()];if(CArithmetic.S64.equals(e))return[];if("signed"===e.type)return[k.i64.extend_i32_u()];if("unsigned"===e.type)return[k.i64.extend_i32_u()]}else if(CArithmetic.S64.equals(n)){if(CArithmetic.Fp64.equals(e))return[k.i64.trunc_f64_s()];if(CArithmetic.Fp32.equals(e))return[k.i64.trunc_f32_s()];if(CArithmetic.U64.equals(e))return[];if("signed"===e.type)return[k.i64.extend_i32_s()];if("unsigned"===e.type)return[k.i64.extend_i32_u()]}else{if(CArithmetic.U32.equals(n))return CArithmetic.Fp64.equals(e)?[k.i32.trunc_sat_f64_u()]:CArithmetic.Fp32.equals(e)?[k.i32.trunc_sat_f32_u()]:8===e.bytes?[k.i32.wrap_i64()]:[];if(CArithmetic.S32.equals(n))return CArithmetic.Fp64.equals(e)?[k.i32.trunc_sat_f64_s()]:CArithmetic.Fp32.equals(e)?[k.i32.trunc_sat_f32_s()]:8===e.bytes?[k.i32.wrap_i64()]:[];if("signed"===n.type&&n.bytes<4){if("float"!==e.type&&e.bytes<n.bytes)return[];if(CArithmetic.BOOL.equals(e))return[];const t=[k.i32.const(32-8*n.bytes),k.i32.shl(),k.i32.const(32-8*n.bytes),k.i32.shr_s()];return CArithmetic.Fp64.equals(e)&&t.unshift(k.i32.trunc_f64_s()),CArithmetic.Fp32.equals(e)&&t.unshift(k.i32.trunc_f32_s()),"float"!==e.type&&8===e.bytes&&t.unshift(k.i32.wrap_i64()),t}if("unsigned"===n.type&&n.bytes<4){if(CArithmetic.BOOL.equals(e))return[];const t=[k.i32.const(2**(8*n.bytes)-1),k.i32.and()];return CArithmetic.Fp64.equals(e)&&t.unshift(k.i32.trunc_sat_f64_u()),CArithmetic.Fp32.equals(e)&&t.unshift(k.i32.trunc_sat_f32_u()),"float"!==e.type&&8===e.bytes&&t.unshift(k.i32.wrap_i64()),t}}throw new Error("Invalid arithmetic type")}(e,n);if(e instanceof CArithmetic&&"float"!==e.type&&n instanceof CPointer)return e.bytes>4?[k.i32.wrap_i64()]:[];if(n instanceof CArithmetic&&"float"!==n.type&&e instanceof CPointer)return[];if(n instanceof CPointer&&e instanceof CPointer)return[];if(e instanceof CFuncType&&n instanceof CPointer&&e.equals(n.type))return[];throw new Error(`Cannot convert ${e.typeName} to ${n.typeName}`)}function Le(e){if("float"===e.type)return 4===e.bytes?g:b;if(8===e.bytes)return y;if(e.bytes<=4)return m;throw new Error("Unknown type")}function Ee(e){return e instanceof CVoid||Ie(e)?[]:[xe(e)]}function Ie(e){return e instanceof CStruct||e instanceof CUnion}function Ae(e,n){const t=Math.ceil(e.nextStaticAddr/n.type.alignment)*n.type.alignment;if(e.nextStaticAddr=t+n.type.bytes,$e(n,{type:"static",address:t}),n.staticValue){const i=n.staticValue;return()=>e.module.dataSegment(t,_e(e,i,n.type))}}function Se(e,n){const t=[],i=[];for(const s of n.declarations)if(s instanceof CArgument&&(s.type instanceof CStruct||s.type instanceof CUnion?(e.shadowStackUsage=Math.ceil(e.shadowStackUsage/s.type.alignment)*s.type.alignment,$e(s,{type:"shadow",shadowOffset:e.shadowStackUsage}),t.push(...Re([k.local.get(e.builder.args[s.index])],[k.global.get(e.gen.shadowStackPtr),k.i32.const(e.shadowStackUsage),k.i32.add()],s.type.bytes)),e.shadowStackUsage+=s.type.bytes):s.addressUsed?(e.shadowStackUsage=Math.ceil(e.shadowStackUsage/s.type.alignment)*s.type.alignment,$e(s,{type:"shadow",shadowOffset:e.shadowStackUsage}),t.push(k.global.get(e.gen.shadowStackPtr)),t.push(k.local.get(e.builder.args[s.index])),t.push(De(s.type,e.shadowStackUsage)),e.shadowStackUsage+=s.type.bytes):$e(s,{type:"local",index:e.builder.args[s.index]})),s instanceof CVarDefinition)if("local"===s.storage)if(s.addressUsed||!(s.type instanceof CArithmetic||s.type instanceof CPointer))e.shadowStackUsage=Math.ceil(e.shadowStackUsage/s.type.alignment)*s.type.alignment,$e(s,{type:"shadow",shadowOffset:e.shadowStackUsage}),e.shadowStackUsage+=s.type.bytes;else{const n=e.builder.getTempLocal(xe(s.type));i.push(n),$e(s,{type:"local",index:n})}else if("static"===s.storage&&void 0===Ue(s))throw new GenError("In function static variable is not setup");return[t,()=>i.forEach((n=>e.builder.freeTempLocal(n)))]}function Te(e,n,t){const[i,s]=ke(e,t);return n instanceof CStruct||n instanceof CUnion||n instanceof CPointer&&n.original instanceof CArray?Ne(e,t):("local"===s.type?i.push(k.local.get(s.index)):"static"===s.type?i.push(k.i32.const(0),Me(n,s.address)):"shadow"===s.type?i.push(k.global.get(e.gen.shadowStackPtr),Me(n,s.shadowOffset)):"pointer"===s.type&&i.push(Me(n,0)),i)}function Fe(e,n,t,i,s){if(n instanceof CArray||n instanceof CStruct||n instanceof CUnion)throw new GenError("Cannot storageUpdate "+n.typeName,e,t.node);const[r,o]=ke(e,t);return"local"===o.type?(r.push(k.local.get(o.index),...i),s?r.push(k.local.tee(o.index)):r.push(k.local.set(o.index)),r):("static"===o.type?(r.push(k.i32.const(0),k.i32.const(0),Me(n,o.address),...i),s?r.push(...e.withTemporaryLocal(xe(n),(e=>[k.local.tee(e),De(n,o.address),k.local.get(e)]))):r.push(De(n,o.address))):"shadow"===o.type?(r.push(k.global.get(e.gen.shadowStackPtr),k.global.get(e.gen.shadowStackPtr)),r.push(Me(n,o.shadowOffset),...i),s?r.push(...e.withTemporaryLocal(xe(n),(e=>[k.local.tee(e),De(n,o.shadowOffset),k.local.get(e)]))):r.push(De(n,o.shadowOffset))):"pointer"===o.type&&(r.push(...e.withTemporaryLocal(m,(e=>[k.local.tee(e),k.local.get(e)]))),r.push(Me(n,0),...i),s?r.push(...e.withTemporaryLocal(xe(n),(e=>[k.local.tee(e),De(n,0),k.local.get(e)]))):r.push(De(n,0))),r)}function Ne(e,n){const[t,i]=ke(e,n);if("local"===i.type)throw new GenError("Local with addressed access stored in local. This shouldn't happen!",e,n.node);return"static"===i.type?t.push(k.i32.const(i.address)):"shadow"===i.type&&t.push(k.global.get(e.gen.shadowStackPtr),k.i32.const(i.shadowOffset),k.i32.add()),t}function ke(e,n){if(!n.lvalue)throw new GenError("Only lvalue expressions can have storage locations",e,n.node);if(n instanceof CIdentifier){let t=Ue(n.value);if(t)return[[],t];if(n.value instanceof CVarDeclaration){if(void 0===n.value.definition)throw new GenError("No variable definition found",e,n.node);if(t=Ue(n.value.definition),t)return[[],t]}}else{if(n instanceof CMemberAccess){const t=e.expression(n.body,!1);if(n.structUnion instanceof CStruct){let e=0;for(const t of n.structUnion.members){if(e=Math.ceil(e/t.type.alignment)*t.type.alignment,t.name===n.member)break;e+=t.type.bytes}return[[...t,k.i32.const(e),k.i32.add()],{type:"pointer"}]}return[t,{type:"pointer"}]}if(n instanceof CDereference)return[e.expression(n.body,!1),{type:"pointer"}]}throw new GenError("Invalid location expression",e,n.node)}function Oe(e){e instanceof CVarDeclaration&&e.definition&&(e=e.definition);const n=Ue(e);return"static"===n?.type?n.address:void 0}const Pe=Symbol("storage location");function $e(e,n){e[Pe]=n}function Ue(e){return e[Pe]}function Me(e,n){if(e instanceof CPointer)return k.i32.load(2,n);if(e instanceof CStruct||e instanceof CUnion||e instanceof CArray)throw new Error("Invalid "+e.typeName+" load");if(e instanceof CVoid||e instanceof CFuncType)throw new Error("Cannot load "+e.typeName);return"float"===e.type?8===e.bytes?k.f64.load(3,n):k.f32.load(2,n):8===e.bytes?k.i64.load(3,n):4===e.bytes?k.i32.load(2,n):"signed"===e.type?2===e.bytes?k.i32.load16_s(1,n):k.i32.load8_s(0,n):2===e.bytes?k.i32.load16_u(1,n):k.i32.load8_u(0,n)}function De(e,n){if(e instanceof CPointer)return k.i32.store(2,n);if(e instanceof CStruct||e instanceof CUnion||e instanceof CArray)throw new Error("Invalid "+e.typeName+" store");if(e instanceof CVoid||e instanceof CFuncType)throw new Error("Cannot store "+e.typeName);return"float"===e.type?8===e.bytes?k.f64.store(3,n):k.f32.store(2,n):8===e.bytes?k.i64.store(3,n):4===e.bytes?k.i32.store(2,n):2===e.bytes?k.i32.store16(1,n):k.i32.store8(0,n)}function Re(e,n,t){return[...n,...e,k.i32.const(t),k.memory.copy()]}var ze=t(428);const Ge=new Map;function Be(e,n=[]){for(const t of e){n.push(t),Be(t.children(),n),n.pop();for(const e of Ge.get(Object.getPrototypeOf(t).constructor)??[])e(t,n)}return e}class ParseTreeValidationError extends CError{constructor(e,n,t){super(e&&e.loc?`Line ${e.loc.first_line+1}: ${n}`:n,e,t),this.name="TreeValidationError"}}function qe(e,n){const t=Ge.get(e);t?t.push(n):Ge.set(e,[n])}const Ve=e=>{if(e.qualifierList.length>1)throw new ParseTreeValidationError(e,"Invalid qualifiers.");!function(e,n){if(e.every((e=>"string"==typeof e))&&!ne(e))throw new ParseTreeValidationError(n,"Invalid specifiers - "+e.join(", "))}(e.specifierList,e)};function Xe(e,n){for(let t=n.length-1;t>=0;t--){if(!(n[t]instanceof ze.Expression)||"sizeof"===n[t].type)return;if("constantExpr"===n[t].type)throw new ParseTreeValidationError(e,"Invalid constant expr.")}}qe(ze.SpecifierQualifiers,Ve),qe(ze.DeclarationSpecifiers,Ve),qe(ze.DeclarationSpecifiers,((e,n)=>{if(e.storageList.length>1)throw new ParseTreeValidationError(e,"Invalid storage class list.");if(e.fnSpecifierList.length>1)throw new ParseTreeValidationError(e,"Invalid fn specifier list.");if("typedef"===e.storageList[0]&&1!==n.length)throw new ParseTreeValidationError(e,"Nested typedefs are not allowed")})),qe(ze.UnaryExpression,((e,n)=>{switch(e.type){case"postfixIncrement":case"postfixDecrement":case"prefixIncrement":case"prefixDecrement":case"addressOf":case"dereference":Xe(e,n)}})),qe(ze.BinaryExpression,((e,n)=>{switch(e.type){case"comma":case"arraySubscript":Xe(e,n)}})),qe(ze.FunctionCallExpression,Xe),qe(ze.MemberAccessExpression,Xe);var We=t(347);const He=Object.fromEntries(["if","break","case","char","const","continue","default","do","double","else","enum","extern","float","for","inline","int","long","return","short","signed","sizeof","static","struct","switch","typedef","union","unsigned","void","while","_Bool","goto","auto","register","volatile","import"].map((e=>[e,e.toUpperCase()]))),je=[{type:e=>He[e]??"IDENTIFIER",regex:/[a-zA-Z_][a-zA-Z0-9_]*/},{type:e=>e,regex:new RegExp(["...","<<=",">>=","!=","%=","&&","&=","*=","++","+=","--","-=","->","/=","<<","<=","==",">=",">>","^=","|=","||","!","%","&","(",")","*","+",",","-",".","/",":",";","<","=",">","?","[","]","^","{","|","}","~"].map((e=>e.replace(/[.*+?^${}()|[\]\\]/g,"\\$&"))).join("|"))},{type:"CONSTANT_FLOAT",regex:/(?:[0-9]+[Ee][+-]?[0-9]+|(?:[0-9]*\.[0-9]+|[0-9]+\.[0-9]*)(?:[Ee][+-]?[0-9]+)?)[fFlL]?|(?:[1-9][0-9]*|0)[fF]/},{type:"CONSTANT_HEX",regex:/0[xX][a-fA-F0-9]+(?:[uU][lL]{0,2}|[lL]{1,2}[uU]?|)/},{type:"CONSTANT_OCTAL",regex:/0[0-7]+(?:[uU][lL]{0,2}|[lL]{1,2}[uU]?|)/},{type:"CONSTANT_INT",regex:/(?:[1-9][0-9]*|0)(?:[uU][lL]{0,2}|[lL]{1,2}[uU]?|)/},{type:"CONSTANT_CHAR",regex:/'(?:[^\\\n']|\\(?:.|x[0-9a-fA-F]{1,2}|[0-7]{1,3}))'/,value:e=>e.slice(1,-1)},{type:"STRING_LITERAL",regex:/"(?:[^\\\n"]|\\(?:[^x0-7\n]|x[0-9a-fA-F]{1,2}|[0-7]{1,3}))*"/,value:e=>e.slice(1,-1)}];class Lexer{constructor(){this.source="",this.index=0,this.line=0,this.col=0}next(){for(;this.index<this.source.length&&(" "===this.source[this.index]||"\t"===this.source[this.index]||"\v"===this.source[this.index]||"\f"===this.source[this.index]||"\n"===this.source[this.index]);)"\n"===this.source[this.index]?(this.line++,this.col=1):this.col++,this.index++;const e={first_line:this.line,first_column:this.col,last_line:this.line,last_column:this.col+1,source:this.source};if(this.index===this.source.length)return{type:"EOF",value:"",text:"",loc:e};Lexer.regex.lastIndex=this.index;const n=Lexer.regex.exec(this.source);if(!n)throw new LexerError(e);const t=n[0];this.index+=t.length,this.col+=t.length,e.last_column=this.col;let i=0;for(;void 0===n[i+1];)i++;const s=je[i];return{type:"function"==typeof s.type?s.type(t):s.type,value:s.value?.(t)??t,text:t,loc:e}}reset(e){this.source=e,this.index=0,this.line=0,this.col=1}}Lexer.regex=new RegExp(je.map((e=>"("+e.regex.source+")")).join("|"),"ym");class LexerError extends CError{constructor(e){super("Unknown token",new class extends ze.ParseNode{constructor(){super(...arguments),this.type="Unknown"}}(e)),this.name="LexerError"}}const Ze=new Lexer;const Ye=We;function Je(e){try{return Be(Ye.parse(e))}catch(e){throw e?.hash?.loc&&(e.message+="\n\n"+j(e.hash?.loc)),e}}Ye.parser.lexer=new class WrappedLexer{constructor(){this.types=new Map}lex(){const e=Ze.next();return this.yytext=e.value,this.yylloc=e.loc,this.yylineno=e.loc.first_line,"IDENTIFIER"===e.type&&this.types.get(e.text)?"TYPE_NAME":e.type}setInput(e){this.yytext=void 0,this.yylloc=void 0,this.yylineno=void 0,this.types.clear(),Ze.reset(e)}externalDeclaration(e){if("typedef"===e.typeInfo.storageList[0])for(let n of e.list){for(;!(n instanceof ze.IdentifierDeclarator);)n=n.body;this.types.set(n.id,!0)}}};const Ke=new class extends ze.ParseNode{constructor(){super({first_line:0,first_column:0,last_line:0,last_column:0,source:""}),this.type="__internal__"}},Qe={wasm:new CFuncDeclaration(Ke,"__wasm__",new CFuncType(Ke,new CVoid,[CArithmetic.U32],void 0,!0),"internal"),wasm_i32:new CFuncDeclaration(Ke,"__wasm_i32__",new CFuncType(Ke,CArithmetic.U32,[CArithmetic.U32],void 0,!0),"internal"),wasm_i64:new CFuncDeclaration(Ke,"__wasm_i64__",new CFuncType(Ke,CArithmetic.U64,[CArithmetic.U32],void 0,!0),"internal"),wasm_f32:new CFuncDeclaration(Ke,"__wasm_f32__",new CFuncType(Ke,CArithmetic.Fp32,[CArithmetic.U32],void 0,!0),"internal"),wasm_f64:new CFuncDeclaration(Ke,"__wasm_f64__",new CFuncType(Ke,CArithmetic.Fp64,[CArithmetic.U32],void 0,!0),"internal"),wasm_ssp:new CFuncDeclaration(Ke,"__wasm_ssp__",new CFuncType(Ke,new CPointer(Ke,new CVoid,!0),[]),"internal"),wasm_rload:new CFuncDeclaration(Ke,"__wasm_rload__",new CFuncType(Ke,new CPointer(Ke,new CVoid,!0),[new CPointer(Ke,new CVoid,!0)]),"internal")},en=new Scope;function nn(e,n,t){if(!(n.args[0]instanceof CConstant))throw new GenError("__wasm__ first argument should be integer constant specifying the number of parameters",e,n.args[0].node);const i=Number(n.args[0].value),s=n.args.slice(1,i+1),r=s.flatMap((n=>e.expression(n,!1))),o=n.args.slice(i+1).map((n=>{if(n instanceof CConstant)return Number(n.changeType(CArithmetic.U8).value);throw new GenError("__wasm__ instructions must be constants",e,n.node)}));return[...r,()=>({name:"arbitrary",type:"zeroArg",immediate:{},encoded:o,parameters:s.map((e=>xe(e.type))),result:t,reads:[],writes:["arbitraryCode","memory"],copy(){return()=>this}})]}function tn(e,n,t){return t?[]:[hn(Le(n.type),"const",n.value)]}function sn(e,n,t){const i=[];if(n.body instanceof CIdentifier&&(n.body.value instanceof CFuncDefinition||n.body.value instanceof CFuncDeclaration));else{if(!(n.body.type instanceof CFuncType||n.body.type instanceof CPointer&&n.body.type.type instanceof CFuncType))throw new GenError("Invalid fn call identifier",e,n.body.node);i.push(...cn(e,n.body,n.body.type))}const s=function(e,n,t){if(n.body instanceof CIdentifier)switch(n.body.value){case Qe.wasm:return nn(e,n,null);case Qe.wasm_i32:return nn(e,n,m);case Qe.wasm_i64:return nn(e,n,y);case Qe.wasm_f32:return nn(e,n,g);case Qe.wasm_f64:return nn(e,n,b);case Qe.wasm_ssp:return t?[]:[k.global.get(e.gen.shadowStackPtr)];case Qe.wasm_rload:if(n.args[0].type instanceof CPointer){const t=e.expression(n.args[0],!1),i=n.args[0].type.type;return(i instanceof CStruct||i instanceof CUnion)&&t.push(k.i32.load(2,0)),t}throw new GenError("__wasm_rload__ argument should be pointer");default:return}}(e,n,t);if(void 0!==s)return n.fnType.returnType.bytes>0&&t&&s.push(k.drop()),s;const r=n.fnType.parameterTypes.flatMap(((t,i)=>cn(e,n.args[i],t)));let o;Ie(n.fnType.returnType)&&(o=[k.global.get(e.gen.shadowStackPtr),k.i32.const(e.shadowStackUsage),k.i32.add()],e.shadowStackUsage+=4*Math.ceil(n.fnType.returnType.bytes/4),r.push(...o)),i.length>0&&r.push(...i);let a=e.shadowStackUsage;if(n.fnType.variadic){const t=[];for(let i=n.fnType.parameterTypes.length;i<n.args.length;i++){let s=n.args[i].type;s instanceof CArithmetic&&(s="float"===s.type?CArithmetic.Fp64:Q(s)),t.unshift(xe(s)),r.push(k.global.get(e.gen.shadowStackPtr),...cn(e,n.args[i],s))}a+=16;for(const e of t)r.push(hn(e,"store",e===y||e===b?3:2,a)),a+=8}if(a>0&&r.push(k.global.get(e.gen.shadowStackPtr),k.i32.const(a),k.i32.add(),k.global.set(e.gen.shadowStackPtr)),i.length>0)r.push(k.call_indirect(e.gen.typeIndex(n.fnType)));else{const t=n.body.value;r.push(k.call(e.gen.functionIndex(t)))}return t&&Ee(n.fnType.returnType).length&&r.push(k.drop()),a>0&&r.push(k.global.get(e.gen.shadowStackPtr),k.i32.const(a),k.i32.sub(),k.global.set(e.gen.shadowStackPtr)),!t&&o&&r.push(...o),r}function rn(e,n,t){const i=n.type instanceof CPointer?n.type.type.bytes:1,s=xe(n.type);return"post"!==n.pos||t?Fe(e,n.body.type,n.body,[pn(s,i),hn(s,"++"===n.op?"add":"sub")],!t&&"pre"===n.pos):function(e,n,t,i){if(n instanceof CArray||n instanceof CStruct||n instanceof CUnion)throw new GenError("Cannot storageGetThenUpdate "+n.typeName,e,t.node);const[s,r]=ke(e,t);return"local"===r.type?(s.push(k.local.get(r.index)),s.push(k.local.get(r.index),...i,k.local.set(r.index))):"static"===r.type?(s.push(k.i32.const(0),k.i32.const(0),Me(n,r.address)),s.push(...e.withTemporaryLocal(xe(n),(e=>[k.local.tee(e),...i,De(n,r.address),k.local.get(e)])))):"shadow"===r.type?(s.push(k.global.get(e.gen.shadowStackPtr),k.global.get(e.gen.shadowStackPtr)),s.push(Me(n,r.shadowOffset)),s.push(...e.withTemporaryLocal(xe(n),(e=>[k.local.tee(e),...i,De(n,r.shadowOffset),k.local.get(e)])))):"pointer"===r.type&&(s.push(...e.withTemporaryLocal(m,(e=>[k.local.tee(e),k.local.get(e)]))),s.push(Me(n,0)),s.push(...e.withTemporaryLocal(xe(n),(e=>[k.local.tee(e),...i,De(n,0),k.local.get(e)])))),s}(e,n.body.type,n.body,[pn(s,i),hn(s,"++"===n.op?"add":"sub")])}function on(e,n,t){if(void 0===n.assignmentType||n.rhs instanceof CInitializer){if(n.rhs instanceof CInitializer){const i=[];if(n.rhs.type instanceof CArray)for(let t=0;t<n.rhs.body.length;t++){const s=n.rhs.body[t],r=new CAddSub(n.lhs.node,n.lhs,new CConstant(n.lhs.node,Z,BigInt(t)),"+"),o=new CDereference(n.lhs.node,r),a=new CAssignment(s.node,o,s,void 0,n.initialAssignment);i.push(...an(e,a,!0))}else if(n.rhs.type instanceof CUnion){const t=new CAddressOf(n.lhs.node,n.lhs),s=new CMemberAccess(n.rhs.node,t,n.rhs.type.members[0].name),r=new CAssignment(n.rhs.body[0].node,s,n.rhs.body[0],void 0,!0);i.push(...an(e,r,!0))}else{if(!(n.rhs.type instanceof CStruct))throw new GenError("Unknown initializer",e,n.node);{const t=new CAddressOf(n.lhs.node,n.lhs);for(let s=0;s<n.rhs.body.length;s++){const r=new CMemberAccess(n.rhs.node,t,n.rhs.type.members[s].name),o=new CAssignment(n.rhs.body[s].node,r,n.rhs.body[s],void 0,!0);i.push(...an(e,o,!0))}}}return t||i.push(...an(e,n.lhs,!1)),i}return function(e,n,t,i,s){const[r,o]=ke(e,t),a=e.expression(i,!1);return a.push(...Ce(i.type,t.type)),n instanceof CStruct||n instanceof CUnion||n instanceof CArray?Re(a,Ne(e,t),n.bytes):("local"===o.type?r.push(...a,s?k.local.tee(o.index):k.local.set(o.index)):"static"===o.type?(r.push(k.i32.const(0),...a),s?r.push(...e.withTemporaryLocal(xe(n),(e=>[k.local.tee(e),De(n,o.address),k.local.get(e)]))):r.push(De(n,o.address))):"shadow"===o.type?(r.push(k.global.get(e.gen.shadowStackPtr),...a),s?r.push(...e.withTemporaryLocal(xe(n),(e=>[k.local.tee(e),De(n,o.shadowOffset),k.local.get(e)]))):r.push(De(n,o.shadowOffset))):"pointer"===o.type&&(r.push(...a),s?r.push(...e.withTemporaryLocal(xe(n),(e=>[k.local.tee(e),De(n,0),k.local.get(e)]))):r.push(De(n,0))),r)}(e,n.lhs.type,n.lhs,n.rhs,!t)}{let i;i="mul"===n.assignmentType?new CMulDiv(n.node,n.lhs,n.rhs,"*"):"div"===n.assignmentType?new CMulDiv(n.node,n.lhs,n.rhs,"/"):"mod"===n.assignmentType?new CMod(n.node,n.lhs,n.rhs):"add"===n.assignmentType?new CAddSub(n.node,n.lhs,n.rhs,"+"):"sub"===n.assignmentType?new CAddSub(n.node,n.lhs,n.rhs,"-"):"leftShift"===n.assignmentType?new CShift(n.node,n.lhs,n.rhs,"left"):"rightShift"===n.assignmentType?new CShift(n.node,n.lhs,n.rhs,"right"):"bitwiseAnd"===n.assignmentType?new CBitwiseAndOr(n.node,n.lhs,n.rhs,"and"):"bitwiseXor"===n.assignmentType?new CBitwiseAndOr(n.node,n.lhs,n.rhs,"xor"):new CBitwiseAndOr(n.node,n.lhs,n.rhs,"or");const s=an(e,i,!1),r=an(e,n.lhs,!1),o=s.slice(r.length);return o.push(...Ce(i.type,n.lhs.type)),Fe(e,n.lhs.type,n.lhs,o,!t)}}function an(e,n,t){if(!t&&n.type instanceof CArithmetic&&!(n instanceof CConstant)&&a().generation_try_constant_expr){const e=ue(n);if(e)return tn(0,new CConstant(n.node,n.type,e.value),!1)}return n instanceof CConstant?tn(0,n,t):n instanceof CIdentifier?function(e,n,t){return t?[]:n.value instanceof CFuncDefinition||n.value instanceof CFuncDeclaration?[k.i32.const(e.gen.indirectIndex(n.value))]:Te(e,n.type,n)}(e,n,t):n instanceof CStringLiteral?function(e,n,t){if(t)return[];const i=e.gen.nextStaticAddr;return e.gen.nextStaticAddr+=n.value.length,e.gen.module.dataSegment(i,n.value.map(Number)),[k.i32.const(i)]}(e,n,t):n instanceof CFunctionCall?sn(e,n,t):n instanceof CMemberAccess?function(e,n,t){return t?an(e,n.body,!0):Te(e,n.type,n)}(e,n,t):n instanceof CIncrDecr?rn(e,n,t):n instanceof CAddressOf?function(e,n,t){return t?an(e,n.body,!0):n.body instanceof CIdentifier&&(n.body.value instanceof CFuncDefinition||n.body.value instanceof CFuncDeclaration)?[k.i32.const(e.gen.indirectIndex(n.body.value))]:Ne(e,n.body)}(e,n,t):n instanceof CDereference?function(e,n,t){return t?an(e,n.body,!0):n.type instanceof CPointer&&n.type.original instanceof CFuncType?an(e,n.body,!1):Te(e,n.type,n)}(e,n,t):n instanceof CUnaryPlusMinus?function(e,n,t){if(t)return an(e,n.body,!0);const i=an(e,n.body,!1);if("-"===n.op){const e=ve(n.body.type);e===g||e===b?i.push(un(e,"neg")):(i.unshift(pn(e,0)),i.push(hn(e,"sub")))}return i}(e,n,t):n instanceof CBitwiseNot?function(e,n,t){if(t)return an(e,n.body,!0);const i=Le(n.type);return[...cn(e,n.body,n.type),dn(i,"const",-1n),dn(i,"xor")]}(e,n,t):n instanceof CLogicalNot?function(e,n,t){if(t)return an(e,n.body,!0);const i=an(e,n.body,!1),s=xe(n.body.type);return fn(s)?[...i,dn(s,"eqz")]:[...i,un(s,"const",0),un(s,"eq")]}(e,n,t):n instanceof CSizeof?function(e,n,t){return t?[]:[k.i32.const(n.body.bytes)]}(0,n,t):n instanceof CCast?function(e,n,t){return t?an(e,n.body,!0):[...an(e,n.body,!1),...Ce(n.body.type,n.type)]}(e,n,t):n instanceof CMulDiv?function(e,n,t){if(t)return[...an(e,n.lhs,!0),...an(e,n.rhs,!0)];const i=[...cn(e,n.lhs,n.type),...cn(e,n.rhs,n.type)],s=Le(n.type);return fn(s)?"*"===n.op?i.push(dn(s,"mul")):i.push("signed"===n.type.type?dn(s,"div_s"):dn(s,"div_u")):i.push("*"===n.op?un(s,"mul"):un(s,"div")),i}(e,n,t):n instanceof CMod?function(e,n,t){if(t)return[...an(e,n.lhs,!0),...an(e,n.rhs,!0)];const i=Le(n.type);return"signed"===n.type.type?[...cn(e,n.lhs,n.type),...cn(e,n.rhs,n.type),dn(i,"rem_s")]:[...cn(e,n.lhs,n.type),...cn(e,n.rhs,n.type),dn(i,"rem_u")]}(e,n,t):n instanceof CAddSub?function(e,n,t){if(t)return[...an(e,n.lhs,!0),...an(e,n.rhs,!0)];if(n.type instanceof CArithmetic){const i=cn(e,n.lhs,n.type),s=cn(e,n.rhs,n.type),r=Le(n.type);return[...i,...s,"+"===n.op?hn(r,"add"):hn(r,"sub")]}{function o(t){if(t.type instanceof CPointer)return e.expression(t,!1);{const i=cn(e,t,CArithmetic.U32),s=n.type.type.bytes;return s>1&&i.push(k.i32.const(s),k.i32.mul()),i}}return[...o(n.lhs),...o(n.rhs),"+"===n.op?k.i32.add():k.i32.sub()]}}(e,n,t):n instanceof CShift?function(e,n,t){if(t)return[...an(e,n.lhs,!0),...an(e,n.rhs,!0)];const i=Le(n.type);return"left"===n.dir?[...cn(e,n.lhs,n.type),...cn(e,n.rhs,n.type),dn(i,"shl")]:"signed"===n.type.type?[...cn(e,n.lhs,n.type),...cn(e,n.rhs,n.type),dn(i,"shr_s")]:[...cn(e,n.lhs,n.type),...cn(e,n.rhs,n.type),dn(i,"shr_u")]}(e,n,t):n instanceof CRelational?function(e,n,t){if(t)return[...an(e,n.lhs,!0),...an(e,n.rhs,!0)];const i=Le(n.commonType);return fn(i)?"signed"===n.commonType.type?[...cn(e,n.lhs,n.commonType),...cn(e,n.rhs,n.commonType),"LT"===n.op?dn(i,"lt_s"):"GT"===n.op?dn(i,"gt_s"):"LEq"===n.op?dn(i,"le_s"):dn(i,"ge_s")]:[...cn(e,n.lhs,n.commonType),...cn(e,n.rhs,n.commonType),"LT"===n.op?dn(i,"lt_u"):"GT"===n.op?dn(i,"gt_u"):"LEq"===n.op?dn(i,"le_u"):dn(i,"ge_u")]:[...cn(e,n.lhs,n.commonType),...cn(e,n.rhs,n.commonType),"LT"===n.op?un(i,"lt"):"GT"===n.op?un(i,"gt"):"LEq"===n.op?un(i,"le"):un(i,"ge")]}(e,n,t):n instanceof CEquality?function(e,n,t){return t?[...an(e,n.lhs,!0),...an(e,n.rhs,!0)]:[...cn(e,n.lhs,n.commonType),...cn(e,n.rhs,n.commonType),hn(Le(n.commonType),"=="===n.op?"eq":"ne")]}(e,n,t):n instanceof CBitwiseAndOr?function(e,n,t){return t?[...an(e,n.lhs,!0),...an(e,n.rhs,!0)]:[...cn(e,n.lhs,n.type),...cn(e,n.rhs,n.type),dn(Le(n.type),n.op)]}(e,n,t):n instanceof CLogicalAndOr?function(e,n,t){return t?[...an(e,n.lhs,!0),...an(e,n.rhs,!0)]:"and"===n.op?[...ln(e,n.lhs),k.if(m,ln(e,n.rhs,!1),[k.i32.const(0n)])]:[...ln(e,n.lhs),k.if(m,[k.i32.const(1n)],ln(e,n.rhs,!1))]}(e,n,t):n instanceof CConditional?function(e,n,t){const i=ln(e,n.test);if(t){const t=an(e,n.trueValue,!0),s=an(e,n.falseValue,!0);return 0===t.length&&0===s.length?[]:[...i,k.if(null,t,s)]}return[...i,k.if(xe(n.type),cn(e,n.trueValue,n.type),cn(e,n.falseValue,n.type))]}(e,n,t):n instanceof CAssignment?on(e,n,t):function(e,n,t){return[...an(e,n.lhs,!0),...an(e,n.rhs,t)]}(e,n,t)}function cn(e,n,t,i=!1){return an(e,new CCast(n.node,t,n),i)}function ln(e,n,t=!0){const i=ve(n.type);if(i===m||i instanceof CPointer)return t||CArithmetic.BOOL.equals(n.type)?an(e,n,!1):[...an(e,n,!1),k.i32.const(0n),k.i32.ne()];if("number"!=typeof i)throw new GenError("Invalid condition",e,n.node);return[...an(e,n,!1),pn(i,0),hn(i,"ne")]}function fn(e){return e===m||e===y}function un(e,n,...t){if("number"!=typeof e)throw new Error("Instructions can only operate on value types");if(e===g)return k.f32[n](...t);if(e===b)return k.f64[n](...t);throw new Error("Invalid value type for floating point instruction")}function dn(e,n,...t){if("number"!=typeof e)throw new Error("Instructions can only operate on value types");if(e===m)return k.i32[n](...t);if(e===y)return k.i64[n](...t);throw new Error("Invalid value type for integer instruction")}function hn(e,n,...t){if("number"!=typeof e)throw new Error("Instructions can only operate on value types");if(e===m)return k.i32[n](...t);if(e===y)return k.i64[n](...t);if(e===g)return k.f32[n](...t);if(e===b)return k.f64[n](...t);throw new Error("Invalid value type?")}function pn(e,n){if("number"!=typeof e)throw new Error("Constants can only take value types");if(e!==(0|e))throw new Error("Invalid generic constant - not integer");if(e===m)return k.i32.const(BigInt(n));if(e===y)return k.i64.const(BigInt(n));if(e===g)return k.f32.const(n);if(e===b)return k.f64.const(n);throw new Error("Invalid value type?")}function _n(e){let n=e.instr.parameters.length;for(let t=e.instrIndex-1;t>=0;t--){const i=e.expr.instructions[t];if(i.result&&n--,0===n)return i;n+=i.parameters.length}}function mn(e){"local.tee"===e.instr.name?e.expr.replace(e.instrIndex,e.instrIndex+1,k.nop()):"local.set"===e.instr.name&&e.expr.replace(e.instrIndex,e.instrIndex+1,k.drop())}Object.values(Qe).forEach((e=>en.addIdentifier(e)));const yn=[];function gn(e){const n=a(),t=e.body;e.instrCounts.push({name:"before opt",count:bn(t)});for(const i of yn)i.enabled(n)&&(i.run(t),e.instrCounts.push({name:i.name,count:bn(t)}))}function bn(e){let n=e.instructions.length;for(const t of e.instructions)"structured"===t.type&&(n+=bn(t.immediate.expression),t.immediate.expression2&&(n+=bn(t.immediate.expression2)));return n}function wn(e){const n=a();R(e,M.filter((e=>e.enabled(n))).map((e=>[e.run,e.peepholeSize])))}yn.push({name:"Peephole optimisations",enabled:()=>!0,run:wn}),yn.push({name:"Partial redundancy elimination",enabled:e=>e.partial_redundancy_elimination,run:function(e){const n=B(e);if(!n.all.length)return;const t=function(e){const n=[],t=[e];let i;for(;void 0!==(i=t.shift());){const{instructions:e}=i;e:for(const[s,r]of e.entries()){if("structured"===r.type){t.push(r.immediate.expression),r.immediate.expression2&&t.push(r.immediate.expression2);continue}if(r.parameters.length||r.writes.length||!r.result)continue;const o=[r.result],a=new Set(r.reads);for(let t=s+1;t<e.length;t++){const r=e[t];if(r.parameters.length>o.length||r.writes.length)continue e;o.splice(0,r.parameters.length),r.result&&o.unshift(r.result);for(const e of r.reads)a.add(e);if(1===o.length&&t-s>=2){const r={start:s,end:t,expr:i},c={positions:[r],resources:a,type:o[0],instructions:e.slice(s,t+1),bit:1n<<BigInt(n.length)},l=n.find((e=>{return t=c,(n=e).type===t.type&&n.instructions.length===t.instructions.length&&n.instructions.every(((e,n)=>{const i=e.encoded,s=t.instructions[n].encoded;return i.length===s.length&&i.every(((e,n)=>e===s[n]))}));var n,t}));l?l.positions.push(r):n.push(c)}}}}return n}(e);if(!t.length)return;const{INSERT:i,INSERT_EDGE:s,REPLACE:r}=W(n,t);if(0===i.size&&0===s.size&&0===r.size)return;const o=function(e,{INSERT:n,INSERT_EDGE:t,REPLACE:i}){const s=[];for(const r of e){const e=[];for(const[t,i]of n.entries())i&r.bit&&(t.instr?e.push(t):e.push(...t.flowNext));const o=[];for(const[n,i]of t.entries())for(const[t,s]of i)s&r.bit&&(n.instr&&t.instr?o.push([n,t]):e.push(t));const a=[];for(const[e,n]of i.entries())n&r.bit&&a.push(e);if(e.length+o.length&&a.length){const n=a[0].expr.builder.addLocal(r.type),t=[...r.instructions,k.local.set(n)],i=[k.local.get(n)];s.push({expression:r,insertBefore:e,insertBetween:o,insertAfter:[],insertInstructions:t,replacementFlows:a,replacementInstructions:i,fnLengthChange:0})}}for(const e of s){for(const n of new Set(e.insertBetween.map((([e])=>e))))[...n.flowNext].every((t=>t.instr&&(e.insertBetween.find((([e,i])=>n===e&&t===i))||e.insertBefore.includes(t))))&&(e.insertBetween=e.insertBetween.filter((([e])=>n!==e)),e.insertBefore=e.insertBefore.filter((e=>-1===n.flowNext.indexOf(e))),"structured"===n.instr.type?e.insertBefore.push(n):e.insertAfter.push(n));const n=e.insertInstructions.length*(e.insertBefore.length+e.insertBetween.length+e.insertAfter.length),t=(e.expression.instructions.length-e.replacementInstructions.length)*e.replacementFlows.length;e.fnLengthChange=n-t}return s}(t,{INSERT:i,INSERT_EDGE:s,REPLACE:r});!function(e){e.sort(((e,n)=>{const t=e.fnLengthChange-n.fnLengthChange;return 0!==t?t:n.expression.instructions.length-e.expression.instructions.length}));const n=[];for(let t=0;t<e.length;t++){const i=e[t],s=i.expression.instructions.length,r=i.replacementFlows.map((e=>[e.expr,e.instrIndex-s,e.instrIndex]));r.some((([e,t,i])=>n.some((([n,s,r])=>e===n&&i>=s&&r>=t))))?(e.splice(t,1),t--):n.push(...r)}}(o);const a=new InstrSplicer;for(const e of o){const n=e.expression.instructions.length;for(const t of e.replacementFlows)a.splice(t,n,e.replacementInstructions,1-n);for(const n of e.insertBefore)a.splice(n,0,e.insertInstructions,0);for(const n of e.insertAfter)n.instr.name.startsWith("br")?a.splice(n,0,e.insertInstructions,0):a.splice(n,0,e.insertInstructions,1);for(const[n,t]of e.insertBetween)if(n.expr===t.expr&&n.instrIndex+1===t.instrIndex)a.splice(t,0,e.insertInstructions);else if(a.realIndex(n)+1===n.expr.instructions.length)a.splice(n,0,e.insertInstructions,n.instr.name.startsWith("br")?0:1);else if(n.instr.name.startsWith("br"))a.splice(n,0,e.insertInstructions);else if(t.expr.parent===n.instr&&0===t.instrIndex)a.splice(t,0,e.insertInstructions);else{if(!(n.expr.depth>t.expr.depth))throw new Error("Unknown PRE insertion");a.splice(n,0,e.insertInstructions,n.instr.name.startsWith("br")?0:1)}}}}),yn.push({name:"Dead code elimination",enabled:e=>e.dead_code_elimination,run:P}),yn.push({name:"Copy propagation",enabled:e=>e.copy_propagation,run:function(e){const{definitions:n,reaching:t,localMasks:i}=function(e){const n=q(e,(e=>e.name.startsWith("local."))),t=new Map,i=new Map,s=[],r=Array(e.builder.args.length+e.builder.locals.length).fill(0n);let o=0n;for(let n=0n;n<e.builder.args.length;n++){const e={local:n,type:"arg",possibleUses:[],definiteUses:[],bit:1n<<BigInt(s.length)};o|=e.bit,r[Number(n)]|=e.bit,s.push(e)}t.set(n.entry,o);for(const e of n.all)if("index"===e.instr.type&&("local.set"===e.instr.name||"local.tee"===e.instr.name)){const n={local:e.instr.immediate.value,type:e.instr.name,possibleUses:[],definiteUses:[],flow:e,bit:1n<<BigInt(s.length)};r[Number(n.local)]|=n.bit,i.set(e,n),s.push(n)}V(n,null,t,"forwards","union",((e,n)=>{const t=i.get(e);return t&&(n&=~r[Number(t.local)],n|=t.bit),n}));for(const[e,n]of t.entries()){if(!e.instr||"index"!==e.instr.type||"local.get"!==e.instr.name)continue;const t=e.instr.immediate.value,i=[];for(let e=0,o=n&r[Number(t)];o;e++)1n&o&&i.push(s[e]),o>>=1n;1===i.length&&i[0].definiteUses.push(e),i.forEach((n=>n.possibleUses.push(e)))}return{definitions:s,reaching:t,localMasks:r}}(e);if(n.length)for(const e of n){if("arg"===e.type)continue;if(0===e.possibleUses.length){mn(e.flow);continue}if(0===e.definiteUses.length)continue;const n=_n(e.flow);if("constant"===n?.type){const t=hn(e.flow.instr.parameters[0],"const",n.immediate.value);for(const n of e.definiteUses)n.expr.replace(n.instrIndex,n.instrIndex+1,t)}else{if("index"!==n?.type||"local.get"!==n.name&&"local.tee"!==n.name)continue;{const s=[...e.flow.flowPrevious].find((n=>n.instr&&n.instrIndex===e.flow.instrIndex-1&&n.expr===e.flow.expr));if(!s)continue;const r=Number(n.immediate.value),o=(t.get(s)??0n)&i[r],a=k.local.get(r);let c=!0;for(const n of e.definiteUses)o===((t.get(n)??0n)&i[r])?n.expr.replace(n.instrIndex,n.instrIndex+1,a):c=!1;if(!c)continue}}e.definiteUses.length===e.possibleUses.length&&mn(e.flow)}}}),yn.push({name:"Local live range splitting",enabled:e=>e.live_range_splitting,run:function(e){const n=q(e,(e=>e.name.startsWith("local."))),t=new Map,i=new Map,s=n.entry.flowNext.slice();let r;for(;void 0!==(r=s.shift());){const n=[];for(const e of r.flowPrevious)for(const[i,s]of(t.get(e)??[]).entries())s&&(void 0!==n[i]?n[i]=n[i].merge(s):n[i]=s.get());if(r.instr&&"index"===r.instr.type&&("local.set"===r.instr.name||"local.tee"===r.instr.name)){const t=Number(r.instr.immediate.value)-e.builder.args.length;if(t>=0){let e=i.get(r);e||i.set(r,e=new LocalRange(r.instr.parameters[0])),n[t]=e}}const o=t.get(r);if(!o||o.length!==n.length||o.some(((e,t)=>n[t]!==e))){t.set(r,n);for(const e of r.flowNext)s.push(e)}}const o=[...new Set([...i.values()].map((e=>e.get())))];if(!(o.length<=e.builder.locals.length)){e.builder.wipeLocals();for(const n of o)n.newLocal=e.builder.addLocal(n.type);for(const[n,i]of t.entries()){if(!n.instr||"index"!==n.instr.type)continue;const t=Number(n.instr.immediate.value)-e.builder.args.length;t<0||("local.get"===n.instr.name?n.expr.replace(n.instrIndex,n.instrIndex+1,k.local.get(i[t].getNewLocal())):"local.set"===n.instr.name?n.expr.replace(n.instrIndex,n.instrIndex+1,k.local.set(i[t].getNewLocal())):"local.tee"===n.instr.name&&n.expr.replace(n.instrIndex,n.instrIndex+1,k.local.tee(i[t].getNewLocal())))}}}}),yn.push({name:"Reallocate locals",enabled:e=>e.reallocate_locals,run:function(e){if(e.builder.locals.length<=1)return;const n=q(e,(e=>e.name.startsWith("local."))),t=new Map,i=BigInt(e.builder.args.length);V(n,null,t,"backwards","union",((e,n)=>{if(e.instr&&"index"===e.instr.type){const t=1n<<e.instr.immediate.value-i;if("local.get"===e.instr.name)return n|t;if("local.set"===e.instr.name||"local.tee"===e.instr.name)return n&~t}return n}));const s=e.builder.locals.map((({type:e},n)=>({local:n,type:e,clash:new Set})));for(let e of t.values()){if(0n===e)continue;const n=[];for(let t=0;e;t++)1n&e&&n.push(t),e>>=1n;if(!(n.length<=1))for(const e of n)for(const t of n)e!==t&&s[e].clash.add(t)}const r=[],o=s.map((({local:e,clash:n})=>({local:e,clash:new Set(n)})));for(;o.length;){o.sort(((e,n)=>e.clash.size-n.clash.size));const{local:e}=o.shift();r.push(e);for(const n of o)n.clash.delete(e)}e.builder.wipeLocals();const a=[],c=Array(s.length);for(;r.length;){const n=r.pop(),{type:t}=s[n],i=new Set;for(const e of s[n].clash)c[e]&&i.add(c[e]);let o;for(const e of a)if(e.type===t&&!i.has(e)){o=e;break}o||a.push(o=e.builder.addLocal(t)),c[n]=o}c.unshift(...e.builder.args),X(e,c)}}),yn.push({name:"Dead code elimination 2nd pass",enabled:e=>e.dead_code_elimination,run:P}),yn.push({name:"Remove unused locals",enabled:e=>e.unused_locals,run:e=>{const n=new Set;for(const t of[...e.writes,...e.reads])t instanceof WLocal&&!t.isArgument&&n.add(t);if(n.size===e.builder.locals.length)return;const t=e.builder.args.slice();t.push(...e.builder.locals);for(const t of e.builder.locals.slice())n.has(t)||e.builder.deleteLocal(t);X(e,t)}}),yn.push({name:"Peephole optimisations 2nd pass",enabled:e=>e.peephole_2nd_pass,run:wn});class WImportedFunction{constructor(e,n,t,i){this.parent=e,this.type=n,this.module=t,this.name=i}getIndex(){return this.parent._funcIndex(this)}getTableIndex(){return this.parent._tableIndex(this)}}class WFunction{constructor(e,n,t){this.parent=e,this.type=n,this.exportName=t,this.hints={inline:!1},this.instrCounts=[]}getIndex(){return this.parent._funcIndex(this)}getTableIndex(){return this.parent._tableIndex(this)}define(e){if(void 0!==this._builder)throw new Error("Wasm function already defined");this._builder=new WFunctionBuilder(this,e),gn(this);const n=this._builder.expr;if(this.type[1].length>0){const e=n.get(-1);"return"===e.name?n.pop():0===n.stack.length&&"unreachable"!==e.name&&n.push(k.unreachable())}}toBytes(){if(void 0===this._builder)throw new Error("Wasm function body not defined");const e=[];let n=null,t=0n;for(const i of this.locals)i===n?t++:(n&&e.push([t,n]),n=i,t=1n);n&&e.push([t,n]);const i=C(e.map((e=>[...f(e[0]),e[1]])));return i.push(...this._builder.expr.encoded),i.unshift(...f(BigInt(i.length))),i}get locals(){return this._builder?.locals?.map((e=>e.type))??[]}get body(){if(!this._builder)throw new Error("Wasm function body is not yet defined");return this._builder.expr}}class WFunctionBuilder{constructor(e,n){this.fn=e,this._locals=[],this._freeTempLocals=[],this._arguments=e.type[0].map((e=>new WLocal(this._localidx.bind(this),e,!0))),this.expr=new WExpression(null,0,this),this.expr.push(...n(this))}get locals(){return this._locals}addLocal(e){const n=new WLocal(this._localidx.bind(this),e,!1);return this._locals.push(n),n}getTempLocal(e){const n=this._freeTempLocals.findIndex((n=>n.type===e));return n<0?this.addLocal(e):this._freeTempLocals.splice(n,1)[0]}freeTempLocal(e){a().reallocate_locals||this._freeTempLocals.push(e)}deleteLocal(e){const n=this._locals.indexOf(e);n>=0&&this._locals.splice(n,1)}wipeLocals(){this._locals.splice(0,this._locals.length)}get args(){return this._arguments}get self(){return{getIndex:this.fn.getIndex.bind(this.fn)}}get type(){return this.fn.type}getLocal(e){const n=Number(e);return e<this._arguments.length?this._arguments[n]:this._locals[n-this._arguments.length]}_localidx(e){let n=this._arguments.indexOf(e);if(n>=0)return BigInt(n);if(n=this._locals.indexOf(e),n>=0)return BigInt(this._arguments.length+n);throw"Local not found?"}}class WLocal{constructor(e,n,t){this.lookup=e,this.type=n,this.isArgument=t}getIndex(){return this.lookup(this)}}class ModuleBuilder{constructor(){this._functions=[],this._importedFunctions=[],this._functionTable=[],this._functionTypes=[],this._globals=[],this._dataSegments=[]}function(e,n,t,i){const s=new WFunction(this,[e,n],i);return this._functions.push(s),t&&s.define(t),s}importFunction(e,n,t,i){if(this._functions.length>0)throw new Error("Cannot define an imported functions after defining normal functions");const s=new WImportedFunction(this,[e,n],t,i);return this._importedFunctions.push(s),s}global(e,n,t,i){const s=new WGlobal(this,e,n,t,i);return this._globals.push(s),s}setupMemory(e,n){if(e<1||void 0!==n&&n<e)throw new Error("Invalid memory size");this._memory=void 0===n?[BigInt(e)]:[BigInt(e),BigInt(n)]}dataSegment(e,n){let t=0;for(;t<n.length&&0===n[t];)t++;for(n=n.slice(t),e+=t;n.length&&0===n[n.length-1];)n.pop();n.length&&this._dataSegments.push([e,n])}byteList(){const e=this._encodeImports(),n=this._functions.map((e=>f(this._typeIndex(e.type)))),t=this._functions.map((e=>e.toBytes()));this.emitCallback&&this.emitCallback();const i=[];return this.startFunction&&(i.push(...f(this.startFunction.getIndex())),i.unshift(8,...f(BigInt(i.length)))),[0,97,115,109,1,0,0,0,...vn(1,this._functionTypes.map(v)),...vn(2,e),...vn(3,n),...vn(4,this._encodeTable()),...vn(5,this._memory?[x(this._memory)]:[]),...vn(6,this._globals.map((e=>e.toBytes()))),...vn(7,this._encodeExports()),...i,...vn(9,this._encodeElements()),...vn(10,t),...vn(11,this._encodeDataSegments())]}toBytes(){return new Uint8Array(this.byteList())}async execute(e){return(await WebAssembly.instantiate(this.toBytes(),e)).instance.exports}_encodeImports(){const e=[];for(const n of this._importedFunctions)e.push([...p(n.module),...p(n.name),0,...f(this._typeIndex(n.type))]);return e}_encodeTable(){if(0===this._functionTable.length)return[];const e=BigInt(this._functionTable.length);return[[112,...x([e,e])]]}_encodeExports(){const e=[];for(const n of this._functions)n.exportName&&e.push([...p(n.exportName),0,...f(n.getIndex())]);for(const n of this._globals)n.exportName&&e.push([...p(n.exportName),3,...f(n.getIndex())]);return this._memory&&e.push([...p("__mem"),2,0]),e}_encodeElements(){return 0===this._functionTable.length?[]:[[0,...h(0,m),11,...C(this._functionTable.map((e=>f(e.getIndex()))))]]}_encodeDataSegments(){if(this._dataSegments.length>0&&void 0===this._memory)throw new Error("Cannot use data segments with memory disabled");this._dataSegments.sort(((e,n)=>e[0]-n[0]));let e=-1/0;for(let n=0;n<this._dataSegments.length;n++){const[t,i]=this._dataSegments[n];if(e+5>=t){const s=this._dataSegments[n-1][1];for(let n=e;n<t;n++)s.push(0);s.push(...i),this._dataSegments.splice(n,1),n--}e=t+i.length}return this._dataSegments.map((([e,n])=>[0,...h(e,m),11,...f(BigInt(n.length)),...n]))}_funcIndex(e){let n;if(n=e instanceof WImportedFunction?this._importedFunctions.indexOf(e):this._functions.indexOf(e),n<0)throw new Error("Function not found?");return e instanceof WFunction&&(n+=this._importedFunctions.length),BigInt(n)}_tableIndex(e){let n=this._functionTable.indexOf(e);return n<0&&(n=this._functionTable.push(e)-1),BigInt(n)}_typeIndex(e){for(let n=0;n<this._functionTypes.length;n++){const t=this._functionTypes[n];if(t[0].length===e[0].length&&t[0].every(((n,t)=>n===e[0][t]))&&t[1].length===e[1].length&&t[1].every(((n,t)=>n===e[1][t])))return BigInt(n)}return BigInt(this._functionTypes.push(e)-1)}_globalIndex(e){const n=this._globals.indexOf(e);if(n<0)throw new Error("Global not found?");return BigInt(n)}get functions(){return this._functions}get functionImports(){return this._importedFunctions}_functionLookup(e){return e<this._importedFunctions.length?this._importedFunctions[Number(e)]:this._functions[Number(e)-this._importedFunctions.length]}_typeLookup(e){return this._functionTypes[Number(e)]}_globalLookup(e){return this._globals[Number(e)]}_inFunctionTable(e){return this._functionTable.indexOf(e)>=0}_removeFunction(e){const n=this._functions.indexOf(e);n>=0&&this._functions.splice(n,1)}}function vn(e,n){if(0===n.length)return[];const t=C(n);return[e,...f(BigInt(t.length)),...t]}function xn(e){const n=FnInfo.infoMap(e),t=new Set,i=new InstrSplicer;for(const e of n.values())for(const n of e.inliningCandidates()){const s=e.fn.type[0],r=[...s,...e.fn.locals].map((e=>n.expr.builder.addLocal(e))),o=e.fn.type[1][0]??null,a=[];for(let e=s.length-1;e>=0;e--)a.push(k.local.set(r[e]));a.push(k.block(o,[])),i.splice(n,1,a);const c=i.realIndex(n)+s.length,l=n.expr.instructions[c];if(!l||"structured"!==l.type||0!==l.immediate.expression.instructions.length)throw new Error("Failed to inline function");e.fn.body.copyInto(l.immediate.expression),X(l.immediate.expression,r),D(l.immediate.expression,(([e],n)=>{if("return"===e.name)return[o?k.br(n,o):k.br(n)]}),1),t.add(n.fn)}for(const e of t)gn(e);t.size&&function(e){const n=FnInfo.infoMap(e),t=[...e.functions,...e.functionImports].map((t=>{const i=n.get(t);if(0!==i?.usages.length||i.inTable||i.exported)return t;e._removeFunction(t)})),i=t.indexOf(void 0);if(-1===i)return;for(let e=i+1;e<t.length;e++){const i=t[e],s=n.get(i);if(i&&s)for(const e of s.usages)e.expr.replace(e.instrIndex,e.instrIndex+1,k.call(i))}}(e)}class FnInfo{constructor(e,n){this.fn=e,this.fnMap=n,this.usages=[],this.size=0,this.inTable=e.parent._inFunctionTable(e),this.exported=void 0!==e.exportName}analyze(){if(this.size>0)return;const e=[this.fn.body];let n;for(;void 0!==(n=e.shift());){this.size+=n.instructions.length;for(const[t,i]of n.instructions.entries())if("structured"===i.type)e.push(i.immediate.expression),i.immediate.expression2&&e.push(i.immediate.expression2);else if("index"===i.type&&"call"===i.name){const e=this.fn.parent._functionLookup(i.immediate.value),s=this.fnMap.get(e);s&&s.usages.push({fn:this.fn,fnInfo:s,expr:n,instrIndex:t})}}}inliningCandidates(){if(this.size>50||0===this.usages.length)return[];let e=this.size;return e+=5*Math.min(this.fn.body.builder.args.length-1,0),e+=5*this.fn.locals.length,this.fn.hints.inline&&(e-=20),e<=8||e<=16&&this.usages.length<=3&&!this.inTable&&!this.exported?this.usages.filter((({fn:e})=>e!==this.fn)):[]}static infoMap(e){const n=new Map;for(const t of e.functions)n.set(t,new FnInfo(t,n));for(const e of n.values())e.analyze();return n}}function Cn(e,n){return n instanceof CCompoundStatement?function(e,n){const[t,i]=Se(e,n.scope);if(void 0===n.scope.labelledStatement)t.push(...n.statements.flatMap((n=>Cn(e,n))));else{const i=[],s=[];for(const e of n.statements)s.length>0||n.scope.labelledStatement.body===e?s.push(e):i.push(e);t.push(k.block(null,i.flatMap((n=>Cn(e,n))),In(n.scope.labelledStatement)),k.loop(null,s.flatMap((n=>Cn(e,n)))))}return i(),t}(e,n):n instanceof CExpressionStatement?function(e,n){return e.expression(n.expression,!0)}(e,n):n instanceof CNop?[]:n instanceof CIf?function(e,n){const t=void 0===n.ifBody?[k.nop()]:Cn(e,n.ifBody),i=void 0===n.elseBody?void 0:Cn(e,n.elseBody);return[...ln(e,n.test),k.if(null,t,i)]}(e,n):n instanceof CForLoop?function(e,n){if(void 0===n.body)throw new GenError("Invalid for loop body",e,n.node);const[t,i]=Se(e,n.scope);let s=[];Array.isArray(n.init)?s=n.init.flatMap((n=>e.expression(n.expression,!0))):void 0===n.init||n.init instanceof CNop||(s=e.expression(n.init.expression,!0));let r=[k.i32.const(1n)];void 0===n.test||n.test instanceof CNop||(r=ln(e,n.test.expression));let o=[];return void 0!==n.update&&(o=e.expression(n.update,!0)),t.push(...s,k.loop(null,[...r,k.if(null,[k.block(null,[...Cn(e,n.body)],An(n)),...o,k.br(1)],void 0,In(n))])),i(),t}(e,n):n instanceof CWhileLoop?function(e,n){if(void 0===n.body)throw new GenError("Invalid while loop body",e,n.node);return[k.loop(null,[...ln(e,n.test),k.if(null,[...Cn(e,n.body),k.br(1)],void 0,In(n))],An(n))]}(e,n):n instanceof CDoLoop?function(e,n){if(void 0===n.body)throw new GenError("Invalid while loop body",e,n.node);return[k.block(null,[k.loop(null,[...Cn(e,n.body),...ln(e,n.test),k.br_if(0)],An(n))],In(n))]}(e,n):n instanceof CSwitch?function(e,n){const t=Le(n.expression.type);return e.withTemporaryLocal(t,(i=>{const s=[...an(e,n.expression,!1),k.local.set(i)];let r=n.children.findIndex((e=>e.default));-1===r&&(r=n.children.length);const o=[];let c=2n**65n,l=-c,f=0;for(const e of n.children)for(const n of e.cases)n.value>l&&(l=BigInt(n.value)),n.value<c&&(c=BigInt(n.value)),f++;if(l-c<=Math.min(65536,8*f)&&a().generation_switch_br_table){if(o.push(k.local.get(i)),c<0||c>16){const e=t===m?k.i32:k.i64;o.push(e.const(c),e.sub())}else c=0n;t===y&&o.push(k.i32.wrap_i64());const e=Array(Number(l-c)+1).fill(r);for(const[t,i]of n.children.entries())for(const n of i.cases)e[Number(n.value)-Number(c)]=t;o.push(k.br_table(r,e))}else{for(const[s,r]of n.children.entries())for(const a of r.cases){if(a.type instanceof CPointer)throw new GenError("Invalid switch case",e,n.node);const r=new CConstant(n.node,a.type,a.value);o.push(k.local.get(i),...cn(e,r,n.expression.type),hn(t,"eq")),o.push(k.br_if(s))}o.push(k.br(r))}let u=k.block(null,o);for(let t=0;t<n.children.length;t++)u=k.block(null,[u,...e.statement(n.children[t].body)],t===n.children.length-1?In(n):void 0);return[...s,u]}))}(e,n):n instanceof CGoto?function(e,n){return[k.br({getIndex(t){const i=n.target[Ln];if(void 0===i)throw new GenError("Failed to find target depth",e,n.node);return BigInt(t-i)}})]}(e,n):n instanceof CContinue?function(e,n){return[k.br({getIndex(t){const i=n.loop[En];if(void 0===i)throw new GenError("Failed to find continue depth",e,n.node);return BigInt(t-i)}})]}(e,n):n instanceof CBreak?function(e,n){return[k.br({getIndex(t){const i=n.target[Ln];if(void 0===i)throw new GenError("Failed to find break depth",e,n.node);return BigInt(t-i)}})]}(e,n):function(e,n){return void 0===n.value?[k.return()]:Ie(n.func.type.returnType)?[...Re(cn(e,n.value,n.func.type.returnType),[k.local.get(n.func.type.parameterTypes.length)],n.value.type.bytes),k.return()]:[...cn(e,n.value,n.func.type.returnType),k.return()]}(e,n)}const Ln=Symbol("break depth"),En=Symbol("continue depth");function In(e){const n=e;return({depth:e})=>{n[Ln]=e+1}}function An(e){const n=e;return({depth:e})=>{n[En]=e+1}}class generator_WGenerator{constructor(e){this.functions=new Map,this.nextStaticAddr=32,this.module=new ModuleBuilder;const n=[];for(const t of e.emitVariables){const e=Ae(this,t);e&&n.push(e)}for(const n of e.emitImports)this.importFunction(n);for(const n of e.emitExportedFunctions)this.function(n,n.name);for(const n of e.emitFunctions)this.function(n);for(const[e,n]of this.functions.entries())e instanceof CFuncDefinition&&n instanceof WFunction&&n.define((n=>this.functionBody(e,n)));for(const e of n)e();var t;t=this.module,a().inlining&&xn(t),this.module.emitCallback=()=>{const e=1024*Math.ceil(this.nextStaticAddr/1024);if(this._shadowStackPtr){const n=e+1024;this._shadowStackPtr.initialValue=BigInt(n),this.module.setupMemory(Math.ceil((n+1048576)/65536))}else this.isMemoryUsed()&&this.module.setupMemory(Math.ceil(e/65536))}}get shadowStackPtr(){return this._shadowStackPtr||(this._shadowStackPtr=this.module.global(m,!0,0n,"__sp")),this._shadowStackPtr}isMemoryUsed(){if(this._shadowStackPtr||this.nextStaticAddr>32)return!0;for(const e of this.module.functions)for(const n of e.body.instructionsRecursive())if("structured"!==n.type&&"call"!==n.name&&"call_indirect"!==n.name&&(n.reads.includes("memory")||n.writes.includes("memory")))return!0;return!1}function(e,n){Ie(e.type.returnType)&&(n=void 0),n&&!e.type.parameterTypes.every((e=>e instanceof CArithmetic))&&this.shadowStackPtr;const t=this.module.function(...generator_WGenerator.funcType(e.type),void 0,n);t.hints.inline=e.hints.inline,this.functions.set(e,t)}functionBody(e,n){const t=new WFnGenerator(this,n,e.name),i=t.statement(e.body);return t.shadowStackUsage>0&&a().generation_zero_shadow_stack&&i.unshift(k.global.get(this.shadowStackPtr),k.i32.const(0),k.i32.const(t.shadowStackUsage),k.memory.fill()),i}importFunction(e){const n=this.module.importFunction(e.type.parameterTypes.map(xe),Ee(e.type.returnType),"c2wasm",e.name);this.functions.set(e,n)}functionIndex(e){return e instanceof CFuncDeclaration&&void 0!==e.definition&&(e=e.definition.getFunction()),{getIndex:()=>{const n=this.functions.get(e);if(void 0===n)throw new GenError(`Function '${e.name}' not emitted`,void 0,e.node);return n.getIndex()}}}static funcType(e){const n=e.parameterTypes.map(xe);return Ie(e.returnType)&&n.push(m),[n,Ee(e.returnType)]}typeIndex(e){return this.module._typeIndex(generator_WGenerator.funcType(e))}indirectIndex(e){e instanceof CFuncDeclaration&&void 0!==e.definition&&(e=e.definition.getFunction());const n=this.functions.get(e);if(void 0===n)throw new GenError(`Function '${e.name}' not emitted`,void 0,e.node);return n.getTableIndex()}}class WFnGenerator{constructor(e,n,t){this.gen=e,this.builder=n,this.fnName=t,this.shadowStackUsage=0}statement(e){return Cn(this,e)}expression(e,n){return an(this,e,n)}withTemporaryLocal(e,n){const t=this.builder.getTempLocal(e),i=n(t);return this.builder.freeTempLocal(t),i}}function Sn(e,n){let t=function(e,n){const t=e.specifierList,i=1===t.length?t[0]:void 0;if(i instanceof ze.StructUnionSpecifier){const e="struct"===i.structure?CStruct:CUnion;let t=new e(i,i.id);if(i.id){const s=n.lookupTag(i.id,e,i);s?t=s:n.addTag(t)}if(!i.declarations)return t;const s=[];for(const e of i.declarations){const t=Sn(e,n);for(const i of e.list){const r=Tn(t,i,n),o=Fn(i);if(r.incomplete||0===r.bytes||r instanceof CFuncType)throw new ParseTreeValidationError(i,"Type must be complete");s.push(new CCompoundMember(e,o,r))}}return t.members=s,t.node=i,t}if(i instanceof ze.EnumSpecifier){let e=new CEnum(i,i.id);if(i.id){const t=n.lookupTag(i.id,CEnum,i);t?e=t:n.addTag(e)}if(!i.body)return CArithmetic.S32;let t=0n;const s=[];for(const e of i.body){e.value&&(t=kn(e.value,n).value);const i=new CVarDefinition(e,e.id,J(CArithmetic.S32,"const"),"static","internal");i.staticValue=new CConstant(e,CArithmetic.S32,t),n.addIdentifier(i),s.push({name:e.id,value:t++})}return e.values=s,e.node=i,CArithmetic.S32}if(t.every((e=>"string"==typeof e))){const e=ne(t);if(e)return e}else if(1===t.length&&t[0]instanceof ze.CustomTypeSpecifier)return n.lookupTypedef(t[0].name);throw new ParseTreeValidationError(e,"Invalid specifier")}(e.typeInfo,n);return e.typeInfo.qualifierList.length&&(t=J(t,e.typeInfo.qualifierList[0])),e.declarator&&(t=Tn(t,e.declarator,n)),t}function Tn(e,n,t){let i=n;for(;i&&!(i instanceof ze.IdentifierDeclarator);)if(i instanceof ze.PointerDeclarator||i instanceof ze.AbstractPointerDeclarator){let n=i.pointer;for(;n;)e=new CPointer(n,e,n.qualifierList?.includes("const")),n=n.body;i=i.body}else if(i instanceof ze.ArrayDeclarator||i instanceof ze.AbstractArrayDeclarator){if(e=new CArray(i,e),i.length&&(e.length=Number(kn(i.length,t).value),e.length<=0))throw new ParseTreeValidationError(i.length,"Invalid array length");i=i.body}else{const n=[];let s;for(const e of i.args??[]){let i=Sn(e,t);if(i instanceof CArray)i=new CPointer(i.node,i.type);else if(i instanceof CFuncType)throw new ParseTreeValidationError(e,"Functions cannot be parameters");if(n.push(i),e.declarator&&!e.declarator.abstractDeclarator&&(s??(s=[]),s.push(Fn(e.declarator))),s&&s.length!==n.length)throw new ParseTreeValidationError(e,"Unexpected mix of abstract & non-abstract declarators")}1===n.length&&n[0]instanceof CVoid&&n.shift(),0===n.length&&(s=[]),e=new CFuncType(i,e,n,s,i.variadic),i=i.body}return e}function Fn(e){for(;!(e instanceof ze.IdentifierDeclarator);)e=e.body;return e.id}function Nn(e,n){if(e instanceof ze.ConstantExpression)return Nn(e.expr,n);if(e instanceof ze.Constant)return On(e);if(e instanceof ze.Identifier){const t=new CIdentifier(e,n.lookupIdentifier(e.name,e));return n.func&&n.func.dependencies.set(t.value,!0),t}if(e instanceof ze.StringLiteral){const n=[],t=/[^\\\n"]|\\(?:[^x0-7\n]|x[0-9a-fA-F]{1,2}|[0-7]{1,3})/y;for(;t.lastIndex<e.value.length;){const i=t.exec(e.value);if(!i||0===t.lastIndex)throw new ParseTreeValidationError(e,"Invalid string literal");n.push(BigInt(Pn(i[0],e).codePointAt(0)??0))}return n.push(0n),new CStringLiteral(e,n)}if(e instanceof ze.UnaryExpression)return function(e,n){const t=Nn(e.body,n);if("prefixIncrement"===e.type)return new CIncrDecr(e,t,"++","pre");if("prefixDecrement"===e.type)return new CIncrDecr(e,t,"--","pre");if("postfixIncrement"===e.type)return new CIncrDecr(e,t,"++","post");if("postfixDecrement"===e.type)return new CIncrDecr(e,t,"--","post");if("addressOf"===e.type)return new CAddressOf(e,t);if("dereference"===e.type)return new CDereference(e,t);if("unaryPlus"===e.type)return new CUnaryPlusMinus(e,t,"+");if("unaryMinus"===e.type)return new CUnaryPlusMinus(e,t,"-");if("bitwiseNot"===e.type)return new CBitwiseNot(e,t);if("logicalNot"===e.type)return new CLogicalNot(e,t);throw new ParseTreeValidationError(e,"Invalid unary expression")}(e,n);if(e instanceof ze.BinaryExpression)return function(e,n){const t=Nn(e.lhs,n),i=Nn(e.rhs,n);if("mul"===e.type)return new CMulDiv(e,t,i,"*");if("div"===e.type)return new CMulDiv(e,t,i,"/");if("mod"===e.type)return new CMod(e,t,i);if("add"===e.type)return new CAddSub(e,t,i,"+");if("sub"===e.type)return new CAddSub(e,t,i,"-");if("bitwiseShiftLeft"===e.type)return new CShift(e,t,i,"left");if("bitwiseShiftRight"===e.type)return new CShift(e,t,i,"right");if("relationalLT"===e.type)return new CRelational(e,t,i,"LT");if("relationalGT"===e.type)return new CRelational(e,t,i,"GT");if("relationalLEq"===e.type)return new CRelational(e,t,i,"LEq");if("relationalGEq"===e.type)return new CRelational(e,t,i,"GEq");if("relationalEq"===e.type)return new CEquality(e,t,i,"==");if("relationalNEq"===e.type)return new CEquality(e,t,i,"!=");if("bitwiseAnd"===e.type)return new CBitwiseAndOr(e,t,i,"and");if("bitwiseXor"===e.type)return new CBitwiseAndOr(e,t,i,"xor");if("bitwiseOr"===e.type)return new CBitwiseAndOr(e,t,i,"or");if("logicalAnd"===e.type)return new CLogicalAndOr(e,t,i,"and");if("logicalOr"===e.type)return new CLogicalAndOr(e,t,i,"or");if("comma"===e.type)return new CComma(e,t,i);if("arraySubscript"===e.type)return new CDereference(e,new CAddSub(e,Nn(e.lhs,n),Nn(e.rhs,n),"+"));throw new ParseTreeValidationError(e,"Invalid binary expression")}(e,n);if(e instanceof ze.SizeofExpression)return e.body instanceof ze.Expression?new CSizeof(e,Nn(e.body,n).type):new CSizeof(e,Sn(e.body,n));if(e instanceof ze.CastExpression)return new CCast(e,Sn(e.targetType,n),Nn(e.body,n));if(e instanceof ze.FunctionCallExpression)return new CFunctionCall(e,Nn(e.fn,n),(e.args??[]).map((e=>Nn(e,n))));if(e instanceof ze.MemberAccessExpression){let t=Nn(e.lhs,n);return e.pointer||(t=new CAddressOf(e,t)),new CMemberAccess(e,t,e.rhs)}if(e instanceof ze.ConditionalExpression)return new CConditional(e,Nn(e.condition,n),Nn(e.trueValue,n),Nn(e.falseValue,n));if(e instanceof ze.AssignmentExpression)return new CAssignment(e,Nn(e.lhs,n),Nn(e.rhs,n),e.assignType);throw new ParseTreeValidationError(e,"Invalid expression")}function kn(e,n){return function(e,n){const t=de(e,n);if(t)return t;throw new ExpressionTypeError(e.node,"constant integer expression")}(Nn(e.expr,n))}function On(e){let n,t=e.value;if("int"===e.valueType||"oct"===e.valueType||"hex"===e.valueType){let n,i,s=!1,r=!1;if(t=t.toLowerCase(),t.endsWith("u")&&(t=t.slice(0,-1),s=!0),t.endsWith("l")&&(t=t.slice(0,-1),r=!0,t.endsWith("l")&&(t=t.slice(0,-1))),!s&&t.endsWith("u")&&(t=t.slice(0,-1),s=!0),"oct"!==e.valueType)n=BigInt(t);else{n=0n;for(let e=0;e<t.length-1;e++)n+=BigInt(t[t.length-1-e])*8n**BigInt(e)}i="int"!==e.valueType||s||r?"int"===e.valueType||s||r?s&&r?[CArithmetic.U64]:r?[CArithmetic.S64,CArithmetic.U64]:[CArithmetic.U32,CArithmetic.U64]:[CArithmetic.S32,CArithmetic.U32,CArithmetic.S64,CArithmetic.U64]:[CArithmetic.S32,CArithmetic.S64,CArithmetic.U64];for(const t of i)if(n>=t.minValue&&n<=t.maxValue)return new CConstant(e,t,n);throw new ParseTreeValidationError(e,"Integer constant too large for its type")}if("float"===e.valueType)return t.endsWith("f")?(t=t.slice(0,-1),n=CArithmetic.Fp32):n=CArithmetic.Fp64,new CConstant(e,n,parseFloat(t));if("char"===e.valueType)return t=Pn(t,e),new CConstant(e,CArithmetic.U8,BigInt(t.codePointAt(0)));throw new ParseTreeValidationError(e,"Invalid constant type?")}function Pn(e,n){if(e.startsWith("\\")){if("\\n"===e)return"\n";if("\\t"===e)return"\t";if("\\v"===e)return"\v";if("\\b"===e)return"\b";if("\\r"===e)return"\r";if("\\f"===e)return"\f";if("\\a"===e)return"";if("\\\\"===e)return"\\";if("\\?"===e)return"?";if("\\'"===e)return"'";if('\\"'===e)return'"';let t;if(t=e.startsWith("\\x")?parseInt(e.slice(2),16):parseInt(e.slice(1),8),!isNaN(t)&&t>=0&&t<=255)return String.fromCharCode(t);throw new ParseTreeValidationError(n,"Invalid character escape")}const t=e.codePointAt(0);if(1!==e.length||void 0===t||t>255)throw new ParseTreeValidationError(n,"Invalid character");return e}function $n(e,n){const t=Je(`int x = ${e};`);if(1!==t.length||"declaration"!==t[0].type||1!==t[0].list.length||"initDeclarator"!==t[0].list[0].type||Array.isArray(t[0].list[0].initializer))throw n.error("Invalid #if conditional: `"+e+"`");return Un(t[0].list[0].initializer,n)}function Un(e,n){if(e instanceof ze.Constant&&"float"!==e.valueType)return BigInt(On(e).value);if(e instanceof ze.BinaryExpression)switch(e.type){case"add":return Un(e.lhs,n)+Un(e.rhs,n);case"sub":return Un(e.lhs,n)-Un(e.rhs,n);case"mul":return Un(e.lhs,n)*Un(e.rhs,n);case"div":return Un(e.lhs,n)/Un(e.rhs,n);case"bitwiseAnd":return Un(e.lhs,n)&Un(e.rhs,n);case"bitwiseOr":return Un(e.lhs,n)|Un(e.rhs,n);case"bitwiseXor":return Un(e.lhs,n)^Un(e.rhs,n);case"bitwiseShiftLeft":return Un(e.lhs,n)<<Un(e.rhs,n);case"bitwiseShiftRight":return Un(e.lhs,n)>>Un(e.rhs,n);case"relationalEq":return Un(e.lhs,n)===Un(e.rhs,n)?1n:0n;case"relationalNEq":return Un(e.lhs,n)!==Un(e.rhs,n)?1n:0n;case"relationalLT":return Un(e.lhs,n)<Un(e.rhs,n)?1n:0n;case"relationalLEq":return Un(e.lhs,n)<=Un(e.rhs,n)?1n:0n;case"relationalGT":return Un(e.lhs,n)>Un(e.rhs,n)?1n:0n;case"relationalGEq":return Un(e.lhs,n)>=Un(e.rhs,n)?1n:0n;case"logicalAnd":return 0n!==Un(e.lhs,n)&&0n!==Un(e.rhs,n)?1n:0n;case"logicalOr":return 0n!==Un(e.lhs,n)||0n!==Un(e.rhs,n)?1n:0n}else if(e instanceof ze.UnaryExpression)switch(e.type){case"unaryPlus":return Un(e.body,n);case"unaryMinus":return-Un(e.body,n);case"logicalNot":return 0n===Un(e.body,n)?1n:0n}else if(e instanceof ze.Identifier)return 0n;throw n.error("Invalid preprocessor expression")}const Mn=/^[a-zA-Z_][a-zA-Z0-9_]*/,Dn=/^(?:"(?:\\"|[^\n"])*"|[^ \t\v\f\na-zA-Z_]+)/,Rn=/^[ \t\v\f]+/,zn=/\/\*[^]*?\*\/|\/\/.*?$/gm,Gn=/defined(?:[ \t]*\([ \t]*([a-zA-Z_][a-zA-Z0-9_]*)[ \t]*\)|[ \t]+([a-zA-Z_][a-zA-Z0-9_]*))|(d?[^d]*)/gm;class Definition{constructor(e,n,t,i){this.preprocessor=e,this.identifier=n,this.replacement=t,this.parameters=i}expand(e){if(this.parameters.length>0)return this.expandWithParameters(e);return{output:this.replacement.map((e=>e.value)).join(""),line:e}}expandWithParameters(e){const n=e;if(0===(e=this.preprocessor.consume(e,Rn).remainingLine).length||"("!==e[0])return{output:this.identifier,line:n};e=this.preprocessor.mustConsume(e,"(").remainingLine;const t=[];for(let n=0;n<this.parameters.length;n++){const i=this.consumeArgument(e);t.push(i.value.trim()),e=n!==this.parameters.length-1?this.preprocessor.mustConsume(i.remainingLine,",").remainingLine:this.preprocessor.mustConsume(i.remainingLine,")").remainingLine}let i="";for(const e of this.replacement){if("identifier"===e.type){const n=this.parameters.indexOf(e.value);if(n>=0){i+=this.preprocessor.expandDefinitions(t[n]);continue}}i+=e.value}return{output:i,line:e}}consumeArgument(e){const n={value:"",remainingLine:e};let t=!1,i=0;for(;n.remainingLine.length>0&&(t||0!==i||","!==n.remainingLine[0]&&")"!==n.remainingLine[0]);){const e=n.remainingLine[0];let s=1;t&&"\\"===e&&'"'===n.remainingLine[1]?s=2:t||"'"!==e?'"'===e?t=!t:"("!==e||t?")"!==e||t||i--:i++:s+=Math.max(n.remainingLine.indexOf("'",1),0),n.value+=n.remainingLine.substring(0,s),n.remainingLine=n.remainingLine.substring(s)}return n}equals(e){return e.identifier===this.identifier&&e.replacement.length===this.replacement.length&&e.replacement.every(((e,n)=>e.value===this.replacement[n].value))&&e.parameters.length===this.parameters.length&&e.parameters.every(((e,n)=>e===this.parameters[n]))}}class Preprocessor extends class PreprocessorBase{consumeAny(e){let n;if((n=this.consume(e,Mn)).success)return n.type="identifier",n;if((n=this.consume(e,Dn)).success)return n;if((n=this.consume(e,Rn)).success)return n;throw this.error("Malformed input? Line does not match defined regular expressions.\n`"+e+"`")}mustConsume(e,n,t=n.toString()){const i=this.consume(e,n);if(i.success)return i;throw this.error(`Expected to find ${t} but found \`${e}\` instead`)}consume(e,n){if("string"==typeof n)return e.startsWith(n)?{success:!0,value:n,remainingLine:e.substring(n.length)}:{success:!1,remainingLine:e};const t=e.match(n);return null===t?{success:!1,remainingLine:e}:{success:!0,value:t[0],remainingLine:e.substring(t[0].length)}}}{constructor(e,n=!0,t){if(super(),this.filename=e,this.definitions=new Map,this.userFiles=new Map,this.libraryFiles=n?new Map(i):new Map,this.definitions.set("__FILE__",new Definition(this,"__FILE__",[{value:`"${e}"`}],[])),this.definitions.set("__c2wasm__",new Definition(this,"__c2wasm__",[{value:"1"}],[])),t)for(const[e,n]of Object.entries(t))this.definitions.set(e,new Definition(this,e,[{value:n}],[]))}process(e,n=this.filename){const t=(e=(e=e.replace(/\r\n/g,"\n")).replace(zn," ")).replace(/\\\n/g,"").split("\n");let i="";for(;t.length>0;){let e=t.shift();if(e.startsWith("#")){let s;if(e=e.substring(1).trimStart(),(s=this.consume(e,"define")).success)this._define(s.remainingLine);else if((s=this.consume(e,"undef")).success)this._undef(s.remainingLine);else if((s=this.consume(e,"include")).success)i+=this._include(s.remainingLine)+"\n";else if((s=this.consume(e,"ifdef")).success)this._ifdef(s.remainingLine,!0,t);else if((s=this.consume(e,"ifndef")).success)this._ifdef(s.remainingLine,!1,t);else if((s=this.consume(e,"if")).success)i+=this._if(s.remainingLine,t);else if((s=this.consume(e,"pragma")).success){if("once"===this.mustConsume(s.remainingLine,Rn,"whitespace").remainingLine.trim()){const e=`__pragma_once_${n}__`;if(this.definitions.has(e))return i;this.definitions.set(e,new Definition(this,e,[],[]))}}else{if((s=this.consume(e,"error")).success)throw this.error("#"+e);if(e.trim().length>1)throw this.error(`Unknown preprocessor directive "#${e}"`)}}else i+=this.expandDefinitions(e)+"\n"}return i}expandDefinitions(e,n=this.definitions){let t="";for(;e.length>0;){const i=this.consumeAny(e);if("identifier"===i?.type){const s=n.get(i.value);if(void 0!==s){const r=s.expand(i.remainingLine),o=new Map(n);o.delete(i.value);let a=r.output,c="";for(;a!==c;)c=a,a=this.expandDefinitions(a,o);t+=a,e=r.line;continue}}t+=i?.value,e=i.remainingLine}return t}error(e){return new class extends Error{constructor(){super(...arguments),this.name="PreprocessorError"}}(`In file '${this.filename}': ${e}`)}_include(e){if((e=this.mustConsume(e,Rn,"whitespace").remainingLine.trim()).startsWith('"')&&e.endsWith('"'))return this._includeUser(e.substring(1,e.length-1));if(e.startsWith("<")&&e.endsWith(">"))return this._includeLib(e.substring(1,e.length-1));if((e=this.expandDefinitions(e)).startsWith('"')&&e.endsWith('"'))return this._includeUser(e.substring(1,e.length-1));if(e.startsWith("<")&&e.endsWith(">"))return this._includeLib(e.substring(1,e.length-1));throw this.error("Invalid #include")}_includeLib(e){const n=this.libraryFiles.get(e);if(void 0===n)throw this.error("Unknown path `"+e+"`");return this.process(n,`<${e}>`)}_includeUser(e){const n=this.filename.replace(/[^/\\]*$/,e);let t=this.userFiles.get(n);return void 0===t&&(t=this.userFiles.get(e),void 0===t)?this._includeLib(e):this.process(t,e)}_define(e){e=this.mustConsume(e,Rn,"whitespace").remainingLine;const n=this.mustConsume(e,Mn,"identifier"),t=[],i=[];if(n.remainingLine.trim().length>0){if("("===n.remainingLine[0]){for(e=this.mustConsume(n.remainingLine,"(").remainingLine;e.length>0;){e=this.consume(e,Rn).remainingLine;const n=this.mustConsume(e,Mn,"identifier");if(i.push(n.value),0===(e=this.consume(n.remainingLine,Rn).remainingLine).length)throw this.error("Unexpected end of line");if(","!==e[0]){if(")"===e[0])break;throw this.error("Unexpected")}e=this.mustConsume(e,",").remainingLine}(e=this.mustConsume(e,")").remainingLine).length>0&&(e=this.mustConsume(e,Rn,"whitespace").remainingLine)}else e=this.mustConsume(n.remainingLine,Rn,"whitespace").remainingLine;for(;e.length>0;){const n=this.consumeAny(e);"identifier"===n.type&&i.includes(n.value)||(n.value=this.expandDefinitions(n.value)),t.push(n),e=n.remainingLine}}const s=new Definition(this,n.value,t,i),r=this.definitions.get(n.value);if(void 0!==r&&!s.equals(r))throw this.error("Duplicate defines must be the same");this.definitions.set(n.value,s)}_undef(e){e=this.mustConsume(e,Rn,"whitespace").remainingLine;const n=this.mustConsume(e,Mn,"identifier");if(0!==n.remainingLine.trim().length)throw this.error("Unexpected extra characters in undef");this.definitions.delete(n.value)}_ifdef(e,n,t){e=this.mustConsume(e,Rn,"whitespace").remainingLine;const i=this.mustConsume(e,Mn,"identifier");t.unshift(`#if ${n?"":"!"} defined ${i.value}`)}_if(e,n){const t=this.mustConsume(e,Rn,"whitespace").remainingLine;let i=this._condition(t),s=i,r=1,o=!1;const a=[];for(let e=0;e<n.length;e++){const t=n[e].trimEnd();if(t.startsWith("#if"))r++;else if("#endif"===t){if(r--,0===r)return n.splice(0,e+1),this.process(a.join("\n"))}else{if("#else"===t&&1===r){if(o)throw this.error("more than one #else statement");o=!0,i=!s,s=!0;continue}if(t.startsWith("#elif")&&1===r){if(s)i=!1;else{const t=this.mustConsume(n[e].substring(5),Rn,"whitespace").remainingLine;i=this._condition(t),s||(s=i)}continue}}i&&a.push(n[e])}throw this.error("no matching #endif found")}_condition(e){let n="";for(const t of e.matchAll(Gn)){if(4!==t.length)throw this.error("invalid regex result when processing #if condition");const e=t[1]??t[2];n+=e?this.definitions.has(e)?" 1L ":" 0L ":t[3]}n=this.expandDefinitions(n);try{return 0n!==$n(n,this)}catch(n){throw this.error("Invalid condition `"+e+"`")}}}function Bn(e,n,t){if("typedef"===e.typeInfo.storageList[0])return function(e,n){if(0===e.list.length)throw new ParseTreeValidationError(e,"typedef must define at least one identifier");const t=Sn(e,n);for(const i of e.list){if(i instanceof ze.InitDeclarator)throw new ParseTreeValidationError(e,"cannot initialize a typedef");const s=Tn(t,i,n),r=Fn(i);n.addTypedef(r,s,i)}}(e,n),[];const i=Sn(e,n),s=[];for(let r of e.list){const o=Fn(r);let a;r instanceof ze.InitDeclarator&&(a=qn(r,r.initializer,n),r=r.body);const c=Tn(i,r,n),l=a?.type instanceof CPointer?a.type.original??a.type:a?.type;if(l instanceof CArray&&c instanceof CArray&&c.incomplete&&(c.length=l.length),c.incomplete)throw new ExpressionTypeError(c.node??r,"complete type","incomplete type");if(c instanceof CFuncType){const t="static"===e.typeInfo.storageList[0]?"internal":"external",i="import"===e.typeInfo.fnSpecifierList[0];n.addIdentifier(new CFuncDeclaration(r,o,c,t,i))}else{if(e.typeInfo.fnSpecifierList.length>0)throw new ExpressionTypeError(r,"variable declaration with function specifier");let i,l,f;"static"===e.typeInfo.storageList[0]?(i="static",l=t?"none":"internal",f=t||void 0!==a?CVarDefinition:CVarDeclaration):"extern"===e.typeInfo.storageList[0]?(i="static",l="external",f=CVarDeclaration):(i=t?"local":"static",l=t?"none":"external",f=t||void 0!==a?CVarDefinition:CVarDeclaration);const u=new f(r,o,c,i,l);if(n.addIdentifier(u),a){if(u instanceof CVarDeclaration)throw new ExpressionTypeError(r,"declaration","declaration with initializer");if(a instanceof CInitializer&&(a.type=c),a instanceof CConstant&&c instanceof CArithmetic&&c!==a.type&&(a=a.changeType(c)),t&&"static"!==u.storage){const e=new CIdentifier(r,u);s.push(new CAssignment(r,e,a,void 0,!0))}else{u.staticValue=a,CAssignment.checkAssignmentValid(r,c,u.staticValue);for(const e of a.identifiers())u.dependencies.set(e.value,!0)}}}}return s}function qn(e,n,t){return Array.isArray(n)?new CInitializer(e,n.map((n=>qn(e,n,t)))):Nn(n,t)}function Vn(e,n){if("import"===e.typeInfo.fnSpecifierList[0])throw new ExpressionTypeError(e,"function definition to not be marked `import`");const t=Sn(e,n);if(!(t instanceof CFuncType))throw new ParseTreeValidationError(e,"Unexpected declarator");const i=Fn(e.declarator);let s;if("static"===e.typeInfo.storageList[0])s="internal";else{if("typedef"===e.typeInfo.storageList[0])throw new ParseTreeValidationError(e,"Invalid typedef");s="external"}const r=new CFuncDefinition(e,i,t,s,n);if(r.hints.inline="inline"===e.typeInfo.fnSpecifierList[0],n.addIdentifier(r),!t.parameterNames)throw new ParseTreeValidationError(e,"Expected parameter names");for(let n=0;n<t.parameterTypes.length;n++)r.body.scope.addIdentifier(new CArgument(e,t.parameterNames[n],t.parameterTypes[n],n));if(Hn(e.body,r),!(t.returnType instanceof CVoid||Xn(r.body)))throw new ParseTreeValidationError(e.body,"Non-void function may not return")}function Xn(e){if(e instanceof CReturn)return!0;if(e instanceof CCompoundStatement){for(let n=0;n<e.statements.length;n++)if(Xn(e.statements[n])){if(n+1<e.statements.length){if(e.statements[n+1]===e.scope.labelledStatement?.body)continue;throw new ParseTreeValidationError(e.statements[n+1].node,"Statement after return")}return!0}}else{if(e instanceof CIf)return Xn(e.ifBody)&&Xn(e.elseBody);if(e instanceof CDoLoop)return Xn(e.body);if(e instanceof CSwitch)return e.children.every((e=>Xn(e.body)))&&void 0!==e.children.find((e=>e.default))}return!1}function Wn(e,n){if(e instanceof ze.CompoundStatement)return Hn(e,n);if(e instanceof ze.ExpressionStatement)return new CExpressionStatement(e,Nn(e.expression,n.scope),n);if(e instanceof ze.IfStatement){const t=new CIf(e,Nn(e.expression,n.scope),n);return t.ifBody=Wn(e.ifBody,t),e.elseBody&&(t.elseBody=Wn(e.elseBody,t)),t}if(e instanceof ze.ForLoop){const t=new CForLoop(e,n);return e.init instanceof ze.ExpressionStatement||e.init instanceof ze.NoOp?t.init=Wn(e.init,t):t.init=Bn(e.init,t.scope,!0).map((e=>new CExpressionStatement(e.node,e,t))),t.test=Wn(e.test,t),e.update&&(t.update=Nn(e.update,t.scope)),t.body=Wn(e.body,t),t}if(e instanceof ze.WhileLoop){const t=new CWhileLoop(e,Nn(e.test,n.scope),n);return t.body=Wn(e.body,t),t}if(e instanceof ze.DoWhileLoop){const t=new CDoLoop(e,Nn(e.test,n.scope),n);return t.body=Wn(e.body,t),t}if(e instanceof ze.GotoStatement){let t=n;for(;t.scope.labelledStatement?.label!==e.target;){if(t.parent instanceof CFuncDefinition)throw new ParseTreeValidationError(e,"No properly structured control flow target for goto statement");t=t.parent}return new CGoto(e,t.scope.labelledStatement,n)}if(e instanceof ze.ContinueStatement){let t=n;for(;!(t instanceof CForLoop||t instanceof CWhileLoop||t instanceof CDoLoop);){if(t.parent instanceof CFuncDefinition)throw new ParseTreeValidationError(e,"No target for continue statement");t=t.parent}return new CContinue(e,t,n)}if(e instanceof ze.BreakStatement){let t=n;for(;!(t instanceof CForLoop||t instanceof CWhileLoop||t instanceof CDoLoop||t instanceof CSwitch);){if(t.parent instanceof CFuncDefinition)throw new ParseTreeValidationError(e,"No target for break statement");t=t.parent}return new CBreak(e,t,n)}if(e instanceof ze.SwitchStatement){const t=new CSwitch(e,Nn(e.expression,n.scope),n);return function(e,n,t){if(!(n.body instanceof ze.CompoundStatement))throw new ParseTreeValidationError(n,"Expected switch statement to have a compound statement body");const i=n.body.body.slice();for(;i.length>0;){const s=i.shift();if(s instanceof ze.CaseStatement||s instanceof ze.DefaultStatement){let r;e.children.length>0&&0===e.children[e.children.length-1].body.statements.length?r=e.children[e.children.length-1]:(r={cases:[],default:!1,body:new CCompoundStatement(n,e)},e.children.push(r)),s instanceof ze.CaseStatement?r.cases.push(kn(s.value,t)):r.default=!0,i.unshift(s.body)}else if(s){if(0===e.children.length)throw new ParseTreeValidationError(s,"Unexpected first statement inside a switch statement");jn(s,e.children[e.children.length-1].body)}}}(t,e,n.scope),t}if(e instanceof ze.ReturnStatement){let t=n;for(;!(t instanceof CFuncDefinition);)t=t.parent;const i=e.value?Nn(e.value,n.scope):void 0;return new CReturn(e,t,i,n)}if(e instanceof ze.NoOp)return new CNop(e,n);if(e instanceof ze.CaseStatement)throw new ParseTreeValidationError(e,"Unexpected case statement");if(e instanceof ze.DefaultStatement)throw new ParseTreeValidationError(e,"Unexpected default statement");throw new ParseTreeValidationError(e,"Unknown statement type")}function Hn(e,n){const t=n instanceof CFuncDefinition?n.body:new CCompoundStatement(e,n),i=e.body.filter((e=>e instanceof ze.Statement&&void 0!==e.label));if(i.length>1)throw new ParseTreeValidationError(i[0],"Only one labelled statement is supported per block",i[1]);1===i.length&&(t.scope.labelledStatement=new CLabelledStatement(i[0],i[0].label));for(const n of e.body)jn(n,t);return t}function jn(e,n){if(e instanceof ze.Declaration)for(const t of Bn(e,n.scope,!0))n.statements.push(new CExpressionStatement(t.node,t,n));else{const t=Wn(e,n);n.statements.push(t),void 0!==e.label&&n.scope.labelledStatement?.node===e&&(n.scope.labelledStatement.body=t)}}function Zn(e){return function(e){const n=new Scope(void 0,en);for(const t of e)t instanceof ze.FunctionDefinition?Vn(t,n):Bn(t,n,!1);return n}(Je(e))}class linker_Linker{constructor(e,n=!0,t){this.files=e,this._emitExportedFunctions=[],this._emitFunctions=[],this._emitImports=[],this._emitVariables=[],this._linkables=new Map,this._linked=!1;for(const[i,s]of e.entries()){if(!i.endsWith(".c"))continue;const r=new Preprocessor(i,n,t);for(const[n,t]of e.entries())r.userFiles.set(n,t);const o=r.process(s);try{this.process_scope(Zn(o))}catch(e){throw e.message=(e.message??"")+"\nIn file: "+i,e}}}link(...e){if(this._linked)throw new LinkingError("Already linked!");if(e&&e.some((e=>!e._linked)))throw new LinkingError("Cannot link against a not-linked Linker!");e:for(const n of this._linkables.values())if(void 0===n.definition){for(const t of e){const e=t._linkables.get(n.id);if(void 0!==e&&e.definition){if(n instanceof ExternalFunction&&e instanceof ExternalFunction)n.setDefinition(e.definition,t);else{if(!(n instanceof ExternalVariable&&e instanceof ExternalVariable))throw new LinkingError("Tried to link incompatible types",n.parseNode,e.parseNode);n.setDefinition(e.definition,t)}continue e}}if("variable"!==n.externalType){if("function"!==n.externalType||!n.declarationArray[0].fnImport)throw new LinkingError("Failed to find definition",n.parseNode);n.setDefinition(new CFuncImport(n.declarationArray[0]),this)}else{const e=new CVarDefinition(n.parseNode,n.id,n.type,"static","external");n.setDefinition(e,this)}}const n=new Map,t=[];for(const e of this._linkables.values()){if(void 0===e.definition)throw new LinkingError("Invalid state - declaration has no definition in emit",e.parseNode);e.definitionLinker===this&&(n.set(e.definition,!0),t.unshift(e.definition))}for(;t.length;){const e=t.shift();if(e instanceof CFuncImport)this._emitImports.push(e.declaration);else{"variable"===e.declType?"static"===e.storage&&this._emitVariables.push(e):"external"===e.linkage&&this._linkables.get(e.name)?.definitionLinker===this?this._emitExportedFunctions.push(e):this._emitFunctions.push(e);for(const i of e.dependencies.keys())if(i instanceof CFuncDeclaration||i instanceof CVarDeclaration)if("__internal__"===i.node.type);else{if(void 0===i.definition)throw new LinkingError("Invalid state - declaration doesn't have definition in emit",i.node);n.has(i.definition)||(n.set(i.definition,!0),t.push(i.definition))}else i instanceof CArgument||n.has(i)||(n.set(i,!0),t.push(i))}}this._linked=!0}get emitExportedFunctions(){return this._emitExportedFunctions}get emitFunctions(){return this._emitFunctions}get emitImports(){return this._emitImports}get emitVariables(){return this._emitVariables}process_scope(e){for(const n of e.declarations)if(n instanceof CFuncDeclaration)if("external"===n.linkage)this.externalFn(n).addDeclaration(n);else{if(!n.fnImport)throw new LinkingError("No definition of internally linked function",n.node);n.definition=new CFuncImport(n)}else n instanceof CFuncDefinition?("external"===n.linkage&&this.externalFn(n).setDefinition(n,this),this.process_fn_body(n.body)):n instanceof CVarDeclaration?"external"===n.linkage?this.externalVar(n).addDeclaration(n):n.definition=new CVarDefinition(n.node,n.name,n.type,n.storage,n.linkage):n instanceof CVarDefinition&&"external"===n.linkage&&this.externalVar(n).setDefinition(n,this)}process_fn_body(e){if(e instanceof CCompoundStatement){this.process_scope(e.scope);for(const n of e.statements)this.process_fn_body(n)}else if(e instanceof CForLoop)this.process_scope(e.scope),e.body&&this.process_fn_body(e.body);else if(e instanceof CIf)e.ifBody&&this.process_fn_body(e.ifBody);else if(e instanceof CWhileLoop||e instanceof CDoLoop)e.body&&this.process_fn_body(e.body);else if(e instanceof CSwitch)for(const n of e.children)this.process_fn_body(n.body)}externalFn(e){let n=this._linkables.get(e.name);if(void 0===n)this._linkables.set(e.name,n=new ExternalFunction(e.name,e.type));else{if(n instanceof ExternalVariable)throw new LinkingError("Tried to link function with variable",e.node,n.parseNode);if(!n.type.equals(e.type))throw new LinkingError("Tried to link functions with incompatible types",e.node,n.parseNode);if((!(e instanceof CFuncDefinition)&&e.fnImport)!==(!n.definition&&n.declarationArray[0].fnImport))throw new LinkingError("Tried to link mix of functions marked import",e.node,n.parseNode)}return n}externalVar(e){let n=this._linkables.get(e.name);if(void 0===n)this._linkables.set(e.name,n=new ExternalVariable(e.name,e.type));else{if(n instanceof ExternalFunction)throw new LinkingError("Tried to link variable with function",e.node,n.parseNode);if(!n.type.equals(e.type))throw new LinkingError("Tried to link variables with incompatible types",e.node,n.parseNode)}return n}}class Linkable{constructor(e,n){this.id=e,this.type=n,this.declarations=[]}addDeclaration(e){this.declarations.push(e),this._definition&&(e.definition=this._definition)}setDefinition(e,n){if(void 0!==this._definition)throw new LinkingError("Already defined!",e.node,this.parseNode);this._definition=e,this._defLinker=n,this.declarations.forEach((n=>{n.definition=e}))}get parseNode(){if(this._definition)return this._definition.node;if(this.declarations.length>0)return this.declarations[0].node;throw new LinkingError("Linkable without parse node? This shouldn't happen!")}get definition(){return this._definition}get definitionLinker(){if(!this._defLinker)throw new Error("Definition not set");return this._defLinker}get declarationArray(){return this.declarations}}class ExternalFunction extends Linkable{constructor(){super(...arguments),this.externalType="function"}}class ExternalVariable extends Linkable{constructor(){super(...arguments),this.externalType="variable"}}class LinkingError extends CError{constructor(){super(...arguments),this.name="LinkingError"}}function Yn(e,t){if("string"==typeof e){const n=new Map;n.set("main.c",e),e=n}const i=new linker_Linker(e,!0,t);i.link(function(e){const t=JSON.stringify(e);let i=Jn.get(t);i||(i=new linker_Linker(n,!0,e),i.link(),Jn.set(t,i));return i}(t));return new generator_WGenerator(i).module}const Jn=new Map;function Kn(e="",n=""){const t=document.createElement("div");return e&&(t.innerText=e),n&&(t.innerHTML+="\n"+n),document.body.appendChild(t),document.body.appendChild(document.createElement("hr")),t}document.body.innerHTML='\n    <a href="https://github.com/eembc/coremark" target="_blank" style="float: right"><b>Sources</b></a>\n    <h1>CoreMark</h1>\n    <h4>Compiled in the browser to WebAssembly using <a href="https://github.com/ictrobot/c2wasm">c2wasm</a>.</h4>\n    <hr>\n';let Qn=performance.now();Kn("Fetching sources"),fetch(`examples/CoreMark.json?v=${(new Date).getTime()}`).then((async e=>{const n=await e.text();Qn=performance.now()-Qn,Kn("Downloaded sources ",`- ${(n.length/1024).toFixed(2)} KiB in ${Qn.toFixed(2)}ms (${(8*n.length/1024/1024/(Qn/1e3)).toFixed(2)} Mb/s)`);const t=new Map(Object.entries(JSON.parse(n)));for(const[e,n]of[...t.entries()])e.startsWith("c2wasm/")?(t.set(e.replace("c2wasm/",""),n),t.delete(e)):e.startsWith("simple/")&&t.delete(e);Kn("Source license:",`<pre>${t.get("coremark.h")?.match(/\/\*([^\\*]*)\*\//)?.[1]}</pre>`),console.log("Sources",t),Kn("Precompiling standard library"),setTimeout((()=>async function(e){let n=performance.now();try{Yn("")}catch(e){return void Kn("Failed ",`<pre>${e.stack}</pre>`)}n=performance.now()-n,Kn("Compiled in",`${n.toFixed(2)} ms`),Kn("Compiling module"),setTimeout((()=>async function(e){o("default"),o({inlining:!0});let n,t="",i=performance.now();try{n=(await Yn(e).execute({c2wasm:{__put_char:e=>t+=String.fromCharCode(e),__time:()=>performance.now()}})).main}catch(e){return void Kn("Failed ",`<pre>${e.stack}</pre>`)}i=performance.now()-i,Kn("Compiled in",`${i.toFixed(2)} ms`);const s=document.createElement("button");s.innerText="Run",s.addEventListener("click",(()=>async function(e,n){Kn("Running CoreMark (will take 10-20 seconds)"),setTimeout((()=>{let t;try{t=e()}catch(e){return void Kn("Failed ",`<pre>${e.stack}</pre>`)}Kn("Output:",`<pre>${n()}</pre>`),Kn("Returned exit code",`<code>${t}</code>`)}),100)}(n,(()=>{const e=t;return t="",e})))),Kn("").appendChild(s)}(e)),100)}(t)),100)}))})()})();
//# sourceMappingURL=CoreMark.js.map