{"version":3,"file":"JPEG.js","mappings":"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AGjC,IAAK,IAAI/P,KAAKhjC,KAAKo6B,MAAM2Y,GAErB,IADA/P,GAAKA,KACK8O,EAAQ,CACd,IAAItuB,EAAIwvB,EAAkBhQ,EAAIhjC,KAAK4yC,eAAe5P,GAC9Cxf,IAAMxJ,EAAMwJ,KACZyvB,EAAS31C,KAAKkmB,GACdxJ,EAAMwJ,IAAK,GAIvB,OAAOyvB,GAEfE,aA1gBQ,SAAYp5B,GAIR,IAHA,IAAIq3B,EAAK,GACLpO,EAAIjpB,EAAEtX,IACN7D,EAAImb,EAAEq5B,KACD70C,EAAI,EAAGW,EAAI8jC,EAAExkC,OAAQD,EAAIW,EAAGX,IACjC6yC,EAAG9zC,KAAK,CACJ0lC,EAAEzkC,GACFK,EAAEL,KAGV,OAAO6yC,EAggBLiC,CAAG,CACf5wC,IAAK0uC,EAAE,CACP,GACA,GACA,GACAp3B,EACA,CAAC,GAAI,GACL,GACA,GACA,GACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACL,GACA,GACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACL,GACA,GACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACN,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,IACN,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,GACN,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,GACN,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,GACN,IACA,IACA,IACAA,EACA,CAAC,IAAK,GACN,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACN,IACA,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,GACN,IACA,IACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACN,IACA,IACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACN,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACN,IACA,IACA,IACA,IACA,MAEAq5B,KAAMjC,EAAE,CACR,EACAp3B,EACA,CAAC,EAAG,GACJoE,EACA,CAAC,GAAI,GACL,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACAA,EACA,CAAC,GAAI,GACLpE,EACA,CAAC,EAAG,GACJ,EACAA,EACA,CAAC,EAAG,GACJ,EACA,EACAA,EACA,CAAC,EAAG,GACJoE,EACA,CAAC,EAAG,GACJA,EACA,CAAC,EAAG,GACJA,EACA,CAAC,EAAG,GACJA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,EAAG,GACJ,EACAA,EACA,CAAC,EAAG,GACJpE,EACA,CAAC,EAAG,IACJoE,EACA,CAAC,GAAI,GACLA,EACA,CAAC,EAAG,GACJA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,EAAG,GACJA,EACA,CAAC,GAAI,GACLpE,EACA,CAAC,EAAG,IACJ,EACA,EACAoE,EACA,CAAC,IAAK,GACN,EACA,EACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,IAAK,GACN,EACA,EACA,EACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACL,EACA,EACA,EACAA,EACA,CAAC,EAAG,GACJA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACL,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACAA,EACA,CAAC,GAAI,GACLA,EACA,C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AFA,IAAI9B,EAAI+mB,EAAEjlB,GACN41C,EAAI,GACClgC,EAAI,EAAGA,EAAIxX,EAAGwX,IAAK,CACxB,IAAImgC,EAAIJ,EAAEzlC,QACV,OAAQlN,EAAEkN,SACV,KAAK,EACD4lC,EAAEC,GAAK,CACHz8B,EAAEpJ,QACF+C,EAAE/C,SAEN,MAEJ,KAAK,EACD4lC,EAAEC,GAAKrnC,EAAEwB,QACT,MAEJ,QAEI4lC,EAAEC,GAAK,CACH,IAIZhD,EAAG9zC,KAAK62C,GAEZ,OAAO/C,EAk8EZiD,CAAG,CACRtmB,IAAKojB,EAAE,CACP,GACA,EACA,GACAp3B,EACA,CAAC,EAAG,GACJ,GACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,EAAG,IACJ,EACA,EACAA,EACA,CAAC,EAAG,GACJ,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACAA,EACA,CAAC,EAAG,GACJ,GACA,GACA,EACA,GACA,EACA,GACA,GACA,EACA,EACA,EACA,GACA,GACA,EACA,EACA,EACA,EACA,GACA,GACA,EACA,EACA,GACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,GACA,EACA,GACA,GACA,GACA,GACA,GACAoE,EACA,CAAC,GAAI,GACLpE,EACA,CAAC,EAAG,GACJ,GACA,EACA,EACA,GACA,GACA,GACAA,EACA,CAAC,EAAG,GACJ,GACA,EACA,GACA,GACA,GACA,GACA,GACA,EACA,EACA,GACAoE,EACA,CAAC,GAAI,GACLpE,EACA,CAAC,EAAG,GACJ,GACA,GACA,EACA,EACA,EACAA,EACA,CAAC,EAAG,GACJ,GACA,EACAoE,EACA,CAAC,EAAG,GACJ,GACAA,EACA,CAAC,IAAK,GACN,EACApE,EACA,CAAC,EAAG,GACJoE,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACL,EACA,EACA,GACA,EACAA,EACA,CAAC,EAAG,GACJpE,EACA,CAAC,EAAG,GACJ,EACA,GACA,EACA,EACA,EACA,GACAA,EACA,CAAC,EAAG,IACJ,GACA,GACA,GACA,GACAoE,EACA,CAAC,GAAI,GACLA,EACA,CAAC,EAAG,GACJpE,EACA,CAAC,EAAG,GACJ,GACA,GACA,GACAoE,EACA,CAAC,GAAI,GACL,EACA,GACA,GACA,GACA,GACApE,EACA,CAAC,GAAI,GACL,GACA,GACA,GACA,GACAA,EACA,CAAC,GAAI,GACL,EACA,EACA,GACA,EACA,GACA,EACA,GACAA,EACA,CAAC,GAAI,GACL,EACA,GACAoE,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACL,GACA,EACA,EACA,EACA,EACA,GACAA,EACA,CAAC,GAAI,GACL,EACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,IAAK,GACN,EACA,EACA,EACAA,EACA,CAAC,GAAI,GACL,EACA,GACA,GACA,EACA,GACAA,EACA,CAAC,IAAK,GACN,GACA,GACA,GACA,GACApE,EACA,CAAC,GAAI,GACL,GACA,GACA,GACAoE,EACA,CAAC,IAAK,GACNA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACL,EACA,EACA,EACA,GACA,GACAA,EACA,CAAC,GAAI,GACL,GACA,GACA,EACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,GAAI,GACL,EACA,GACA,EACAA,EACA,CAAC,IAAK,GACNpE,EACA,CAAC,GAAI,GACL,GACA,GACA,GACAoE,EACA,CAAC,GAAI,GACL,EACA,GACAA,EACA,CAAC,GAAI,GACL,GACA,EACA,GACAA,EACA,CAAC,GAAI,GACL,GACA,EACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACL,EACA,IAEAw0B,OAAQxB,EAAE,CACV,EACAp3B,EACA,CAAC,GAAI,GAAI,GACT,GACA,IACA,IACAA,EACA,CAAC,IAAK,EAAG,GACT,IACA,IACA,IACA,IACA,IACA,IACA,EACAoE,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,GACL,IACA,IACA,EACA,GACA,GACA,GACA,GACA,IACA,IACA,IACA,IACA,IACA,EACA,EACA,EACA,EACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,KACL,GACA,GACA,GACAA,EACA,CAAC,EAAG,GACJ,EACA,GACA,GACA,GACA,IACA,EACA,GACA,EACA,GACA,GACA,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACL,GACA,GACA,IACA,IACA,IACA,EACA,GACA,GACA,GACAA,EACA,CAAC,IAAK,GACN,GACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLpE,EACA,CAAC,IAAK,EAAG,GACT,IACA,IACA,GACA,GACA,IACA,IACAoE,EACA,CAAC,GAAI,IACL,EACApE,EACA,CAAC,EAAG,EAAG,GACP,GACAA,EACA,CAAC,GAAI,EAAG,GACR,GACA,GACA,GACAA,EACA,CAAC,GAAI,EAAG,GACRA,EACA,CAAC,GAAI,GAAI,GACT,IACAoE,EACA,CAAC,GAAI,GACLpE,EACA,CAAC,GAAI,GAAI,GACToE,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,IACL,GACA,GACA,GACApE,EACA,CAAC,GAAI,EAAG,GACRoE,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,IAAK,GACNpE,EACA,CAAC,IAAK,EAAG,GACToE,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACN,EACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,IACN,IACA,EACAA,EACA,CAAC,IAAK,IACN,IACA,IACA,IACAA,EACA,CAAC,IAAK,GACN,EACAA,EACA,CAAC,IAAK,IACN,GACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,IAAK,GACN,IACA,IACAA,EACA,CAAC,IAAK,GACN,GACA,GACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,IACL,EACA,GACA,EACA,GACA,GACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,IACN,IACA,EACA,EACApE,EACA,CAAC,EAAG,EAAG,GACPA,EACA,CAAC,GAAI,GAAI,GACT,GACAA,EACA,CAAC,GAAI,GAAI,GACT,IACAoE,EACA,CAAC,GAAI,GACL,GACA,GACA,GACA,GACA,GACApE,EACA,CAAC,EAAG,GAAI,GACRoE,EACA,CAAC,GAAI,IACL,GACA,GACA,GACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,IACL,GACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,GACN,GACA,GACAA,EACA,CAAC,EAAG,GACJA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,IAAK,IACNpE,EACA,CAAC,GAAI,EAAG,GACRoE,EACA,CAAC,IAAK,IACN,GACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,GACN,IACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,IAAK,GACN,EACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,IAAK,GACN,GACA,GACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,GAAI,GACL,GACA,GACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,KAAM,GACP,EACAA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACN,GACAA,EACA,CAAC,KAAM,GACPpE,EACA,CAAC,EAAG,GACJoE,EACA,CAAC,IAAK,GACNA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACN,GACA,GACA,GACA,GACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,IAAK,GACN,EACA,EACA,EACA,EACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,KAAM,GACP,IACA,IACAA,EACA,CAAC,IAAK,IACN,EACA,GACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,GACN,GACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACL,EACAA,EACA,CAAC,GAAI,IACLpE,EACA,CAAC,GAAI,GAAI,GACT,GACA,GACA,GACA,GACAoE,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,IACL,EACA,EACA,EACAA,EACA,CAAC,KAAM,GACPA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,KACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACN,GACAA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,IAAK,KACNA,EACA,CAAC,GAAI,IACL,GACAA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACP,IACA,GACA,EACA,GACApE,EACA,CAAC,GAAI,GAAI,GACToE,EACA,CAAC,GAAI,GACLA,EACA,CAAC,KAAM,GACPA,EACA,CAAC,KAAM,GACP,IACAA,EACA,CAAC,EAAG,GACJA,EACA,CAAC,KAAM,GACPA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,KAAM,GACPA,EACA,CAAC,KAAM,GACPA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,GACPA,EACA,CAAC,KAAM,GACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACP,EACA,GACAA,EACA,CAAC,KAAM,GACP,EACA,EACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,IAAK,IACN,EACA,EACAA,EACA,CAAC,IAAK,GACN,GACAA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,KAAM,GACPA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,GAAI,KACLA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,GAAI,IACL,EACA,EACAA,EACA,CAAC,KAAM,IACPpE,EACA,CAAC,GAAI,EAAG,GACRoE,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,KACLA,EACA,CAAC,KAAM,GACPA,EACA,CAAC,IAAK,OAENtgB,KAAMszC,EAAE,CACRp3B,EACA,CAAC,EAAG,IACJA,EACA,CAAC,EAAG,IACJ,EACAoE,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLpE,EACA,CAAC,EAAG,IACJoE,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,KACLA,EACA,CAAC,EAAG,GACJA,EACA,CAAC,EAAG,GACJA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNpE,EACA,CAAC,EAAG,IACJA,EACA,CAAC,EAAG,IACJoE,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNpE,EACA,CAAC,EAAG,IACJoE,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNpE,EACA,CAAC,EAAG,KACJoE,EACA,CAAC,IAAK,IACNA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,KAAM,GACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,KACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,KAAM,GACPA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNpE,EACA,CAAC,EAAG,KACJoE,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,GAAI,KACLA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,GAAI,KACLA,EACA,CAAC,IAAK,MAEN40B,MAAO5B,EAAE,CACT,EACAp3B,EACA,CAAC,EAAG,EAAG,GACP,GACA,GACA,GACA,GACA,GACA,EACAA,EACA,CAAC,EAAG,EAAG,GACPoE,EACA,CAAC,GAAI,GACL,GACA,EACA,GACA,GACA,GACA,GACA,GACA,GACA,GACAA,EACA,CAAC,GAAI,GACL,GACAA,EACA,CAAC,EAAG,GACJ,GACAA,EACA,CAAC,EAAG,GACJ,GACAA,EACA,CAAC,EAAG,GACJ,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,IACA,GACA,GACA,GACA,GACA,GACApE,EACA,CAAC,IAAK,GAAI,GACV,IACA,IACA,GACA,GACA,GACA,GACA,GACA,GACA,IACAoE,EACA,CAAC,GAAI,IACL,IACA,IACA,IACA,IACAA,EACA,CAAC,GAAI,GACL,IACA,IACA,IACA,IACA,IACApE,EACA,CAAC,IAAK,EAAG,GACT,GACA,IACA,IACA,GACA,GACAoE,EACA,CAAC,GAAI,GACL,IACAA,EACA,CAAC,GAAI,IACL,IACA,IACA,IACAA,EACA,CAAC,GAAI,GACL,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,GACN,IACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,EAAG,GACJ,IACAA,EACA,CAAC,EAAG,GACJ,GACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,GACN,IACAA,EACA,CAAC,GAAI,GACL,IACAA,EACA,CAAC,IAAK,GACN,IACAA,EACA,CAAC,IAAK,IACN,IACA,IACA,IACAA,EACA,CAAC,GAAI,GACL,IACA,GACAA,EACA,CAAC,EAAG,GACJ,IACAA,EACA,CAAC,EAAG,GACJ,IACA,GACA,IACAA,EACA,CAAC,EAAG,GACJ,IACA,GACA,IACAA,EACA,CAAC,GAAI,IACL,IACA,IACAA,EACA,CAAC,GAAI,GACL,IACA,GACA,GACA,IACAA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,IAAK,GACN,GACA,GACAA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,GAAI,IACL,IACApE,EACA,CAAC,IAAK,EAAG,GACT,IACAoE,EACA,CAAC,IAAK,IACN,IACA,GACA,IACA,GACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,GACN,GACA,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,GACL,IACAA,EACA,CAAC,GAAI,IACL,IACA,IACA,IACAA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,GAAI,IACL,IACA,IACA,IACA,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,GACL,IACAA,EACA,CAAC,GAAI,GACL,IACAA,EACA,CAAC,GAAI,GACL,IACAA,EACA,CAAC,EAAG,GACJ,IACAA,EACA,CAAC,EAAG,GACJ,IACAA,EACA,CAAC,IAAK,IACN,IACApE,EACA,CAAC,IAAK,EAAG,GACToE,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACA,IACAA,EACA,CAAC,IAAK,GACN,IACAA,EACA,CAAC,IAAK,GACN,IACA,GACA,GACA,IACA,GACAA,EACA,CAAC,GAAI,GACL,GACA,GACA,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,GACN,IACA,GACA,IACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,GAAI,GACL,IACA,IACAA,EACA,CAAC,GAAI,GACL,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,IAAK,IACN,IACA,IACA,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,IAAK,GACN,IACA,IACA,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,KAEL81B,KAAM9C,EAAE,CACRp3B,EACA,CAAC,EAAG,IACJA,EACA,CAAC,EAAG,GACJoE,EACA,CAAC,GAAI,KACLA,EACA,CAAC,GAAI,GACL,EACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,EAAG,GACJA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACLpE,EACA,CAAC,EAAG,IACJoE,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,IACLpE,EACA,CAAC,EAAG,IACJoE,EACA,CAAC,GAAI,GACLA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,EAAG,IACJA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACNpE,EACA,CAAC,EAAG,KACJoE,EACA,CAAC,IAAK,KACNpE,EACA,CAAC,EAAG,KACJoE,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,IAAK,KACNpE,EACA,CAAC,EAAG,IACJoE,EACA,CAAC,IAAK,IACNpE,EACA,CAAC,EAAG,OAEJm6B,KAAM/C,EAAE,CACR,EACAp3B,EACA,CAAC,GAAI,GAAI,GACT,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACAoE,EACA,CAAC,GAAI,IACL,GACA,GACA,GACA,GACApE,EACA,CAAC,GAAI,GACLoE,EACA,CAAC,GAAI,IACLpE,EACA,CAAC,GAAI,GACLoE,EACA,CAAC,GAAI,IACLpE,EACA,CAAC,GAAI,GACLoE,EACA,CAAC,GAAI,IACLpE,EACA,CAAC,GAAI,GACLoE,EACA,CAAC,GAAI,IACL,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,IACA,GACApE,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACN,GACA,IACA,GACA,GACA,GACA,GACAA,EACA,CAAC,IAAK,GACN,GACAA,EACA,CAAC,IAAK,IACNoE,EACA,CAAC,GAAI,IACL,GACApE,EACA,CAAC,IAAK,GACN,GACAA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,GAAI,EAAG,GACR,GACA,GACAA,EACA,CAAC,IAAK,EAAG,GACT,IACA,GACA,GACA,GACAoE,EACA,CAAC,GAAI,GACL,IACA,GACA,IACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACN,IACA,IACApE,EACA,CAAC,IAAK,EAAG,GACToE,EACA,CAAC,IAAK,GACN,GACA,IACA,GACApE,EACA,CAAC,IAAK,GACN,IACA,IACAoE,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACLpE,EACA,CAAC,IAAK,GACN,GACA,IACA,GACA,IACAoE,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,GACLpE,EACA,CAAC,IAAK,GACNoE,EACA,CAAC,GAAI,IACLpE,EACA,CAAC,IAAK,GACNoE,EACA,CAAC,GAAI,IACL,IACA,IACA,IACA,IACA,IACA,GACAA,EACA,CAAC,IAAK,IACNpE,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,GAAI,GACVA,EACA,CAAC,GAAI,GACL,IACAA,EACA,CAAC,GAAI,GACL,IACA,IACA,GACA,IACA,GACA,IACAA,EACA,CAAC,GAAI,IACL,IACA,IACA,IACAA,EACA,CAAC,GAAI,IACL,IACAoE,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACLpE,EACA,CAAC,GAAI,GACL,IACA,GACAA,EACA,CAAC,GAAI,GACL,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACLoE,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACNpE,EACA,CAAC,GAAI,GACL,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACL,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,IACL,IACA,IACA,GACA,GACAA,EACA,CAAC,GAAI,GACL,IACA,IACAA,EACA,CAAC,GAAI,GACL,IACA,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,IACL,IACA,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACL,IACA,IACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,GACL,IACA,GACA,GACA,IACA,IACAA,EACA,CAAC,GAAI,IACLoE,EACA,CAAC,IAAK,GACN,IACAA,EACA,CAAC,IAAK,IACN,GACA,GACApE,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACLoE,EACA,CAAC,IAAK,IACN,IACA,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACL,IACA,GACA,IACA,IACAA,EACA,CAAC,GAAI,GACL,IACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,GACN,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,GACA,GACA,IACAA,EACA,CAAC,IAAK,IACN,IACA,IACA,IACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,GAAI,IACL,IACA,IACA,IACA,IACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,GACAA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,IACL,IACA,IACA,IACA,IACA,IACA,IACA,GACAA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,KACLA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,IAAK,IACN,IACA,IACA,IACAA,EACA,CAAC,GAAI,IACL,IACA,IACA,IACA,IACA,IACA,GACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,GACA,GACAA,EACA,CAAC,GAAI,IACL,IACA,IACAA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,KAAM,GACP,IACAA,EACA,CAAC,KAAM,GACP,IACAA,EACA,CAAC,GAAI,IACL,IACA,IACApE,EACA,CAAC,GAAI,GACL,IACA,GACA,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,GAAI,GACL,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACL,IACAA,EACA,CAAC,GAAI,GACLoE,EACA,CAAC,IAAK,IACN,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,IACNpE,EACA,CAAC,GAAI,GACL,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,IACL,IACA,IACA,GACA,GACAA,EACA,CAAC,GAAI,GACL,IACA,IACAA,EACA,CAAC,GAAI,GACL,IACA,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACL,IACA,IACAA,EACA,CAAC,GAAI,GACL,IACA,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,IACL,IACA,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,IACL,IACA,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,IACL,IACA,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,IACL,IACA,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACL,IACA,IACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,GACL,IACA,IACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,GACL,IACA,GACA,GACA,IACA,IACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,GACL,IACA,GACA,GACA,IACA,IACAA,EACA,CAAC,GAAI,IACLoE,EACA,CAAC,IAAK,IACN,IACA,IACA,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,IACL,IACA,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,IAAK,IACN,IACA,IACA,IACAA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACA,IACApE,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,IAAK,GACN,IACA,IACAoE,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,IAAK,QAGRm2B,eA5+IQ,SAAav6B,GAIT,IAHA,IAAIq3B,EAAK,GACL5tB,EAAIzJ,EAAEjZ,IACNwQ,EAAIyI,EAAEm6B,KACD31C,EAAI,EAAGW,EAAIskB,EAAEhlB,OAAQD,EAAIW,EAAGX,IAAK,CAEtC6yC,EADQ5tB,EAAEjlB,IACF+S,EAAE/S,GAEd,OAAO6yC,EAo+IHmD,CAAI,CAClBzzC,IAAKqwC,EAAE,CACPp3B,EACA,CAAC,EAAG,EAAG,GACPA,EACA,CAAC,GAAI,GAAI,GACTA,EACA,CAAC,GAAI,EAAG,GACR,GACA,GACA,GACAA,EACA,CAAC,GAAI,EAAG,GACR,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACAA,EACA,CAAC,GAAI,EAAG,GACR,GACA,GACAA,EACA,CAAC,IAAK,EAAG,GACT,IACA,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,EAAG,GACT,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,EAAG,GACT,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,EAAG,GACT,IACAA,EACA,CAAC,IAAK,GAAI,GACV,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,EAAG,GACT,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,EAAG,GACT,IACA,IACAA,EACA,CAAC,IAAK,EAAG,GACT,IACA,IACAA,EACA,CAAC,IAAK,EAAG,GACT,IACA,IACA,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,EAAG,GACT,IACA,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,EAAG,KAETm6B,KAAM/C,EAAE,CACR,EACA,IACA,IACA,IACAp3B,EACA,CAAC,IAAK,GAAI,GACV,IACA,IACA,IACA,IACA,IACA,EACA,IACA,GACA,GACA,IACA,EACAA,EACA,CAAC,GAAI,EAAG,GACR,IACA,GACA,IACA,IACA,IACA,IACA,GACA,IACA,GACA,GACAA,EACA,CAAC,GAAI,EAAG,GACR,GACA,GACAA,EACA,CAAC,EAAG,EAAG,GACP,GACA,EACA,GACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,EAAG,GACT,IACA,GACA,GACA,IACA,GACA,GACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,GAAI,GAAI,GACT,GACA,GACAA,EACA,CAAC,GAAI,EAAG,GACR,GACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,GACA,GACA,GACA,GACA,GACA,GACA,IACA,GACA,GACA,GACA,IACA,IACA,GACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,GACA,GACA,GACA,GACA,IACA,IACA,IACA,IACA,IACA,IACA,GACA,GACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,QAGFy6B,WAAY,SAAoBp2C,EAAKmqB,EAAMksB,GACvC,IAAIlsB,EAAKmsB,YAYL,KAN0B,mBAAf10C,KAAKuxC,OACZvxC,KAAKuxC,MAAMnzC,GAEVq2C,IACDA,EAAiBz0C,KAAK0wC,kBAEpB,IAAI+D,EAAer2C,EAAKmqB,GAXJ,mBAAfvoB,KAAKuxC,OACZvxC,KAAKuxC,MAAMnzC,GAEfmqB,EAAKosB,WAWbtsB,MAAO,SAAeC,GAClB,IAQIirB,EACA1qB,EAaAV,EAtBAqM,EAAOx0B,KACP6C,EAAQ,IAAI+S,MAAM,KAClBg/B,EAAS,IAAIh/B,MAAM,KAEnBi/B,EAAS,IAAIj/B,MAAM,KACnBk/B,EAAS,IAAIl/B,MAAM,KACnBwkB,EAAQp6B,KAAKo6B,MACb2a,EAAK,EAMLpC,EAAS,EAKTZ,GADS/xC,KAAK8xC,OACR9xC,KAAK+xC,KAEXiD,GADsCh1C,KAAKyxC,QAAQE,+BACvC,CAAC,EAAG,MAIhBxpB,EADAnoB,KAAKi1C,UACGj1C,KAAKi1C,UAELj1C,KAAKi1C,UAAYv6C,OAAO42C,OAAOtxC,KAAKmoB,OAGhD,IAAI+sB,EAAiB,CACjBV,gBAAYr1C,EACZqzC,eAAWrzC,EACXgpB,WAAOhpB,EACPqpB,YAAQrpB,EACRg2C,eAAWh2C,EACXi2C,gBAAYj2C,EACZk2C,aAASl2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","sources":["webpack://@ictrobot/c2wasm/./src/c_library/standard_library.ts","webpack://@ictrobot/c2wasm/./src/optimisation/flags.ts","webpack://@ictrobot/c2wasm/./src/wasm/encoding.ts","webpack://@ictrobot/c2wasm/./src/wasm/wtypes.ts","webpack://@ictrobot/c2wasm/./src/wasm/instr_helpers.ts","webpack://@ictrobot/c2wasm/./src/wasm/instructions.ts","webpack://@ictrobot/c2wasm/./src/optimisation/dead_code.ts","webpack://@ictrobot/c2wasm/./src/optimisation/peephole.ts","webpack://@ictrobot/c2wasm/./src/optimisation/flow/control_flow.ts","webpack://@ictrobot/c2wasm/./src/optimisation/flow/framework.ts","webpack://@ictrobot/c2wasm/./src/optimisation/flow/local_allocation.ts","webpack://@ictrobot/c2wasm/./src/wasm/global.ts","webpack://@ictrobot/c2wasm/./src/optimisation/splicer.ts","webpack://@ictrobot/c2wasm/./src/optimisation/flow/pre.ts","webpack://@ictrobot/c2wasm/./src/optimisation/flow/range_splitting.ts","webpack://@ictrobot/c2wasm/./src/c_error.ts","webpack://@ictrobot/c2wasm/./src/ir/types.ts","webpack://@ictrobot/c2wasm/./src/ir/type_checking.ts","webpack://@ictrobot/c2wasm/./src/ir/expressions.ts","webpack://@ictrobot/c2wasm/./src/ir/scope.ts","webpack://@ictrobot/c2wasm/./src/ir/statements.ts","webpack://@ictrobot/c2wasm/./src/ir/declarations.ts","webpack://@ictrobot/c2wasm/./src/ir/transform/constant_expressions.ts","webpack://@ictrobot/c2wasm/./src/generation/gen_error.ts","webpack://@ictrobot/c2wasm/./src/generation/static_initializer.ts","webpack://@ictrobot/c2wasm/./src/generation/type_conversion.ts","webpack://@ictrobot/c2wasm/./src/generation/storage.ts","webpack://@ictrobot/c2wasm/./src/parsing/validation.ts","webpack://@ictrobot/c2wasm/./src/parsing/lexer.ts","webpack://@ictrobot/c2wasm/./src/parsing/parser.ts","webpack://@ictrobot/c2wasm/./src/ir/internal_scope.ts","webpack://@ictrobot/c2wasm/./src/generation/wasm_functions.ts","webpack://@ictrobot/c2wasm/./src/generation/expressions.ts","webpack://@ictrobot/c2wasm/./src/optimisation/flow/reaching_defs.ts","webpack://@ictrobot/c2wasm/./src/optimisation/index.ts","webpack://@ictrobot/c2wasm/./src/wasm/functions.ts","webpack://@ictrobot/c2wasm/./src/wasm/module.ts","webpack://@ictrobot/c2wasm/./src/optimisation/interprocedural/functions.ts","webpack://@ictrobot/c2wasm/./src/generation/statements.ts","webpack://@ictrobot/c2wasm/./src/generation/generator.ts","webpack://@ictrobot/c2wasm/./src/optimisation/interprocedural/index.ts","webpack://@ictrobot/c2wasm/./src/ir/transform/type_transform.ts","webpack://@ictrobot/c2wasm/./src/ir/transform/expr_transform.ts","webpack://@ictrobot/c2wasm/./src/preprocessor/conditionals.ts","webpack://@ictrobot/c2wasm/./src/preprocessor/helpers.ts","webpack://@ictrobot/c2wasm/./src/preprocessor/definition.ts","webpack://@ictrobot/c2wasm/./src/preprocessor/preprocessor.ts","webpack://@ictrobot/c2wasm/./src/ir/transform/transform.ts","webpack://@ictrobot/c2wasm/./src/ir/index.ts","webpack://@ictrobot/c2wasm/./src/linker.ts","webpack://@ictrobot/c2wasm/./src/compile.ts","webpack://@ictrobot/c2wasm/./src/c_library/runtime/args.ts","webpack://@ictrobot/c2wasm/./src/c_library/runtime/files.ts","webpack://@ictrobot/c2wasm/./demos/JPEG.ts","webpack://@ictrobot/c2wasm/./src/parsing/parsetree.ts","webpack://@ictrobot/c2wasm/./src/parsing/gen/c_grammar.js","webpack://@ictrobot/c2wasm/webpack/bootstrap","webpack://@ictrobot/c2wasm/webpack/runtime/define property getters","webpack://@ictrobot/c2wasm/webpack/runtime/harmony module decorator","webpack://@ictrobot/c2wasm/webpack/runtime/hasOwnProperty shorthand","webpack://@ictrobot/c2wasm/webpack/runtime/make namespace object","webpack://@ictrobot/c2wasm/webpack/startup"],"sourcesContent":["import lib from \"./_standard_library.json\";\n\nexport const STANDARD_LIBRARY = new Map(Object.entries(lib)) as ReadonlyMap<string, string>;\n\nexport const LIBRARY_HEADERS = (() => {\n    const map = new Map<string, string>();\n    for (const [path, data] of STANDARD_LIBRARY.entries()) {\n        if (path.endsWith(\".h\")) map.set(path, data);\n    }\n    return map as ReadonlyMap<string, string>;\n})();\n","const DEFAULT = {\n    generation_try_constant_expr: true,\n    generation_zero_shadow_stack: false,\n    generation_switch_br_table: false,\n\n    peephole_local_tee: true,\n    peephole_i32_constants_ops: true,\n    peephole_constants_add_mul: true,\n    peephole_add_0: true,\n    peephole_combine_adds: true,\n    peephole_load_offset: true,\n    peephole_constant_if: true,\n    peephole_unused_blocks: true,\n\n    partial_redundancy_elimination: true,\n    copy_propagation: true,\n    live_range_splitting: true,\n    dead_code_elimination: true,\n    reallocate_locals: true,\n    unused_locals: true,\n\n    peephole_2nd_pass: true,\n\n    // interprocedural\n    inlining: false,\n} as const;\n\nexport type OptimisationFlags = {[k in keyof typeof DEFAULT]: boolean};\n\nlet current: OptimisationFlags = DEFAULT;\n\nexport function setFlags(flags: Partial<OptimisationFlags> | \"none\" | \"default\"): void {\n    if (typeof flags === \"object\") {\n        current = {...current, ...flags};\n    } else if (flags === \"default\") {\n        current = DEFAULT;\n    } else if (flags === \"none\") {\n        current = {...current, ...Object.fromEntries(Object.keys(DEFAULT).map(name => [name, false]))};\n    }\n\n    // ensure valid configuration of flags\n    if (current.reallocate_locals && !current.copy_propagation) {\n        // realloc_locals presumes that variables are dead if not accessed, so copy_propagation\n        // is required to remove definitions which are never used.\n        current = {...current, copy_propagation: true};\n    }\n}\n\nexport function getFlags(): OptimisationFlags {\n    // return a copy\n    return {...current};\n}\n\nexport function getDefaultFlags(): OptimisationFlags {\n    return {...DEFAULT};\n}\n","import type {byte} from \"./base_types\";\nimport {ValueType, i32Type, i64Type, f32Type, f64Type} from \"./wtypes\";\n\nexport function encodeF32(n: number): byte[] {\n    const buffer = new ArrayBuffer(4);\n    new DataView(buffer).setFloat32(0, n, true);\n    return [...new Uint8Array(buffer)] as byte[];\n}\n\nexport function encodeF64(n: number): byte[] {\n    const buffer = new ArrayBuffer(8);\n    new DataView(buffer).setFloat64(0, n, true);\n    return [...new Uint8Array(buffer)] as byte[];\n}\n\n// unsigned 32 bit integer, used in wasm module format\nexport function encodeU32(n: bigint): byte[] {\n    if (n > 2n ** 32n - 1n || n < 0n) {\n        throw new Error(`Value ${n} outside of range for u32`);\n    }\n    return unsignedLeb128(n) as byte[];\n}\n\n// \"uninterpreted\" values, i.e. could be signed or not signed. Stored as signed. Used for constants\nexport function encodeInt32Constant(n: bigint | number): byte[] {\n    if (typeof n === \"number\") n = BigInt(n);\n\n    if (n < 2n ** 32n && n > 2n ** 31n - 1n) {\n        // need to reinterpret unsigned number as a signed number\n        n -= 2n ** 32n;\n    } else if (n > 2n ** 31n - 1n || n < -(2n ** 31n)) {\n        throw new Error(`Value ${n} outside of range for 32bit uninterpreted int`);\n    }\n    return signedLeb128(n) as byte[];\n}\n\nexport function encodeInt64Constant(n: bigint): byte[] {\n    if (n < 2n ** 64n && n > 2n ** 63n - 1n) {\n        // need to reinterpret unsigned number as a signed number\n        n -= 2n ** 64n;\n    } else if (n > 2n ** 63n - 1n || n < -(2n ** 63n)) {\n        throw new Error(`Value ${n} outside of range for 64bit uninterpreted int`);\n    }\n    return signedLeb128(n) as byte[];\n}\n\nexport function encodeConstantInstr(n: number | bigint, type: ValueType): byte[] {\n    if (type === i32Type) {\n        return [0x41 as byte, ...encodeInt32Constant(n)];\n    } else if (type === i64Type && typeof n === \"bigint\") {\n        return [0x42 as byte, ...encodeInt64Constant(n)];\n    } else if (type === f32Type && typeof n === \"number\") {\n        return [0x43 as byte, ...encodeF32(n)];\n    } else if (type === f64Type && typeof n === \"number\") {\n        return [0x44 as byte, ...encodeF64(n)];\n    } else {\n        throw new Error(`Invalid value type (${type.toString(16)}) or initial value (${n})`);\n    }\n}\n\nexport function encodeUtf8(str: string): byte[] {\n    // modified from https://developer.mozilla.org/en-US/docs/Web/API/TextEncoder#Polyfill\n    const result = [];\n    for (let point = 0, nextcode = 0, i = 0; i < str.length;) {\n        point = str.charCodeAt(i++);\n        if (point >= 0xD800 && point <= 0xDBFF) {\n            if (i === str.length) {\n                result.push(0xef, 0xbf, 0xbd);\n                break;\n            }\n            nextcode = str.charCodeAt(i);\n            if (nextcode >= 0xDC00 && nextcode <= 0xDFFF) {\n                point = (point - 0xD800) * 0x400 + nextcode - 0xDC00 + 0x10000;\n                i += 1;\n                if (point > 0xffff) {\n                    result.push((0x1e << 3) | (point >>> 18), (0x2 << 6) | ((point >>> 12) & 0x3f), (0x2 << 6) | ((point >>> 6) & 0x3f), (0x2 << 6) | (point & 0x3f));\n                    continue;\n                }\n            } else {\n                result.push(0xef, 0xbf, 0xbd);\n                continue;\n            }\n        }\n        if (point <= 0x007f) {\n            result.push((0x0 << 7) | point);\n        } else if (point <= 0x07ff) {\n            result.push((0x6 << 5) | (point >>> 6), (0x2 << 6) | (point & 0x3f));\n        } else {\n            result.push((0xe << 4) | (point >>> 12), (0x2 << 6) | ((point >>> 6) & 0x3f), (0x2 << 6) | (point & 0x3f));\n        }\n    }\n    // WebAssembly stores strings as a vector of bytes, so need to add the length\n    // (stored as u32) at the start\n    result.unshift(...encodeU32(BigInt(result.length)));\n    return result as byte[];\n}\n\nexport function unsignedLeb128(n: bigint): number[] {\n    const result: number[] = [];\n\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        const byte = Number(n & 0x7Fn);\n        n >>= 7n;\n        if (n === 0n) {\n            result.push(byte);\n            return result;\n        }\n        result.push(byte | 0x80);\n    }\n}\n\nexport function signedLeb128(n: bigint): number[] {\n    const result: number[] = [];\n\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        const byte = Number(n & 0x7Fn);\n        n >>= 7n;\n        if ((n === 0n && (byte & 0x40) === 0) || (n === -1n && (byte & 0x40) !== 0)) {\n            result.push(byte);\n            return result;\n        }\n        result.push(byte | 0x80);\n    }\n}\n","import type {byte} from \"./base_types\";\nimport {encodeU32} from \"./encoding\";\n\nexport type ValueType = byte & { __type_value_type__: void };\nexport const i32Type = 0x7F as ValueType;\nexport const i64Type = 0x7E as ValueType;\nexport const f32Type = 0x7D as ValueType;\nexport const f64Type = 0x7C as ValueType;\n\n\nexport type ResultType = ValueType[];\n\nexport function encodeResultType(r: ResultType): byte[] {\n    return encodeVec(r.map(x => [x]));\n}\n\n\nexport type FunctionType = [parameters: ResultType, results: ResultType];\n\nexport function encodeFunctionType(f: FunctionType): byte[] {\n    return [0x60 as byte, ...encodeResultType(f[0]), ...encodeResultType(f[1])];\n}\n\n\nexport type Limits = [minimum: bigint, maximum?: bigint];\nexport type MemoryType = Limits;\n\nexport function encodeLimits(l: Limits): byte[] {\n    if (l[1] === undefined) {\n        return [0x00 as byte, ...encodeU32(l[0])];\n    } else {\n        return [0x01 as byte, ...encodeU32(l[0]), ...encodeU32(l[1])];\n    }\n}\n\n\nexport type GlobalType = [type: ValueType, mutable: boolean];\n\nexport function encodeGlobal(g: GlobalType): byte[] {\n    return [g[0], g[1] ? 0x01 as byte : 0x00 as byte];\n}\n\n\nexport function encodeVec(values: byte[][]): byte[] {\n    return [...encodeU32(BigInt(values.length)), ...values.flat()];\n}\n","import {byte, labelidx} from \"./base_types\";\nimport {encodeU32} from \"./encoding\";\nimport {WFunctionBuilder, WLocal} from \"./functions\";\nimport {WGlobal} from \"./global\";\nimport {ValueType, i32Type, encodeVec} from \"./wtypes\";\n\nexport type ReadResource = \"memory\" | WLocal | WGlobal;\nexport type WriteResource = \"jump\" | \"arbitraryCode\" | ReadResource;\n\ntype Context = {\n    depth: number;\n    builder: WFunctionBuilder,\n    stack: ReadonlyArray<ValueType>;\n};\ntype InstrContext<T> = (c: Context) => T;\nexport type PartialInstr = InstrContext<InstrInstance>;\n\nexport interface BaseInstance<T extends BaseInstance<T>> {\n    readonly name: string;\n    readonly type: string;\n    readonly immediate: object;\n\n    /* Instruction as bytes */\n    encoded: ReadonlyArray<byte>;\n    /* Values consumed from stack, parameters[n-1] being top of the stack */\n    readonly parameters: ReadonlyArray<ValueType>;\n    /* Value pushed onto stack if any */\n    readonly result: ValueType | null;\n\n    readonly reads: ReadonlyArray<ReadResource>;\n    /* Resource written to */\n    readonly writes: ReadonlyArray<WriteResource>;\n\n    /* deep copy a function without re-evaluate parameters */\n    copy(): InstrContext<T>;\n}\n\nexport type InstrInstance = ZeroArgInstance | ConstantInstance<bigint | number> | MemInstance | IdxInstance | TableInstance | StructureInstance;\n\n// Zero argument instructions\ninterface ZeroArgInstance extends BaseInstance<ZeroArgInstance> {\n    type: \"zeroArg\";\n    immediate: {};\n}\n\nexport function zeroArgs(name: string, opcode: number[], parameters: ReadonlyArray<ValueType>, result: ValueType | null,\n                         reads: ReadResource[] = [], writes: WriteResource[] = []): () => InstrContext<ZeroArgInstance> {\n    const instr: ZeroArgInstance = {\n        name,\n        type: \"zeroArg\", immediate: {},\n        encoded: opcode as byte[],\n        parameters, result,\n        reads, writes,\n\n        copy() {\n            return () => this;\n        }\n    };\n    return () => () => instr;\n}\n\ntype DataFlow = {parameters: ValueType[], result: ValueType | null, reads: ReadResource[], writes: WriteResource[]};\nexport function zeroArgsSpecial(name: string, opcode: number[], specialFn: InstrContext<DataFlow>): () => InstrContext<ZeroArgInstance> {\n    return () => (context) => {\n        const {parameters, result, reads, writes} = specialFn(context);\n        return {\n            name, type: \"zeroArg\", immediate: {},\n            encoded: opcode as byte[],\n            parameters, result,\n            reads, writes,\n\n            copy() {\n                return () => this;\n            }\n        };\n    };\n}\n\n// Arithmetic constant instructions\ninterface ConstantInstance<T extends bigint | number> extends BaseInstance<ConstantInstance<T>> {\n    type: \"constant\";\n    immediate: {readonly value: T};\n    result: ValueType;\n}\n\nexport function constantArg<T extends bigint | number>(name: string, opcode: number[],\n                                                       encodeFn: (x: T) => byte[],\n                                                       typeFn: (x: T) => T,\n                                                       result: ValueType): (x: T) => InstrContext<ConstantInstance<T>> {\n    return (value) => () => ({\n        name, type: \"constant\",\n        immediate: {value: typeFn(value)},\n        encoded: [...opcode as byte[], ...encodeFn(value)],\n        parameters: [], result,\n        reads: [], writes: [],\n\n        copy() {\n            return () => this;\n        }\n    });\n}\n\n// Memory argument instructions\ninterface MemInstance extends BaseInstance<MemInstance> {\n    type: \"memory\";\n    immediate: {readonly align: bigint, readonly offset: bigint};\n}\n\nexport function memArg(name: string, opcode: number[],\n                       type: \"load\" | \"store\", valueType: ValueType): (align: number | bigint, offset: number | bigint) => InstrContext<MemInstance> {\n    return (align, offset) => {\n        if (typeof align === \"number\") align = BigInt(align);\n        if (typeof offset === \"number\") offset = BigInt(offset);\n        const encoded = [...opcode as byte[], ...encodeU32(align), ...encodeU32(offset)];\n        const args = {align, offset};\n\n        return () => ({\n            name, encoded,\n            type: \"memory\", immediate: args,\n            parameters: type === \"load\" ? [i32Type] : [i32Type, valueType],\n            result: type === \"load\" ? valueType : null,\n            reads: type === \"load\" ? [\"memory\"] : [],\n            writes: type === \"load\" ? [] : [\"memory\"],\n\n            copy() {\n                return () => this;\n            }\n        });\n    };\n}\n\n// Index argument instructions\n\n// either an index (instance of T), an object with a getter for the index\n// or a plain number to make the api easier to use\ntype Index<T extends bigint> = number | T | {getIndex(depth: number): T};\ninterface IdxInstance extends BaseInstance<IdxInstance> {\n    type: \"index\";\n    immediate: {readonly value: bigint};\n}\n\nfunction getIndex<T extends bigint>(idx: Index<T>, depth: number): T {\n    let value: T;\n    if (typeof idx === \"number\") {\n        value = BigInt(idx) as T;\n    } else if (typeof idx === \"bigint\") {\n        value = idx as T;\n    } else {\n        value = idx.getIndex(depth);\n    }\n    return value;\n}\n\ntype IndexFn<T extends bigint, X> = (c: Context & {value: T, extra: X}) => DataFlow;\nexport function idxArg<T extends bigint, X extends any[]>(name: string, opcode: number[], suffix: number[],\n                                                          stackOps: IndexFn<T, X>): (x: Index<T>, ...extra: X) => InstrContext<IdxInstance> {\n    return (x, ...extra) => context => {\n        const value = getIndex(x, context.depth);\n        const encoded = [...opcode as byte[], ...encodeU32(value), ...suffix as byte[]];\n        const {parameters, result, reads, writes} = stackOps({value, extra, ...context});\n\n        return {\n            name, encoded,\n            type: \"index\", immediate: {value},\n            parameters, result,\n            reads, writes,\n\n            copy() {\n                return () => this;\n            }\n        };\n    };\n}\n\ninterface TableInstance extends BaseInstance<TableInstance> {\n    type: \"table\";\n    immediate: {readonly defaultValue: bigint, readonly valueTable: ReadonlyArray<bigint>};\n}\n\nexport function brTableInstr(opcode: number): (defaultLbl: Index<labelidx>, lblArray: Index<labelidx>[]) => InstrContext<TableInstance> {\n    return (defaultLbl, lblArray) => context => {\n        const defaultValue = getIndex(defaultLbl, context.depth);\n        const valueTable = lblArray.map(x => getIndex(x, context.depth));\n        const encoded = [opcode as byte, ...encodeVec(valueTable.map(encodeU32)), ...encodeU32(defaultValue)];\n\n        return {\n            name: \"br_table\", encoded,\n            type: \"table\", immediate: {defaultValue, valueTable},\n            parameters: [i32Type], result: null,\n            reads: [], writes: [\"jump\"],\n\n            copy() {\n                return () => this;\n            }\n        };\n    };\n}\n\n// Structured instructions\ntype StructureInstance = BlockLoopInstance | IfInstance;\ninterface BlockLoopInstance extends BaseInstance<BlockLoopInstance> {\n    type: \"structured\";\n    name: \"block\" | \"loop\";\n    immediate: {readonly type: ValueType | null, readonly expression: WExpression, readonly expression2: undefined};\n}\n\ninterface IfInstance extends BaseInstance<IfInstance> {\n    type: \"structured\";\n    name: \"if\";\n    immediate: {readonly type: ValueType | null, readonly expression: WExpression, readonly expression2: WExpression | undefined};\n}\n\nfunction encodeBlockType(t: ValueType | null): byte[] {\n    if (t === null) return [0x40 as byte];\n    return [t];\n}\n\nexport function blockLoopInstr(opcode: number, name: \"block\" | \"loop\"): (type: ValueType | null, body: (PartialInstr | InstrInstance)[], contextFn?: InstrContext<void>) => InstrContext<BlockLoopInstance> {\n    const constructor = (type: ValueType | null, body: (PartialInstr | InstrInstance)[], contextFn?: InstrContext<void>) => (context: Context) => {\n        if (contextFn) contextFn(context); // used to store depth\n\n        const instr: BlockLoopInstance = {\n            name, type: \"structured\",\n            parameters: [], result: type,\n\n            get encoded() {\n                return [opcode as byte, ...encodeBlockType(type), ...expression.encoded];\n            },\n            get immediate() {\n                return {type, expression, expression2: undefined};\n            },\n            get reads() {\n                return expression.reads;\n            },\n            get writes() {\n                return expression.writes;\n            },\n\n            copy() {\n                return (ctx) => {\n                    const x = constructor(type, [])(ctx);\n                    expression.copyInto(x.immediate.expression);\n                    return x;\n                };\n            }\n        };\n        const expression = new WExpression(instr, context.depth + 1, context.builder);\n        expression.push(...body);\n        return instr;\n    };\n\n    return constructor;\n}\n\nexport function ifInstr(opcode: number, elseOpcode: number): (type: ValueType | null, body: (PartialInstr | InstrInstance)[], elseBody?: (PartialInstr | InstrInstance)[], contextFn?: InstrContext<void>) => InstrContext<IfInstance> {\n    const constructor = (type: ValueType | null, body: (PartialInstr | InstrInstance)[], elseBody?: (PartialInstr | InstrInstance)[], contextFn?: InstrContext<void>) => (context: Context) => {\n        if (contextFn) contextFn(context); // used to store depth\n\n        const instr: IfInstance = {\n            name: \"if\", type: \"structured\",\n            parameters: [i32Type], result: type,\n\n            get encoded() {\n                const instr = [opcode as byte, ...encodeBlockType(type), ...expression.encoded];\n                if (expression2) {\n                    instr.pop(); // replace 0x0B marking end of expression1 with 0x05 for else\n                    instr.push(elseOpcode as byte, ...expression2.encoded);\n                }\n                return instr;\n            },\n            get immediate() {\n                return {type, expression, expression2};\n            },\n            get reads() {\n                if (expression2) {\n                    return [...new Set([...expression.reads, ...expression2.reads])];\n                }\n                return expression.reads;\n            },\n            get writes() {\n                if (expression2) {\n                    return [...new Set([...expression.writes, ...expression2.writes])];\n                }\n                return expression.writes;\n            },\n\n            copy() {\n                return (ctx) => {\n                    const x = constructor(type, [], expression2 ? [] : undefined)(ctx);\n                    expression.copyInto(x.immediate.expression);\n                    if (expression2) expression2.copyInto(x.immediate.expression2 as WExpression);\n                    return x;\n                };\n            }\n        };\n\n        const expression = new WExpression(instr, context.depth + 1, context.builder);\n        expression.push(...body);\n        let expression2: WExpression | undefined;\n        if (elseBody) {\n            expression2 = new WExpression(instr, context.depth + 1, context.builder);\n            expression2.push(...elseBody);\n        }\n        return instr;\n    };\n\n    return constructor;\n}\n\n\n// Expressions\nexport class WExpression {\n    private _stack: ValueType[] = [];\n    private _instructions: InstrInstance[] = [];\n\n    constructor(readonly parent: StructureInstance | null, readonly depth: number, readonly builder: WFunctionBuilder) {\n    }\n\n    push(...items: (PartialInstr | InstrInstance)[]): void {\n        for (const instrFn of items) {\n            this._instructions.push(this.createInstr(instrFn, this._stack));\n        }\n    }\n\n    get(index: number): InstrInstance {\n        if (index < 0) index += this.instructions.length;\n        return this._instructions[index];\n    }\n\n    pop(): InstrInstance | undefined {\n        const instr = this._instructions.pop();\n        if (!instr) return undefined;\n\n        if (instr.result) this._stack.pop();\n        this._stack.push(...instr.parameters);\n        return instr;\n    }\n\n    replace(start: number, end: number, ...items: (PartialInstr | InstrInstance)[]): void {\n        if (start < 0 || end < start || start > this._instructions.length) {\n            throw new Error(\"Invalid replacement indices\");\n        }\n\n        // stack and instructions before\n        const stack: ValueType[] = []; // new instructions going at start of expression, so stack will be empty\n        const instructions: InstrInstance[] = this._instructions.slice(0, start);\n        instructions.forEach(x => this.stackManipulation(x, stack));\n\n        // new instructions\n        items.forEach(newInstr => instructions.push(this.createInstr(newInstr, stack)));\n\n        // instructions after\n        try {\n            for (let i = end, instr; i < this._instructions.length; i++) {\n                this.stackManipulation(instr = this._instructions[i], stack);\n                instructions.push(instr);\n            }\n\n            // check stack the same\n            if (this._stack.length !== stack.length || this._stack.some((v, i) => v !== stack[i])) {\n                throw new Error(\"Stack different\");\n            }\n\n            this._instructions = instructions;\n        } catch (e) {\n            throw new Error(`Invalid replacement due to: \\n\\n${e.stack}\\n`);\n        }\n    }\n\n    copyInto(target: WExpression): void {\n        for (const instr of this.instructions) target.push(instr.copy());\n    }\n\n    *instructionsRecursive(): IterableIterator<InstrInstance> {\n        for (const instr of this.instructions) {\n            yield instr;\n            if (instr.type === \"structured\") {\n                yield* instr.immediate.expression.instructionsRecursive();\n                if (instr.immediate.expression2) yield* instr.immediate.expression2.instructionsRecursive();\n            }\n        }\n    }\n\n    private stackManipulation(instr: InstrInstance, stack: ValueType[]) {\n        // check stack parameters\n        for (let i = instr.parameters.length - 1; i >= 0; i--) {\n            if (instr.parameters[i] !== stack.pop()) {\n                throw new Error(`Stack does not match Wasm instruction (${instr.name}) parameters\\nPrevious instructions: ${this._instructions.map(x => x.name).reverse().join(\", \")}`);\n            }\n        }\n        // push result if any\n        if (instr.result) stack.push(instr.result);\n    }\n\n    private createInstr(instr: PartialInstr | InstrInstance, stack: ValueType[]): InstrInstance {\n        if (typeof instr === \"function\") {\n            // PartialInstr - get instance of the instruction\n            instr = instr({\n                depth: this.depth,\n                builder: this.builder,\n                stack\n            });\n        }\n        this.stackManipulation(instr, stack);\n        return instr;\n    }\n\n    get instructions(): ReadonlyArray<InstrInstance> {\n        return this._instructions;\n    }\n\n    get stack(): ReadonlyArray<ValueType> {\n        return this._stack;\n    }\n\n    get encoded(): byte[] {\n        const encoded = this._instructions.flatMap(x => x.encoded);\n        encoded.push(0x0B as byte);\n        return encoded;\n    }\n\n    get reads(): ReadonlyArray<ReadResource> {\n        const reads = this._instructions.flatMap(x => x.reads);\n        return [...new Set(reads)];\n    }\n\n    get writes(): ReadonlyArray<WriteResource> {\n        const writes = this._instructions.flatMap(x => x.writes);\n        return [...new Set(writes)];\n    }\n}\n","import {labelidx, funcidx, typeidx, localidx, globalidx} from \"./base_types\";\nimport {encodeF32, encodeF64, encodeInt64Constant, encodeInt32Constant} from \"./encoding\";\nimport {zeroArgs, blockLoopInstr, ifInstr, idxArg, zeroArgsSpecial, memArg, constantArg, PartialInstr, brTableInstr} from \"./instr_helpers\";\nimport {i32Type, i64Type, f32Type, f64Type, ValueType} from \"./wtypes\";\n\nexport type WInstruction = PartialInstr;\nexport {WExpression} from \"./instr_helpers\";\n\nexport const Instructions = {\n    // control instructions\n    unreachable: zeroArgs(\"unreachable\", [0x00], [], null),\n    nop: zeroArgs(\"nop\", [0x01], [], null),\n    block: blockLoopInstr(0x02, \"block\"),\n    loop: blockLoopInstr(0x03, \"loop\"),\n    if: ifInstr(0x04, 0x05),\n    br: idxArg<labelidx, ValueType[]>(\"br\", [0x0C], [], ({extra}) => ({\n        // if this br consumes a result, it must be passed into the function call as it cannot be inferred\n        parameters: extra, result: null,\n        reads: [], writes: [\"jump\"]\n    })),\n    br_if: idxArg<labelidx, []>(\"br_if\",[0x0D], [], () => ({\n        parameters: [], result: null,\n        reads: [], writes: [\"jump\"]\n    })),\n    br_table: brTableInstr(0x0E),\n    return: zeroArgsSpecial(\"return\", [0x0F], ({builder}) => ({\n        parameters: builder.type[1], result: null,\n        reads: [], writes: [\"jump\"]\n    })),\n    call: idxArg<funcidx, []>(\"call\", [0x10], [], ({builder, value}) => {\n        const func = builder.fn.parent._functionLookup(value); // function that we are calling may write to memory\n        return {parameters: func.type[0], result: func.type[1][0] ?? null, reads: [], writes: [\"jump\", \"memory\"]};\n    }),\n    call_indirect: idxArg<typeidx, []>(\"call_indirect\", [0x11], [0x00], ({builder, value}) => {\n        const type = builder.fn.parent._typeLookup(value);\n        return {parameters: [...type[0], i32Type], result: type[1][0] ?? null, reads: [], writes: [\"jump\", \"memory\"]};\n    }),\n\n\n    // parametric instructions\n    drop: zeroArgsSpecial(\"drop\", [0x1A], ({stack}) => {\n        if (stack.length <= 0) throw new Error(\"Drop on empty stack\");\n\n        return {\n            parameters: [stack[stack.length - 1]], result: null,\n            reads: [], writes: []\n        };\n    }),\n    // select: zeroArgsSpecial(\"select\", ...),\n\n\n    // variable instructions\n    local: {\n        get: idxArg<localidx, []>(\"local.get\", [0x20], [], ({builder, value}) => {\n            const local = builder.getLocal(value);\n            return {parameters: [], result: local.type, reads: [local], writes: []};\n        }),\n        set: idxArg<localidx, []>(\"local.set\", [0x21], [], ({builder, value}) => {\n            const local = builder.getLocal(value);\n            return {parameters: [local.type], result: null, reads: [], writes: [local]};\n        }),\n        tee: idxArg<localidx, []>(\"local.tee\", [0x22], [], ({builder, value}) => {\n            const local = builder.getLocal(value);\n            return {parameters: [local.type], result: local.type, reads: [], writes: [local]};\n        }),\n    } as const,\n    global: {\n        get: idxArg<globalidx, []>(\"global.get\", [0x23], [], ({builder, value}) => {\n            const global = builder.fn.parent._globalLookup(value);\n            return {parameters: [], result: global.type, reads: [global], writes: []};\n        }),\n        set: idxArg<globalidx, []>(\"global.set\", [0x24], [], ({builder, value}) => {\n            const global = builder.fn.parent._globalLookup(value);\n            return {parameters: [global.type], result: null, reads: [], writes: [global]};\n        }),\n    } as const,\n\n\n    // memory instructions\n    memory: {\n        size: zeroArgs(\"memory.size\",[0x3F, 0x00], [], i32Type, [\"memory\"], []),\n        grow: zeroArgs(\"memory.grow\", [0x40, 0x00], [i32Type], i32Type, [\"memory\"], [\"memory\"]),\n        copy: zeroArgs(\"memory.copy\", [0xFC, 0x0A, 0x00, 0x00], [i32Type, i32Type, i32Type], null, [\"memory\"], [\"memory\"]),\n        fill: zeroArgs(\"memory.fill\", [0xFC, 0x0B, 0x00], [i32Type, i32Type, i32Type], null, [], [\"memory\"])\n    } as const,\n\n\n    i32: {\n        load: memArg(\"i32.load\", [0x28],\"load\", i32Type),\n        load8_s: memArg(\"i32.load8_s\", [0x2C], \"load\", i32Type),\n        load8_u: memArg(\"i32.load8_u\", [0x2D], \"load\", i32Type),\n        load16_s: memArg(\"i32.load16_s\", [0x2E], \"load\", i32Type),\n        load16_u: memArg(\"i32.load16_u\", [0x2F], \"load\", i32Type),\n        store: memArg(\"i32.store\", [0x36], \"store\", i32Type),\n        store8: memArg(\"i32.store8\", [0x3A], \"store\", i32Type),\n        store16: memArg(\"i32.store16\", [0x3B], \"store\", i32Type),\n\n        const: constantArg<number|bigint>(\"i32.const\", [0x41], encodeInt32Constant, BigInt, i32Type),\n\n        eqz: zeroArgs(\"i32.eqz\", [0x45], [i32Type], i32Type),\n        eq: zeroArgs(\"i32.eq\", [0x46], [i32Type, i32Type], i32Type),\n        ne: zeroArgs(\"i32.ne\", [0x47], [i32Type, i32Type], i32Type),\n        lt_s: zeroArgs(\"i32.lt_s\", [0x48], [i32Type, i32Type], i32Type),\n        lt_u: zeroArgs(\"i32.lt_u\", [0x49], [i32Type, i32Type], i32Type),\n        gt_s: zeroArgs(\"i32.gt_s\", [0x4A], [i32Type, i32Type], i32Type),\n        gt_u: zeroArgs(\"i32.gt_u\", [0x4B], [i32Type, i32Type], i32Type),\n        le_s: zeroArgs(\"i32.le_s\", [0x4C], [i32Type, i32Type], i32Type),\n        le_u: zeroArgs(\"i32.le_u\", [0x4D], [i32Type, i32Type], i32Type),\n        ge_s: zeroArgs(\"i32.ge_s\", [0x4E], [i32Type, i32Type], i32Type),\n        ge_u: zeroArgs(\"i32.ge_u\", [0x4F], [i32Type, i32Type], i32Type),\n\n        clz: zeroArgs(\"i32.clz\", [0x67], [i32Type], i32Type),\n        ctz: zeroArgs(\"i32.ctz\", [0x68], [i32Type], i32Type),\n        popcnt: zeroArgs(\"i32.popcnt\", [0x69], [i32Type], i32Type),\n        add: zeroArgs(\"i32.add\", [0x6A], [i32Type, i32Type], i32Type),\n        sub: zeroArgs(\"i32.sub\", [0x6B], [i32Type, i32Type], i32Type),\n        mul: zeroArgs(\"i32.mul\", [0x6C], [i32Type, i32Type], i32Type),\n        div_s: zeroArgs(\"i32.div_s\", [0x6D], [i32Type, i32Type], i32Type),\n        div_u: zeroArgs(\"i32.div_u\", [0x6E], [i32Type, i32Type], i32Type),\n        rem_s: zeroArgs(\"i32.rem_s\", [0x6F], [i32Type, i32Type], i32Type),\n        rem_u: zeroArgs(\"i32.rem_u\", [0x70], [i32Type, i32Type], i32Type),\n        and: zeroArgs(\"i32.and\", [0x71], [i32Type, i32Type], i32Type),\n        or: zeroArgs(\"i32.or\", [0x72], [i32Type, i32Type], i32Type),\n        xor: zeroArgs(\"i32.xor\", [0x73], [i32Type, i32Type], i32Type),\n        shl: zeroArgs(\"i32.shl\", [0x74], [i32Type, i32Type], i32Type),\n        shr_s: zeroArgs(\"i32.shr_s\", [0x75], [i32Type, i32Type], i32Type),\n        shr_u: zeroArgs(\"i32.shr_u\", [0x76], [i32Type, i32Type], i32Type),\n        rotl: zeroArgs(\"i32.rotl\", [0x77], [i32Type, i32Type], i32Type),\n        rotr: zeroArgs(\"i32.rotr\", [0x78], [i32Type, i32Type], i32Type),\n\n        wrap_i64: zeroArgs(\"i32.wrap_i64\", [0xA7], [i64Type], i32Type),\n        trunc_f32_s: zeroArgs(\"i32.trunc_f32_s\", [0xA8], [f32Type], i32Type),\n        trunc_f32_u: zeroArgs(\"i32.trunc_f32_u\", [0xA9], [f32Type], i32Type),\n        trunc_f64_s: zeroArgs(\"i32.trunc_f64_s\", [0xAA], [f64Type], i32Type),\n        trunc_f64_u: zeroArgs(\"i32.trunc_f64_u\", [0xAB], [f64Type], i32Type),\n\n        reinterpret_f32: zeroArgs(\"i32.reinterpret_f32\", [0xBC], [f32Type], i32Type),\n        extend8_s: zeroArgs(\"i32.extend8_s\", [0xC0], [i32Type], i32Type),\n        extend16_s: zeroArgs(\"i32.extend16_s\", [0xC1], [i32Type], i32Type),\n\n        // Non-trapping Float-to-int Conversions\n        trunc_sat_f32_s: zeroArgs(\"i32.trunc_sat_f32_s\", [0xFC, 0], [f32Type], i32Type),\n        trunc_sat_f32_u: zeroArgs(\"i32.trunc_sat_f32_u\", [0xFC, 1], [f32Type], i32Type),\n        trunc_sat_f64_s: zeroArgs(\"i32.trunc_sat_f64_s\", [0xFC, 2], [f64Type], i32Type),\n        trunc_sat_f64_u: zeroArgs(\"i32.trunc_sat_f64_u\", [0xFC, 3], [f64Type], i32Type),\n    } as const,\n\n    i64: {\n        load: memArg(\"i64.load\", [0x29], \"load\", i64Type),\n        load8_s: memArg(\"i64.load8_s\", [0x30], \"load\", i64Type),\n        load8_u: memArg(\"i64.load8_u\", [0x31], \"load\", i64Type),\n        load16_s: memArg(\"i64.load16_s\", [0x32], \"load\", i64Type),\n        load16_u: memArg(\"i64.load16_u\", [0x33], \"load\", i64Type),\n        load32_s: memArg(\"i64.load32_s\", [0x34], \"load\", i64Type),\n        load32_u: memArg(\"i64.load32_u\", [0x35], \"load\", i64Type),\n        store: memArg(\"i64.store\", [0x37], \"store\", i64Type),\n        store8: memArg(\"i64.store8\", [0x3C], \"store\", i64Type),\n        store16: memArg(\"i64.store16\", [0x3D], \"store\", i64Type),\n        store32: memArg(\"i64.store32\", [0x3E], \"store\", i64Type),\n\n        const: constantArg<bigint>(\"i64.const\", [0x42], encodeInt64Constant, BigInt, i64Type),\n\n        eqz: zeroArgs(\"i64.eqz\", [0x50], [i64Type], i32Type),\n        eq: zeroArgs(\"i64.eq\", [0x51], [i64Type, i64Type], i32Type),\n        ne: zeroArgs(\"i64.ne\", [0x52], [i64Type, i64Type], i32Type),\n        lt_s: zeroArgs(\"i64.lt_s\", [0x53], [i64Type, i64Type], i32Type),\n        lt_u: zeroArgs(\"i64.lt_u\", [0x54], [i64Type, i64Type], i32Type),\n        gt_s: zeroArgs(\"i64.gt_s\", [0x55], [i64Type, i64Type], i32Type),\n        gt_u: zeroArgs(\"i64.gt_u\", [0x56], [i64Type, i64Type], i32Type),\n        le_s: zeroArgs(\"i64.le_s\", [0x57], [i64Type, i64Type], i32Type),\n        le_u: zeroArgs(\"i64.le_u\", [0x58], [i64Type, i64Type], i32Type),\n        ge_s: zeroArgs(\"i64.ge_s\", [0x59], [i64Type, i64Type], i32Type),\n        ge_u: zeroArgs(\"i64.ge_u\", [0x5A], [i64Type, i64Type], i32Type),\n\n        clz: zeroArgs(\"i64.clz\", [0x79], [i64Type], i64Type),\n        ctz: zeroArgs(\"i64.ctz\", [0x7A], [i64Type], i64Type),\n        popcnt: zeroArgs(\"i64.popcnt\", [0x7B], [i64Type], i64Type),\n        add: zeroArgs(\"i64.add\", [0x7C], [i64Type, i64Type], i64Type),\n        sub: zeroArgs(\"i64.sub\", [0x7D], [i64Type, i64Type], i64Type),\n        mul: zeroArgs(\"i64.mul\", [0x7E], [i64Type, i64Type], i64Type),\n        div_s: zeroArgs(\"i64.div_s\", [0x7F], [i64Type, i64Type], i64Type),\n        div_u: zeroArgs(\"i64.div_u\", [0x80], [i64Type, i64Type], i64Type),\n        rem_s: zeroArgs(\"i64.rem_s\", [0x81], [i64Type, i64Type], i64Type),\n        rem_u: zeroArgs(\"i64.rem_u\", [0x82], [i64Type, i64Type], i64Type),\n        and: zeroArgs(\"i64.and\", [0x83], [i64Type, i64Type], i64Type),\n        or: zeroArgs(\"i64.or\", [0x84], [i64Type, i64Type], i64Type),\n        xor: zeroArgs(\"i64.xor\", [0x85], [i64Type, i64Type], i64Type),\n        shl: zeroArgs(\"i64.shl\", [0x86], [i64Type, i64Type], i64Type),\n        shr_s: zeroArgs(\"i64.shr_s\", [0x87], [i64Type, i64Type], i64Type),\n        shr_u: zeroArgs(\"i64.shr_u\", [0x88], [i64Type, i64Type], i64Type),\n        rotl: zeroArgs(\"i64.rotl\", [0x89], [i64Type, i64Type], i64Type),\n        rotr: zeroArgs(\"i64.rotr\", [0x8A], [i64Type, i64Type], i64Type),\n\n        extend_i32_s: zeroArgs(\"i64.extend_i32_s\", [0xAC], [i32Type], i64Type),\n        extend_i32_u: zeroArgs(\"i64.extend_i32_u\", [0xAD], [i32Type], i64Type),\n        trunc_f32_s: zeroArgs(\"i64.trunc_f32_s\", [0xAE], [f32Type], i64Type),\n        trunc_f32_u: zeroArgs(\"i64.trunc_f32_u\", [0xAF], [f32Type], i64Type),\n        trunc_f64_s: zeroArgs(\"i64.trunc_f64_s\", [0xB0], [f64Type], i64Type),\n        trunc_f64_u: zeroArgs(\"i64.trunc_f64_u\", [0xB1], [f64Type], i64Type),\n\n        reinterpret_f64: zeroArgs(\"i64.reinterpret_f64\", [0xBD], [f64Type], i64Type),\n        extend8_s: zeroArgs(\"i64.extend8_s\", [0xC2], [i64Type], i64Type),\n        extend16_s: zeroArgs(\"i64.extend16_s\", [0xC3], [i64Type], i64Type),\n        extend32_s: zeroArgs(\"i64.extend32_s\", [0xC4], [i64Type], i64Type),\n\n        // Non-trapping Float-to-int Conversions\n        trunc_sat_f32_s: zeroArgs(\"i32.trunc_sat_f32_s\", [0xFC, 4], [f32Type], i64Type),\n        trunc_sat_f32_u: zeroArgs(\"i32.trunc_sat_f32_u\", [0xFC, 5], [f32Type], i64Type),\n        trunc_sat_f64_s: zeroArgs(\"i32.trunc_sat_f64_s\", [0xFC, 6], [f64Type], i64Type),\n        trunc_sat_f64_u: zeroArgs(\"i32.trunc_sat_f64_u\", [0xFC, 7], [f64Type], i64Type),\n    } as const,\n\n    f32: {\n        load: memArg(\"f32.load\", [0x2A], \"load\", f32Type),\n        store: memArg(\"f32.store\", [0x38], \"store\", f32Type),\n\n        const: constantArg<number>(\"f32.const\", [0x43], encodeF32, Number, f32Type),\n\n        eq: zeroArgs(\"f32.eq\", [0x5B], [f32Type, f32Type], i32Type),\n        ne: zeroArgs(\"f32.ne\", [0x5C], [f32Type, f32Type], i32Type),\n        lt: zeroArgs(\"f32.lt\", [0x5D], [f32Type, f32Type], i32Type),\n        gt: zeroArgs(\"f32.gt\", [0x5E], [f32Type, f32Type], i32Type),\n        le: zeroArgs(\"f32.le\", [0x5F], [f32Type, f32Type], i32Type),\n        ge: zeroArgs(\"f32.ge\", [0x60], [f32Type, f32Type], i32Type),\n\n        abs: zeroArgs(\"f32.abs\", [0x8B], [f32Type], f32Type),\n        neg: zeroArgs(\"f32.neg\", [0x8C], [f32Type], f32Type),\n        ceil: zeroArgs(\"f32.ceil\", [0x8D], [f32Type], f32Type),\n        floor: zeroArgs(\"f32.floor\", [0x8E], [f32Type], f32Type),\n        trunc: zeroArgs(\"f32.trunc\", [0x8F], [f32Type], f32Type),\n        nearest: zeroArgs(\"f32.nearest\", [0x90], [f32Type], f32Type),\n        sqrt: zeroArgs(\"f32.sqrt\", [0x91], [f32Type], f32Type),\n        add: zeroArgs(\"f32.add\", [0x92], [f32Type, f32Type], f32Type),\n        sub: zeroArgs(\"f32.sub\", [0x93], [f32Type, f32Type], f32Type),\n        mul: zeroArgs(\"f32.mul\", [0x94], [f32Type, f32Type], f32Type),\n        div: zeroArgs(\"f32.div\", [0x95], [f32Type, f32Type], f32Type),\n        min: zeroArgs(\"f32.min\", [0x96], [f32Type, f32Type], f32Type),\n        max: zeroArgs(\"f32.max\", [0x97], [f32Type, f32Type], f32Type),\n        copysign: zeroArgs(\"f32.copysign\", [0x98], [f32Type, f32Type], f32Type),\n\n        convert_i32_s: zeroArgs(\"f32.convert_i32_s\", [0xB2], [i32Type], f32Type),\n        convert_i32_u: zeroArgs(\"f32.convert_i32_u\", [0xB3], [i32Type], f32Type),\n        convert_i64_s: zeroArgs(\"f32.convert_i64_s\", [0xB4], [i64Type], f32Type),\n        convert_i64_u: zeroArgs(\"f32.convert_i64_u\", [0xB5], [i64Type], f32Type),\n        demote_f64: zeroArgs(\"f32.demote_f64\", [0xB6], [f64Type], f32Type),\n\n        reinterpret_i32: zeroArgs(\"f32.reinterpret_i32\", [0xBE], [i32Type], f32Type),\n    } as const,\n\n    f64: {\n        load: memArg(\"f64.load\", [0x2B], \"load\", f64Type),\n        store: memArg(\"f64.store\", [0x39], \"store\", f64Type),\n\n        const: constantArg<number>(\"f64.const\", [0x44], encodeF64, Number, f64Type),\n\n        eq: zeroArgs(\"f64.eq\", [0x61], [f64Type, f64Type], i32Type),\n        ne: zeroArgs(\"f64.ne\", [0x62], [f64Type, f64Type], i32Type),\n        lt: zeroArgs(\"f64.lt\", [0x63], [f64Type, f64Type], i32Type),\n        gt: zeroArgs(\"f64.gt\", [0x64], [f64Type, f64Type], i32Type),\n        le: zeroArgs(\"f64.le\", [0x65], [f64Type, f64Type], i32Type),\n        ge: zeroArgs(\"f64.ge\", [0x66], [f64Type, f64Type], i32Type),\n\n        abs: zeroArgs(\"f64.abs\", [0x99], [f64Type], f64Type),\n        neg: zeroArgs(\"f64.neg\", [0x9A], [f64Type], f64Type),\n        ceil: zeroArgs(\"f64.ceil\", [0x9B], [f64Type], f64Type),\n        floor: zeroArgs(\"f64.floor\", [0x9C], [f64Type], f64Type),\n        trunc: zeroArgs(\"f64.trunc\", [0x9D], [f64Type], f64Type),\n        nearest: zeroArgs(\"f64.nearest\", [0x9E], [f64Type], f64Type),\n        sqrt: zeroArgs(\"f64.sqrt\", [0x9F], [f64Type], f64Type),\n        add: zeroArgs(\"f64.add\", [0xA0], [f64Type, f64Type], f64Type),\n        sub: zeroArgs(\"f64.sub\", [0xA1], [f64Type, f64Type], f64Type),\n        mul: zeroArgs(\"f64.mul\", [0xA2], [f64Type, f64Type], f64Type),\n        div: zeroArgs(\"f64.div\", [0xA3], [f64Type, f64Type], f64Type),\n        min: zeroArgs(\"f64.min\", [0xA4], [f64Type, f64Type], f64Type),\n        max: zeroArgs(\"f64.max\", [0xA5], [f64Type, f64Type], f64Type),\n        copysign: zeroArgs(\"f64.copysign\", [0xA6], [f64Type, f64Type], f64Type),\n\n        convert_i32_s: zeroArgs(\"f64.convert_i32_s\", [0xB7], [i32Type], f64Type),\n        convert_i32_u: zeroArgs(\"f64.convert_i32_u\", [0xB8], [i32Type], f64Type),\n        convert_i64_s: zeroArgs(\"f64.convert_i64_s\", [0xB9], [i64Type], f64Type),\n        convert_i64_u: zeroArgs(\"f64.convert_i64_u\", [0xBA], [i64Type], f64Type),\n        promote_f32: zeroArgs(\"f64.promote_f32\", [0xBB], [f32Type], f64Type),\n\n        reinterpret_i64: zeroArgs(\"f64.reinterpret_i64\", [0xBF], [i64Type], f64Type),\n    } as const\n\n} as const;\n","import {WExpression, ValueType, Instructions} from \"../wasm\";\nimport {WLocal} from \"../wasm/functions\";\nimport {InstrInstance, PartialInstr} from \"../wasm/instr_helpers\";\n\nexport function deadCodeElimination(expr: WExpression, usedLocals = new Set<WLocal>()): void {\n    const [instructions, stackItems] = dataflow(expr);\n\n    // instructions which write to a non-local resource are definitely needed\n    for (const instruction of instructions) {\n        if (instruction.instr.writes.some(resource => !(resource instanceof WLocal))) {\n            markNeeded(instruction);\n        }\n    }\n    markRecursively(stackItems);\n\n    // instructions writing to locals which are read after are also needed\n    for (let i = instructions.length - 1; i >= 0; i--) {\n        const instruction = instructions[i], instr = instruction.instr;\n\n        if (!instruction.needed) {\n            for (const write of instr.writes) {\n                if (write instanceof WLocal && usedLocals.has(write)) {\n                    markNeeded(instruction);\n                    markRecursively(stackItems);\n                    break;\n                }\n            }\n        }\n\n        if (instruction.needed) {\n            // recursively check subexpressions now before other locals are marked as used\n            if (instr.type === \"structured\") {\n                // special case: loops may repeat code so just presume all locals are needed before recurring\n                if (instr.name === \"loop\") {\n                    for (const read of instr.reads) {\n                        if (read instanceof WLocal) usedLocals.add(read);\n                    }\n                }\n\n                deadCodeElimination(instr.immediate.expression, usedLocals);\n                if (instr.immediate.expression2) deadCodeElimination(instr.immediate.expression2, usedLocals);\n\n                if (instr.name === \"loop\") continue;\n            }\n\n            for (const read of instr.reads) {\n                if (read instanceof WLocal) usedLocals.add(read);\n            }\n        }\n    }\n\n    if (instructions.some(instr => !instr.needed)) {\n        // discard unneeded instructions if any\n        const replacement: (PartialInstr | InstrInstance)[] = [];\n        for (const instruction of instructions) {\n            if (instruction.needed || instruction.instr.name === \"unreachable\") { // also preserve \"unreachable\" instructions\n                replacement.push(instruction.instr);\n\n                if (instruction.produces && !instruction.produces.needed) {\n                    replacement.push(Instructions.drop());\n                }\n            }\n        }\n        expr.replace(0, expr.instructions.length, ...replacement);\n    }\n}\n\nfunction dataflow(expr: WExpression): [DFInstruction[], DFStackItem[]] {\n    const instructions = expr.instructions.map(instr => ({instr, produces: undefined, consumes: []} as DFInstruction));\n    const stackItems: DFStackItem[] = [];\n\n    const currentStack: DFStackItem[] = [];\n    for (const dfInstr of instructions) {\n        for (let i = 0; i < dfInstr.instr.parameters.length; i++) {\n            const item = currentStack.pop() as DFStackItem;\n            item.consumedBy = dfInstr;\n            dfInstr.consumes.push(item);\n        }\n\n        if (dfInstr.instr.result !== null) {\n            dfInstr.produces = {\n                type: dfInstr.instr.result,\n                producedBy: dfInstr,\n                index: stackItems.length\n            };\n            currentStack.push(dfInstr.produces);\n            stackItems.push(dfInstr.produces);\n        }\n    }\n\n    // mark anything left on the stack as definitely needed\n    for (const remainingItem of currentStack) remainingItem.needed = true;\n\n    return [instructions, stackItems];\n}\n\nfunction markNeeded(instr: DFInstruction) {\n    instr.needed = true;\n    for (const item of instr.consumes) item.needed = true;\n}\n\nfunction markRecursively(items: DFStackItem[]) {\n    let changed = 1;\n    while (changed) {\n        changed = 0;\n        for (const item of items.filter(item => item.needed && !item.producedBy.needed)) {\n            markNeeded(item.producedBy);\n            changed++;\n        }\n    }\n}\n\ninterface DFInstruction {\n    instr: InstrInstance;\n    produces: DFStackItem | undefined;\n    consumes: DFStackItem[];\n    needed?: true;\n}\n\ninterface DFStackItem {\n    type: ValueType;\n    producedBy: DFInstruction;\n    consumedBy?: DFInstruction;\n    index: number;\n    needed?: true;\n}\n","import {Instructions, f32Type, f64Type, i32Type, WExpression, i64Type} from \"../wasm\";\nimport {labelidx} from \"../wasm/base_types\";\nimport {WLocal} from \"../wasm/functions\";\nimport {InstrInstance, PartialInstr} from \"../wasm/instr_helpers\";\nimport {OptimisationFlags} from \"./flags\";\n\ntype PeepholeCallback = (instr: InstrInstance[], depth: number) => (InstrInstance | PartialInstr)[] | undefined;\ninterface PeepholeOptimiser {\n    name: string,\n    enabled: (flags: OptimisationFlags) => boolean,\n    run: PeepholeCallback,\n    peepholeSize: number\n}\n\nexport const peepholeOptimisers: PeepholeOptimiser[] = [];\n\nexport function peephole(expr: WExpression, fn: PeepholeCallback, size: number, depth = 0): void {\n    for (let i = 0; i <= expr.instructions.length - size; i++) {\n        const replacement = fn(expr.instructions.slice(i, i + size), depth);\n        if (replacement !== undefined) expr.replace(i, i + size, ...replacement);\n    }\n\n    for (const instruction of expr.instructions) {\n        if (instruction.type === \"structured\") {\n            peephole(instruction.immediate.expression, fn, size, depth + 1);\n            if (instruction.immediate.expression2) peephole(instruction.immediate.expression2, fn, size, depth + 1);\n        }\n    }\n}\n\nexport function peepholeMulti(expr: WExpression, fns: [fn: PeepholeCallback, size: number][], depth = 0): void {\n    const maxSize = fns.map(x => x[1]).reduce((a, b) => Math.max(a, b), 1);\n\n    // optimise inside structured instructions first in case this eliminates branches etc which enable\n    // more optimisations to occur at this level\n    for (const instruction of expr.instructions) {\n        if (instruction.type === \"structured\") {\n            peepholeMulti(instruction.immediate.expression, fns, depth + 1);\n            if (instruction.immediate.expression2) peepholeMulti(instruction.immediate.expression2, fns, depth + 1);\n        }\n    }\n\n    for (let i = 0; i < expr.instructions.length; i++) {\n        for (const [fn, size] of fns) {\n            if (i + size > expr.instructions.length) continue;\n\n            const replacement = fn(expr.instructions.slice(i, i + size), depth);\n            if (replacement !== undefined) {\n                expr.replace(i, i + size, ...replacement);\n\n                i -= maxSize; // repeat optimisers with new instructions\n                if (i < -1) i = -1;\n                break;\n            }\n        }\n    }\n}\n\npeepholeOptimisers.push({\n    name: \"[local.set, local.get] => [local.tee]\",\n    enabled: (flags) => flags.peephole_local_tee,\n    run: ([instr1, instr2]) => {\n        if (instr1.name === \"local.set\" && instr2.name === \"local.get\") {\n            const resource = instr1.writes[0];\n            if (!(resource instanceof WLocal) || instr2.reads[0] !== resource) return;\n            return [Instructions.local.tee(resource)];\n        } else if (instr1.name === \"local.tee\" && instr2.name === \"drop\") {\n            // convert back to a single local.set if the result is now discarded\n            const resource = instr1.writes[0];\n            if (!(resource instanceof WLocal)) return;\n            return [Instructions.local.set(resource)];\n        }\n    },\n    peepholeSize: 2\n});\n\npeepholeOptimisers.push({\n    name: \"?.const 0, ?.add\",\n    enabled: (flags) => flags.peephole_add_0,\n    run: ([instr1, instr2]) => {\n        // eslint-disable-next-line eqeqeq\n        if (instr1.type !== \"constant\" || instr1.immediate.value != 0) return;\n        if (instr2.name.endsWith(\".add\")) return [];\n    },\n    peepholeSize: 2\n});\n\npeepholeOptimisers.push({\n    name: \"i32.const, i32.const, i32.[op]\",\n    enabled: (flags) => flags.peephole_i32_constants_ops,\n    run: ([instr1, instr2, instr3]) => {\n        if (instr1.type !== \"constant\" || instr2.type !== \"constant\" || !instr3.name.startsWith(\"i32.\")) return;\n        if (instr1.result !== i32Type || instr2.result !== i32Type) return;\n\n        const s1 = Number(instr1.immediate.value), s2 = Number(instr2.immediate.value);\n        const u1 = (BigInt(s1) + 2n ** 32n) % (2n ** 32n), u2 = (BigInt(s2) + 2n ** 32n) % (2n ** 32n);\n\n        switch (instr3.name) {\n        case \"i32.eq\":\n            return [Instructions.i32.const(s1 === s2 ? 1 : 0)];\n        case \"i32.ne\":\n            return [Instructions.i32.const(s1 !== s2 ? 1 : 0)];\n        case \"i32.lt_s\":\n            return [Instructions.i32.const(s1 < s2 ? 1 : 0)];\n        case \"i32.lt_u\":\n            return [Instructions.i32.const(u1 < u2 ? 1 : 0)];\n        case \"i32.gt_s\":\n            return [Instructions.i32.const(s1 > s2 ? 1 : 0)];\n        case \"i32.gt_u\":\n            return [Instructions.i32.const(u1 > u2 ? 1 : 0)];\n        case \"i32.le_s\":\n            return [Instructions.i32.const(s1 <= s2 ? 1 : 0)];\n        case \"i32.le_u\":\n            return [Instructions.i32.const(u1 <= u2 ? 1 : 0)];\n        case \"i32.ge_s\":\n            return [Instructions.i32.const(s1 >= s2 ? 1 : 0)];\n        case \"i32.ge_u\":\n            return [Instructions.i32.const(u1 >= u2 ? 1 : 0)];\n        case \"i32.add\":\n            return [Instructions.i32.const((s1 + s2) | 0)];\n        case \"i32.sub\":\n            return [Instructions.i32.const((s1 - s2) | 0)];\n        case \"i32.mul\":\n            return [Instructions.i32.const((u1 * u2) & (2n ** 32n - 1n))];\n        case \"i32.div_s\":\n            if (s2 === 0) return;\n            return [Instructions.i32.const((s1 / s2) | 0)];\n        case \"i32.div_u\":\n            if (s2 === 0) return;\n            return [Instructions.i32.const(u1 / u2)];\n        case \"i32.rem_s\":\n            if (s2 === 0) return;\n            return [Instructions.i32.const(s1 % s2)];\n        case \"i32.rem_u\":\n            if (s2 === 0) return;\n            return [Instructions.i32.const(u1 % u2)];\n        case \"i32.and\":\n            return [Instructions.i32.const(s1 & s2)];\n        case \"i32.or\":\n            return [Instructions.i32.const(s1 | s2)];\n        case \"i32.xor\":\n            return [Instructions.i32.const(s1 ^ s2)];\n        case \"i32.shl\":\n            return [Instructions.i32.const(s1 << s2)];\n        case \"i32.shr_s\":\n            return [Instructions.i32.const(s1 >> s2)];\n        case \"i32.shr_u\":\n            return [Instructions.i32.const(s1 >>> s2)];\n        }\n    },\n    peepholeSize: 3\n});\n\npeepholeOptimisers.push({\n    name: \"i32.const, i32.eqz\",\n    enabled: (flags) => flags.peephole_i32_constants_ops,\n    run: ([instr1, instr2]) => {\n        if (instr1.type !== \"constant\" || !instr2.name.endsWith(\".eqz\")) return;\n        // eslint-disable-next-line eqeqeq\n        return [Instructions.i32.const(instr1.immediate.value == 0 ? 1 : 0)];\n    },\n    peepholeSize: 2\n});\n\npeepholeOptimisers.push({\n    name: \"?.const, ?.const, ?.add/mul\",\n    enabled: (flags) => flags.peephole_constants_add_mul,\n    run: ([instr1, instr2, instr3]) => {\n        // eslint-disable-next-line eqeqeq\n        if (instr1.type !== \"constant\" || instr2.type !== \"constant\") return;\n\n        let value;\n        if (instr3.name.endsWith(\".add\")) {\n            if (instr1.result === f32Type) {\n                return [Instructions.f32.const(Number(instr1.immediate.value) + Number(instr2.immediate.value))];\n            } else if (instr1.result === f64Type) {\n                return [Instructions.f64.const(Number(instr1.immediate.value) + Number(instr2.immediate.value))];\n            }\n\n            value = BigInt(instr1.immediate.value) + BigInt(instr2.immediate.value);\n        } else if (instr3.name.endsWith(\".mul\")) {\n            if (instr1.result === f32Type) {\n                return [Instructions.f32.const(Number(instr1.immediate.value) * Number(instr2.immediate.value))];\n            } else if (instr1.result === f64Type) {\n                return [Instructions.f64.const(Number(instr1.immediate.value) * Number(instr2.immediate.value))];\n            }\n\n            value = BigInt(instr1.immediate.value) * BigInt(instr2.immediate.value);\n        } else {\n            return;\n        }\n\n        if (instr1.result === i32Type) {\n            return [Instructions.i32.const(emulateInt(32n, value))];\n        } else {\n            return [Instructions.i64.const(emulateInt(64n, value))];\n        }\n    },\n    peepholeSize: 3\n});\n\npeepholeOptimisers.push({\n    name: \"i32.const, i32.add, i32.const, i32.add\",\n    enabled: (flags) => flags.peephole_combine_adds,\n    run: ([instr1, instr2, instr3, instr4]) => {\n        // eslint-disable-next-line eqeqeq\n        if (instr1.type !== \"constant\" || instr3.type !== \"constant\") return;\n        if (instr2.name !== \"i32.add\" || instr4.name !== \"i32.add\") return;\n        return [\n            Instructions.i32.const(emulateInt(32n, BigInt(instr1.immediate.value) + BigInt(instr3.immediate.value))),\n            Instructions.i32.add()\n        ];\n    },\n    peepholeSize: 4\n});\n\npeepholeOptimisers.push({\n    name: \"..., i32.const, i32.add, *.load offset\",\n    enabled: (flags) => flags.peephole_load_offset,\n    run: ([instr1, instr2, instr3]) => {\n        if (instr1.type !== \"constant\" || instr1.result !== i32Type) return;\n        if (instr2.name !== \"i32.add\") return;\n        if (instr3.type !== \"memory\" || !instr3.name.includes(\".load\")) return;\n\n        const offset = instr3.immediate.offset + BigInt(instr1.immediate.value);\n        if (offset > 127) return; // only inline small offsets\n\n        if (instr3.result === i32Type) {\n            if (instr3.name === \"i32.load\") return [Instructions.i32.load(instr3.immediate.align, offset)];\n            if (instr3.name === \"i32.load8_s\") return [Instructions.i32.load8_s(instr3.immediate.align, offset)];\n            if (instr3.name === \"i32.load8_u\") return [Instructions.i32.load8_u(instr3.immediate.align, offset)];\n            if (instr3.name === \"i32.load16_s\") return [Instructions.i32.load16_s(instr3.immediate.align, offset)];\n            if (instr3.name === \"i32.load16_u\") return [Instructions.i32.load16_u(instr3.immediate.align, offset)];\n        } else if (instr3.result === i64Type) {\n            if (instr3.name === \"i64.load\") return [Instructions.i64.load(instr3.immediate.align, offset)];\n            if (instr3.name === \"i64.load8_s\") return [Instructions.i64.load8_s(instr3.immediate.align, offset)];\n            if (instr3.name === \"i64.load16_s\") return [Instructions.i64.load16_s(instr3.immediate.align, offset)];\n            if (instr3.name === \"i64.load16_u\") return [Instructions.i64.load16_u(instr3.immediate.align, offset)];\n            if (instr3.name === \"i64.load32_s\") return [Instructions.i64.load32_s(instr3.immediate.align, offset)];\n            if (instr3.name === \"i64.load32_u\") return [Instructions.i64.load32_u(instr3.immediate.align, offset)];\n        } else if (instr3.result === f32Type) {\n            return [Instructions.f32.load(instr3.immediate.align, offset)];\n        } else if (instr3.result === f64Type) {\n            return [Instructions.f64.load(instr3.immediate.align, offset)];\n        }\n    },\n    peepholeSize: 3\n});\n\npeepholeOptimisers.push({\n    name: \"remove unused blocks and loops\",\n    enabled: (flags) => flags.peephole_unused_blocks,\n    run: ([instr]) => {\n        if (instr.type !== \"structured\" || instr.name === \"if\") return;\n        if (branchedTo(instr)) return;\n\n        return eliminateStructuredInstruction(instr.immediate.expression);\n    },\n    peepholeSize: 1\n});\n\npeepholeOptimisers.push({\n    name: \"remove constant ifs\",\n    enabled: (flags) => flags.peephole_constant_if,\n    run: ([instr1, instr2]) => {\n        if (instr1.type !== \"constant\" || instr1.result !== i32Type) return;\n        if (instr2.type !== \"structured\" || instr2.name !== \"if\") return;\n\n        let body;\n        // eslint-disable-next-line eqeqeq\n        if (instr1.immediate.value != 0) {\n            // if statement always true\n            body = instr2.immediate.expression;\n        } else if (instr2.immediate.expression2) {\n            // if statement always false and else clause present\n            body = instr2.immediate.expression2;\n        } else {\n            // always false and no else clause\n            return [];\n        }\n\n        // replace constant if with a block with the body of the corresponding clause which is needed encase the\n        // if statement was branched too, otherwise `peephole_unused_blocks` will remove it\n        return [Instructions.block(instr2.immediate.type, body.instructions.slice())];\n    },\n    peepholeSize: 2\n});\n\nfunction emulateInt(bits: bigint, value: bigint) {\n    const bitmask = (2n ** bits) - 1n;\n    return value & bitmask;\n}\n\nfunction branchedTo(instr: InstrInstance, depth = -1n): boolean {\n    if (instr.type === \"index\" && instr.name.startsWith(\"br\")) {\n        return instr.immediate.value === depth;\n    }\n    if (instr.type === \"table\" && instr.name === \"br_table\") {\n        return instr.immediate.defaultValue === depth || instr.immediate.valueTable.some(x => x === depth);\n    }\n    if (instr.type !== \"structured\") return false;\n\n    const {expression, expression2} = instr.immediate;\n    if (expression.instructions.some(child => branchedTo(child, depth + 1n))) return true;\n    if (expression2 === undefined) return false;\n    return expression2.instructions.some(child => branchedTo(child, depth + 1n));\n}\n\nexport function eliminateStructuredInstruction(expr: WExpression): InstrInstance[] {\n    // decrement the values of branch instructions which branch outside\n    peephole(expr, ([child], depth) => {\n        if (child.type === \"index\") {\n            if (child.immediate.value < depth) return;\n\n            if (child.name === \"br\") {\n                // ...child.parameters => preserve whether the br consumes a result\n                return [Instructions.br(child.immediate.value - 1n as labelidx, ...child.parameters)];\n            } else if (child.name === \"br_if\") {\n                return [Instructions.br_if(child.immediate.value - 1n as labelidx)];\n            }\n        } else if (child.type === \"table\" && child.name === \"br_table\") {\n            const {defaultValue, valueTable} = child.immediate;\n            return [Instructions.br_table(\n                (defaultValue < depth ? defaultValue : defaultValue - 1n) as labelidx,\n                valueTable.map(v => (v < depth ? v : v - 1n) as labelidx)\n            )];\n        }\n    }, 1);\n\n    return expr.instructions.slice();\n}\n","import {WExpression} from \"../../wasm\";\nimport {InstrInstance} from \"../../wasm/instr_helpers\";\n\nexport function controlFlow(expr: WExpression): ControlFlowGraph {\n    const entryFlow: MarkerFlow = {type: \"entry\", instr: undefined, flowPrevious: [], flowNext: []};\n    const exitFlow: MarkerFlow = {type: \"exit\", instr: undefined, flowPrevious: [], flowNext: []};\n    const allFlows: Flow[] = [entryFlow, exitFlow];\n    const brTargets: Flow[] = [];\n\n    function _expr2flow(expr: WExpression, previousFlow: Flow, followingFlow: Flow) {\n        const instructions = expr.instructions;\n        const flows: Flow[] = [];\n\n        for (const [instrIndex, instr] of instructions.entries()) {\n            flows.push({instr, instrIndex, expr, type: \"instr\", flowPrevious: [], flowNext: []});\n        }\n        allFlows.push(...flows);\n        flows.push(followingFlow);\n\n        for (let i = 0; i < instructions.length; i++) {\n            const instr = instructions[i];\n            const flow = flows[i];\n            const nextFlow = flows[i + 1];\n\n            if (instr.type === \"structured\" && instr.name === \"if\") {\n                // br to if jumps to the first instruction after the loop\n                brTargets.unshift(nextFlow);\n                const child1 = _expr2flow(instr.immediate.expression, flow, nextFlow);\n                const child2 = instr.immediate.expression2 && _expr2flow(instr.immediate.expression2, flow, nextFlow);\n                brTargets.shift();\n\n                if (child1 && child2) continue;\n\n            } else if (instr.type === \"structured\") {\n                // br to a loop jumps back to the loop, br to block jumps to the first instruction after the loop\n                brTargets.unshift(instr.name === \"loop\" ? flow : nextFlow);\n                const child = _expr2flow(instr.immediate.expression, flow, nextFlow);\n                brTargets.shift();\n\n                if (child) continue;\n\n            } else if (instr.type === \"index\" && instr.name.startsWith(\"br\")) {\n                const target = brTargets[Number(instr.immediate.value)];\n                if (!target) throw new Error(\"No such target for br?\");\n                flow.flowNext.push(target);\n\n                if (instr.name !== \"br_if\") continue;\n\n            } else if (instr.type === \"table\" && instr.name === \"br_table\") {\n                for (const targetIdx of [instr.immediate.defaultValue, ...instr.immediate.valueTable]) {\n                    const target = brTargets[Number(targetIdx)];\n                    if (!target) throw new Error(\"No such target for br_table?\");\n                    flow.flowNext.push(target);\n                }\n                continue;\n\n            } else if (instr.name === \"return\") {\n                flow.flowNext.push(exitFlow);\n                continue;\n            }\n\n            // flow passes through to next\n            flow.flowNext.push(flows[i + 1]);\n        }\n\n        const initial = flows.find(x => x.type === \"instr\");\n        if (initial) previousFlow.flowNext.push(initial);\n        return !!initial;\n    }\n\n    _expr2flow(expr, entryFlow, exitFlow);\n\n    // populate flowPrevious\n    for (const flow of allFlows) {\n        for (const next of flow.flowNext) {\n            next.flowPrevious.push(flow);\n        }\n    }\n\n    return {entry: entryFlow, exit: exitFlow, all: allFlows.filter(x => x.type === \"instr\") as InstrFlow[]};\n}\n\nexport function simplifiedControlFlow(expr: WExpression, filter: (instr: InstrInstance) => boolean): ControlFlowGraph {\n    const {entry, exit, all} = controlFlow(expr);\n    const newAll: InstrFlow[] = [];\n\n    for (const flow of all) {\n        if (flow.flowPrevious.length === 1 && flow.flowNext.length === 1 && !filter(flow.instr)) {\n            const previous = flow.flowPrevious[0];\n            const next = flow.flowNext[0];\n\n            previous.flowNext[previous.flowNext.indexOf(flow)] = next;\n            next.flowPrevious[next.flowPrevious.indexOf(flow)] = previous;\n        } else {\n            newAll.push(flow);\n        }\n    }\n\n    return {entry, exit, all: newAll};\n}\n\nexport interface InstrFlow {\n    type: \"instr\"\n    instr: InstrInstance;\n    expr: WExpression;\n    instrIndex: number;\n\n    // instructions which could be the previous executed instruction\n    flowPrevious: Flow[];\n    // instructions which could be the next executed instruction\n    flowNext: Flow[];\n}\n\nexport interface MarkerFlow {\n    type: \"entry\" | \"exit\";\n    instr: undefined;\n\n    flowPrevious: Flow[];\n    flowNext: Flow[];\n}\n\nexport type Flow = InstrFlow | MarkerFlow;\nexport type ControlFlowGraph = {entry: MarkerFlow, exit: MarkerFlow, all: InstrFlow[]};\n","import type {ControlFlowGraph, InstrFlow, Flow} from \"./control_flow\";\n\nexport function framework(\n    cfg: ControlFlowGraph,\n    intermediateMap: Map<Flow, bigint> | null,\n    bitMap: Map<Flow, bigint>,\n    direction: \"forwards\" | \"backwards\",\n    meetOperation: \"union\" | \"intersection\",\n    transferFunction: (f: Flow, x: bigint) => bigint,\n    intermediateOverride?: (f: Flow, x: bigint) => bigint\n): void {\n\n    const queue: Flow[] = (direction === \"forwards\" ? cfg.entry.flowNext : cfg.exit.flowPrevious)\n        .filter(x => x.instr);\n\n    let flow: Flow | undefined;\n    while ((flow = queue.shift()) !== undefined) {\n        let X = meetOperation === \"union\" ? 0n : -1n;\n        for (const before of (direction === \"forwards\" ? flow.flowPrevious : flow.flowNext)) {\n            const beforeBits = bitMap.get(before as InstrFlow) ?? 0n;\n\n            if (meetOperation === \"union\") {\n                X |= beforeBits;\n            } else { // intersection\n                X &= beforeBits;\n            }\n        }\n\n        // used by PRE to force some values to false if not safe\n        if (intermediateOverride) X = intermediateOverride(flow, X);\n        // also used by PRE analysis\n        if (intermediateMap) intermediateMap.set(flow, X);\n\n        X = transferFunction(flow, X);\n\n        if (X !== bitMap.get(flow)) {\n            bitMap.set(flow, X);\n\n            for (const after of (direction === \"forwards\" ? flow.flowNext : flow.flowPrevious)) {\n                if (after.instr) queue.push(after);\n            }\n        }\n    }\n}\n\n/*\n// Implementation using JS sets instead of bits\n\nexport function framework<T>(\n    cfg: ControlFlowGraph,\n    setMap: Map<Flow, Set<T>>,\n    direction: \"forwards\" | \"backwards\",\n    meetOperation: \"union\" | \"intersection\",\n    transferFunction: (f: InstrFlow, x: Set<T>) => Set<T>\n): void {\n\n    const queue = new Set<InstrFlow>();\n\n    for (const starting of (direction === \"forwards\" ? cfg.entry.flowNext : cfg.exit.flowPrevious)) {\n        if (starting.instr) queue.add(starting);\n    }\n\n    let next: IteratorResult<InstrFlow, InstrFlow>;\n    while ((next = queue.keys().next()).value) {\n        const flow = next.value;\n        queue.delete(flow);\n\n        let X = undefined;\n        for (const before of (direction === \"forwards\" ? flow.flowPrevious : flow.flowNext)) {\n            const beforeSet = setMap.get(before as InstrFlow);\n\n            if (X === undefined) {\n                X = beforeSet;\n            } else if (meetOperation === \"union\") {\n                if (!beforeSet) continue;\n                for (const v of beforeSet) {\n                    X.add(v);\n                }\n            } else if (meetOperation === \"intersection\") {\n                if (beforeSet) {\n                    for (const v of X) {\n                        if (!beforeSet.has(v)) X.delete(v);\n                    }\n                } else {\n                    X.clear();\n                }\n            }\n        }\n\n        X = transferFunction(flow, X ?? new Set<T>());\n\n        if (!setEquals(X, setMap.get(flow))) {\n            setMap.set(flow, X);\n\n            for (const after of (direction === \"forwards\" ? flow.flowNext : flow.flowPrevious)) {\n                if (after.instr) queue.add(after);\n            }\n        }\n    }\n}\n\nfunction setEquals<T>(a: Set<T>, b?: Set<T>): boolean {\n    if (!b || a.size !== b.size) return false;\n    for (const x of a) {\n        if (!b.has(x)) return false;\n    }\n    return true;\n}\n*/\n","import {WExpression, ValueType, Instructions} from \"../../wasm\";\nimport {WLocal} from \"../../wasm/functions\";\nimport {peephole} from \"../peephole\";\nimport {Flow, simplifiedControlFlow} from \"./control_flow\";\nimport {framework} from \"./framework\";\n\ntype ClashNode = {local: number, type: ValueType, clash: Set<number>};\n\nexport function realloc_locals(expr: WExpression): void {\n    if (expr.builder.locals.length <= 1) return;\n\n    const cfg = simplifiedControlFlow(expr, x => x.name.startsWith(\"local.\"));\n    const liveMap = new Map<Flow, bigint>();\n    const numArgs = BigInt(expr.builder.args.length);\n\n    // LVA\n    framework(cfg, null, liveMap, \"backwards\", \"union\", (f, x) => {\n        // (out-live \\ def) U ref\n        if (f.instr && f.instr.type === \"index\") {\n            const flag = 1n << (f.instr.immediate.value - numArgs);\n            if (f.instr.name === \"local.get\") { // ref\n                return x | flag;\n            } else if (f.instr.name === \"local.set\" || f.instr.name === \"local.tee\") { // def\n                return x & ~flag;\n            }\n        }\n        return x;\n    });\n\n    // make clash graph\n    const clashGraph: ClashNode[] = expr.builder.locals\n        .map(({type}, local) => ({local, type: type, clash: new Set()}));\n    for (let bits of liveMap.values()) {\n        if (bits === 0n) continue;\n\n        const live: number[] = [];\n        for (let i = 0; bits; i++) {\n            if (bits & 1n) live.push(i);\n            bits >>= 1n;\n        }\n        if (live.length <= 1) continue;\n\n        for (const i of live) {\n            for (const j of live) i !== j && clashGraph[i].clash.add(j);\n        }\n    }\n\n    // push vertex with the least edges onto a stack\n    const stack: number[] = [];\n    const clashCopy = clashGraph.map(({local, clash}) => ({local, clash: new Set(clash)}));\n    while (clashCopy.length) {\n        clashCopy.sort((a, b) => a.clash.size - b.clash.size);\n        const {local} = clashCopy.shift() as ClashNode;\n        stack.push(local);\n\n        for (const node of clashCopy) node.clash.delete(local);\n    }\n\n    // pop and allocate\n    expr.builder.wipeLocals();\n    const locals: WLocal[] = [];\n    const mapping: WLocal[] = Array(clashGraph.length);\n    while (stack.length) {\n        const oldLocal = stack.pop() as number;\n        const {type} = clashGraph[oldLocal];\n\n        const clashesWith = new Set<WLocal>();\n        for (const c of clashGraph[oldLocal].clash) {\n            if (mapping[c]) clashesWith.add(mapping[c]);\n        }\n\n        let newLocal = undefined;\n        for (const local of locals) {\n            if (local.type !== type) continue;\n            if (clashesWith.has(local)) continue;\n            newLocal = local;\n            break;\n        }\n        if (!newLocal) locals.push(newLocal = expr.builder.addLocal(type));\n\n        mapping[oldLocal] = newLocal;\n    }\n    mapping.unshift(...expr.builder.args); // add arguments back into mapping\n\n    // transform according to the mapping\n    remapLocals(expr, mapping);\n}\n\nexport function remapLocals(expr: WExpression, mapping: WLocal[]): void {\n    peephole(expr, ([instr]) => {\n        if (instr.type !== \"index\" || !instr.name.startsWith(\"local.\")) return;\n        const local = mapping[Number(instr.immediate.value)];\n        if (instr.name === \"local.get\") {\n            return [Instructions.local.get(local)];\n        } else if (instr.name === \"local.set\") {\n            return [Instructions.local.set(local)];\n        } else if (instr.name === \"local.tee\") {\n            return [Instructions.local.tee(local)];\n        }\n    }, 1);\n}\n","import {byte, globalidx} from \"./base_types\";\nimport {encodeConstantInstr} from \"./encoding\";\nimport {ModuleBuilder} from \"./module\";\nimport {ValueType, encodeGlobal} from \"./wtypes\";\n\nexport class WGlobal {\n\n    constructor(readonly module: ModuleBuilder,\n                readonly type: ValueType,\n                readonly mutable: boolean,\n                public initialValue: number | bigint,\n                readonly exportName?: string) {\n    }\n\n    getIndex(): globalidx {\n        return this.module._globalIndex(this);\n    }\n\n    toBytes(): byte[] {\n        return [\n            ...encodeGlobal([this.type, this.mutable]),\n            ...encodeConstantInstr(this.initialValue, this.type),\n            0x0B as byte\n        ];\n    }\n}\n","import {WExpression} from \"../wasm\";\nimport {PartialInstr, InstrInstance} from \"../wasm/instr_helpers\";\n\n// subset of InstrFlow, also used by fn inlining\ninterface InstrLoc {\n    expr: WExpression;\n    instrIndex: number;\n}\n\n// keeps track of edits and offsets the precomputed indices on instr flows accordingly\nexport class InstrSplicer {\n    private offsetsMap = new Map<WExpression, { index: number, offset: number }[]>();\n\n    splice(loc: InstrLoc, deleteCount: number, replacements: (PartialInstr | InstrInstance)[], beginOffset?: number): void {\n        let offsets = this.offsetsMap.get(loc.expr);\n        if (!offsets) this.offsetsMap.set(loc.expr, offsets = []);\n\n        let instrIndex = loc.instrIndex + (beginOffset ?? 0);\n        for (const {index, offset} of offsets) {\n            if (instrIndex > index) instrIndex += offset;\n        }\n\n        loc.expr.replace(instrIndex, instrIndex + deleteCount, ...replacements);\n\n        const offset = replacements.length - deleteCount;\n        if (offset) offsets.push({index: instrIndex, offset});\n    }\n\n    realIndex(flow: InstrLoc): number {\n        const offsets = this.offsetsMap.get(flow.expr);\n        if (!offsets) return flow.instrIndex;\n\n        let instrIndex = flow.instrIndex;\n        for (const {index, offset} of offsets) {\n            if (instrIndex > index) instrIndex += offset;\n        }\n        return instrIndex;\n    }\n}\n","import {WExpression, ValueType, Instructions} from \"../../wasm\";\nimport {WLocal} from \"../../wasm/functions\";\nimport {WGlobal} from \"../../wasm/global\";\nimport {InstrInstance, ReadResource, PartialInstr} from \"../../wasm/instr_helpers\";\nimport {InstrSplicer} from \"../splicer\";\nimport {InstrFlow, controlFlow, ControlFlowGraph, Flow} from \"./control_flow\";\nimport {framework} from \"./framework\";\n\n// partial redundancy elimination\n// https://dl.acm.org/doi/pdf/10.1145/307824.307851\n\n// Local properties\n// TRANSP - Transparent - expression operands are not modified by execution of statement\n// ANTLOC - Locally anticipable - expression computed in basic block b and doesn't previous define operands\n// COMP - Locally available - expression computed in basic block b and b doesn't later redefine operands\n\n// Global properties\n// AV[IN/OUT] - Availability\n// ANT[IN/OUT] - Anticipability\n// SPAV[IN/OUT] - Safe partial availability\n// SPANT[IN/OUT] - Safe partial anticipability\n// SAFE[IN,OUT] - Safe to insert a computation\n\ninterface SubExpr {\n    positions: {start: number, end: number, expr: WExpression}[];\n    instructions: InstrInstance[];\n    resources: Set<ReadResource>;\n    type: ValueType;\n    bit: bigint;\n}\n\ninterface ExprResult {\n    expression: SubExpr;\n\n    insertBefore: InstrFlow[]; // INSERT_i\n    insertBetween: [InstrFlow, InstrFlow][]; // INSERT_{i,j}\n    insertAfter: InstrFlow[]; // from edge insertion minimization\n    insertInstructions: (InstrInstance | PartialInstr)[];\n\n    replacementFlows: InstrFlow[]; // REPLACE\n    replacementInstructions: (InstrInstance | PartialInstr)[];\n\n    fnLengthChange: number;\n}\n\nfunction subExprMatches(s1: SubExpr, s2: SubExpr): boolean {\n    if (s1.type !== s2.type || s1.instructions.length !== s2.instructions.length) return false;\n    return s1.instructions.every((v, i) => {\n        const arr1 = v.encoded, arr2 = s2.instructions[i].encoded;\n        return arr1.length === arr2.length && arr1.every((v, i) => v === arr2[i]);\n    });\n}\n\nfunction expressions(top: WExpression): SubExpr[] {\n    const expressions: SubExpr[] = [];\n    const exprQueue = [top];\n\n    let expr;\n    while ((expr = exprQueue.shift()) !== undefined) {\n        const {instructions} = expr;\n\n        instrLoop:\n        for (const [i, startInstr] of instructions.entries()) {\n            if (startInstr.type === \"structured\") {\n                exprQueue.push(startInstr.immediate.expression);\n                if (startInstr.immediate.expression2) exprQueue.push(startInstr.immediate.expression2);\n                continue;\n            }\n            if (startInstr.parameters.length || startInstr.writes.length || !startInstr.result) {\n                continue;\n            }\n\n            const stack = [startInstr.result];\n            const resources = new Set(startInstr.reads);\n            for (let j = i + 1; j < instructions.length; j++) {\n                const instr = instructions[j];\n                if (instr.parameters.length > stack.length || instr.writes.length) continue instrLoop;\n\n                stack.splice(0, instr.parameters.length);\n                if (instr.result) stack.unshift(instr.result);\n                for (const resource of instr.reads) resources.add(resource);\n\n                if (stack.length === 1 && (j - i) >= 2) {\n                    const position = {start: i, end: j, expr};\n                    const subExpr: SubExpr = {\n                        positions: [position],\n                        resources,\n                        type: stack[0],\n                        instructions: instructions.slice(i, j + 1),\n                        bit: 1n << BigInt(expressions.length)\n                    };\n\n                    // see if there is an existing subexpr which matches\n                    const matching = expressions.find(x => subExprMatches(x, subExpr));\n                    if (matching) {\n                        matching.positions.push(position);\n                    } else {\n                        expressions.push(subExpr);\n                    }\n                }\n            }\n        }\n    }\n\n    return expressions;\n}\n\nfunction transparent(cfg: ControlFlowGraph, expressions: SubExpr[]): (f: Flow) => bigint {\n    const fullyTransparent = (1n << BigInt(expressions.length)) - 1n;\n    const transpMap = new Map<InstrFlow, bigint>();\n    for (const f of cfg.all) {\n        let flags = fullyTransparent;\n        if (f.instr.type !== \"structured\") {\n            for (const resource of f.instr.writes) {\n                if (resource === \"memory\" || resource instanceof WGlobal || resource instanceof WLocal) {\n                    for (const [i, expression] of expressions.entries()) {\n                        if (expression.resources.has(resource)) flags &= ~(1n << BigInt(i));\n                    }\n                }\n            }\n        } // structured instructions are themselves transparent\n        transpMap.set(f, flags);\n    }\n    return (f) => transpMap.get(f as InstrFlow) ?? fullyTransparent;\n}\n\nfunction computed(cfg: ControlFlowGraph, expressions: SubExpr[]): (f: Flow) => bigint {\n    const computedMap = new Map<InstrFlow, bigint>();\n    for (const f of cfg.all) {\n        let flags = 0n;\n\n        for (const [expIdx, expression] of expressions.entries()) {\n            if (expression.positions.find(({expr, end}) => expr === f.expr && end === f.instrIndex)) {\n                flags |= 1n << BigInt(expIdx);\n            }\n        }\n\n        computedMap.set(f, flags);\n    }\n    return (f) => computedMap.get(f as InstrFlow) ?? 0n;\n}\n\nfunction analysis(cfg: ControlFlowGraph, exprs: SubExpr[]) {\n    const TRANSP = transparent(cfg, exprs);\n    const COMP = computed(cfg, exprs);\n    const ANTLOC = COMP; // since this implementation has no basic blocks, ANTLOC = COMP ?\n\n    // Step 1: Compute AVIN/AVOUT and ANTIN/ANTOUT for all nodes.\n    const AVIN = new Map<Flow, bigint>(), AVOUT = new Map<Flow, bigint>();\n    framework(cfg,\n        AVIN,\n        AVOUT,\n        \"forwards\",\n        \"intersection\",\n        (f, x) => COMP(f) | (x & TRANSP(f))\n    );\n\n    const ANTOUT = new Map<Flow, bigint>(), ANTIN = new Map<Flow, bigint>();\n    framework(cfg,\n        ANTOUT,\n        ANTIN,\n        \"backwards\",\n        \"intersection\",\n        (f, x) => ANTLOC(f) | (x & TRANSP(f))\n    );\n\n    // Step 2: Compute SAFEIN/SAFEOUT for all nodes.\n    const SAFEIN = new Map<Flow, bigint>(), SAFEOUT = new Map<Flow, bigint>();\n    for (const f of cfg.all) {\n        SAFEIN.set(f, (AVIN.get(f) ?? 0n) | (ANTIN.get(f) ?? 0n));\n        SAFEOUT.set(f, (AVOUT.get(f) ?? 0n) | (ANTOUT.get(f) ?? 0n));\n    }\n\n    // Step 3: Compute SPAVIN/SPAVOUT and SPANTIN/SPANTOUT for all nodes.\n    const SPAVIN = new Map<Flow, bigint>(), SPAVOUT = new Map<Flow, bigint>();\n    framework(cfg,\n        SPAVIN,\n        SPAVOUT,\n        \"forwards\",\n        \"union\",\n        (f, x) => (COMP(f) | (x & TRANSP(f))) & (SAFEOUT.get(f) ?? 0n),\n        (f, x) => x & (SAFEIN.get(f) ?? 0n)\n    );\n\n    const SPANTOUT = new Map<Flow, bigint>(), SPANTIN = new Map<Flow, bigint>();\n    framework(cfg,\n        SPANTOUT,\n        SPANTIN,\n        \"backwards\",\n        \"union\",\n        (f, x) => (ANTLOC(f) | (x & TRANSP(f))) & (SAFEIN.get(f) ?? 0n),\n        (f, x) => x & (SAFEOUT.get(f) ?? 0n)\n    );\n\n    // Step 4: Compute points of insertions and replacements INSERT, INSERT(i,j), and REPLACE.\n    const INSERT = new Map<Flow, bigint>(), REPLACE = new Map<Flow, bigint>();\n    const INSERT_EDGE = new Map<Flow, [Flow, bigint][]>();\n    for (const i of [cfg.entry, ...cfg.all]) {\n        const comp = COMP(i), spavin = (SPAVIN.get(i) ?? 0n), spantout = (SPANTOUT.get(i) ?? 0n);\n        const insert = comp & (~spavin) & spantout;\n        if (insert !== 0n) INSERT.set(i, insert);\n\n        const antloc = ANTLOC(i);\n        const replace = (antloc & spavin) | (comp & spantout);\n        if (replace !== 0n) REPLACE.set(i, replace);\n\n        const spavout = SPAVOUT.get(i) ?? 0n, edgeList = [];\n        for (const j of i.flowNext) {\n            if (!j.instr) continue;\n            const insert_edge = (~spavout) & (SPAVIN.get(j) ?? 0n) & (SPANTIN.get(j) ?? 0n);\n            if (insert_edge !== 0n) edgeList.push([j, insert_edge] as [InstrFlow, bigint]);\n        }\n        if (edgeList.length) INSERT_EDGE.set(i, edgeList);\n    }\n    return {INSERT, INSERT_EDGE, REPLACE};\n}\n\nfunction processResults(exprs: SubExpr[], {INSERT, INSERT_EDGE, REPLACE}: ReturnType<typeof analysis>): ExprResult[] {\n    // convert the results from bits\n    const results: ExprResult[] = [];\n    for (const exp of exprs) {\n        const insertBefore: InstrFlow[] = [];\n        for (const [i, bits] of INSERT.entries()) {\n            if (bits & exp.bit) {\n                if (i.instr) {\n                    insertBefore.push(i);\n                } else { // i must be entry\n                    insertBefore.push(...i.flowNext as InstrFlow[]);\n                }\n            }\n        }\n\n        const insertBetween: [InstrFlow, InstrFlow][] = [];\n        for (const [i, list] of INSERT_EDGE.entries()) {\n            for (const [j, bits] of list) {\n                if (bits & exp.bit) {\n                    if (i.instr && j.instr) {\n                        insertBetween.push([i, j]);\n                    } else { // i must be entry\n                        insertBefore.push(j as InstrFlow);\n                    }\n                }\n            }\n        }\n\n        const replacementFlows: InstrFlow[] = [];\n        for (const [i, bits] of REPLACE.entries()) {\n            if (bits & exp.bit) replacementFlows.push(i as InstrFlow);\n        }\n\n        if (insertBefore.length + insertBetween.length && replacementFlows.length) {\n            const local = replacementFlows[0].expr.builder.addLocal(exp.type);\n            const insertInstructions = [...exp.instructions, Instructions.local.set(local)];\n            const replacementInstructions = [Instructions.local.get(local)];\n\n            results.push({\n                expression: exp,\n                insertBefore, insertBetween, insertAfter: [],\n                insertInstructions,\n                replacementFlows,\n                replacementInstructions,\n                fnLengthChange: 0\n            });\n        }\n    }\n\n    for (const result of results) {\n        // minimizing edge insertions\n        for (const i of new Set(result.insertBetween.map(([i]) => i))) {\n            const check = [...i.flowNext].every(j =>\n                j.instr && (result.insertBetween.find(([i2, j2]) => i === i2 && j === j2) || result.insertBefore.includes(j))\n            );\n            if (check) {\n                // remove [i, *j] from edges and [*j] from nodes\n                result.insertBetween = result.insertBetween.filter(([i2]) => i !== i2);\n                result.insertBefore = result.insertBefore.filter(j2 => i.flowNext.indexOf(j2) === -1);\n\n                if (i.instr.type === \"structured\") {\n                    // the structured nodes appear in the flow graph at the start of their blocks, and the algorithm\n                    // wants to insert after that flow graph, NOT after the whole structured instruction.\n                    result.insertBefore.push(i);\n                    // so instead insert before, which is safe as structured instructions only side effects are jumping\n                } else {\n                    result.insertAfter.push(i);\n                }\n            }\n        }\n\n        // calculate how this result would change the length of the function\n        const inserted = result.insertInstructions.length * ((result.insertBefore.length) + (result.insertBetween.length) + (result.insertAfter.length));\n        const removed = (result.expression.instructions.length - result.replacementInstructions.length) * result.replacementFlows.length;\n        result.fnLengthChange = inserted - removed;\n    }\n    return results;\n}\n\nfunction eliminateOverlapping(results: ExprResult[]): void {\n    // as expressions(...) returns all subexpressions in functions, need to chose which results to action\n\n    results.sort((a, b) => {\n        // prioritize expression replacements which would make the function shorter as these probably replace\n        // longer subexpressions which appear more often\n        const diff = a.fnLengthChange - b.fnLengthChange;\n        if (diff !== 0) return diff;\n        // after that prioritize longer subexpressions\n        return b.expression.instructions.length - a.expression.instructions.length;\n    });\n\n    // filter out expressions we can't do because they overlap with other expressions\n    // (hopefully due to the above sorting we will keep the longer expressions and discard their subexpressions)\n    const modificationRegions: [expr: WExpression, start: number, end: number][] = [];\n    for (let i = 0; i < results.length; i++) {\n        const result = results[i];\n        const expressionLen = result.expression.instructions.length;\n\n        const regions = result.replacementFlows.map(f =>\n            [f.expr, f.instrIndex - expressionLen, f.instrIndex] as [WExpression, number, number]);\n\n        const overlaps = regions.some(([expr1, min1, max1]) =>\n            modificationRegions.some(([expr2, min2, max2]) =>\n                expr1 === expr2 && max1 >= min2 && max2 >= min1\n            ));\n\n        if (overlaps) { // can't process this result as it overlaps with another with higher score\n            results.splice(i, 1);\n            i--;\n        } else {\n            modificationRegions.push(...regions);\n        }\n    }\n}\n\nexport function pre(expr: WExpression): void {\n    const cfg = controlFlow(expr);\n    if (!cfg.all.length) return;\n    const exprs = expressions(expr);\n    if (!exprs.length) return;\n\n    const {INSERT, INSERT_EDGE, REPLACE} = analysis(cfg, exprs);\n    if (INSERT.size === 0 && INSERT_EDGE.size === 0 && REPLACE.size === 0) return;\n\n    const results = processResults(exprs, {INSERT, INSERT_EDGE, REPLACE});\n    eliminateOverlapping(results);\n\n    const ifs = new InstrSplicer(); // keeps tracks of edits and adjust indices\n    for (const result of results) {\n        const exprLength = result.expression.instructions.length;\n        for (const i of result.replacementFlows) { // i is the last node of the expression\n            ifs.splice(i, exprLength, result.replacementInstructions, 1 - exprLength);\n        }\n\n        for (const i of result.insertBefore) {\n            ifs.splice(i, 0, result.insertInstructions, 0);\n        }\n        for (const i of result.insertAfter) {\n            if (i.instr.name.startsWith(\"br\")) {\n                // just insert before instead\n                ifs.splice(i, 0, result.insertInstructions, 0);\n            } else {\n                ifs.splice(i, 0, result.insertInstructions, 1);\n            }\n        }\n\n        for (const [i, j] of result.insertBetween) {\n            if (i.expr === j.expr && i.instrIndex + 1 === j.instrIndex) {\n                // instructions one after each other\n                ifs.splice(j, 0, result.insertInstructions);\n            } else if (ifs.realIndex(i) + 1 === i.expr.instructions.length) {\n                // i at the end of a block\n                ifs.splice(i, 0, result.insertInstructions, i.instr.name.startsWith(\"br\") ? 0 : 1);\n            } else if (i.instr.name.startsWith(\"br\")) {\n                // at a branch\n                ifs.splice(i, 0, result.insertInstructions);\n            } else if (j.expr.parent === i.instr && j.instrIndex === 0) {\n                // j is first instruction inside i\n                ifs.splice(j, 0, result.insertInstructions);\n            } else if (i.expr.depth > j.expr.depth) {\n                // i nested deeper inside expr containing j\n                ifs.splice(i, 0, result.insertInstructions, i.instr.name.startsWith(\"br\") ? 0 : 1);\n            } else {\n                throw new Error(\"Unknown PRE insertion\");\n            }\n        }\n    }\n}\n","import {WExpression, ValueType, Instructions} from \"../../wasm\";\nimport {WLocal} from \"../../wasm/functions\";\nimport {simplifiedControlFlow, Flow} from \"./control_flow\";\n\nexport function rangeSplitting(expr: WExpression): void {\n    const cfg = simplifiedControlFlow(expr, x => x.name.startsWith(\"local.\"));\n    const localsMap = new Map<Flow, LocalRange[]>();\n    const definitionMap = new Map<Flow, LocalRange>();\n\n    const queue = cfg.entry.flowNext.slice();\n\n    let flow: Flow | undefined;\n    while ((flow = queue.shift()) !== undefined) {\n        const ranges: LocalRange[] = [];\n        for (const prev of flow.flowPrevious) {\n            for (const [i, local] of (localsMap.get(prev) ?? []).entries()) {\n                if (!local) continue;\n                if (ranges[i] !== undefined) {\n                    ranges[i] = ranges[i].merge(local);\n                } else {\n                    ranges[i] = local.get();\n                }\n            }\n        }\n\n        if (flow.instr && flow.instr.type === \"index\" && (flow.instr.name === \"local.set\" || flow.instr.name === \"local.tee\")) {\n            const i = Number(flow.instr.immediate.value) - expr.builder.args.length;\n            if (i >= 0) {\n                let local = definitionMap.get(flow);\n                if (!local) definitionMap.set(flow, local = new LocalRange(flow.instr.parameters[0]));\n                ranges[i] = local;\n            }\n        }\n\n        const existing = localsMap.get(flow);\n        if (!existing || existing.length !== ranges.length || existing.some((x, i) => ranges[i] !== x)) {\n            localsMap.set(flow, ranges);\n            for (const next of flow.flowNext) queue.push(next);\n        }\n    }\n\n    const allLocals = [...new Set([...definitionMap.values()].map(x => x.get()))];\n    if (allLocals.length <= expr.builder.locals.length) return;\n\n    expr.builder.wipeLocals();\n    for (const l of allLocals) l.newLocal = expr.builder.addLocal(l.type);\n\n    for (const [flow, ranges] of localsMap.entries()) {\n        if (!flow.instr || flow.instr.type !== \"index\") continue;\n        const index = Number(flow.instr.immediate.value) - expr.builder.args.length;\n        if (index < 0) continue;\n\n        if (flow.instr.name === \"local.get\") {\n            flow.expr.replace(flow.instrIndex, flow.instrIndex + 1, Instructions.local.get(ranges[index].getNewLocal()));\n        } else if (flow.instr.name === \"local.set\") {\n            flow.expr.replace(flow.instrIndex, flow.instrIndex + 1, Instructions.local.set(ranges[index].getNewLocal()));\n        } else if (flow.instr.name === \"local.tee\") {\n            flow.expr.replace(flow.instrIndex, flow.instrIndex + 1, Instructions.local.tee(ranges[index].getNewLocal()));\n        }\n    }\n}\n\nlet localId = 0;\nclass LocalRange {\n    readonly id = localId++;\n    private target?: LocalRange;\n    newLocal?: WLocal;\n\n    constructor(readonly type: ValueType) {\n    }\n\n    merge(other: LocalRange): LocalRange {\n        if (this === other) return this.get();\n\n        if (this.target) {\n            return this.target.merge(other);\n        } else if (other.id < this.id) {\n            other.merge(this);\n            return this.get();\n        } else {\n            this.target = other;\n            return other.get();\n        }\n    }\n\n    get(): LocalRange {\n        if (this.target) return this.target.get();\n        return this;\n    }\n\n    getNewLocal(): WLocal {\n        if (this.target) return this.target.getNewLocal();\n        if (!this.newLocal) throw new Error(\"No new local assigned?\");\n        return this.newLocal;\n    }\n}\n","import type {Location, ParseNode} from \"./parsing\";\n\nexport class CError extends Error {\n    name = \"CError\";\n\n    constructor(message: string, readonly node?: ParseNode, readonly node2?: ParseNode) {\n        super(message);\n\n        if (node?.loc) {\n            this.message += \"\\n\\n\" + locationString(node.loc);\n            if (node2?.loc) this.message += \"\\n\\n\" + locationString(node2.loc, \"Secondary location\");\n        }\n    }\n}\n\nexport function locationString(loc: Location, label: string = \"Location\"): string {\n    const lines = loc.source.split(\"\\n\");\n    if (loc.first_line >= lines.length) return `${label}: [UNKNOWN]`;\n\n    let output = `${label}:\\n`;\n\n    const lnumDigits = Math.ceil(Math.log10(loc.last_line + 4));\n    function outputLine(lnum: number) {\n        output += `L${(lnum + 1).toString().padStart(lnumDigits, '0')}: ${lines[lnum]}\\n`;\n    }\n\n    if (loc.first_line > 1) outputLine(loc.first_line - 2);\n    if (loc.first_line > 0) outputLine(loc.first_line - 1);\n    outputLine(loc.first_line);\n\n    // output ^^^ arrows\n    output += new Array(3 + lnumDigits + loc.first_column).join(\" \");\n    if (loc.first_line === loc.last_line) {\n        output += new Array(1 + loc.last_column - loc.first_column).join(\"^\");\n    } else {\n        output += \"^\";\n    }\n    output += \"\\n\";\n\n    if (loc.first_line + 1 < lines.length) outputLine(loc.first_line + 1);\n    if (loc.first_line + 2 < lines.length) outputLine(loc.first_line + 2);\n    return output;\n}\n","import {CError} from \"../c_error\";\nimport type {TypeSpecifier, TypeQualifier, ParseNode} from \"../parsing/parsetree\";\n\n// types for expressions and declarations in the IR\nexport type CType = CNotFuncType | CFuncType;\nexport type CNotFuncType = CArithmetic | CPointer | CArray | CStruct | CUnion | CVoid;\nexport type CQualifiedType<T extends CType> = T & {qualifier?: TypeQualifier, _base?: T};\n\nexport class CFuncType {\n    readonly typeName = \"function\";\n    readonly bytes = 0;\n    readonly alignment = 1;\n    readonly incomplete = false;\n\n    constructor(readonly node: ParseNode | undefined,\n                readonly returnType: CQualifiedType<CNotFuncType>,\n                readonly parameterTypes: CQualifiedType<CNotFuncType>[],\n                public parameterNames?: string[],\n                readonly variadic: boolean = false) {\n        // return type and parameter types must be complete\n        if (!(returnType instanceof CVoid)) checkTypeComplete(returnType);\n        parameterTypes.forEach(x => checkTypeComplete(x));\n    }\n\n    equals(t: Object): boolean {\n        return t instanceof CFuncType\n            && t.returnType.equals(this.returnType)\n            && t.parameterTypes.length === this.parameterTypes.length\n            && t.parameterTypes.every((other, i) => this.parameterTypes[i].equals(other))\n            && t.variadic === this.variadic;\n    }\n\n    get pointerGeneration(): CPointer {\n        return addQualifier(new CPointer(this.node, this, false, this), getQualifier(this));\n    }\n}\n\nexport class CPointer {\n    readonly bytes = 4;\n    readonly alignment = 4;\n    readonly incomplete = false;\n    readonly qualifier?: TypeQualifier;\n\n    constructor(readonly node: ParseNode | undefined,\n                readonly type: CType,\n                constant: boolean = false,\n                readonly original?: CFuncType | CArray /* used in pointer generation */) {\n        // allow pointers to incomplete types\n        if (constant) this.qualifier = \"const\";\n    }\n\n    equals(t: object): boolean {\n        return t instanceof CPointer && t.qualifier === this.qualifier && this.type.equals(t.type);\n    }\n\n    get pointerGeneration(): this {\n        return this; // no pointer generation (already a pointer!)\n    }\n\n    get typeName(): string {\n        return this.type.typeName + \"*\" + (this.qualifier ? \" \" + this.qualifier : \"\");\n    }\n}\n\nexport class CArray {\n    readonly alignment: number;\n\n    constructor(readonly node: ParseNode | undefined, readonly type: CType, public length?: number) {\n        checkTypeComplete(type);\n        this.alignment = type.alignment;\n    }\n\n    get bytes(): number {\n        if (this.length === undefined) throw new Error(\"Tried to get size of incomplete type\");\n        return this.type.bytes * this.length;\n    }\n\n    get incomplete(): boolean {\n        return this.length === undefined;\n    }\n\n    equals(t: object): boolean {\n        return t instanceof CArray && t.length === this.length && this.type.equals(t.type);\n    }\n\n    get pointerGeneration(): CPointer {\n        return addQualifier(new CPointer(this.node, this.type, false, this), getQualifier(this));\n    }\n\n    get typeName(): string {\n        if (this.length) {\n            return this.type.typeName + \"[\" + this.length + \"]\";\n        } else {\n            return this.type.typeName + \"[]\";\n        }\n    }\n}\n\nexport type CCompound = CStruct | CUnion | CEnum;\n\nexport class CCompoundMember {\n    constructor(readonly node: ParseNode, readonly name: string, readonly type: CQualifiedType<CNotFuncType>) {}\n}\n\nexport class CStruct {\n    private _members: ReadonlyArray<CCompoundMember> | undefined;\n\n    constructor(public node: ParseNode | undefined, readonly name: string | undefined) {\n    }\n\n    get members(): ReadonlyArray<CCompoundMember> {\n        if (this._members === undefined) throw new Error(\"Can't get members of an incomplete struct\");\n        return this._members;\n    }\n\n    set members(children: ReadonlyArray<CCompoundMember>) {\n        if (this._members !== undefined) throw new Error(\"Can't redefine a struct's members\");\n        if (children.length === 0) throw new Error(\"Struct must have one or more member\");\n        this._members = children;\n    }\n\n    get bytes(): number {\n        if (this.incomplete) throw new Error(\"Tried to get size of incomplete type\");\n        return this.members.reduce((total, x) => {\n            // align member type\n            total = Math.ceil(total / x.type.alignment) * x.type.alignment;\n            return total + x.type.bytes;\n        }, 0);\n    }\n\n    get alignment(): number {\n        return Math.max(...this.members.map(x => x.type.alignment));\n    }\n\n    get incomplete(): boolean {\n        return this._members === undefined;\n    }\n\n    equals(t: object): boolean {\n        if (!(t instanceof CStruct)) return false;\n        if (this.name === undefined && t.name === undefined) {\n            /** TODO breaks spec but works around anonymous structure being included in multiple files from a header file\n             *\n             * \"Structures, unions and enumerations with different tags are distinct,\n             * and a tagless union, structure, or enumeration specifies a unique type\" */\n            if (this.members.length !== t.members.length) return false;\n            return this.members.every((x, i) => t.members[i].name === x.name && t.members[i].type.equals(x.type));\n        }\n        return t.name === this.name;\n    }\n\n    memberType(m: string): CType {\n        const member = this.members.find(x => x.name === m);\n        if (member) return member.type;\n        throw new Error(`Struct does not contain member \"${m}\"`);\n    }\n\n    hasConstMember(): boolean { // if the struct contains one or more const members\n        return this.members.find(m =>\n            getQualifier(m.type) || ((m.type instanceof CUnion || m.type instanceof CStruct) && m.type.hasConstMember())\n        ) !== undefined;\n    }\n\n    get pointerGeneration(): this {\n        return this; // no pointer generation\n    }\n\n    get typeName(): string {\n        if (this.name) {\n            return \"struct \" + this.name;\n        } else {\n            return \"struct {\" + this.members.map(x => x.type.typeName + \" \" + x.name + \";\").join(\" \") + \"}\";\n        }\n    }\n}\n\nexport class CUnion {\n    private _members: ReadonlyArray<CCompoundMember> | undefined;\n\n    constructor(public node: ParseNode | undefined, readonly name: string | undefined) {\n    }\n\n    get members(): ReadonlyArray<CCompoundMember> {\n        if (this._members === undefined) throw new Error(\"Can't get members of an incomplete union\");\n        return this._members;\n    }\n\n    set members(children: ReadonlyArray<CCompoundMember>) {\n        if (this._members !== undefined) throw new Error(\"Can't redefine a union's members\");\n        if (children.length === 0) throw new Error(\"Struct must have one or more member\");\n        this._members = children;\n    }\n\n    get bytes(): number {\n        if (this.incomplete) throw new Error(\"Tried to get size of incomplete type\");\n        return this.members.reduce((total, x) => Math.max(total, x.type.bytes), 0);\n    }\n\n    get alignment(): number {\n        return Math.max(...this.members.map(x => x.type.alignment));\n    }\n\n    get incomplete(): boolean {\n        return this._members === undefined;\n    }\n\n    equals(t: object): boolean {\n        if (!(t instanceof CUnion)) return false;\n        if (this.name === undefined && t.name === undefined) {\n            if (this.members.length !== t.members.length) return false;\n            return this.members.every((x, i) => t.members[i].name === x.name && t.members[i].type.equals(x.type));\n        }\n        return t.name === this.name;\n    }\n\n    memberType(m: string): CType {\n        const member = this.members.find(x => x.name === m);\n        if (member) return member.type;\n        throw new Error(`Union does not contain member \"${m}\"`);\n    }\n\n    hasConstMember(): boolean { // if the union has one or more const members\n        return this.members.find(m =>\n            getQualifier(m.type) || ((m.type instanceof CUnion || m.type instanceof CStruct) && m.type.hasConstMember())\n        ) !== undefined;\n    }\n\n    get pointerGeneration(): this {\n        return this; // no pointer generation\n    }\n\n    get typeName(): string {\n        if (this.name) {\n            return \"union \" + this.name;\n        } else {\n            return \"union {\" + this.members.map(x => x.type.typeName + \" \" + x.name + \";\").join(\" \") + \"}\";\n        }\n    }\n}\n\nexport type CEnumValue = {name: string, value: bigint};\nexport class CEnum {\n    readonly typeName = \"enum\";\n    private _values: ReadonlyArray<CEnumValue> | undefined;\n\n    constructor(public node: ParseNode | undefined, readonly name: string | undefined) {\n    }\n\n    get values(): ReadonlyArray<CEnumValue> {\n        if (this._values === undefined) throw new Error(\"Can't get values of an incomplete enum\");\n        return this._values;\n    }\n\n    set values(children: ReadonlyArray<CEnumValue>) {\n        if (this._values !== undefined) throw new Error(\"Can't redefine an enum's values\");\n        if (children.length === 0) throw new Error(\"Enum must have one or more value\");\n        this._values = children;\n    }\n\n    get incomplete(): boolean {\n        return this._values === undefined;\n    }\n\n    equals(t: object): boolean {\n        if (this.name === undefined) return this === t;\n        return t instanceof CEnum && t.name === this.name;\n    }\n}\n\nexport class CVoid {\n    readonly typeName = \"void\";\n    readonly bytes = 0;\n    readonly alignment = 1;\n    readonly incomplete = true;\n    readonly node = undefined;\n\n    equals(t: object): boolean {\n        return t instanceof CVoid;\n    }\n\n    get pointerGeneration(): this {\n        return this; // no pointer generation\n    }\n}\n\nexport class CArithmetic {\n    readonly incomplete = false;\n    readonly node = undefined;\n    readonly alignment: number;\n\n    private constructor(readonly typeName: string, readonly bytes: number, readonly type: \"float\" | \"signed\" | \"unsigned\") {\n        this.alignment = bytes;\n    }\n\n    equals(t: object): boolean {\n        return t instanceof CArithmetic && t.typeName === this.typeName && t.type === this.type && t.bytes === this.bytes;\n    }\n\n    get minValue(): bigint | number {\n        if (CArithmetic.BOOL.equals(this)) return 0;\n\n        switch (this.type) {\n        case \"float\":\n            return -Infinity;\n        case \"unsigned\":\n            return 0;\n        case \"signed\":\n            return -(2n ** (BigInt(this.bytes * 8) - 1n));\n        }\n    }\n\n    get maxValue(): bigint | number {\n        if (CArithmetic.BOOL.equals(this)) return 1;\n\n        switch (this.type) {\n        case \"float\":\n            return Infinity;\n        case \"unsigned\":\n            return 2n ** BigInt(this.bytes * 8) - 1n;\n        case \"signed\":\n            return 2n ** (BigInt(this.bytes * 8) - 1n) - 1n;\n        }\n    }\n\n    get pointerGeneration(): this {\n        return this; // no pointer generation\n    }\n\n    static readonly Fp32 = new CArithmetic(\"float\", 4, \"float\");\n    static readonly Fp64 = new CArithmetic(\"double\", 8, \"float\");\n\n    static readonly U8 = new CArithmetic(\"char\", 1, \"unsigned\");\n    static readonly S8 = new CArithmetic(\"signed char\", 1, \"signed\");\n    static readonly U16 = new CArithmetic(\"unsigned short\", 2, \"unsigned\");\n    static readonly S16 = new CArithmetic(\"short\", 2, \"signed\");\n    static readonly U32 = new CArithmetic(\"unsigned int\", 4, \"unsigned\");\n    static readonly S32 = new CArithmetic(\"int\", 4, \"signed\");\n    static readonly U64 = new CArithmetic(\"unsigned long\", 8, \"unsigned\");\n    static readonly S64 = new CArithmetic(\"long\", 8, \"signed\");\n\n    static readonly BOOL = new CArithmetic(\"bool\", 4, \"signed\");\n}\n\nexport const CSizeT = CArithmetic.U32;\n\n\nconst constType = Symbol(\"const\"); // hidden property key\n\n/**\n * Add a qualifier to a type.\n *\n * This creates a new object with the qualifier attached, using the existing type as its prototype, allowing it to be\n * treated as the existing type. This new object is also cached on the existing type using a field referenced by a\n * symbol, so it can't be accessed when enumerating the fields and doesn't affect existing code.\n */\nexport function addQualifier<T extends CType>(t: T, qualifier?: TypeQualifier): CQualifiedType<T> {\n    if (qualifier === undefined) return t;\n    if (Object.prototype.hasOwnProperty.call(t, \"qualifier\")) {\n        throw new Error(\"Type already has a qualifier\");\n    }\n\n    const baseType = t as Record<typeof constType, any>;\n    if (baseType[constType]) {\n        // const type already exists\n        return baseType[constType];\n    }\n\n    const type = Object.setPrototypeOf({qualifier, _base: t}, t);\n    baseType[constType] = type;\n    return type;\n}\n\nexport function getQualifier(t: CQualifiedType<CType>): TypeQualifier | undefined {\n    return t?.qualifier;\n}\n\n/** integer promotion from the C standard */\nexport function integerPromotion(t: CArithmetic): CArithmetic {\n    if (t.type === \"float\") return t;\n    if (t.bytes < CArithmetic.S32.bytes || t === CArithmetic.BOOL) return CArithmetic.S32;\n    return t;\n}\n\n/** \"The usual arithmetic conversions\" from the C standard */\nexport function usualArithmeticConversion(t1: CArithmetic, t2: CArithmetic): CArithmetic {\n    if (t1 === CArithmetic.Fp64 || t2 === CArithmetic.Fp64) return CArithmetic.Fp64;\n    if (t1 === CArithmetic.Fp32 || t2 === CArithmetic.Fp32) return CArithmetic.Fp32;\n\n    // integer promotion\n    t1 = integerPromotion(t1);\n    t2 = integerPromotion(t2);\n\n    if (t1 === CArithmetic.U64 || t2 === CArithmetic.U64) return CArithmetic.U64;\n    if (t1 === CArithmetic.S64 || t2 === CArithmetic.S64) return CArithmetic.S64;\n    if (t1 === CArithmetic.U32 || t2 === CArithmetic.U32) return CArithmetic.U32;\n    return CArithmetic.S32;\n}\n\n/** Convert a list of specifier strings (e.g. \"signed\", \"int\") into a CType instance. */\nexport function getArithmeticType(specifierList: ReadonlyArray<TypeSpecifier & string>): CArithmetic | CVoid | undefined {\n    const copy = specifierList.slice();\n\n    function remove(s: TypeSpecifier & string) { // remove an item from a list if present, and return whether it was\n        const idx = copy.indexOf(s);\n        if (idx > -1) {\n            copy.splice(idx, 1);\n            return true;\n        }\n        return false;\n    }\n\n    function check<T>(x: T): T | undefined { // check that there are no specifiers left to be processed\n        if (copy.length > 0) return undefined; // extra specifiers so this type is invalid (e.g. \"unsigned signed int\")\n        return x;\n    }\n\n    if (remove(\"void\")) { // if \"void\" in list\n        return check(new CVoid()); // then the type must be void, check no extra specifiers were provided\n    } else if (remove(\"double\")) {\n        remove(\"long\"); // remove \"long\" if present, as treating \"long double\" as normal doubles\n        return check(CArithmetic.Fp64);\n    } else if (remove(\"float\")) {\n        return check(CArithmetic.Fp32);\n    } else if (remove(\"char\")) {\n        if (remove(\"signed\")) return check(CArithmetic.S8);\n        remove(\"unsigned\");\n        return check(CArithmetic.U8);\n    } else if (remove(\"short\")) {\n        remove(\"int\"); // remove optional \"int\" (\"short int\" === \"int\")\n        if (remove(\"unsigned\")) return check(CArithmetic.U16);\n        remove(\"signed\");\n        return check(CArithmetic.S16);\n    } else if (remove(\"long\")) {\n        remove(\"long\"); // remove an 2nd \"long\" if present, as treating \"long long\" as \"long\"\n        remove(\"int\");\n        if (remove(\"unsigned\")) return check(CArithmetic.U64);\n        remove(\"signed\");\n        return check(CArithmetic.S64);\n    } else if (remove(\"int\")) {\n        if (remove(\"unsigned\")) return check(CArithmetic.U32);\n        remove(\"signed\");\n        return check(CArithmetic.S32);\n    } else if (remove(\"unsigned\")) { // support just `unsigned` and `signed`\n        return check(CArithmetic.U32);\n    } else if (remove(\"signed\")) {\n        return check(CArithmetic.S32);\n    } else if (remove(\"bool\")) {\n        return check(CArithmetic.BOOL);\n    }\n    return undefined;\n}\n\n/** Assert that type is complete */\nexport function checkTypeComplete<T extends CType>(type: T, node: ParseNode | undefined = type.node): T {\n    if (type.incomplete) {\n        throw new class extends CError {\n            name = \"IncompleteTypeError\";\n        }(\"Invalid use of an incomplete type\", node);\n    }\n    return type;\n}\n","import {CError} from \"../c_error\";\nimport type {ParseNode} from \"../parsing\";\nimport type {CExpression} from \"./expressions\";\nimport {CArithmetic, CPointer, CStruct, CUnion, CType, CFuncType, checkTypeComplete} from \"./types\";\n\nexport class ExpressionTypeError extends CError {\n    name = \"ExpressionTypeError\";\n\n    constructor(node: ParseNode, readonly wantedType: string, readonly actualType?: string) {\n        super(actualType ? `Expected ${wantedType} but got ${actualType} instead!` : `Expected ${wantedType}`, node);\n    }\n}\n\n// Basic type checking for expressions, throws an exception if the expression's type is not the expected type\n\nexport function asArithmetic(node: ParseNode, t: CType): CArithmetic {\n    if (t instanceof CArithmetic) return t;\n    throw new ExpressionTypeError(node, \"arithmetic\", t.typeName);\n}\n\nexport function asInteger(node: ParseNode, t: CType): CArithmetic {\n    const arithmetic = asArithmetic(node, t);\n    switch (arithmetic.type) {\n    case \"signed\":\n    case \"unsigned\":\n        return arithmetic;\n    default:\n        throw new ExpressionTypeError(node, \"integer\", t.typeName);\n    }\n}\n\nexport function asPointer(node: ParseNode, t: CType): CPointer {\n    if (t instanceof CPointer) return t;\n    throw new ExpressionTypeError(node, \"pointer\", t.typeName);\n}\n\nexport function asArithmeticOrPointer(node: ParseNode, t: CType): CArithmetic | CPointer {\n    if (t instanceof CArithmetic) return t;\n    if (t instanceof CPointer) return t;\n    throw new ExpressionTypeError(node, \"arithmetic or pointer\", t.typeName);\n}\n\nexport function asNonFunctionPointer<T extends CType>(node: ParseNode, t: T): T {\n    if (t instanceof CPointer && t.type instanceof CFuncType) {\n        throw new ExpressionTypeError(node, \"non-function pointer\", \"function pointer\");\n    }\n    return t;\n}\n\nexport function asFunction(node: ParseNode, t: CType): CFuncType {\n    if (t instanceof CFuncType) return t;\n    if (t instanceof CPointer && t.type instanceof CFuncType) return t.type;\n    throw new ExpressionTypeError(node, \"function\", t.typeName);\n}\n\nexport function asStructOrUnion(node: ParseNode, t: CType): CStruct | CUnion {\n    checkTypeComplete(t);\n    if (t instanceof CStruct) return t;\n    if (t instanceof CUnion) return t;\n    throw new ExpressionTypeError(node, \"struct or union\", t.typeName);\n}\n\nexport function checkLvalue(expression: CExpression, lvalue: boolean): CExpression {\n    if (expression.lvalue === lvalue) return expression;\n    throw new ExpressionTypeError(expression.node, `lvalue=${lvalue}`, `lvalue=${expression.lvalue}`);\n}\n","import type {ParseNode, pt} from \"../parsing\";\nimport type {CDeclaration, CVariable, CArgument} from \"./declarations\";\nimport * as checks from \"./type_checking\";\nimport {\n    CArithmetic, CType, CArray, CPointer, CUnion, CStruct,\n    CSizeT, usualArithmeticConversion, integerPromotion, CFuncType, CVoid, checkTypeComplete, getQualifier\n} from \"./types\";\n\n// Classes to represent all the possible expression types in the IR\n\nexport type CExpression =\n    CConstant | CIdentifier | CStringLiteral |\n    CFunctionCall | CMemberAccess | CIncrDecr | // postfix\n    CAddressOf | CDereference | CUnaryPlusMinus | CBitwiseNot | CLogicalNot | CSizeof | // unary\n    CCast |\n    CMulDiv | CMod | CAddSub | CShift |\n    CRelational | CEquality |\n    CBitwiseAndOr | CLogicalAndOr |\n    CConditional | CAssignment | CComma;\n\n// evaluated expression, value and type pair\nexport type CValue = {readonly value: number | bigint, readonly type: CArithmetic | CPointer};\n\nexport class CConstant {\n    readonly lvalue = false;\n\n    constructor(readonly node: ParseNode, readonly type: CArithmetic, readonly value: bigint | number) {\n    }\n\n    changeType(type: CArithmetic): CConstant {\n        if (this.type.equals(type)) return this;\n\n        let newValue: bigint | number;\n        if (type.equals(CArithmetic.BOOL)) {\n            // eslint-disable-next-line eqeqeq\n            newValue = this.value == 0 ? 0 : 1;\n        } else if (type.type === \"float\") {\n            newValue = Number(this.value);\n        } else {\n            if (this.value > type.maxValue || this.value < type.minValue) {\n                throw new checks.ExpressionTypeError(this.node, `value which fits in ${type.typeName}`, this.value.toString());\n            }\n            newValue = BigInt(this.value);\n        }\n        return new CConstant(this.node, type, newValue);\n    }\n\n    // for analyzing expression dependencies\n    *identifiers(): IterableIterator<CIdentifier> {\n        // no identifier children\n    }\n}\n\nexport class CIdentifier {\n    readonly lvalue: boolean;\n\n    constructor(readonly node: ParseNode, readonly value: CDeclaration) {\n        this.lvalue = !(value.type instanceof CFuncType);\n    }\n\n    get type(): CType {\n        return this.value.type.pointerGeneration;\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield this;\n    }\n}\n\nexport class CStringLiteral {\n    readonly lvalue = false;\n    readonly type: CPointer;\n\n    constructor(readonly node: ParseNode, readonly value: bigint[]) {\n        // currently only supports UTF8\n        if (value.length === 0 || value[value.length - 1] !== 0n) {\n            throw new checks.ExpressionTypeError(node, \"null terminated char[]\", \"char[]\");\n        }\n        this.type = new CArray(node, CArithmetic.U8, value.length).pointerGeneration;\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        // no identifier children\n    }\n}\n\nexport class CFunctionCall {\n    readonly lvalue = false;\n    readonly fnType: CFuncType;\n    readonly type: CType;\n\n    constructor(readonly node: ParseNode, readonly body: CExpression, readonly args: CExpression[]) {\n        this.fnType = checks.asFunction(body.node, body.type);\n        this.type = this.fnType.returnType.pointerGeneration;\n\n        // check arguments correct for the function type\n        if (this.fnType.variadic && this.fnType.parameterTypes.length > args.length) {\n            throw new checks.ExpressionTypeError(node, `at least ${this.fnType.parameterTypes.length} argument(s) to variadic function`);\n        } else if (!this.fnType.variadic && this.fnType.parameterTypes.length !== args.length) {\n            throw new checks.ExpressionTypeError(node, `${this.fnType.parameterTypes.length} argument(s)`, `${args.length}`);\n        }\n        for (let i = 0; i < this.fnType.parameterTypes.length; i++) {\n            CAssignment.checkAssignmentValid(args[i].node, this.fnType.parameterTypes[i], args[i]);\n        }\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.body.identifiers();\n        for (const a of this.args) yield* a.identifiers();\n    }\n}\n\nexport class CMemberAccess {\n    readonly lvalue: boolean;\n    readonly structUnion: CStruct | CUnion;\n    readonly type: CType;\n\n    /** transform `e.member` to `(&e)->member` before calling */\n    constructor(readonly node: ParseNode, readonly body: CExpression, readonly member: string) {\n        const bodyType = body.type instanceof CPointer ? (body.type.original ?? body.type) : body.type; // no pointer gen\n        const pointerType = checks.asPointer(body.node, bodyType);\n        this.structUnion = checks.asStructOrUnion(body.node, pointerType.type);\n\n        const type = this.structUnion.memberType(member);\n        this.type = type.pointerGeneration;\n        this.lvalue = !(this.type instanceof CArray);\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.body.identifiers();\n    }\n}\n\nexport class CIncrDecr {\n    readonly lvalue = false;\n    readonly type: CArithmetic | CPointer;\n\n    constructor(readonly node: ParseNode, readonly body: CExpression,\n                readonly op: \"++\" | \"--\", readonly pos: \"pre\" | \"post\") {\n        checks.checkLvalue(body, true);\n\n        const bodyType = body.type instanceof CPointer ? (body.type.original ?? body.type) : body.type; // no pointer gen\n        this.type = checks.asNonFunctionPointer(body.node, checks.asArithmeticOrPointer(body.node, bodyType));\n        if (this.type instanceof CPointer) checkTypeComplete(this.type.type);\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.body.identifiers();\n    }\n}\n\nexport class CSizeof {\n    readonly lvalue = false;\n    readonly type = CSizeT;\n    readonly body: CType;\n\n    constructor(readonly node: ParseNode, body: CType) {\n        this.body = body instanceof CPointer ? (body.original ?? body) : body; // no pointer gen\n        if (this.body.incomplete || this.body.bytes === 0 || this.body instanceof CFuncType) {\n            throw new checks.ExpressionTypeError(node, \"Complete non-function type\", body.typeName);\n        }\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        // no identifier children\n    }\n}\n\nexport class CAddressOf { // &\n    readonly lvalue = false;\n    readonly type: CPointer;\n    readonly body: CExpression;\n\n    constructor(readonly node: ParseNode, body: CExpression) {\n        const bodyType = body.type instanceof CPointer ? (body.type.original ?? body.type) : body.type; // no pointer gen\n        if (!(body instanceof CIdentifier && bodyType instanceof CFuncType)) checks.checkLvalue(body, true);\n        this.type = new CPointer(node, bodyType);\n\n        if (body instanceof CIdentifier) {\n            // when translating to wasm all variables which have their address taken have to be stored on the shadow stack\n            (body.value as CVariable | CArgument).addressUsed = true;\n        }\n        this.body = body;\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.body.identifiers();\n    }\n}\n\nexport class CDereference { // * or 'indirection'\n    readonly lvalue = true;\n    readonly type: CType;\n\n    constructor(readonly node: ParseNode, readonly body: CExpression) {\n        this.type = checks.asPointer(node, body.type).type.pointerGeneration;\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.body.identifiers();\n    }\n}\n\nexport class CUnaryPlusMinus {\n    readonly lvalue = false;\n    readonly type: CArithmetic;\n    readonly bodyType: CArithmetic;\n\n    constructor(readonly node: ParseNode, readonly body: CExpression, readonly op: \"+\" | \"-\") {\n        this.bodyType = checks.asArithmetic(body.node, body.type);\n        this.type = integerPromotion(this.bodyType);\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.body.identifiers();\n    }\n}\n\nexport class CBitwiseNot {\n    readonly lvalue = false;\n    readonly type: CArithmetic;\n    readonly bodyType: CArithmetic;\n\n    constructor(readonly node: ParseNode, readonly body: CExpression) {\n        this.bodyType = checks.asInteger(body.node, body.type);\n        this.type = this.bodyType.bytes < CArithmetic.S32.bytes ? CArithmetic.S32 : this.bodyType;\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.body.identifiers();\n    }\n}\n\nexport class CLogicalNot {\n    readonly lvalue = false;\n    readonly type = CArithmetic.S32;\n\n    constructor(readonly node: ParseNode, readonly body: CExpression) {\n        checks.asArithmeticOrPointer(body.node, body.type);\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.body.identifiers();\n    }\n}\n\nexport class CCast {\n    readonly lvalue = false;\n    readonly type: CType;\n\n    constructor(readonly node: ParseNode, type: CType, readonly body: CExpression) {\n        this.type = type.pointerGeneration;\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.body.identifiers();\n    }\n}\n\nexport class CMulDiv {\n    readonly lvalue = false;\n    readonly type: CArithmetic;\n\n    constructor(readonly node: ParseNode, readonly lhs: CExpression, readonly rhs: CExpression, readonly op: \"*\" | \"/\") {\n        this.type = usualArithmeticConversion(\n            checks.asArithmetic(lhs.node, lhs.type),\n            checks.asArithmetic(rhs.node, rhs.type));\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.lhs.identifiers();\n        yield* this.rhs.identifiers();\n    }\n}\n\nexport class CMod {\n    readonly lvalue = false;\n    readonly type: CArithmetic;\n\n    constructor(readonly node: ParseNode, readonly lhs: CExpression, readonly rhs: CExpression) {\n        this.type = usualArithmeticConversion(\n            checks.asInteger(lhs.node, lhs.type),\n            checks.asInteger(rhs.node, rhs.type));\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.lhs.identifiers();\n        yield* this.rhs.identifiers();\n    }\n}\n\n// Array subscript a[b] becomes *(a + b)\nexport class CAddSub {\n    readonly lvalue = false;\n    readonly type: CArithmetic | CPointer;\n\n    constructor(readonly node: ParseNode, readonly lhs: CExpression, readonly rhs: CExpression, readonly op: \"+\" | \"-\") {\n        if (lhs.type instanceof CPointer && rhs.type instanceof CPointer) { // both pointers\n            if (!lhs.type.equals(rhs.type)) throw new checks.ExpressionTypeError(node, \"both pointers to have the same type\");\n            checkTypeComplete(lhs.type.type);\n            this.type = checks.asNonFunctionPointer(lhs.node, lhs.type);\n            checks.asNonFunctionPointer(rhs.node, rhs.type);\n\n        } else if (lhs.type instanceof CPointer) { // one pointer, one integral\n            checks.asInteger(rhs.node, rhs.type);\n            checkTypeComplete(lhs.type.type);\n            this.type = checks.asNonFunctionPointer(lhs.node, lhs.type);\n\n        } else if (rhs.type instanceof CPointer) { // one pointer, one integral\n            checks.asInteger(lhs.node, lhs.type);\n            checkTypeComplete(rhs.type.type);\n            this.type = checks.asNonFunctionPointer(rhs.node, rhs.type);\n\n        } else {\n            this.type = usualArithmeticConversion(checks.asArithmetic(lhs.node, lhs.type), checks.asArithmetic(rhs.node, rhs.type));\n        }\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.lhs.identifiers();\n        yield* this.rhs.identifiers();\n    }\n}\n\nexport class CShift {\n    readonly lvalue = false;\n    readonly type: CArithmetic;\n\n    constructor(readonly node: ParseNode, readonly lhs: CExpression, readonly rhs: CExpression, readonly dir: \"left\" | \"right\") {\n        this.type = integerPromotion(checks.asInteger(lhs.node, lhs.type));\n        checks.asInteger(rhs.node, rhs.type);\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.lhs.identifiers();\n        yield* this.rhs.identifiers();\n    }\n}\n\nexport class CRelational {\n    readonly lvalue = false;\n    readonly type = CArithmetic.BOOL;\n    readonly commonType: CArithmetic;\n\n    constructor(readonly node: ParseNode, readonly lhs: CExpression, readonly rhs: CExpression, readonly op: \"LT\" | \"GT\" | \"LEq\" | \"GEq\") {\n        checks.asArithmeticOrPointer(lhs.node, lhs.type);\n        checks.asArithmeticOrPointer(rhs.node, rhs.type);\n\n        this.commonType = usualArithmeticConversion(\n            lhs.type instanceof CArithmetic ? lhs.type : CSizeT,\n            rhs.type instanceof CArithmetic ? rhs.type : CSizeT);\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.lhs.identifiers();\n        yield* this.rhs.identifiers();\n    }\n}\n\nexport class CEquality {\n    readonly lvalue = false;\n    readonly type = CArithmetic.BOOL;\n    readonly commonType: CArithmetic;\n\n    constructor(readonly node: ParseNode, readonly lhs: CExpression, readonly rhs: CExpression, readonly op: \"==\" | \"!=\") {\n        checks.asArithmeticOrPointer(lhs.node, lhs.type);\n        checks.asArithmeticOrPointer(rhs.node, rhs.type);\n\n        this.commonType = usualArithmeticConversion(\n            lhs.type instanceof CArithmetic ? lhs.type : CSizeT,\n            rhs.type instanceof CArithmetic ? rhs.type : CSizeT);\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.lhs.identifiers();\n        yield* this.rhs.identifiers();\n    }\n}\n\nexport class CBitwiseAndOr {\n    readonly lvalue = false;\n    readonly type: CArithmetic;\n\n    constructor(readonly node: ParseNode, readonly lhs: CExpression, readonly rhs: CExpression, readonly op: \"and\" | \"or\" | \"xor\") {\n        this.type = usualArithmeticConversion(\n            checks.asInteger(lhs.node, lhs.type),\n            checks.asInteger(rhs.node, rhs.type));\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.lhs.identifiers();\n        yield* this.rhs.identifiers();\n    }\n}\n\nexport class CLogicalAndOr {\n    readonly lvalue = false;\n    readonly type = CArithmetic.BOOL;\n\n    constructor(readonly node: ParseNode, readonly lhs: CExpression, readonly rhs: CExpression, readonly op: \"and\" | \"or\") {\n        checks.asArithmeticOrPointer(lhs.node, lhs.type);\n        checks.asArithmeticOrPointer(rhs.node, rhs.type);\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.lhs.identifiers();\n        yield* this.rhs.identifiers();\n    }\n}\n\nexport class CConditional { // [test] ? [trueValue] : [falseValue]\n    readonly lvalue = false;\n    readonly type: CType;\n\n    constructor(readonly node: ParseNode, readonly test: CExpression, readonly trueValue: CExpression, readonly falseValue: CExpression) {\n        checks.asArithmeticOrPointer(test.node, test.type);\n\n        if (trueValue.type instanceof CArithmetic && falseValue.type instanceof CArithmetic) {\n            this.type = usualArithmeticConversion(trueValue.type, falseValue.type);\n            return;\n        } else if (trueValue.type.equals(falseValue.type)) {\n            this.type = trueValue.type;\n            return;\n        } else if (trueValue.type instanceof CPointer && falseValue.type instanceof CPointer) {\n            // both pointers - check if either is void* pointer\n            if (trueValue.type.type instanceof CVoid) {\n                this.type = falseValue.type;\n                return;\n            } else if (falseValue.type.type instanceof CVoid) {\n                this.type = trueValue.type;\n                return;\n            }\n        } else if (trueValue.type instanceof CPointer || falseValue.type instanceof CPointer) {\n            // one pointer - check if other null constant\n            const otherValue = trueValue.type instanceof CPointer ? falseValue : trueValue;\n            // eslint-disable-next-line eqeqeq\n            if (otherValue instanceof CConstant && otherValue.value == 0) {\n                this.type = trueValue.type instanceof CPointer ? trueValue.type : falseValue.type;\n                return;\n            }\n        }\n        throw new checks.ExpressionTypeError(node, \"both conditional branches to have the same type\", \"different types\");\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.test.identifiers();\n        yield* this.trueValue.identifiers();\n        yield* this.falseValue.identifiers();\n    }\n}\n\nexport class CAssignment {\n    readonly lvalue = false;\n    readonly type: CType;\n\n    // rhs may require casting\n    constructor(readonly node: ParseNode, readonly lhs: CExpression, readonly rhs: CExpression | CInitializer,\n                readonly assignmentType: pt.AssignmentType, readonly initialAssignment: boolean = false) {\n        // check lvalue\n        const lhsType = lhs.type instanceof CPointer ? (lhs.type.original ?? lhs.type) : lhs.type; // no pointer gen\n        checks.checkLvalue(lhs, true);\n        if ((lhsType instanceof CArray && !initialAssignment) || lhsType instanceof CFuncType || lhs.type.incomplete) {\n            throw new checks.ExpressionTypeError(lhs.node, \"assignable type\");\n        } else if (getQualifier(lhsType) === \"const\" && !initialAssignment) {\n            throw new checks.ExpressionTypeError(lhs.node, \"non-const location\");\n        } else if ((lhsType instanceof CStruct || lhsType instanceof CUnion) && lhsType.hasConstMember() && !initialAssignment) {\n            throw new checks.ExpressionTypeError(lhs.node, \"structure without a const member\");\n        }\n        this.type = lhsType.pointerGeneration;\n\n        // check assignment types are valid\n        if (assignmentType) {\n            if (rhs instanceof CInitializer) {\n                throw new checks.ExpressionTypeError(node,\"simple assignments with structure initializers\");\n            }\n            let rhsType = rhs.type;\n\n            // typecheck `lhs op= rhs` as `lhs = lhs op rhs`\n            // LHS only evaluated once so can't just be transformed: see `a[i++] += 1;`\n            switch (assignmentType) {\n            case \"mul\": rhsType = new CMulDiv(node, lhs, rhs, \"*\").type; break;\n            case \"div\": rhsType = new CMulDiv(node, lhs, rhs, \"/\").type; break;\n            case \"mod\": rhsType = new CMod(node, lhs, rhs).type; break;\n            case \"add\": rhsType = new CAddSub(node, lhs, rhs, \"+\").type; break;\n            case \"sub\": rhsType = new CAddSub(node, lhs, rhs, \"-\").type; break;\n            case \"leftShift\": rhsType = new CShift(node, lhs, rhs, \"left\").type; break;\n            case \"rightShift\": rhsType = new CShift(node, lhs, rhs, \"right\").type; break;\n            case \"bitwiseAnd\": rhsType = new CBitwiseAndOr(node, lhs, rhs, \"and\").type; break;\n            case \"bitwiseOr\": rhsType = new CBitwiseAndOr(node, lhs, rhs, \"or\").type; break;\n            case \"bitwiseXor\": rhsType = new CBitwiseAndOr(node, lhs, rhs, \"xor\").type; break;\n            default: throw new checks.ExpressionTypeError(node, \"valid assignment type\");\n            }\n            CAssignment._checkAssignmentTypeValid(node, lhsType, rhsType);\n        } else {\n            CAssignment.checkAssignmentValid(node, lhsType, rhs);\n        }\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.lhs.identifiers();\n        yield* this.rhs.identifiers();\n    }\n\n    static checkAssignmentValid(node: ParseNode, varType: CType, value: CExpression | CInitializer): void {\n        // also allow constant 0 to be assigned to a pointer\n        if (varType instanceof CPointer && value instanceof CConstant) {\n            if (value.value === 0n) return;\n        }\n        this._checkAssignmentTypeValid(node, varType, value.type);\n    }\n\n    private static _checkAssignmentTypeValid(node: ParseNode, varType: CType, valueType: CType): void {\n        if (varType.equals(valueType)) return;\n        if (varType instanceof CArithmetic && valueType instanceof CArithmetic) {\n            return; // arithmetic types always assignable\n        }\n        if (varType instanceof CPointer && valueType instanceof CPointer) {\n            // void pointers can be assigned to any pointer and any pointer can be assigned to a void pointer\n            if (varType.type instanceof CVoid || valueType.type instanceof CVoid) return;\n            // allow non-constant pointers to be assigned to constant pointers\n            if (varType.type.equals(valueType.type)) return;\n        }\n        if (varType instanceof CPointer && valueType instanceof CFuncType) {\n            // implicit function pointer conversion\n            if (varType.type.equals(valueType)) return;\n        }\n        if (valueType instanceof CPointer && valueType.original) {\n            // pointer generation\n            if (varType.equals(valueType.original)) return;\n\n            if (varType instanceof CArray && valueType.original instanceof CArray && varType.type.equals(valueType.type)) {\n                // allow assigning smaller arrays to larger ones\n                if ((valueType.original.length ?? 0) < (varType.length ?? 0)) return;\n            }\n        }\n\n        throw new checks.ExpressionTypeError(node, varType.typeName, valueType.typeName);\n    }\n}\n\nexport class CComma {\n    readonly lvalue = false;\n    readonly type: CType;\n\n    constructor(readonly node: ParseNode, readonly lhs: CExpression, readonly rhs: CExpression) {\n        this.type = rhs.type;\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.lhs.identifiers();\n        yield* this.rhs.identifiers();\n    }\n}\n\n/** Special type of expression permitted only in declarations */\nexport class CInitializer {\n    private _type: CType;\n    private _memberTypes: CType[] = [];\n\n    constructor(readonly node: ParseNode, readonly body: (CExpression | CInitializer)[], type?: CType) {\n        // default to a void* array which isn't the true type but lets the array size be used when declaring arrays\n        this._type = type ?? new CArray(undefined, new CPointer(undefined, new CVoid()), body.length);\n    }\n\n    get memberTypes(): ReadonlyArray<CType> {\n        return this._memberTypes;\n    }\n\n    get type(): CType {\n        return this._type;\n    }\n\n    /** Once the initializer is recursively constructed and the declaration's type is known, set the type of the\n     * initializer to the type of the declaration, checking that this initializer is valid for the provided type */\n    set type(value: CType) {\n        this._memberTypes = [];\n\n        if (value instanceof CArray) {\n            if (this.body.length > (value.length ?? Infinity)) {\n                throw new checks.ExpressionTypeError(this.node, `at most ${value.length} elements`, `${this.body.length} elements`);\n            }\n            for (let i = 0; i < this.body.length; i++) {\n                this.body[i] = CInitializer.typeCheck(value.type, this.body[i]);\n                this._memberTypes.push(value.type);\n            }\n\n        } else if (value instanceof CStruct) {\n            if (this.body.length > value.members.length) {\n                throw new checks.ExpressionTypeError(this.node, `at most ${value.members.length} elements`, `${this.body.length} elements`);\n            }\n            for (let i = 0; i < this.body.length; i++) {\n                this.body[i] = CInitializer.typeCheck(value.members[i].type, this.body[i]);\n                this._memberTypes.push(value.members[i].type);\n            }\n\n        } else if (value instanceof CUnion) {\n            if (this.body.length > 1) {\n                throw new checks.ExpressionTypeError(this.node, `one element matching first member in union`, `${this.body.length} elements`);\n            } else if (this.body.length === 1) {\n                this.body[0] = CInitializer.typeCheck(value.members[0].type, this.body[0]);\n                this._memberTypes.push(value.members[0].type);\n            }\n\n        } else {\n            throw new checks.ExpressionTypeError(this.node, \"Invalid type for initializer\");\n        }\n        this._type = value;\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        for (const c of this.body) yield* c.identifiers();\n    }\n\n    private static typeCheck(desiredType: CType, expr: CExpression | CInitializer): CExpression | CInitializer {\n        if (expr instanceof CInitializer) {\n            expr.type = desiredType;\n        } else {\n            CAssignment.checkAssignmentValid(expr.node, desiredType, expr);\n\n            if (expr instanceof CConstant && desiredType instanceof CArithmetic && expr.type !== desiredType) {\n                expr = expr.changeType(desiredType);\n            }\n        }\n        return expr;\n    }\n}\n","import {CError} from \"../c_error\";\nimport type {ParseNode} from \"../parsing\";\nimport type {CDeclaration} from \"./declarations\";\nimport {CFuncDeclaration, CFuncDefinition, CVarDeclaration, CVarDefinition} from \"./declarations\";\nimport type {CLabelledStatement} from \"./statements\";\nimport type {CCompound, CType} from \"./types\";\n\n/**\n * Represents a scope storing identifiers (variables & functions) and tags (struct, union & enum names) in the IR.\n * Each one has a parent scope excluding the base scope for the translation unit.\n *\n * e.g. base scope (function declarations) <- function scope (contains parameters) <- compound statement scope (fn locals).\n *\n * If a tag or identifier isn't found in the current scope, parents are checked.\n */\nexport class Scope {\n    private tags = new Map<string, CCompound>(); // names of structs, unions & enums\n    private identifiers = new Map<string, CDeclaration>(); // names of variables and functions\n    private typedefs = new Map<string, CType>();\n    labelledStatement?: CLabelledStatement;\n\n    constructor(readonly node?: ParseNode,\n                readonly parent?: Scope,\n                readonly func: CFuncDefinition | undefined = parent?.func) {\n    }\n\n    private _getTag(tag: string): CCompound | undefined {\n        // perform recursive lookup in parents if not found\n        return this.tags.get(tag) ?? this.parent?._getTag(tag);\n    }\n\n    lookupTag<T extends CCompound>(tag: string, wantedType?: { new(...args: any[]): T }, node?: ParseNode): T | undefined {\n        const result = this._getTag(tag);\n        if (wantedType && result && wantedType.prototype !== Object.getPrototypeOf(result)) {\n            throw new ScopeError(\"`\" + tag + \"` was already declared as a \" + result.typeName, result.node, node);\n        }\n        return result as T | undefined;\n    }\n\n    addTag(value: CCompound): void {\n        if (!value.name) throw new Error(\"Cannot add nameless compound type to scope\"); // shouldn't happen\n        if (this._getTag(value.name)) throw new ScopeError(\"Compound type `\" + value.name + \"` is already defined!\", value.node);\n        this.tags.set(value.name, value);\n    }\n\n    private _getId(name: string): CDeclaration | undefined {\n        return this.identifiers.get(name) ?? this.parent?._getId(name);\n    }\n\n    lookupIdentifier(name: string, node?: ParseNode): CDeclaration {\n        const result = this._getId(name);\n        if (!result) {\n            throw new ScopeError(\"Failed to find `\" + name + \"`\", node);\n        }\n        return result;\n    }\n\n    addIdentifier(value: CDeclaration): void {\n        const existing = this.identifiers.get(value.name); // allowing redefining identifiers defined in parent scopes\n        if (existing) {\n            if (existing.type.equals(value.type) && existing instanceof CFuncDeclaration && value instanceof CFuncDefinition) {\n                // allow replacement of function declaration with definition\n                if (existing.linkage !== \"external\" && value.linkage === \"external\") {\n                    // linkage inherited from first declaration\n                    value.linkage = existing.linkage;\n                }\n                existing.definition = value;\n            } else if (existing.type.equals(value.type) && value instanceof CFuncDeclaration) {\n                // allow functions to be redeclared (but don't override instance in scope)\n                if (existing instanceof CFuncDeclaration) existing.fnImport ||= value.fnImport;\n                return;\n            } else if (existing.type.equals(value.type) && existing instanceof CVarDeclaration && value instanceof CVarDefinition) {\n                // allow replacement of variable declaration with definition\n                if (existing.linkage !== \"external\" && existing.linkage !== value.linkage) {\n                    // check linkage is the same\n                    throw new ScopeError(\"Variable `\" + value.name + \"` is already defined with \" + existing.linkage + \" linkage\", existing.node, value.node);\n                }\n                existing.definition = value;\n            } else if (existing.type.equals(value.type) && value instanceof CVarDeclaration) {\n                // allow variables to be redeclared (but don't override instance in scope)\n                if (existing.linkage !== \"external\" && existing.linkage !== value.linkage) {\n                    // check linkage is the same\n                    throw new ScopeError(\"Variable `\" + value.name + \"` is already defined with \" + existing.linkage + \" linkage\", existing.node, value.node);\n                }\n                return;\n            } else {\n                throw new ScopeError(\"Identifier `\" + value.name + \"` is already defined in this scope!\", existing.node, value.node);\n            }\n        }\n        this.identifiers.set(value.name, value);\n    }\n\n    get declarations(): ReadonlyArray<CDeclaration> {\n        return [...this.identifiers.values()];\n    }\n\n    private _getTypedef(id: string): CType | undefined {\n        // perform recursive lookup in parents if not found\n        return this.typedefs.get(id) ?? this.parent?._getTypedef(id);\n    }\n\n    lookupTypedef(id: string, node?: ParseNode): CType {\n        const result = this._getTypedef(id);\n        if (result === undefined) {\n            throw new ScopeError(\"typedef `\" + id + \"` not found in scope\", node);\n        }\n        return result;\n    }\n\n    addTypedef(id: string, type: CType, node?: ParseNode): void {\n        const existing = this._getTypedef(id);\n        if (existing) {\n            if (existing.equals(type)) return;\n            throw new ScopeError(\"typedef already defined with a different type\", node);\n        }\n        this.typedefs.set(id, type);\n    }\n}\n\nclass ScopeError extends CError {\n    name = \"ScopeError\";\n}\n","import type * as pt from \"../parsing/parsetree\";\nimport {CFuncDefinition} from \"./declarations\";\nimport {CExpression, CAssignment, CValue} from \"./expressions\";\nimport {Scope} from \"./scope\";\nimport {ExpressionTypeError, asArithmeticOrPointer} from \"./type_checking\";\n\n// classes to represent the various C statements in the IR\nexport type CStatement =\n    CCompoundStatement | CExpressionStatement | CNop |\n    CIf | CForLoop | CWhileLoop | CDoLoop | CSwitch |\n    CGoto | CContinue | CBreak | CReturn;\n\nexport class CCompoundStatement {\n    readonly scope: Scope;\n    readonly statements: CStatement[] = [];\n\n    constructor(readonly node: pt.ParseNode, readonly parent: CStatement | CFuncDefinition) {\n        this.scope = new Scope(node, parent.scope, parent instanceof CFuncDefinition ? parent : undefined);\n    }\n}\n\nexport class CExpressionStatement {\n    constructor(readonly node: pt.ParseNode, readonly expression: CExpression, readonly parent: CStatement) {\n    }\n\n    get scope(): Scope {\n        return this.parent.scope;\n    }\n}\n\nexport class CNop {\n    constructor(readonly node: pt.NoOp, readonly parent: CStatement) {\n    }\n\n    get scope(): Scope {\n        return this.parent.scope;\n    }\n}\n\nexport class CIf {\n    ifBody?: CStatement;\n    elseBody?: CStatement;\n\n    constructor(readonly node: pt.IfStatement, readonly test: CExpression, readonly parent: CStatement) {\n        asArithmeticOrPointer(test.node, test.type);\n    }\n\n    get scope(): Scope {\n        return this.parent.scope;\n    }\n}\n\nexport class CForLoop {\n    init?: CExpressionStatement | CExpressionStatement[] | CNop;\n    test?: CExpressionStatement | CNop;\n    update?: CExpression;\n    body?: CStatement;\n\n    readonly scope: Scope; // own scope for init variable\n\n    constructor(readonly node: pt.ForLoop, readonly parent: CStatement) {\n        this.scope = new Scope(node, parent.scope);\n    }\n}\n\nexport class CWhileLoop {\n    body?: CStatement;\n\n    constructor(readonly node: pt.WhileLoop, readonly test: CExpression, readonly parent: CStatement) {\n        asArithmeticOrPointer(test.node, test.type);\n    }\n\n    get scope(): Scope {\n        return this.parent.scope;\n    }\n}\n\nexport class CDoLoop {\n    body?: CStatement;\n\n    constructor(readonly node: pt.DoWhileLoop, readonly test: CExpression, readonly parent: CStatement) {\n        asArithmeticOrPointer(test.node, test.type);\n    }\n\n    get scope(): Scope {\n        return this.parent.scope;\n    }\n}\n\nexport class CGoto {\n    constructor(readonly node: pt.GotoStatement, readonly target: CLabelledStatement, readonly parent: CStatement) {\n    }\n\n    get scope(): Scope {\n        return this.parent.scope;\n    }\n}\n\nexport class CSwitch {\n    children: {cases: CValue[], body: CCompoundStatement, default: boolean}[] = [];\n\n    constructor(readonly node: pt.SwitchStatement, readonly expression: CExpression, readonly parent: CStatement) {\n    }\n\n    get scope(): Scope {\n        return this.parent.scope;\n    }\n}\n\nexport class CContinue {\n    constructor(readonly node: pt.ContinueStatement,\n                readonly loop: CForLoop | CWhileLoop | CDoLoop,\n                readonly parent: CStatement) {\n    }\n\n    get scope(): Scope {\n        return this.parent.scope;\n    }\n}\n\nexport class CBreak {\n    constructor(readonly node: pt.BreakStatement,\n                readonly target: CForLoop | CWhileLoop | CDoLoop | CSwitch,\n                readonly parent: CStatement) {\n    }\n\n    get scope(): Scope {\n        return this.parent.scope;\n    }\n}\n\nexport class CReturn {\n    constructor(readonly node: pt.ReturnStatement,\n                readonly func: CFuncDefinition,\n                public value: CExpression | undefined,\n                readonly parent: CStatement) {\n\n        if (value === undefined) {\n            if (func.type.returnType.bytes > 0) {\n                // function return type is not void but a value was not provided\n                throw new ExpressionTypeError(node, \"`return [expression]`\", \"`return;`\");\n            }\n        } else {\n            if (!func.type.returnType.equals(value.type)) {\n                // check provided return value matches the function's return type\n                CAssignment.checkAssignmentValid(node, func.type.returnType, value);\n            }\n        }\n    }\n\n    get scope(): Scope {\n        return this.parent.scope;\n    }\n}\n\n// not a CStatement, used to store labelled statements in Scopes\nexport class CLabelledStatement {\n    body?: CStatement;\n\n    constructor(readonly node: pt.Statement, readonly label: string) {\n    }\n}\n","import type {FunctionDefinition, ParseNode} from \"../parsing/parsetree\";\nimport type {CInitializer, CExpression} from \"./expressions\";\nimport type {Scope} from \"./scope\";\nimport {CCompoundStatement} from \"./statements\";\nimport type {CFuncType, CNotFuncType, CQualifiedType} from \"./types\";\n\n// classes to represent all the different types of declarations in the IR\nexport type CDeclaration = CVariable | CFunction;\nexport type CVariable = CVarDeclaration | CVarDefinition | CArgument;\nexport type CFunction = CFuncDefinition | CFuncDeclaration;\n\nexport class CVarDeclaration {\n    readonly declType = \"variable\";\n    _addressUsed: boolean = false;\n    _definition?: CVarDefinition;\n\n    constructor(readonly node: ParseNode,\n                readonly name: string,\n                readonly type: CQualifiedType<CNotFuncType>,\n                readonly storage: \"static\" | \"local\",\n                readonly linkage: \"none\" | \"internal\" | \"external\") {\n    }\n\n    set addressUsed(b: boolean) {\n        if (this._definition) this._definition.addressUsed ||= b;\n        else this._addressUsed ||= b;\n    }\n\n    get addressUsed(): boolean {\n        return this._definition ? this._definition.addressUsed : this._addressUsed;\n    }\n\n    set definition(v: CVarDefinition | undefined) {\n        if (v === undefined) throw new Error(\"Cannot set definition to undefined\");\n        v.addressUsed ||= this._addressUsed;\n        this._definition = v;\n    }\n\n    get definition(): CVarDefinition | undefined {\n        return this._definition;\n    }\n}\n\nexport class CVarDefinition {\n    readonly declType = \"variable\";\n    staticValue?: CExpression | CInitializer;\n    addressUsed: boolean = false;\n    readonly dependencies = new Map<CDeclaration, boolean>(); // direct dependencies of initializer only\n\n    constructor(readonly node: ParseNode,\n                readonly name: string,\n                readonly type: CQualifiedType<CNotFuncType>,\n                readonly storage: \"static\" | \"local\",\n                public linkage: \"none\" | \"internal\" | \"external\") {\n    }\n}\n\nexport class CArgument {\n    readonly declType = \"variable\";\n    readonly storage = \"argument\";\n    readonly linkage = \"none\";\n    addressUsed: boolean = false;\n\n    constructor(readonly node: ParseNode,\n                readonly name: string,\n                readonly type: CQualifiedType<CNotFuncType>,\n                readonly index: number) {\n    }\n}\n\nexport class CFuncDeclaration {\n    readonly declType = \"function\";\n    definition?: CFuncDefinition | CFuncImport;\n\n    constructor(readonly node: ParseNode,\n                readonly name: string,\n                readonly type: CQualifiedType<CFuncType>,\n                readonly linkage: \"none\" | \"internal\" | \"external\",\n                public fnImport: boolean = false) {\n    }\n}\n\nexport class CFuncImport {\n    readonly declType = \"import\";\n    readonly node: ParseNode;\n\n    constructor(readonly declaration: CFuncDeclaration) {\n        this.node = declaration.node;\n    }\n\n    getFunction(): CFuncDeclaration {\n        return this.declaration;\n    }\n}\n\nexport class CFuncDefinition {\n    readonly declType = \"function\";\n    readonly body: CCompoundStatement;\n    readonly dependencies = new Map<CDeclaration, boolean>(); // direct dependencies only\n    readonly hints: {inline: boolean} = {inline: false};\n\n    constructor(readonly node: FunctionDefinition,\n                readonly name: string,\n                readonly type: CQualifiedType<CFuncType>,\n                public linkage: \"none\" | \"internal\" | \"external\",\n                readonly translationUnit: Scope) {\n        this.body = new CCompoundStatement(node.body, this);\n    }\n\n    get scope(): Scope {\n        return this.translationUnit;\n    }\n\n    equals(t: object): boolean {\n        return t === this;\n    }\n\n    getFunction(): CFuncDefinition {\n        return this;\n    }\n}\n","import {CVarDefinition} from \"../declarations\";\nimport {CExpression, CConstant, CIdentifier, CSizeof, CBitwiseNot, CLogicalNot, CCast, CMulDiv, CMod, CAddSub, CShift, CRelational, CEquality, CBitwiseAndOr, CLogicalAndOr, CConditional, CUnaryPlusMinus, CValue, CInitializer} from \"../expressions\";\nimport {ExpressionTypeError} from \"../type_checking\";\nimport {CArithmetic, CSizeT, CPointer} from \"../types\";\n\ntype ExtraFn = (e: CExpression, evalExpr: (e: CExpression) => CValue | undefined, fail: (e: CExpression) => undefined) => CValue | undefined;\n\nconst CONSTANT = Symbol(\"constant\");\n\nexport function constExpression(e: CExpression, extra?: ExtraFn): CValue {\n    const v = evalExpression(e, extra);\n    if (v) return v;\n    throw new ExpressionTypeError(e.node, \"constant expression\");\n}\n\nexport function constInteger(e: CExpression, extra?: ExtraFn): CValue & {readonly value: bigint} {\n    const v = evalInteger(e, extra);\n    if (v) return v;\n    throw new ExpressionTypeError(e.node, \"constant integer expression\");\n}\n\nfunction fail(e: CExpression): undefined {\n    (e as object as {[CONSTANT]: boolean})[CONSTANT] = false;\n    return undefined;\n}\n\nexport function evalExpression(e: CExpression, extra?: ExtraFn): CValue | undefined {\n    if (!((e as object as { [CONSTANT]: boolean })[CONSTANT] ?? true)) {\n        return undefined; // cache on expr if failed previously to speed up flags.generation_try_constant_expr\n    } else if (e instanceof CConstant) {\n        return {value: e.value, type: e.type};\n    } else if (e instanceof CIdentifier && e.value instanceof CVarDefinition && e.value.type.qualifier === \"const\" && e.value.staticValue instanceof CConstant) {\n        return evalExpression(e.value.staticValue, extra);\n\n    } else if (e instanceof CSizeof) {\n        return normalizeType({value: e.body.bytes, type: CSizeT});\n\n    } else if (e instanceof CUnaryPlusMinus) {\n        const v = evalExpression(e.body, extra);\n        if (!v) return fail(e);\n        return e.op === \"+\" ? v : {value: -v.value, type: e.type};\n\n    } else if (e instanceof CBitwiseNot) {\n        const v = evalInteger(e.body, extra);\n        if (!v) return fail(e);\n        return normalizeType({value: ~v.value, type: v.type});\n\n    } else if (e instanceof CLogicalNot) {\n        const v = evalExpression(e.body, extra);\n        if (!v) return fail(e);\n        // eslint-disable-next-line eqeqeq\n        return {value: v.value == 0 ? 1n : 0n, type: CArithmetic.S32};\n\n    } else if (e instanceof CCast && (e.type instanceof CArithmetic || e.type instanceof CPointer)) {\n        const v = evalExpression(e.body, extra);\n        if (!v) return fail(e);\n        return normalizeType({value: v.value, type: e.type});\n\n    } else if (e instanceof CMulDiv) {\n        const lhs = evalExpression(e.lhs, extra), rhs = evalExpression(e.rhs, extra);\n        if (!lhs || !rhs) return fail(e);\n        if (e.op === \"*\") {\n            if (e.type.type === \"float\") {\n                return {value: Number(lhs.value) * Number(rhs.value), type: e.type};\n            }\n            return normalizeType({value: BigInt(lhs.value) * BigInt(rhs.value), type: e.type});\n\n            // eslint-disable-next-line eqeqeq\n        } else if (rhs.value != 0) {\n            if (e.type.type === \"float\") {\n                return {value: Number(lhs.value) / Number(rhs.value), type: e.type};\n            }\n            return normalizeType({value: BigInt(lhs.value) / BigInt(rhs.value), type: e.type});\n        }\n\n    } else if (e instanceof CMod) {\n        const lhs = evalInteger(e.lhs, extra), rhs = evalInteger(e.rhs, extra);\n        if (!lhs || !rhs || rhs.value === 0n) return fail(e);\n        return normalizeType({value: lhs.value % rhs.value, type: e.type});\n\n    } else if (e instanceof CAddSub && e.type instanceof CArithmetic) {\n        const lhs = evalExpression(e.lhs, extra), rhs = evalExpression(e.rhs, extra);\n        if (!lhs || !rhs) return fail(e);\n        if (e.op === \"+\") {\n            if (e.type.type === \"float\") {\n                return {value: Number(lhs.value) + Number(rhs.value), type: e.type};\n            }\n            return normalizeType({value: BigInt(lhs.value) + BigInt(rhs.value), type: e.type});\n        } else {\n            if (e.type.type === \"float\") {\n                return {value: Number(lhs.value) - Number(rhs.value), type: e.type};\n            }\n            return normalizeType({value: BigInt(lhs.value) - BigInt(rhs.value), type: e.type});\n        }\n\n    } else if (e instanceof CShift) {\n        const lhs = evalInteger(e.lhs, extra), rhs = evalInteger(e.rhs, extra);\n        if (!lhs || !rhs) return fail(e);\n        if (e.dir === \"left\") {\n            return normalizeType({value: lhs.value << rhs.value, type: e.type});\n        }\n        return normalizeType({value: lhs.value >> rhs.value, type: e.type});\n\n    } else if (e instanceof CRelational) {\n        const lhs = evalExpression(e.lhs, extra), rhs = evalExpression(e.rhs, extra);\n        if (!lhs || !rhs) return fail(e);\n        if (e.op === \"LT\") {\n            return {value: lhs.value < rhs.value ? 1n : 0n, type: CArithmetic.S32};\n        } else if (e.op === \"GT\") {\n            return {value: lhs.value > rhs.value ? 1n : 0n, type: CArithmetic.S32};\n        } else if (e.op === \"LEq\") {\n            return {value: lhs.value <= rhs.value ? 1n : 0n, type: CArithmetic.S32};\n        } else {\n            return {value: lhs.value >= rhs.value ? 1n : 0n, type: CArithmetic.S32};\n        }\n\n    } else if (e instanceof CEquality) {\n        const lhs = evalExpression(e.lhs, extra), rhs = evalExpression(e.rhs, extra);\n        if (!lhs || !rhs) return fail(e);\n        if (e.op === \"==\") {\n            // eslint-disable-next-line eqeqeq\n            return {value: lhs.value == rhs.value ? 1n : 0n, type: CArithmetic.S32};\n        } else {\n            // eslint-disable-next-line eqeqeq\n            return {value: lhs.value != rhs.value ? 1n : 0n, type: CArithmetic.S32};\n        }\n\n    } else if (e instanceof CBitwiseAndOr) {\n        const lhs = evalInteger(e.lhs, extra), rhs = evalInteger(e.rhs, extra);\n        if (!lhs || !rhs) return fail(e);\n        if (e.op === \"and\") {\n            return normalizeType({value: lhs.value & rhs.value, type: e.type});\n        } else if (e.op === \"or\") {\n            return normalizeType({value: lhs.value | rhs.value, type: e.type});\n        } else {\n            return normalizeType({value: lhs.value ^ rhs.value, type: e.type});\n        }\n\n    } else if (e instanceof CLogicalAndOr) {\n        const lhs = evalExpression(e.lhs, extra);\n        if (!lhs) return fail(e);\n        if (e.op === \"and\") {\n            // eslint-disable-next-line eqeqeq\n            if (lhs.value != 0) {\n                const rhs = evalExpression(e.rhs, extra);\n                if (!rhs) return fail(e);\n                // eslint-disable-next-line eqeqeq\n                if (rhs.value != 0) return {value: 1n, type: CArithmetic.S32};\n            }\n            return {value: 0n, type: CArithmetic.S32};\n        } else {\n            // eslint-disable-next-line eqeqeq\n            if (lhs.value != 0) return {value: 1n, type: CArithmetic.S32};\n            const rhs = evalExpression(e.rhs, extra);\n            if (!rhs) return fail(e);\n            // eslint-disable-next-line eqeqeq\n            if (rhs.value != 0) return {value: 1n, type: CArithmetic.S32};\n            return {value: 0n, type: CArithmetic.S32};\n        }\n\n    } else if (e instanceof CConditional && (e.type instanceof CArithmetic || e.type instanceof CPointer)) {\n        const test = evalExpression(e.test, extra);\n        if (!test) return fail(e);\n        let value: CValue | undefined;\n        // eslint-disable-next-line eqeqeq\n        if (test.value != 0) {\n            value = evalExpression(e.trueValue, extra);\n        } else {\n            value = evalExpression(e.falseValue, extra);\n        }\n        if (!value) return fail(e);\n        return normalizeType({value: value.value, type: e.type});\n\n    }\n\n    // for adding addressof support etc for static initializers\n    if (extra !== undefined) {\n        const v = extra(e, (e2) => evalExpression(e2, extra), fail);\n        if (v) return v;\n    }\n\n    fail(e);\n}\n\nexport function evalInteger(e: CExpression, extra?: ExtraFn): undefined | CValue & {readonly value: bigint} {\n    const v = evalExpression(e, extra);\n    if (v?.type instanceof CArithmetic && v.type.type !== \"float\") return {value: BigInt(v.value), type: v.type};\n    return undefined;\n}\n\nfunction normalizeType(v: CValue): CValue {\n    if (v.type instanceof CArithmetic) {\n        if (CArithmetic.BOOL.equals(v.type)) {\n            // eslint-disable-next-line eqeqeq\n            return {value: v.value == 0 ? 0n : 1n, type: CArithmetic.BOOL};\n        } else if (v.type.type === \"float\") {\n            return {value: typeof v.value === \"number\" ? v.value : Number(v.value), type: v.type};\n        } else {\n            let value: bigint;\n            if (typeof v.value === \"number\") {\n                // need to emulate runtime behaviour - i.e. the use of the trunc_sat instructions\n                if (isNaN(v.value)) {\n                    value = 0n;\n                } else if (v.value > v.type.maxValue) {\n                    value = BigInt(v.type.maxValue);\n                } else if (v.value < v.type.minValue) {\n                    value = BigInt(v.type.minValue);\n                } else {\n                    value = BigInt(Math.trunc(v.value));\n                }\n            } else {\n                value = v.value;\n            }\n\n            const bitmask = 2n ** BigInt(8 * v.type.bytes) - 1n;\n            if (v.type.type === \"unsigned\") {\n                value &= bitmask;\n            } else { // signed\n                const minValue = BigInt(v.type.minValue);\n                value = ((value - minValue) & bitmask) + minValue;\n            }\n\n            return {value, type: v.type};\n        }\n    } else { // instanceof CPointer\n        // normalize as if U32\n        const value = normalizeType({value: v.value, type: CArithmetic.U32}).value;\n        return {value: value, type: v.type};\n    }\n}\n\nexport const normalizeValueType = normalizeType;\n","import {CError} from \"../c_error\";\nimport type {ParseNode} from \"../parsing\";\nimport type {WFnGenerator} from \"./generator\";\n\nexport class GenError extends CError {\n    name = \"GenerationError\";\n\n    constructor(message: string, ctx?: WFnGenerator, node?: ParseNode) {\n        super(ctx !== undefined ? `In function '${ctx.fnName}': ${message}` : message, node);\n    }\n}\n","import {ParseNode} from \"../parsing\";\nimport {CConstant, CInitializer, CStringLiteral, CExpression, CValue, CCast, CAddressOf, CIdentifier, CAddSub, CDereference} from \"../ir/expressions\";\nimport {constExpression, normalizeValueType} from \"../ir/transform/constant_expressions\";\nimport {CArithmetic, CArray, CUnion, CStruct, CSizeT, CPointer, CType} from \"../ir/types\";\nimport {byte} from \"../wasm/base_types\";\nimport {GenError} from \"./gen_error\";\nimport {WGenerator} from \"./generator\";\nimport {getStaticAddress} from \"./storage\";\n\nexport function staticInitializer(ctx: WGenerator, init: CExpression | CInitializer, targetType?: CType): byte[] {\n    if (init instanceof CInitializer) {\n        if (targetType && !init.type.equals(targetType)) throw new GenError(\"Static initializer type mismatch\", undefined, init.node);\n        return initializer(ctx, init);\n    } else if (init instanceof CStringLiteral && targetType instanceof CPointer) {\n        // string literal being used as pointer\n        return stringLiteralPtr(ctx, init);\n    } else if (init instanceof CStringLiteral) {\n        // string literal being used as array\n        return stringLiteral(init);\n    } else {\n        if (targetType && !init.type.equals(targetType)) init = new CCast(init.node, targetType, init);\n        const value = constExpression(init, (e: CExpression, evalExpr, fail) => {\n            if (e instanceof CAddressOf && e.body instanceof CIdentifier) {\n                let addr: number | bigint | undefined;\n                if (e.body.value.declType === \"variable\") {\n                    addr = getStaticAddress(e.body.value);\n                } else {\n                    addr = ctx.indirectIndex(e.body.value);\n                }\n                if (addr !== undefined) return normalizeValueType({value: addr, type: e.type});\n\n            } else if (e instanceof CAddressOf && e.body instanceof CDereference) { // &x[3] turns into &*(x + 3)\n                const v = evalExpr(e.body.body);\n                if (!v) return fail(e);\n                return normalizeValueType({value: v.value, type: e.type});\n\n            } else if (e instanceof CIdentifier && e.value.declType === \"function\") { // implicit function to pointer conversion\n                const addr = ctx.indirectIndex(e.value);\n                return normalizeValueType({value: addr, type: new CPointer(e.node, e.type)});\n\n            } else if (e instanceof CIdentifier) { // implicit array to pointer conversion\n                const addr = getStaticAddress(e.value);\n                if (addr !== undefined) return normalizeValueType({value: addr, type: new CPointer(e.node, e.type)});\n\n            } else if (e instanceof CStringLiteral) {\n                // allocate a new string literal and return pointer\n                const addr = ctx.nextStaticAddr; // chars 1 byte aligned\n                const stringBytes = stringLiteral(e);\n                ctx.nextStaticAddr += stringBytes.length;\n                ctx.module.dataSegment(addr, stringBytes);\n                return normalizeValueType({value: addr, type: e.type});\n\n            } else if (e instanceof CAddSub && e.type instanceof CPointer) { // pointer arithmetic\n                const lhs = evalExpr(e.lhs), rhs = evalExpr(e.rhs);\n                if (!lhs || !rhs) return fail(e);\n                const lhsValue = lhs.type instanceof CPointer ? BigInt(lhs.value) : BigInt(e.type.type.bytes) * BigInt(lhs.value);\n                const rhsValue = rhs.type instanceof CPointer ? BigInt(rhs.value) : BigInt(e.type.type.bytes) * BigInt(rhs.value);\n                return normalizeValueType({value: lhsValue + rhsValue, type: e.type});\n            }\n        });\n        return constant(value, init.node);\n    }\n}\n\nfunction encode(bytes: number, method: (d: DataView) => void): byte[] {\n    const buffer = new ArrayBuffer(bytes);\n    method(new DataView(buffer));\n    return [...new Uint8Array(buffer)] as byte[];\n}\n\nfunction constant(c: CValue, node?: ParseNode): byte[] {\n    if (CArithmetic.S64.equals(c.type)) {\n        return encode(8, d => d.setBigInt64(0, BigInt(c.value), true));\n    } else if (CArithmetic.U64.equals(c.type)) {\n        return encode(8, d => d.setBigUint64(0, BigInt(c.value), true));\n    } else if (CArithmetic.S32.equals(c.type)) {\n        return encode(4, d => d.setInt32(0, Number(c.value), true));\n    } else if (CArithmetic.U32.equals(c.type) || c.type instanceof CPointer) {\n        return encode(4, d => d.setUint32(0, Number(c.value), true));\n    } else if (CArithmetic.S16.equals(c.type)) {\n        return encode(2, d => d.setInt16(0, Number(c.value), true));\n    } else if (CArithmetic.U16.equals(c.type)) {\n        return encode(2, d => d.setUint16(0, Number(c.value), true));\n    } else if (CArithmetic.S8.equals(c.type)) {\n        return encode(1, d => d.setInt8(0, Number(c.value)));\n    } else if (CArithmetic.U8.equals(c.type)) {\n        return encode(1, d => d.setUint8(0, Number(c.value)));\n    } else if (CArithmetic.Fp64.equals(c.type)) {\n        return encode(8, d => d.setFloat64(0, Number(c.value), true));\n    } else if (CArithmetic.Fp32.equals(c.type)) {\n        return encode(4, d => d.setFloat32(0, Number(c.value), true));\n    } else if (CArithmetic.BOOL.equals(c.type)) {\n        // eslint-disable-next-line eqeqeq\n        return encode(4, d => d.setInt32(0, c.value == 0 ? 0 : 1, true));\n    }\n    throw new GenError(\"Unknown value type?\", undefined, node);\n}\n\nfunction stringLiteralPtr(ctx: WGenerator, init: CStringLiteral): byte[] {\n    const addr = ctx.nextStaticAddr; // char is any byte aligned\n    const stringBytes = stringLiteral(init);\n    ctx.nextStaticAddr += stringBytes.length;\n    ctx.module.dataSegment(addr, stringBytes);\n\n    return constant(new CConstant(init.node, CSizeT, BigInt(addr)));\n}\n\nfunction stringLiteral(s: CStringLiteral): byte[] {\n    return s.value.map(Number) as byte[];\n}\n\nfunction initializer(ctx: WGenerator, init: CInitializer): byte[] {\n    let bytes: byte[];\n\n    if (init.type instanceof CArray) {\n        if (init.type.length === undefined) throw new GenError(\"Array length still unknown?\", undefined, init.node);\n        bytes = init.body.flatMap((x, i) => {\n            const element = staticInitializer(ctx, x, init.memberTypes[i]);\n            return pad(element, init.memberTypes[i].bytes);\n        });\n\n    } else if (init.type instanceof CUnion) {\n        bytes = staticInitializer(ctx, init.body[0], init.memberTypes[0]);\n\n    } else if (init.type instanceof CStruct) {\n        bytes = [];\n        for (let i = 0; i < init.body.length; i++) {\n            alignPad(bytes, init.memberTypes[i].alignment);\n            const member = staticInitializer(ctx, init.body[i], init.memberTypes[i]);\n            pad(member, init.memberTypes[i].bytes);\n            bytes.push(...member);\n        }\n\n    } else {\n        throw new GenError(\"Invalid initializer\", undefined, init.node);\n    }\n    return bytes;\n}\n\nfunction pad(bytes: byte[], n: number) {\n    while (bytes.length < n) bytes.push(0 as byte);\n    return bytes;\n}\n\nfunction alignPad(bytes: byte[], n: number) {\n    while (bytes.length % n !== 0) bytes.push(0 as byte);\n    return bytes;\n}\n","import {CType, CArithmetic, CPointer, CArray, CVoid, CFuncType, CStruct, CUnion} from \"../ir/types\";\nimport {Instructions, ValueType, f32Type, f64Type, i64Type, i32Type} from \"../wasm\";\nimport {WInstruction} from \"../wasm/instructions\";\nimport {ResultType} from \"../wasm/wtypes\";\n\n// CType - CArithmetic + wasm.ValueType\nexport type ImplementationType = CPointer | CArray | CStruct | CUnion | CVoid | CFuncType | ValueType;\n\n/**\n * Types used when computing the type of WebAssembly expressions.\n * CArithmetic is mapped to corresponding WebAssembly ValueTypes.\n * Otherwise the same C types are used.\n */\nexport function implType(type: CType): ImplementationType {\n    if (type instanceof CArithmetic) return valueType(type);\n    return type;\n}\n\n/**\n * WebAssembly Types used for passing values as a parameter into a function, or storing on the stack.\n */\nexport function realType(type: CType): ValueType {\n    if (type instanceof CArithmetic) return valueType(type);\n    if (type instanceof CPointer) return i32Type;\n    if (type instanceof CStruct || type instanceof CUnion) {\n        // passed around as pointer\n        return i32Type;\n    }\n    if (type instanceof CVoid) throw new Error(\"Void cannot be stored\");\n    throw new Error(type.typeName + \" doesn't have a real type\");\n}\n\nexport function conversion(inType: CType, outType: CType): WInstruction[] {\n    if (inType.equals(outType)) return [];\n\n    if (inType instanceof CArithmetic && outType instanceof CArithmetic) {\n        return arithmeticConversion(inType, outType);\n    } else if (inType instanceof CArithmetic && inType.type !== \"float\" && outType instanceof CPointer) {\n        // convert int to pointer\n        if (inType.bytes > 4) return [Instructions.i32.wrap_i64()]; // check for converting 8 byte int\n        return [];\n    } else if (outType instanceof CArithmetic && outType.type !== \"float\" && inType instanceof CPointer) {\n        // convert pointer to int\n        return [];\n    } else if (outType instanceof CPointer && inType instanceof CPointer) {\n        // pointer.type change\n        return [];\n    } else if (inType instanceof CFuncType && outType instanceof CPointer && inType.equals(outType.type)) {\n        // fn to pointer (function should already a pointer)\n        return [];\n    }\n\n    throw new Error(`Cannot convert ${inType.typeName} to ${outType.typeName}`);\n}\n\n/**\n * Follows the standard. For float -> int conversion it uses saturating truncation instructions to avoid runtime traps.\n *\n * > 3.2.1.3 Floating and integral\n * >\n * > When a value of floating type is converted to integral type, the fractional part is discarded.\n * > If the value of the integral part cannot be represented by the integral type, the behavior is undefined.\n */\nfunction arithmeticConversion(inType: CArithmetic, outType: CArithmetic): WInstruction[] {\n    if (CArithmetic.BOOL.equals(outType)) {\n        if (CArithmetic.Fp64.equals(inType)) return [Instructions.f64.const(0), Instructions.f64.ne()];\n        if (CArithmetic.Fp32.equals(inType)) return [Instructions.f32.const(0), Instructions.f32.ne()];\n        if (inType.bytes === 8) return [Instructions.i64.const(0n), Instructions.i64.ne()];\n        return [Instructions.i32.const(0), Instructions.i32.ne()];\n\n    } else if (CArithmetic.Fp64.equals(outType)) {\n        if (CArithmetic.Fp32.equals(inType)) return [Instructions.f64.promote_f32()];\n        if (inType.type === \"signed\" && inType.bytes === 8) return [Instructions.f64.convert_i64_s()];\n        if (inType.type === \"unsigned\" && inType.bytes === 8) return [Instructions.f64.convert_i64_u()];\n        if (inType.type === \"signed\" && inType.bytes <= 4) return [Instructions.f64.convert_i32_s()];\n        if (inType.type === \"unsigned\" && inType.bytes <= 4) return [Instructions.f64.convert_i32_u()];\n\n    } else if (CArithmetic.Fp32.equals(outType)) {\n        if (CArithmetic.Fp64.equals(inType)) return [Instructions.f32.demote_f64()];\n        if (inType.type === \"signed\" && inType.bytes === 8) return [Instructions.f32.convert_i64_s()];\n        if (inType.type === \"unsigned\" && inType.bytes === 8) return [Instructions.f32.convert_i64_u()];\n        if (inType.type === \"signed\" && inType.bytes <= 4) return [Instructions.f32.convert_i32_s()];\n        if (inType.type === \"unsigned\" && inType.bytes <= 4) return [Instructions.f32.convert_i32_u()];\n\n    } else if (CArithmetic.U64.equals(outType)) {\n        if (CArithmetic.Fp64.equals(inType)) return [Instructions.i64.trunc_sat_f64_u()];\n        if (CArithmetic.Fp32.equals(inType)) return [Instructions.i64.trunc_sat_f32_u()];\n        if (CArithmetic.S64.equals(inType)) return [];\n        if (inType.type === \"signed\") return [Instructions.i64.extend_i32_u()];\n        if (inType.type === \"unsigned\") return [Instructions.i64.extend_i32_u()];\n\n    } else if (CArithmetic.S64.equals(outType)) {\n        if (CArithmetic.Fp64.equals(inType)) return [Instructions.i64.trunc_f64_s()];\n        if (CArithmetic.Fp32.equals(inType)) return [Instructions.i64.trunc_f32_s()];\n        if (CArithmetic.U64.equals(inType)) return [];\n        if (inType.type === \"signed\") return [Instructions.i64.extend_i32_s()];\n        if (inType.type === \"unsigned\") return [Instructions.i64.extend_i32_u()];\n\n    } else if (CArithmetic.U32.equals(outType)) {\n        if (CArithmetic.Fp64.equals(inType)) return [Instructions.i32.trunc_sat_f64_u()];\n        if (CArithmetic.Fp32.equals(inType)) return [Instructions.i32.trunc_sat_f32_u()];\n        if (inType.bytes === 8) return [Instructions.i32.wrap_i64()];\n        return [];\n\n    } else if (CArithmetic.S32.equals(outType)) {\n        if (CArithmetic.Fp64.equals(inType)) return [Instructions.i32.trunc_sat_f64_s()];\n        if (CArithmetic.Fp32.equals(inType)) return [Instructions.i32.trunc_sat_f32_s()];\n        if (inType.bytes === 8) return [Instructions.i32.wrap_i64()];\n        return [];\n\n    } else if (outType.type === \"signed\" && outType.bytes < 4) {\n        if (inType.type !== \"float\" && inType.bytes < outType.bytes) return []; // e.g. (un)signed char -> signed short\n        if (CArithmetic.BOOL.equals(inType)) return [];\n\n        const conversion = [\n            Instructions.i32.const(32 - (8 * outType.bytes)),\n            Instructions.i32.shl(),\n            Instructions.i32.const(32 - (8 * outType.bytes)),\n            Instructions.i32.shr_s(),\n        ];\n\n        if (CArithmetic.Fp64.equals(inType)) conversion.unshift(Instructions.i32.trunc_f64_s());\n        if (CArithmetic.Fp32.equals(inType)) conversion.unshift(Instructions.i32.trunc_f32_s());\n        if (inType.type !== \"float\" && inType.bytes === 8) conversion.unshift(Instructions.i32.wrap_i64());\n        return conversion;\n\n    } else if (outType.type === \"unsigned\" && outType.bytes < 4) {\n        if (CArithmetic.BOOL.equals(inType)) return [];\n\n        const conversion = [\n            Instructions.i32.const((2 ** (8 * outType.bytes)) - 1),\n            Instructions.i32.and()\n        ];\n\n        if (CArithmetic.Fp64.equals(inType)) conversion.unshift(Instructions.i32.trunc_sat_f64_u());\n        if (CArithmetic.Fp32.equals(inType)) conversion.unshift(Instructions.i32.trunc_sat_f32_u());\n        if (inType.type !== \"float\" && inType.bytes === 8) conversion.unshift(Instructions.i32.wrap_i64());\n        return conversion;\n    }\n\n    throw new Error(\"Invalid arithmetic type\");\n}\n\nexport function valueType(type: CArithmetic): ValueType {\n    if (type.type === \"float\") {\n        return type.bytes === 4 ? f32Type : f64Type;\n    } else if (type.bytes === 8) {\n        return i64Type;\n    } else if (type.bytes <= 4) {\n        return i32Type;\n    }\n\n    throw new Error(\"Unknown type\");\n}\n\nexport function returnType(type: CType): ResultType {\n    if (type instanceof CVoid || largeReturn(type)) return [];\n    return [realType(type)];\n}\n\nexport function largeReturn(type: CType): boolean {\n    // functions that return structs/unions as they cannot be returned as a single Wasm value\n    return type instanceof CStruct || type instanceof CUnion;\n}\n","import {CArgument, CDeclaration, CVarDefinition, CVarDeclaration} from \"../ir/declarations\";\nimport {CExpression} from \"../ir/expressions\";\nimport * as e from \"../ir/expressions\";\nimport {Scope} from \"../ir/scope\";\nimport {CType, CArithmetic, CPointer, CStruct, CUnion, CArray, CVoid, CFuncType} from \"../ir/types\";\nimport {Instructions, i32Type} from \"../wasm\";\nimport {localidx} from \"../wasm/base_types\";\nimport {WLocal} from \"../wasm/functions\";\nimport {WInstruction} from \"../wasm/instructions\";\nimport {GenError} from \"./gen_error\";\nimport {WFnGenerator, WGenerator} from \"./generator\";\nimport {staticInitializer} from \"./static_initializer\";\nimport {realType, conversion} from \"./type_conversion\";\n\nexport type StorageLocation =\n    {type: \"local\", \"index\": {getIndex(d: number): localidx}} |\n    {type: \"static\", \"address\": number} |\n    {type: \"shadow\", \"shadowOffset\": number} | // offset from shadow pointer\n    {type: \"pointer\"}; // address on stack\n\n/** Setup the static storage location for a variable and if it has a static initializer return a function to set the\n * value AFTER all the functions have been created. This allows static initializer values to refer to each other\n * and to functions. Whilst creating functions only the location of the static variable is needed, not it's value. */\nexport function storageSetupStaticVar(ctx: WGenerator, d: CVarDefinition): (() => void) | undefined {\n    const addr = Math.ceil(ctx.nextStaticAddr / d.type.alignment) * d.type.alignment;\n    ctx.nextStaticAddr = addr + d.type.bytes;\n\n    setStorageLocation(d, {\n        type: \"static\",\n        address: addr\n    });\n\n    if (d.staticValue) {\n        const value = d.staticValue;\n        return () => ctx.module.dataSegment(addr, staticInitializer(ctx, value, d.type));\n    }\n}\n\nexport function storageSetupScope(ctx: WFnGenerator, s: Scope): [setup: WInstruction[], finishedCallback: () => void] {\n    const instr: WInstruction[] = [];\n    const temporaries: WLocal[] = [];\n\n    for (const declaration of s.declarations) {\n        if (declaration instanceof CArgument) {\n            if (declaration.type instanceof CStruct || declaration.type instanceof CUnion) {\n                // argument is effectively a pointer to a struct/union to copy\n\n                // align\n                ctx.shadowStackUsage = Math.ceil(ctx.shadowStackUsage / declaration.type.alignment) * declaration.type.alignment;\n\n                setStorageLocation(declaration, {\n                    type: \"shadow\",\n                    shadowOffset: ctx.shadowStackUsage\n                });\n                // copy from given pointer\n                instr.push(...memcpy(\n                    [Instructions.local.get(ctx.builder.args[declaration.index])],\n                    [Instructions.global.get(ctx.gen.shadowStackPtr), Instructions.i32.const(ctx.shadowStackUsage), Instructions.i32.add()],\n                    declaration.type.bytes\n                ));\n                ctx.shadowStackUsage += declaration.type.bytes;\n\n            } else if (declaration.addressUsed) {\n                ctx.shadowStackUsage = Math.ceil(ctx.shadowStackUsage / declaration.type.alignment) * declaration.type.alignment;\n                setStorageLocation(declaration, {\n                    type: \"shadow\",\n                    shadowOffset: ctx.shadowStackUsage\n                });\n                // copy value onto shadow stack\n                instr.push(Instructions.global.get(ctx.gen.shadowStackPtr));\n                instr.push(Instructions.local.get(ctx.builder.args[declaration.index]));\n                instr.push(store(declaration.type, ctx.shadowStackUsage));\n\n                ctx.shadowStackUsage += declaration.type.bytes; // 4 byte align\n            } else {\n                setStorageLocation(declaration, {\n                    type: \"local\",\n                    index: ctx.builder.args[declaration.index]\n                });\n            }\n        }\n\n        if (declaration instanceof CVarDefinition) {\n            if (declaration.storage === \"local\") {\n                if (declaration.addressUsed || !(declaration.type instanceof CArithmetic || declaration.type instanceof CPointer)) {\n                    // have to place on shadow stack\n                    ctx.shadowStackUsage = Math.ceil(ctx.shadowStackUsage / declaration.type.alignment) * declaration.type.alignment;\n                    setStorageLocation(declaration, {\n                        type: \"shadow\",\n                        shadowOffset: ctx.shadowStackUsage\n                    });\n                    ctx.shadowStackUsage += declaration.type.bytes;\n                } else {\n                    const local = ctx.builder.getTempLocal(realType(declaration.type));\n                    temporaries.push(local);\n                    setStorageLocation(declaration, {\n                        type: \"local\",\n                        index: local\n                    });\n                }\n            } else if (declaration.storage === \"static\" && getStorageLocation(declaration) === undefined) { // storage should have already been setup\n                throw new GenError(\"In function static variable is not setup\");\n            }\n        }\n    }\n\n    return [instr, () => temporaries.forEach(x => ctx.builder.freeTempLocal(x))];\n}\n\n// the storage operations\n\n/** Pushes the stored value from location 'e' onto the stack  */\nexport function storageGet(ctx: WFnGenerator, ctype: CType, locationExpr: CExpression): WInstruction[] {\n    const [instr, location] = fromExpression(ctx, locationExpr);\n\n    if (ctype instanceof CStruct || ctype instanceof CUnion || (ctype instanceof CPointer && ctype.original instanceof CArray)) {\n        // loading a structure just returns a pointer\n        return getAddress(ctx, locationExpr);\n    }\n\n    if (location.type === \"local\") {\n        instr.push(Instructions.local.get(location.index));\n    } else if (location.type === \"static\") {\n        instr.push(Instructions.i32.const(0), load(ctype, location.address));\n    } else if (location.type === \"shadow\") {\n        instr.push(Instructions.global.get(ctx.gen.shadowStackPtr), load(ctype, location.shadowOffset));\n    } else if (location.type === \"pointer\") {\n        instr.push(load(ctype, 0));\n    }\n    return instr;\n}\n\n/** Stores the value on the top of the stack when 'valueExpr' is run into location 'locationExpr'.\n * If keepValue is true then the stored value is kept on the top of the stack after being stored */\nexport function storageSet(ctx: WFnGenerator, ctype: CType, locationExpr: CExpression, valueExpr: CExpression, keepValue: boolean): WInstruction[] {\n    const [instr, location] = fromExpression(ctx, locationExpr);\n    const valueInstr = ctx.expression(valueExpr, false);\n    valueInstr.push(...conversion(valueExpr.type, locationExpr.type));\n\n    if (ctype instanceof CStruct || ctype instanceof CUnion || ctype instanceof CArray) {\n        // storing a structure copies memory, presumes pointer to the same type is on top of stack\n        return memcpy(valueInstr, getAddress(ctx, locationExpr), ctype.bytes);\n    }\n\n    if (location.type === \"local\") {\n        instr.push(...valueInstr, keepValue ? Instructions.local.tee(location.index) : Instructions.local.set(location.index));\n    } else if (location.type === \"static\") {\n        instr.push(Instructions.i32.const(0), ...valueInstr);\n        if (keepValue) {\n            instr.push(...ctx.withTemporaryLocal(realType(ctype), (tmp) => [\n                Instructions.local.tee(tmp), // store copy of value\n                store(ctype, location.address),\n                Instructions.local.get(tmp)\n            ]));\n        } else {\n            instr.push(store(ctype, location.address));\n        }\n    } else if (location.type === \"shadow\") {\n        instr.push(Instructions.global.get(ctx.gen.shadowStackPtr), ...valueInstr);\n        if (keepValue) {\n            instr.push(...ctx.withTemporaryLocal(realType(ctype), (tmp) => [\n                Instructions.local.tee(tmp), // store copy of value\n                store(ctype, location.shadowOffset),\n                Instructions.local.get(tmp)\n            ]));\n        } else {\n            instr.push(store(ctype, location.shadowOffset));\n        }\n    } else if (location.type === \"pointer\") {\n        // address should already be on top of the stack\n        instr.push(...valueInstr);\n        if (keepValue) {\n            instr.push(...ctx.withTemporaryLocal(realType(ctype), (tmp) => [\n                Instructions.local.tee(tmp), // store copy of value\n                store(ctype, 0),\n                Instructions.local.get(tmp)\n            ]));\n        } else {\n            instr.push(store(ctype, 0));\n        }\n    }\n    return instr;\n}\n\n/** Updates the location 'locationExpr' by running 'instr' which should transform its value on the stack.\n * If keepValue is true then the stored value is kept on the top of the stack after being stored */\nexport function storageUpdate(ctx: WFnGenerator, ctype: CType, locationExpr: CExpression, transform: WInstruction[], keepValue: boolean): WInstruction[] {\n    if (ctype instanceof CArray || ctype instanceof CStruct || ctype instanceof CUnion) {\n        throw new GenError(\"Cannot storageUpdate \" + ctype.typeName, ctx, locationExpr.node);\n    }\n    const [instr, location] = fromExpression(ctx, locationExpr);\n\n    if (location.type === \"local\") {\n        instr.push(Instructions.local.get(location.index), ...transform);\n        if (keepValue) instr.push(Instructions.local.tee(location.index));\n        else instr.push(Instructions.local.set(location.index));\n\n        return instr;\n    } else if (location.type === \"static\") {\n        instr.push(Instructions.i32.const(0), Instructions.i32.const(0), load(ctype, location.address), ...transform);\n\n        if (keepValue) {\n            instr.push(...ctx.withTemporaryLocal(realType(ctype), (tmp) => [\n                Instructions.local.tee(tmp), // store copy of value\n                store(ctype, location.address),\n                Instructions.local.get(tmp)\n            ]));\n        } else {\n            instr.push(store(ctype, location.address));\n        }\n    } else if (location.type === \"shadow\") {\n        instr.push(Instructions.global.get(ctx.gen.shadowStackPtr), Instructions.global.get(ctx.gen.shadowStackPtr));\n        instr.push(load(ctype, location.shadowOffset), ...transform);\n\n        if (keepValue) {\n            instr.push(...ctx.withTemporaryLocal(realType(ctype), (tmp) => [\n                Instructions.local.tee(tmp), // store copy of value\n                store(ctype, location.shadowOffset),\n                Instructions.local.get(tmp)\n            ]));\n        } else {\n            instr.push(store(ctype, location.shadowOffset));\n        }\n    } else if (location.type === \"pointer\") {\n        instr.push(...ctx.withTemporaryLocal(i32Type, (addrTmp) => [\n            Instructions.local.tee(addrTmp), // duplicate pointer on top of stack\n            Instructions.local.get(addrTmp)\n        ]));\n        instr.push(load(ctype, 0), ...transform);\n\n        if (keepValue) {\n            instr.push(...ctx.withTemporaryLocal(realType(ctype), (tmp) => [\n                Instructions.local.tee(tmp), // store copy of value\n                store(ctype, 0),\n                Instructions.local.get(tmp)\n            ]));\n        } else {\n            instr.push(store(ctype, 0));\n        }\n    }\n    return instr;\n}\n\n/** Updates the location 'locationExpr' by running 'instr' which should transform its value on the stack.\n * Value before transform is left on the stack */\nexport function storageGetThenUpdate(ctx: WFnGenerator, ctype: CType, locationExpr: CExpression, transform: WInstruction[]): WInstruction[] {\n    if (ctype instanceof CArray || ctype instanceof CStruct || ctype instanceof CUnion) {\n        throw new GenError(\"Cannot storageGetThenUpdate \" + ctype.typeName, ctx, locationExpr.node);\n    }\n    const [instr, location] = fromExpression(ctx, locationExpr);\n\n    if (location.type === \"local\") {\n        instr.push(Instructions.local.get(location.index));\n        instr.push(Instructions.local.get(location.index), ...transform, Instructions.local.set(location.index));\n    } else if (location.type === \"static\") {\n        instr.push(Instructions.i32.const(0), Instructions.i32.const(0), load(ctype, location.address));\n        instr.push(...ctx.withTemporaryLocal(realType(ctype), (tmp) => [\n            Instructions.local.tee(tmp), // store copy of old value\n            ...transform,\n            store(ctype, location.address),\n            Instructions.local.get(tmp)\n        ]));\n    } else if (location.type === \"shadow\") {\n        instr.push(Instructions.global.get(ctx.gen.shadowStackPtr), Instructions.global.get(ctx.gen.shadowStackPtr));\n        instr.push(load(ctype, location.shadowOffset));\n\n        instr.push(...ctx.withTemporaryLocal(realType(ctype), (tmp) => [\n            Instructions.local.tee(tmp), // store copy of old value\n            ...transform,\n            store(ctype, location.shadowOffset),\n            Instructions.local.get(tmp)\n        ]));\n    } else if (location.type === \"pointer\") {\n        instr.push(...ctx.withTemporaryLocal(i32Type, (addrTmp) => [\n            Instructions.local.tee(addrTmp), // duplicate pointer on top of stack\n            Instructions.local.get(addrTmp)\n        ]));\n        instr.push(load(ctype, 0));\n        instr.push(...ctx.withTemporaryLocal(realType(ctype), (tmp) => [\n            Instructions.local.tee(tmp), // store copy of old value\n            ...transform,\n            store(ctype, 0),\n            Instructions.local.get(tmp)\n        ]));\n    }\n    return instr;\n}\n\n// helper to get address of a storage location\nexport function getAddress(ctx: WFnGenerator, s: e.CExpression): WInstruction[] {\n    const [instr, loc] = fromExpression(ctx, s);\n    if (loc.type === \"local\") {\n        throw new GenError(\"Local with addressed access stored in local. This shouldn't happen!\", ctx, s.node);\n    } else if (loc.type === \"static\") {\n        instr.push(Instructions.i32.const(loc.address));\n    } else if (loc.type === \"shadow\") {\n        instr.push(Instructions.global.get(ctx.gen.shadowStackPtr),\n            Instructions.i32.const(loc.shadowOffset),\n            Instructions.i32.add());\n    }\n    return instr;\n}\n\n// helper to get the storage location from an expression\n\n/**\n * Helper function which finds the storage location from a CExpression.\n *\n * The first return value are instructions to be executed before accessing the storage and\n * the second return value is the storage location itself.\n */\nfunction fromExpression(ctx: WFnGenerator, s: e.CExpression): [WInstruction[], StorageLocation] {\n    if (!s.lvalue) throw new GenError(\"Only lvalue expressions can have storage locations\", ctx, s.node);\n\n    if (s instanceof e.CIdentifier) {\n        let location = getStorageLocation(s.value);\n        if (location) return [[], location];\n\n        if (s.value instanceof CVarDeclaration) {\n            if (s.value.definition === undefined) throw new GenError(\"No variable definition found\", ctx, s.node);\n            location = getStorageLocation(s.value.definition);\n            if (location) return [[], location];\n        }\n\n    } else if (s instanceof e.CMemberAccess) {\n        const address = ctx.expression(s.body, false);\n        if (s.structUnion instanceof CStruct) {\n            let offset = 0;\n            for (const member of s.structUnion.members) {\n                offset = Math.ceil(offset / member.type.alignment) * member.type.alignment;\n                if (member.name === s.member) break;\n                offset += member.type.bytes;\n            }\n            return [[...address, Instructions.i32.const(offset), Instructions.i32.add()], {type: \"pointer\"}];\n        }\n        return [address, {type: \"pointer\"}]; // for unions\n    } else if (s instanceof e.CDereference) {\n        return [ctx.expression(s.body, false), {type: \"pointer\"}];\n    }\n\n    throw new GenError(\"Invalid location expression\", ctx, s.node);\n}\n\nexport function getStaticAddress(s: CDeclaration): number | undefined {\n    if (s instanceof CVarDeclaration && s.definition) s = s.definition;\n    const loc = getStorageLocation(s);\n    return loc?.type === \"static\" ? loc.address : undefined;\n}\n\n// helpers for storing storage location on variables using a Symbol\n\nconst locationSymbol = Symbol(\"storage location\");\nfunction setStorageLocation(s: CDeclaration, loc: StorageLocation) {\n    (s as any as Record<typeof locationSymbol, StorageLocation>)[locationSymbol] = loc;\n}\n\nfunction getStorageLocation(s: CDeclaration): StorageLocation | undefined {\n    return (s as any as Record<typeof locationSymbol, StorageLocation | undefined>)[locationSymbol];\n}\n\n// helpers returning the instructions to read/write a type from memory\n\nfunction load(type: CType, offset: number): WInstruction {\n    if (type instanceof CPointer) {\n        return Instructions.i32.load(2, offset);\n    }\n    if (type instanceof CStruct || type instanceof CUnion || type instanceof CArray) {\n        throw new Error(\"Invalid \" + type.typeName + \" load\");\n    }\n    if (type instanceof CVoid || type instanceof CFuncType) {\n        throw new Error(\"Cannot load \" + type.typeName);\n    }\n\n    // must be arithmetic\n    if (type.type === \"float\") {\n        if (type.bytes === 8) {\n            return Instructions.f64.load(3, offset);\n        } else {\n            return Instructions.f32.load(2, offset);\n        }\n\n    } else if (type.bytes === 8) {\n        return Instructions.i64.load(3, offset);\n\n    } else if (type.bytes === 4) {\n        return Instructions.i32.load(2, offset);\n\n    } else if (type.type === \"signed\") {\n        if (type.bytes === 2) {\n            return Instructions.i32.load16_s(1, offset);\n        } else {\n            return Instructions.i32.load8_s(0, offset);\n        }\n\n    } else {\n        if (type.bytes === 2) {\n            return Instructions.i32.load16_u(1, offset);\n        } else {\n            return Instructions.i32.load8_u(0, offset);\n        }\n    }\n}\n\nfunction store(type: CType, offset: number): WInstruction {\n    if (type instanceof CPointer) {\n        return Instructions.i32.store(2, offset);\n    }\n    if (type instanceof CStruct || type instanceof CUnion || type instanceof CArray) {\n        throw new Error(\"Invalid \" + type.typeName + \" store\");\n    }\n    if (type instanceof CVoid || type instanceof CFuncType) {\n        throw new Error(\"Cannot store \" + type.typeName);\n    }\n\n    if (type.type === \"float\") {\n        if (type.bytes === 8) {\n            return Instructions.f64.store(3, offset);\n        } else {\n            return Instructions.f32.store(2, offset);\n        }\n\n    } else if (type.bytes === 8) {\n        return Instructions.i64.store(3, offset);\n    } else if (type.bytes === 4) {\n        return Instructions.i32.store(2, offset);\n    } else if (type.bytes === 2) {\n        return Instructions.i32.store16(1, offset);\n    } else {\n        return Instructions.i32.store8(0, offset);\n    }\n}\n\nexport function memcpy(sourceAddr: WInstruction[], destAddr: WInstruction[], bytes: number): WInstruction[] {\n    return [\n        ...destAddr,\n        ...sourceAddr,\n        Instructions.i32.const(bytes),\n        Instructions.memory.copy()\n    ];\n}\n","import {CError} from \"../c_error\";\nimport {getArithmeticType} from \"../ir/types\";\nimport * as pt from \"./parsetree\";\nimport {ParseNode, TypeSpecifier} from \"./parsetree\";\n\nconst validatorMap = new Map<typeof ParseNode, ((node: ParseNode, parents: ParseNode[]) => void)[]>();\n\nexport function validate<T extends Iterable<ParseNode>>(nodeList: T, parents: ParseNode[] = []): T {\n    for (const node of nodeList) {\n        parents.push(node);\n        validate(node.children(), parents);\n        parents.pop();\n\n        for (const validator of validatorMap.get(Object.getPrototypeOf(node).constructor) ?? []) {\n            validator(node, parents);\n        }\n    }\n    return nodeList;\n}\n\nexport class ParseTreeValidationError extends CError {\n    readonly name = \"TreeValidationError\";\n\n    constructor(node: ParseNode | undefined, message: string, node2?: ParseNode) {\n        super(node && node.loc ? `Line ${node.loc.first_line + 1}: ${message}` : message, node, node2);\n    }\n}\n\nfunction validator<T extends ParseNode>(type: { new(...args: any[]): T}, fn: (node: T, parents: ParseNode[]) => void) {\n    const validators = validatorMap.get(type);\n    if (validators) {\n        validators.push(fn as any);\n    } else {\n        validatorMap.set(type, [fn as any]);\n    }\n}\n\n// DeclarationSpecifiers/SpecifierQualifiers validation\nfunction typeLookup(specifierList: ReadonlyArray<pt.TypeSpecifier>, node?: ParseNode) {\n    if (specifierList.every(v => typeof v === 'string')) {\n        if (!getArithmeticType(specifierList as ReadonlyArray<TypeSpecifier & string>)) {\n            throw new ParseTreeValidationError(node, \"Invalid specifiers - \" + specifierList.join(\", \"));\n        }\n    }\n}\n\nconst typeValidation = (d: pt.SpecifierQualifiers | pt.DeclarationSpecifiers) => {\n    if (d.qualifierList.length > 1) throw new ParseTreeValidationError(d, \"Invalid qualifiers.\");\n    typeLookup(d.specifierList, d);\n};\n\nvalidator(pt.SpecifierQualifiers, typeValidation);\nvalidator(pt.DeclarationSpecifiers, typeValidation);\nvalidator(pt.DeclarationSpecifiers, (d, parents) => {\n    if (d.storageList.length > 1) throw new ParseTreeValidationError(d, \"Invalid storage class list.\");\n    if (d.fnSpecifierList.length > 1) throw new ParseTreeValidationError(d, \"Invalid fn specifier list.\");\n\n    if (d.storageList[0] === \"typedef\" && parents.length !== 1) {\n        throw new ParseTreeValidationError(d, \"Nested typedefs are not allowed\");\n    }\n});\n\n// Constant expr validation\nfunction constExprValidation(n: ParseNode, parents: ParseNode[]) {\n    for (let i = parents.length - 1; i >= 0; i--) {\n        if (!(parents[i] instanceof pt.Expression) || parents[i].type === \"sizeof\") return;\n        if (parents[i].type === \"constantExpr\") throw new ParseTreeValidationError(n, \"Invalid constant expr.\");\n    }\n}\n\nvalidator(pt.UnaryExpression, (node, parent) => {\n    switch (node.type) {\n    case \"postfixIncrement\":\n    case \"postfixDecrement\":\n    case \"prefixIncrement\":\n    case \"prefixDecrement\":\n    case \"addressOf\": // If integers are required (believe this is always the case?)\n    case \"dereference\":\n        constExprValidation(node, parent);\n    }\n});\nvalidator(pt.BinaryExpression, (node, parent) => {\n    switch (node.type) {\n    case \"comma\":\n    case \"arraySubscript\": // If int\n        constExprValidation(node, parent);\n    }\n});\nvalidator(pt.FunctionCallExpression, constExprValidation);\n\n// If int\nvalidator(pt.MemberAccessExpression, constExprValidation);\n","import {CError} from \"../c_error\";\nimport {ParseNode} from \"./parsetree\";\n\nexport type Location = {\n    first_line: number,\n    last_line: number,\n    first_column: number,\n    last_column: number,\n    source: string,\n};\n\nconst keywords = Object.fromEntries([\n    \"if\", \"break\", \"case\", \"char\", \"const\", \"continue\", \"default\", \"do\", \"double\", \"else\", \"enum\", \"extern\", \"float\",\n    \"for\", \"inline\", \"int\", \"long\", \"return\", \"short\", \"signed\", \"sizeof\", \"static\", \"struct\", \"switch\", \"typedef\",\n    \"union\", \"unsigned\", \"void\", \"while\", \"_Bool\", \"goto\",\n\n    // currently unsupported (but still lex so parser throws error)\n    \"auto\", \"register\", \"volatile\",\n\n    // special for c2wasm, not on spec\n    \"import\"\n].map(x => [x, x.toUpperCase()]));\n\nconst symbols = [\n    \"...\",\"<<=\",\">>=\",\n    \"!=\",\"%=\",\"&&\",\"&=\",\"*=\",\"++\",\"+=\",\"--\",\"-=\",\"->\",\"/=\",\"<<\",\"<=\",\"==\",\">=\",\">>\",\"^=\",\"|=\",\"||\",\n    \"!\",\"%\",\"&\",\"(\",\")\",\"*\",\"+\",\",\",\"-\",\".\",\"/\",\":\",\";\",\"<\",\"=\",\">\",\"?\",\"[\",\"]\",\"^\",\"{\",\"|\",\"}\",\"~\"\n];\n\nconst rules: {regex: RegExp, type: string | ((s: string) => string), value?: (s: string) => string}[] = [\n    {\n        type: (s) => keywords[s] ?? 'IDENTIFIER',\n        regex: /[a-zA-Z_][a-zA-Z0-9_]*/,\n    },\n    {\n        type: x => x,\n        regex: new RegExp(symbols.map(s => s.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')).join('|')),\n    },\n    {\n        type: 'CONSTANT_FLOAT',\n        regex: /(?:[0-9]+[Ee][+-]?[0-9]+|(?:[0-9]*\\.[0-9]+|[0-9]+\\.[0-9]*)(?:[Ee][+-]?[0-9]+)?)[fFlL]?|(?:[1-9][0-9]*|0)[fF]/,\n    },\n    {\n        type: 'CONSTANT_HEX',\n        regex: /0[xX][a-fA-F0-9]+(?:[uU][lL]{0,2}|[lL]{1,2}[uU]?|)/,\n    },\n    {\n        type: 'CONSTANT_OCTAL',\n        regex: /0[0-7]+(?:[uU][lL]{0,2}|[lL]{1,2}[uU]?|)/,\n    },\n    {\n        type: 'CONSTANT_INT',\n        regex: /(?:[1-9][0-9]*|0)(?:[uU][lL]{0,2}|[lL]{1,2}[uU]?|)/,\n    },\n    {\n        type: 'CONSTANT_CHAR',\n        regex: /'(?:[^\\\\\\n']|\\\\(?:.|x[0-9a-fA-F]{1,2}|[0-7]{1,3}))'/,\n        value: x => x.slice(1, -1),\n    },\n    {\n        type: 'STRING_LITERAL',\n        regex: /\"(?:[^\\\\\\n\"]|\\\\(?:[^x0-7\\n]|x[0-9a-fA-F]{1,2}|[0-7]{1,3}))*\"/,\n        value: x => x.slice(1, -1),\n    },\n];\n\nexport class Lexer {\n    static regex = new RegExp(rules.map(x => '(' + x.regex.source + ')').join('|'), 'ym');\n\n    private source = '';\n    private index = 0;\n    private line = 0;\n    private col = 0;\n\n    next(): {type: string, value: string, text: string, loc: Location} {\n        // Skip whitespace\n        while (this.index < this.source.length && (this.source[this.index] === ' '\n            || this.source[this.index] === '\\t' || this.source[this.index] === '\\v'\n            || this.source[this.index] === '\\f' || this.source[this.index] === '\\n')) {\n\n            if (this.source[this.index] === '\\n') {\n                this.line++;\n                this.col = 1;\n            } else {\n                this.col++;\n            }\n            this.index++;\n        }\n\n        const loc: Location = {\n            first_line: this.line,\n            first_column: this.col,\n            last_line: this.line,\n            last_column: this.col + 1,\n            source: this.source,\n        };\n\n        // Reached end of source\n        if (this.index === this.source.length) {\n            return {type: 'EOF', value: '', text: '', loc};\n        }\n\n        // Match sticky regex from current index\n        Lexer.regex.lastIndex = this.index;\n        const match = Lexer.regex.exec(this.source);\n        if (!match) throw new LexerError(loc);\n\n        // Update location information\n        const text = match[0];\n        this.index += text.length;\n        this.col += text.length;\n        loc.last_column = this.col;\n\n        // group[n+1] !== undefined means that rule[n] matched\n        let groupIdx = 0;\n        while (match[groupIdx + 1] === undefined) groupIdx++;\n        const group = rules[groupIdx];\n\n        return {\n            type: typeof group.type === 'function' ? group.type(text) : group.type,\n            value: group.value?.(text) ?? text,\n            text, loc,\n        };\n    }\n\n    reset(s: string) {\n        this.source = s;\n        this.index = 0;\n        this.line = 0;\n        this.col = 1;\n    }\n}\n\nclass LexerError extends CError {\n    name = \"LexerError\";\n\n    constructor(loc: Location) {\n        super(\"Unknown token\", new class extends ParseNode {\n            type = \"Unknown\";\n        }(loc));\n    }\n}\n\nexport const lexer = new Lexer();\n","import {locationString} from \"../c_error\";\nimport gen from \"./gen/c_grammar\";\nimport {lexer, Location} from \"./lexer\";\nimport * as parsetree from \"./parsetree\";\nimport {validate} from \"./validation\";\n\n// adapt lexer to work with Jison\nclass WrappedLexer {\n    yytext?: string;\n    yylloc?: Location;\n    yylineno?: number;\n\n    private types = new Map<string, boolean>();\n\n    /** return the token type and update yytext, yylloc, yylineno */\n    lex(): string {\n        const token = lexer.next();\n        this.yytext = token.value;\n        this.yylloc = token.loc;\n        this.yylineno = token.loc.first_line;\n\n        if (token.type === \"IDENTIFIER\" && this.types.get(token.text)) {\n            return \"TYPE_NAME\";\n        }\n        return token.type;\n    }\n\n    setInput(input: string): void {\n        this.yytext = undefined;\n        this.yylloc = undefined;\n        this.yylineno = undefined;\n        this.types.clear();\n\n        lexer.reset(input);\n    }\n\n    externalDeclaration(d: parsetree.Declaration) {\n        if (d.typeInfo.storageList[0] !== \"typedef\") return;\n\n        for (let declarator of d.list) {\n            while (!(declarator instanceof parsetree.IdentifierDeclarator)) declarator = declarator.body;\n            this.types.set(declarator.id, true);\n        }\n    }\n}\n\n// provide the generated parser with our custom lexer\nconst generatedParser = gen as any;\ngeneratedParser.parser.lexer = new WrappedLexer();\n\n/**\n * Parse the input string into a parse tree and perform some basic validation\n */\nexport function parse(input: string): parsetree.TranslationUnit {\n    try {\n        const tree = generatedParser.parse(input);\n        return validate(tree);\n    } catch (e) {\n        if (e?.hash?.loc) { // Jison parse errors\n            e.message += \"\\n\\n\" + locationString(e.hash?.loc);\n        }\n        throw e;\n    }\n}\n","import {ParseNode} from \"../parsing\";\nimport {CFuncDeclaration} from \"./declarations\";\nimport {Scope} from \"./scope\";\nimport {CFuncType, CVoid, CArithmetic, CPointer} from \"./types\";\n\nconst fakeParseNode: ParseNode = new class extends ParseNode {\n    readonly type: string = \"__internal__\";\n\n    constructor() {\n        super({first_line: 0, first_column: 0, last_line: 0, last_column: 0, source: \"\"});\n    }\n}();\n\nexport const INTERNAL_FNS = {\n    /** For executing arbitrary Wasm. Should NOT contain control flow as the code will not be processed\n     * by optimisations. Similarly, locals should only be accessed as parameters as they map be remapped.\n     *\n     * __wasm_push__([#parameters], [parameter1], [parameter2], ..., [byte1], [byte2]...);\n     */\n    wasm: new CFuncDeclaration(\n        fakeParseNode,\n        \"__wasm__\",\n        new CFuncType(fakeParseNode, new CVoid(), [CArithmetic.U32], undefined, true),\n        \"internal\"\n    ),\n    /** For executing arbitrary Wasm* returning i32 */\n    wasm_i32: new CFuncDeclaration(\n        fakeParseNode,\n        \"__wasm_i32__\",\n        new CFuncType(fakeParseNode, CArithmetic.U32, [CArithmetic.U32], undefined, true),\n        \"internal\"\n    ),\n    /** For executing arbitrary Wasm* returning i64 */\n    wasm_i64: new CFuncDeclaration(\n        fakeParseNode,\n        \"__wasm_i64__\",\n        new CFuncType(fakeParseNode, CArithmetic.U64, [CArithmetic.U32], undefined, true),\n        \"internal\"\n    ),\n    /** For executing arbitrary Wasm* returning f32 */\n    wasm_f32: new CFuncDeclaration(\n        fakeParseNode,\n        \"__wasm_f32__\",\n        new CFuncType(fakeParseNode, CArithmetic.Fp32, [CArithmetic.U32], undefined, true),\n        \"internal\"\n    ),\n    /** For executing arbitrary Wasm* returning f64 */\n    wasm_f64: new CFuncDeclaration(\n        fakeParseNode,\n        \"__wasm_f64__\",\n        new CFuncType(fakeParseNode, CArithmetic.Fp64, [CArithmetic.U32], undefined, true),\n        \"internal\"\n    ),\n    /** For getting the value of the shadow stack pointer\n     *\n     * __wasm_ssp__();\n     */\n    wasm_ssp: new CFuncDeclaration(\n        fakeParseNode,\n        \"__wasm_ssp__\",\n        new CFuncType(fakeParseNode, new CPointer(fakeParseNode, new CVoid(), true), []),\n        \"internal\"\n    ),\n    /**\n     * Wasm real type load - compensates for conversation/type_conversion.ts realType()\n     * Most C values are directly stored as Wasm values, but CStruct and CUnions have to be stored as pointers.\n     * This isn't directly expressed in the type information, and so this function is needed for any C directly manipulating memory.\n     *\n     * __wasm_rload__([ptr]);\n     */\n    wasm_rload: new CFuncDeclaration(\n        fakeParseNode,\n        \"__wasm_rload__\",\n        new CFuncType(fakeParseNode, new CPointer(fakeParseNode, new CVoid(), true), [new CPointer(fakeParseNode, new CVoid(), true)]),\n        \"internal\"\n    )\n};\n\nexport const INTERNAL_SCOPE = new Scope();\nObject.values(INTERNAL_FNS).forEach(x => INTERNAL_SCOPE.addIdentifier(x));\n","import {CFunctionCall, CIdentifier, CConstant} from \"../ir/expressions\";\nimport {INTERNAL_FNS} from \"../ir/internal_scope\";\nimport {CArithmetic, CStruct, CUnion, CPointer} from \"../ir/types\";\nimport {ValueType, i32Type, i64Type, f32Type, f64Type} from \"../wasm\";\nimport {byte} from \"../wasm/base_types\";\nimport {WInstruction, Instructions} from \"../wasm/instructions\";\nimport {GenError} from \"./gen_error\";\nimport {WFnGenerator} from \"./generator\";\nimport {realType} from \"./type_conversion\";\n\n\nfunction arbitrary(ctx: WFnGenerator, e: CFunctionCall, result: ValueType | null): WInstruction[] {\n    if (!(e.args[0] instanceof CConstant)) {\n        throw new GenError(\"__wasm__ first argument should be integer constant specifying the number of parameters\", ctx, e.args[0].node);\n    }\n    const parameters = Number(e.args[0].value);\n\n    const parameterArgs = e.args.slice(1, parameters + 1);\n    const parameterInstructions = parameterArgs.flatMap(x => ctx.expression(x, false));\n\n    const instructionArgs = e.args.slice(parameters + 1);\n    const instructionBytes = instructionArgs.map(x => {\n        if (x instanceof CConstant) return Number(x.changeType(CArithmetic.U8).value);\n        throw new GenError(\"__wasm__ instructions must be constants\", ctx, x.node);\n    });\n\n    return [\n        ...parameterInstructions,\n        () => ({\n            name: \"arbitrary\",\n            type: \"zeroArg\",\n            immediate: {},\n\n            encoded: instructionBytes as byte[],\n            parameters: parameterArgs.map(parm => realType(parm.type)),\n            result,\n            reads: [],\n            writes: [\"arbitraryCode\", \"memory\"], // the arbitrary code may write to memory\n\n            copy() {\n                return () => this;\n            }\n        })];\n}\n\nexport function internalFunctions(ctx: WFnGenerator, e: CFunctionCall, discard: boolean): WInstruction[] | undefined {\n    if (!(e.body instanceof CIdentifier)) return undefined; // indirect call\n\n    switch (e.body.value) {\n\n    case INTERNAL_FNS.wasm:\n        return arbitrary(ctx, e, null);\n    case INTERNAL_FNS.wasm_i32:\n        return arbitrary(ctx, e, i32Type);\n    case INTERNAL_FNS.wasm_i64:\n        return arbitrary(ctx, e, i64Type);\n    case INTERNAL_FNS.wasm_f32:\n        return arbitrary(ctx, e, f32Type);\n    case INTERNAL_FNS.wasm_f64:\n        return arbitrary(ctx, e, f64Type);\n\n    case INTERNAL_FNS.wasm_ssp:\n        return discard ? [] : [Instructions.global.get(ctx.gen.shadowStackPtr)];\n\n    case INTERNAL_FNS.wasm_rload:\n        if (e.args[0].type instanceof CPointer) {\n            const instr = ctx.expression(e.args[0], false);\n            const type = e.args[0].type.type;\n            if (type instanceof CStruct || type instanceof CUnion) {\n                instr.push(Instructions.i32.load(2, 0));\n            }\n            return instr;\n        }\n        throw new GenError(\"__wasm_rload__ argument should be pointer\");\n\n    default:\n        return undefined;\n\n    }\n}\n","import {getFlags} from \"../optimisation/flags\";\nimport {CFuncDefinition, CFuncDeclaration} from \"../ir/declarations\";\nimport {CIdentifier} from \"../ir/expressions\";\nimport * as c from \"../ir/expressions\";\nimport {evalExpression} from \"../ir/transform/constant_expressions\";\nimport {CType, CArithmetic, CPointer, CArray, CSizeT, CUnion, CStruct, CFuncType, integerPromotion} from \"../ir/types\";\nimport {i32Type, Instructions, i64Type, f32Type, f64Type, ValueType} from \"../wasm\";\nimport {WInstruction} from \"../wasm/instructions\";\nimport {GenError} from \"./gen_error\";\nimport {WFnGenerator} from \"./generator\";\nimport {storageGet, storageSet, storageUpdate, storageGetThenUpdate, getAddress} from \"./storage\";\nimport {ImplementationType, implType, conversion, valueType, realType, largeReturn, returnType} from \"./type_conversion\";\nimport {internalFunctions} from \"./wasm_functions\";\n\nfunction constant(ctx: WFnGenerator, e: c.CConstant, discard: boolean): WInstruction[] {\n    if (discard) return []; // no possible side effects\n\n    return [gInstr(valueType(e.type), \"const\", e.value)];\n}\n\nfunction identifier(ctx: WFnGenerator, e: c.CIdentifier, discard: boolean): WInstruction[] {\n    if (discard) return []; // no possible side effects\n\n    if (e.value instanceof CFuncDefinition || e.value instanceof CFuncDeclaration) {\n        // get function pointer\n        return [Instructions.i32.const(ctx.gen.indirectIndex(e.value))];\n    }\n    return storageGet(ctx, e.type, e);\n}\n\nfunction stringLiteral(ctx: WFnGenerator, e: c.CStringLiteral, discard: boolean): WInstruction[] {\n    if (discard) return []; // no possible side effects\n    const stringAddress = ctx.gen.nextStaticAddr; // chars allowed to be 1-byte aligned\n    ctx.gen.nextStaticAddr += e.value.length;\n\n    ctx.gen.module.dataSegment(stringAddress, e.value.map(Number));\n    return [Instructions.i32.const(stringAddress)];\n}\n\n/**\n * Stack has to contain function arguments.\n * If any argument (or function pointer) is varadic then it will try to manipulate the same region so need to call all\n * child expressions before storing. This means pushing everything onto the stack in the right order.\n * - evaluate normal function arguments\n * - (allocate space for large return struct/union, push as hidden extra argument)\n * - (evaluate indirect function id)\n * - (evaluate variadic arguments)\n * - (store variadic arguments)\n * - increment shadow stack pointer\n * - call function (and cleanup)\n * - decrement shadow stack pointer\n * - (push large return ptr)\n */\nfunction functionCall(ctx: WFnGenerator, e: c.CFunctionCall, discard: boolean): WInstruction[] {\n    const indirectValue: WInstruction[] = [];\n    if (e.body instanceof c.CIdentifier && (e.body.value instanceof CFuncDefinition || e.body.value instanceof CFuncDeclaration)) {\n        // normal function call\n    } else if (e.body.type instanceof CFuncType || (e.body.type instanceof CPointer && e.body.type.type instanceof CFuncType)) {\n        // indirect function call\n        indirectValue.push(...subExpr(ctx, e.body, e.body.type));\n    } else {\n        throw new GenError(\"Invalid fn call identifier\", ctx, e.body.node);\n    }\n\n    const internalExpression = internalFunctions(ctx, e, discard); // __wasm__ etc\n    if (internalExpression !== undefined) {\n        if (e.fnType.returnType.bytes > 0 && discard) internalExpression.push(Instructions.drop());\n        return internalExpression;\n    }\n\n    const instr = e.fnType.parameterTypes.flatMap((t, i) => subExpr(ctx, e.args[i], t));\n\n    let largeReturnPtr: WInstruction[] | undefined;\n    if (largeReturn(e.fnType.returnType)) {\n        largeReturnPtr = [ // address allocated for storing return value\n            Instructions.global.get(ctx.gen.shadowStackPtr),\n            Instructions.i32.const(ctx.shadowStackUsage),\n            Instructions.i32.add()\n        ];\n        // allocate space for return value\n        ctx.shadowStackUsage += 4 * Math.ceil(e.fnType.returnType.bytes / 4);\n        // push pointer onto stack as hidden argument\n        instr.push(...largeReturnPtr);\n    }\n\n    if (indirectValue.length > 0) {\n        // indirect call index\n        instr.push(...indirectValue);\n    }\n\n    let shadowUsage = ctx.shadowStackUsage;\n    if (e.fnType.variadic) {\n        // push variadic variables onto stack\n        const types: ValueType[] = [];\n        for (let i = e.fnType.parameterTypes.length; i < e.args.length; i++) {\n            // default argument promotions\n            let type = e.args[i].type;\n            if (type instanceof CArithmetic) {\n                if (type.type === \"float\") type = CArithmetic.Fp64;\n                else type = integerPromotion(type);\n            }\n\n            // storing realType so C code needs to do __wasm_rload__ to account for structs being pointers etc\n            types.unshift(realType(type));\n            instr.push(Instructions.global.get(ctx.gen.shadowStackPtr), ...subExpr(ctx, e.args[i], type));\n        }\n\n        shadowUsage += 16; // empty region to help prevent overruns\n        for (const type of types) {\n            instr.push(gInstr(type, \"store\", type === i64Type || type === f64Type ? 3 : 2, shadowUsage));\n            shadowUsage += 8;\n        }\n    }\n    if (shadowUsage > 0) {\n        // increment shadow stack pointer for callee\n        instr.push(Instructions.global.get(ctx.gen.shadowStackPtr),\n            Instructions.i32.const(shadowUsage),\n            Instructions.i32.add(),\n            Instructions.global.set(ctx.gen.shadowStackPtr));\n    }\n\n    // do actual call\n    if (indirectValue.length > 0) {\n        instr.push(Instructions.call_indirect(ctx.gen.typeIndex(e.fnType)));\n    } else {\n        // direct call\n        const fn = (e.body as CIdentifier).value as CFuncDeclaration | CFuncDefinition;\n        instr.push(Instructions.call(ctx.gen.functionIndex(fn)));\n    }\n\n    if (discard && returnType(e.fnType.returnType).length) {\n        // cleanup return value if needed\n        instr.push(Instructions.drop());\n    }\n    if (shadowUsage > 0) {\n        // restore shadow stack pointer\n        instr.push(Instructions.global.get(ctx.gen.shadowStackPtr),\n            Instructions.i32.const(shadowUsage),\n            Instructions.i32.sub(),\n            Instructions.global.set(ctx.gen.shadowStackPtr));\n    }\n    if (!discard && largeReturnPtr) {\n        // return value is the struct/union returned via the largeReturnPtr\n        instr.push(...largeReturnPtr);\n    }\n    return instr;\n}\n\nfunction memberAccess(ctx: WFnGenerator, e: c.CMemberAccess, discard: boolean): WInstruction[] {\n    if (discard) return expressionGeneration(ctx, e.body, true);\n\n    return storageGet(ctx, e.type, e);\n}\n\nfunction incrDecr(ctx: WFnGenerator, e: c.CIncrDecr, discard: boolean): WInstruction[] {\n    const amount = e.type instanceof CPointer ? e.type.type.bytes : 1;\n    const type = realType(e.type);\n\n    if (e.pos === \"post\" && !discard) {\n        return storageGetThenUpdate(ctx, e.body.type, e.body, [\n            gConst(type, amount),\n            gInstr(type, e.op === \"++\" ? \"add\" : \"sub\"),\n        ]);\n    } else {\n        // can convert post and discard => pre with discard\n\n        return storageUpdate(ctx, e.body.type, e.body, [\n            gConst(type, amount),\n            gInstr(type, e.op === \"++\" ? \"add\" : \"sub\"),\n        ], !discard && e.pos === \"pre\");\n    }\n}\n\nfunction addressOf(ctx: WFnGenerator, e: c.CAddressOf, discard: boolean): WInstruction[] {\n    if (discard) return expressionGeneration(ctx, e.body, true); // get any side effects\n\n    if (e.body instanceof CIdentifier && (e.body.value instanceof CFuncDefinition || e.body.value instanceof CFuncDeclaration)) {\n        // get function pointer\n        return [Instructions.i32.const(ctx.gen.indirectIndex(e.body.value))];\n    }\n    return getAddress(ctx, e.body);\n}\n\nfunction dereference(ctx: WFnGenerator, e: c.CDereference, discard: boolean): WInstruction[] {\n    if (discard) return expressionGeneration(ctx, e.body, true); // get any side effects\n\n    if (e.type instanceof CPointer && e.type.original instanceof CFuncType) { // pointer generation\n        // don't do final deref of function pointers\n        return expressionGeneration(ctx, e.body, false);\n    }\n    return storageGet(ctx, e.type, e);\n}\n\nfunction unaryPlusMinus(ctx: WFnGenerator, e: c.CUnaryPlusMinus, discard: boolean): WInstruction[] {\n    if (discard) return expressionGeneration(ctx, e.body, true); // get any side effects\n\n    const instr = expressionGeneration(ctx, e.body, false);\n    if (e.op === \"-\") {\n        const type = implType(e.body.type);\n        if (type === f32Type || type === f64Type) {\n            instr.push(fInstr(type, \"neg\"));\n        } else {\n            instr.unshift(gConst(type, 0));\n            instr.push(gInstr(type, \"sub\"));\n        }\n    }\n    return instr;\n}\n\nfunction bitwiseNot(ctx: WFnGenerator, e: c.CBitwiseNot, discard: boolean): WInstruction[] {\n    if (discard) return expressionGeneration(ctx, e.body, true); // get any side effects\n\n    const wType = valueType(e.type);\n    return [...subExpr(ctx, e.body, e.type), iInstr(wType, \"const\", -1n), iInstr(wType, \"xor\")];\n}\n\nfunction logicalNot(ctx: WFnGenerator, e: c.CLogicalNot, discard: boolean): WInstruction[] {\n    if (discard) return expressionGeneration(ctx, e.body, true); // get any side effects\n\n    const instr = expressionGeneration(ctx, e.body, false);\n    const wType = realType(e.body.type);\n\n    if (isIValueType(wType)) {\n        return [...instr, iInstr(wType, \"eqz\")];\n    } else {\n        return [...instr, fInstr(wType, \"const\", 0), fInstr(wType, \"eq\")];\n    }\n}\n\nfunction sizeof(ctx: WFnGenerator, e: c.CSizeof, discard: boolean): WInstruction[] {\n    if (discard) return []; // no possible side effects\n\n    return [Instructions.i32.const(e.body.bytes)];\n}\n\nfunction cast(ctx: WFnGenerator, e: c.CCast, discard: boolean): WInstruction[] {\n    if (discard) return expressionGeneration(ctx, e.body, true); // get any side effects\n\n    return [...expressionGeneration(ctx, e.body, false), ...conversion(e.body.type, e.type)];\n}\n\nfunction mulDiv(ctx: WFnGenerator, e: c.CMulDiv, discard: boolean): WInstruction[] {\n    if (discard) return [...expressionGeneration(ctx, e.lhs, true), ...expressionGeneration(ctx, e.rhs, true)];\n\n    const instr = [...subExpr(ctx, e.lhs, e.type), ...subExpr(ctx, e.rhs, e.type)];\n    const wType = valueType(e.type);\n    if (isIValueType(wType)){\n        if (e.op === \"*\") instr.push(iInstr(wType, \"mul\"));\n        else instr.push(e.type.type === \"signed\" ? iInstr(wType, \"div_s\") : iInstr(wType, \"div_u\"));\n    } else {\n        instr.push(e.op === \"*\" ? fInstr(wType, \"mul\") : fInstr(wType, \"div\"));\n    }\n\n    return instr;\n}\n\nfunction mod(ctx: WFnGenerator, e: c.CMod, discard: boolean): WInstruction[] {\n    if (discard) return [...expressionGeneration(ctx, e.lhs, true), ...expressionGeneration(ctx, e.rhs, true)];\n\n    const wType = valueType(e.type);\n    if (e.type.type === \"signed\") {\n        return [...subExpr(ctx, e.lhs, e.type), ...subExpr(ctx, e.rhs, e.type), iInstr(wType, \"rem_s\")];\n    } else {\n        return [...subExpr(ctx, e.lhs, e.type), ...subExpr(ctx, e.rhs, e.type), iInstr(wType, \"rem_u\")];\n    }\n}\n\nfunction addSub(ctx: WFnGenerator, e: c.CAddSub, discard: boolean): WInstruction[] {\n    if (discard) return [...expressionGeneration(ctx, e.lhs, true), ...expressionGeneration(ctx, e.rhs, true)];\n\n    if (e.type instanceof CArithmetic) {\n        const lhs = subExpr(ctx, e.lhs, e.type);\n        const rhs = subExpr(ctx, e.rhs, e.type);\n        const wType = valueType(e.type);\n        return [...lhs, ...rhs, e.op === \"+\" ? gInstr(wType, \"add\") : gInstr(wType, \"sub\")];\n    } else {\n        // eslint-disable-next-line no-inner-declarations\n        function toExpr(side: c.CExpression) {\n            if (side.type instanceof CPointer) {\n                return ctx.expression(side, false);\n            } else { // if side.type === integer\n                const instr = subExpr(ctx, side, CArithmetic.U32);\n                const size = (e.type as CPointer).type.bytes;\n                if (size > 1) instr.push(Instructions.i32.const(size), Instructions.i32.mul());\n                return instr;\n            }\n        }\n\n        return [...toExpr(e.lhs), ...toExpr(e.rhs), e.op === \"+\" ? Instructions.i32.add() : Instructions.i32.sub()];\n    }\n}\n\nfunction shift(ctx: WFnGenerator, e: c.CShift, discard: boolean): WInstruction[] {\n    if (discard) return [...expressionGeneration(ctx, e.lhs, true), ...expressionGeneration(ctx, e.rhs, true)];\n\n    const wType = valueType(e.type);\n    if (e.dir === \"left\") {\n        return [...subExpr(ctx, e.lhs, e.type), ...subExpr(ctx, e.rhs, e.type), iInstr(wType, \"shl\")];\n    } else if (e.type.type === \"signed\") {\n        return [...subExpr(ctx, e.lhs, e.type), ...subExpr(ctx, e.rhs, e.type), iInstr(wType, \"shr_s\")];\n    } else {\n        return [...subExpr(ctx, e.lhs, e.type), ...subExpr(ctx, e.rhs, e.type), iInstr(wType, \"shr_u\")];\n    }\n}\n\nfunction relational(ctx: WFnGenerator, e: c.CRelational, discard: boolean): WInstruction[] {\n    if (discard) return [...expressionGeneration(ctx, e.lhs, true), ...expressionGeneration(ctx, e.rhs, true)];\n\n    const wType = valueType(e.commonType);\n    if (!isIValueType(wType)) {\n        return [...subExpr(ctx, e.lhs, e.commonType), ...subExpr(ctx, e.rhs, e.commonType),\n            e.op === \"LT\" ? fInstr(wType, \"lt\") :\n                e.op === \"GT\" ? fInstr(wType, \"gt\") :\n                    e.op === \"LEq\" ? fInstr(wType, \"le\") : fInstr(wType, \"ge\")];\n    } else if (e.commonType.type === \"signed\") {\n        return [...subExpr(ctx, e.lhs, e.commonType), ...subExpr(ctx, e.rhs, e.commonType),\n            e.op === \"LT\" ? iInstr(wType, \"lt_s\") :\n                e.op === \"GT\" ? iInstr(wType, \"gt_s\") :\n                    e.op === \"LEq\" ? iInstr(wType, \"le_s\") : iInstr(wType, \"ge_s\")];\n    } else {\n        return [...subExpr(ctx, e.lhs, e.commonType), ...subExpr(ctx, e.rhs, e.commonType),\n            e.op === \"LT\" ? iInstr(wType, \"lt_u\") :\n                e.op === \"GT\" ? iInstr(wType, \"gt_u\") :\n                    e.op === \"LEq\" ? iInstr(wType, \"le_u\") : iInstr(wType, \"ge_u\")];\n    }\n}\n\nfunction equality(ctx: WFnGenerator, e: c.CEquality, discard: boolean): WInstruction[] {\n    if (discard) return [...expressionGeneration(ctx, e.lhs, true), ...expressionGeneration(ctx, e.rhs, true)];\n\n    return [\n        ...subExpr(ctx, e.lhs, e.commonType),\n        ...subExpr(ctx, e.rhs, e.commonType),\n        gInstr(valueType(e.commonType), e.op === \"==\" ? \"eq\" : \"ne\")];\n}\n\nfunction bitwiseAndOr(ctx: WFnGenerator, e: c.CBitwiseAndOr, discard: boolean): WInstruction[] {\n    if (discard) return [...expressionGeneration(ctx, e.lhs, true), ...expressionGeneration(ctx, e.rhs, true)];\n\n    return [...subExpr(ctx, e.lhs, e.type), ...subExpr(ctx, e.rhs, e.type), iInstr(valueType(e.type), e.op)];\n}\n\nfunction logicalAndOr(ctx: WFnGenerator, e: c.CLogicalAndOr, discard: boolean): WInstruction[] {\n    if (discard) return [...expressionGeneration(ctx, e.lhs, true), ...expressionGeneration(ctx, e.rhs, true)];\n\n    if (e.op === \"and\") {\n        return [...condition(ctx, e.lhs), Instructions.if(i32Type, condition(ctx, e.rhs, false), [\n            Instructions.i32.const(0n)\n        ])];\n    } else { // op === \"or\"\n        return [...condition(ctx, e.lhs), Instructions.if(i32Type, [\n            Instructions.i32.const(1n)\n        ], condition(ctx, e.rhs, false))];\n    }\n}\n\nfunction conditional(ctx: WFnGenerator, e: c.CConditional, discard: boolean): WInstruction[] {\n    const test = condition(ctx, e.test);\n    if (discard) {\n        const trueSideEffects = expressionGeneration(ctx, e.trueValue, true);\n        const falseSideEffects = expressionGeneration(ctx, e.falseValue,true);\n        if (trueSideEffects.length === 0 && falseSideEffects.length === 0) return [];\n\n        return [...test, Instructions.if(null, trueSideEffects, falseSideEffects)];\n    } else {\n        return [...test, Instructions.if(realType(e.type),\n            subExpr(ctx, e.trueValue, e.type),\n            subExpr(ctx, e.falseValue, e.type))];\n    }\n}\n\nfunction assignment(ctx: WFnGenerator, e: c.CAssignment, discard: boolean): WInstruction[] {\n    if (e.assignmentType !== undefined && !(e.rhs instanceof c.CInitializer)) {\n        let body: c.CExpression;\n        if (e.assignmentType === \"mul\") {\n            body = new c.CMulDiv(e.node, e.lhs, e.rhs, \"*\");\n        } else if (e.assignmentType === \"div\") {\n            body = new c.CMulDiv(e.node, e.lhs, e.rhs, \"/\");\n        } else if (e.assignmentType === \"mod\") {\n            body = new c.CMod(e.node, e.lhs, e.rhs);\n        } else if (e.assignmentType === \"add\") {\n            body = new c.CAddSub(e.node, e.lhs, e.rhs, \"+\");\n        } else if (e.assignmentType === \"sub\") {\n            body = new c.CAddSub(e.node, e.lhs, e.rhs, \"-\");\n        } else if (e.assignmentType === \"leftShift\") {\n            body = new c.CShift(e.node, e.lhs, e.rhs, \"left\");\n        } else if (e.assignmentType === \"rightShift\") {\n            body = new c.CShift(e.node, e.lhs, e.rhs, \"right\");\n        } else if (e.assignmentType === \"bitwiseAnd\") {\n            body = new c.CBitwiseAndOr(e.node, e.lhs, e.rhs, \"and\");\n        } else if (e.assignmentType === \"bitwiseXor\") {\n            body = new c.CBitwiseAndOr(e.node, e.lhs, e.rhs, \"xor\");\n        } else {\n            body = new c.CBitwiseAndOr(e.node, e.lhs, e.rhs, \"or\");\n        }\n\n        // try to convert \"body\" into instructions, then remove the instructions which load the lhs to create transformation\n        const exprBody = expressionGeneration(ctx, body, false);\n        const lhs = expressionGeneration(ctx, e.lhs, false);\n\n        const transform = exprBody.slice(lhs.length);\n        // conversion must be added to wrap result correctly as integer promotion etc may have taken place in the body.\n        transform.push(...conversion(body.type, e.lhs.type));\n\n        return storageUpdate(ctx, e.lhs.type, e.lhs, transform, !discard);\n    } else if (e.rhs instanceof c.CInitializer) {\n        const instr: WInstruction[] = [];\n\n        if (e.rhs.type instanceof CArray) {\n            for (let i = 0; i < e.rhs.body.length; i++) {\n                const value = e.rhs.body[i];\n\n                const entryPointer = new c.CAddSub(e.lhs.node, e.lhs, new c.CConstant(e.lhs.node, CSizeT, BigInt(i)), \"+\");\n                const entryDeref = new c.CDereference(e.lhs.node, entryPointer);\n                const entryAssignment = new c.CAssignment(value.node, entryDeref, value, undefined, e.initialAssignment);\n                instr.push(...expressionGeneration(ctx, entryAssignment, true));\n            }\n        } else if (e.rhs.type instanceof CUnion) {\n            const addr = new c.CAddressOf(e.lhs.node, e.lhs);\n            const access = new c.CMemberAccess(e.rhs.node, addr, e.rhs.type.members[0].name);\n            const assignment = new c.CAssignment(e.rhs.body[0].node, access, e.rhs.body[0], undefined, true);\n            instr.push(...expressionGeneration(ctx, assignment, true));\n        } else if (e.rhs.type instanceof CStruct) {\n            const addr = new c.CAddressOf(e.lhs.node, e.lhs);\n\n            for (let i = 0; i < e.rhs.body.length; i++) {\n                const access = new c.CMemberAccess(e.rhs.node, addr, e.rhs.type.members[i].name);\n                const assignment = new c.CAssignment(e.rhs.body[i].node, access, e.rhs.body[i], undefined, true);\n                instr.push(...expressionGeneration(ctx, assignment, true));\n            }\n        } else {\n            throw new GenError(\"Unknown initializer\", ctx, e.node);\n        }\n\n        if (!discard) instr.push(...expressionGeneration(ctx, e.lhs, false));\n        return instr;\n    } else {\n        return storageSet(ctx, e.lhs.type, e.lhs, e.rhs, !discard);\n    }\n}\n\nfunction comma(ctx: WFnGenerator, e: c.CComma, discard: boolean): WInstruction[] {\n    return [...expressionGeneration(ctx, e.lhs, true), ...expressionGeneration(ctx, e.rhs, discard)];\n}\n\nexport function expressionGeneration(ctx: WFnGenerator, e: c.CExpression, discard: boolean): WInstruction[] {\n    if (!discard && e.type instanceof CArithmetic && !(e instanceof c.CConstant) && getFlags().generation_try_constant_expr) {\n        // try to evaluate as constant expression\n        const value = evalExpression(e);\n        if (value) return constant(ctx, new c.CConstant(e.node, e.type, value.value), false);\n    }\n\n    if (e instanceof c.CConstant) return constant(ctx, e, discard);\n    else if (e instanceof c.CIdentifier) return identifier(ctx, e, discard);\n    else if (e instanceof c.CStringLiteral) return stringLiteral(ctx, e, discard);\n    else if (e instanceof c.CFunctionCall) return functionCall(ctx, e, discard);\n    else if (e instanceof c.CMemberAccess) return memberAccess(ctx, e, discard);\n    else if (e instanceof c.CIncrDecr) return incrDecr(ctx, e, discard);\n    else if (e instanceof c.CAddressOf) return addressOf(ctx, e, discard);\n    else if (e instanceof c.CDereference) return dereference(ctx, e, discard);\n    else if (e instanceof c.CUnaryPlusMinus) return unaryPlusMinus(ctx, e, discard);\n    else if (e instanceof c.CBitwiseNot) return bitwiseNot(ctx, e, discard);\n    else if (e instanceof c.CLogicalNot) return logicalNot(ctx, e, discard);\n    else if (e instanceof c.CSizeof) return sizeof(ctx, e, discard);\n    else if (e instanceof c.CCast) return cast(ctx, e, discard);\n    else if (e instanceof c.CMulDiv) return mulDiv(ctx, e, discard);\n    else if (e instanceof c.CMod) return mod(ctx, e, discard);\n    else if (e instanceof c.CAddSub) return addSub(ctx, e, discard);\n    else if (e instanceof c.CShift) return shift(ctx, e, discard);\n    else if (e instanceof c.CRelational) return relational(ctx, e, discard);\n    else if (e instanceof c.CEquality) return equality(ctx, e, discard);\n    else if (e instanceof c.CBitwiseAndOr) return bitwiseAndOr(ctx, e, discard);\n    else if (e instanceof c.CLogicalAndOr) return logicalAndOr(ctx, e, discard);\n    else if (e instanceof c.CConditional) return conditional(ctx, e, discard);\n    else if (e instanceof c.CAssignment) return assignment(ctx, e, discard);\n    else return comma(ctx, e, discard);\n}\n\n// helpers\n/** expressionGeneration + casting */\nexport function subExpr(ctx: WFnGenerator, e: c.CExpression, desiredType: CType, discard: boolean = false): WInstruction[] {\n    const fakeCast = new c.CCast(e.node, desiredType, e);\n    return expressionGeneration(ctx, fakeCast, discard);\n}\n\nexport function condition(ctx: WFnGenerator, e: c.CExpression, anyNonZeroI32 = true): WInstruction[] {\n    const wType = implType(e.type);\n    if (wType === i32Type || wType instanceof CPointer) {\n        if (anyNonZeroI32 || CArithmetic.BOOL.equals(e.type)) {\n            return expressionGeneration(ctx, e, false);\n        } else {\n            return [...expressionGeneration(ctx, e, false), Instructions.i32.const(0n), Instructions.i32.ne()];\n        }\n    } else if (typeof wType !== \"number\") {\n        throw new GenError(\"Invalid condition\", ctx, e.node);\n    }\n    return [...expressionGeneration(ctx, e, false), gConst(wType, 0), gInstr(wType, \"ne\")];\n}\n\nfunction isIValueType(w: ImplementationType) {\n    return w === i32Type || w === i64Type;\n}\n\n/** f32 or f64 instruction */\nfunction fInstr(t: ImplementationType, op: (keyof typeof Instructions.f32 & keyof typeof Instructions.f64), ...args: any[]) {\n    if (typeof t !== \"number\") throw new Error(\"Instructions can only operate on value types\");\n\n    if (t === f32Type) {\n        // @ts-ignore\n        return Instructions.f32[op](...args);\n    } else if (t === f64Type) {\n        // @ts-ignore\n        return Instructions.f64[op](...args);\n    }\n    throw new Error(\"Invalid value type for floating point instruction\");\n}\n\n/** i32 or i64 instruction */\nfunction iInstr(t: ImplementationType, op: (keyof typeof Instructions.i32 & keyof typeof Instructions.i64), ...args: any[]) {\n    if (typeof t !== \"number\") throw new Error(\"Instructions can only operate on value types\");\n\n    if (t === i32Type) {\n        // @ts-ignore\n        return Instructions.i32[op](...args);\n    } else if (t === i64Type) {\n        // @ts-ignore\n        return Instructions.i64[op](...args);\n    }\n    throw new Error(\"Invalid value type for integer instruction\");\n}\n\n/** generic instruction - i32, i64, f32 or f64 */\nexport function gInstr(t: ImplementationType, op: (keyof typeof Instructions.i32 & keyof typeof Instructions.i64 & keyof typeof Instructions.f32 & keyof typeof Instructions.f64), ...args: any[]): WInstruction {\n    if (typeof t !== \"number\") throw new Error(\"Instructions can only operate on value types\");\n\n    if (t === i32Type) {\n        // @ts-ignore\n        return Instructions.i32[op](...args);\n    } else if (t === i64Type) {\n        // @ts-ignore\n        return Instructions.i64[op](...args);\n    } else if (t === f32Type) {\n        // @ts-ignore\n        return Instructions.f32[op](...args);\n    } else if (t === f64Type) {\n        // @ts-ignore\n        return Instructions.f64[op](...args);\n    }\n    throw new Error(\"Invalid value type?\");\n}\n\n/** generic constant */\nfunction gConst(t: ImplementationType, n: number) {\n    if (typeof t !== \"number\") throw new Error(\"Constants can only take value types\");\n    if (t !== (t | 0)) throw new Error(\"Invalid generic constant - not integer\");\n\n    if (t === i32Type) {\n        return Instructions.i32.const(BigInt(n));\n    } else if (t === i64Type) {\n        return Instructions.i64.const(BigInt(n));\n    } else if (t === f32Type) {\n        return Instructions.f32.const(n);\n    } else if (t === f64Type) {\n        return Instructions.f64.const(n);\n    }\n    throw new Error(\"Invalid value type?\");\n}\n","import {gInstr} from \"../../generation/expressions\";\nimport {WExpression, Instructions} from \"../../wasm\";\nimport {InstrInstance} from \"../../wasm/instr_helpers\";\nimport {InstrFlow, simplifiedControlFlow, Flow} from \"./control_flow\";\nimport {framework} from \"./framework\";\n\ntype DUChain = { // def-use chain\n    readonly local: bigint,\n    possibleUses: InstrFlow[], // instructions which reference this definition\n    definiteUses: InstrFlow[], // instructions which reference this definition and no other possible definition\n    bit: bigint,\n} & ({type: \"arg\"} | {type: \"local.set\" | \"local.tee\", flow: InstrFlow});\n\nfunction reachingDefinitions(expr: WExpression): { definitions: DUChain[], reaching: Map<Flow, bigint>, localMasks: bigint[] } {\n    const cfg = simplifiedControlFlow(expr, instr => instr.name.startsWith(\"local.\"));\n\n    const reaching = new Map<Flow, bigint>();\n    const flowDefMap = new Map<InstrFlow, DUChain>();\n    const duChains: DUChain[] = [];\n\n    // masks containing the bits for each local allowing quick killing of all a locals definitions\n    const localMasks: bigint[] = Array(expr.builder.args.length + expr.builder.locals.length).fill(0n);\n\n    // entry definitions are the function parameters\n    let entryDefinitions = 0n;\n    for (let i = 0n; i < expr.builder.args.length; i++) {\n        const d: DUChain = {\n            local: i, type: \"arg\",\n            possibleUses: [], definiteUses: [],\n            bit: 1n << BigInt(duChains.length)\n        };\n        entryDefinitions |= d.bit;\n        localMasks[Number(i)] |= d.bit;\n        duChains.push(d);\n    }\n    reaching.set(cfg.entry, entryDefinitions);\n\n    // definition objects for each of local.set/tee instructions\n    for (const f of cfg.all) {\n        if (f.instr.type === \"index\" && (f.instr.name === \"local.set\" || f.instr.name === \"local.tee\")) {\n            const d: DUChain = {\n                local: f.instr.immediate.value, type: f.instr.name,\n                possibleUses: [], definiteUses: [],\n                flow: f, bit: 1n << BigInt(duChains.length)\n            };\n            localMasks[Number(d.local)] |= d.bit;\n            flowDefMap.set(f, d);\n            duChains.push(d);\n        }\n    }\n\n    framework(cfg, null, reaching,\"forwards\", \"union\", (f, x) => {\n        const flowDef = flowDefMap.get(f as InstrFlow);\n        if (flowDef) {\n            x &= ~localMasks[Number(flowDef.local)];\n            x |= flowDef.bit;\n        }\n        return x;\n    });\n\n    // fill in usage info\n    for (const [flow, defs] of reaching.entries()) {\n        if (!flow.instr || flow.instr.type !== \"index\" || flow.instr.name !== \"local.get\") continue;\n        const local = flow.instr.immediate.value;\n\n        const localDefs = [];\n        for (let i = 0, bits = defs & localMasks[Number(local)]; bits; i++) {\n            if (bits & 1n) localDefs.push(duChains[i]);\n            bits >>= 1n;\n        }\n\n        if (localDefs.length === 1) {\n            localDefs[0].definiteUses.push(flow);\n        }\n        localDefs.forEach(d => d.possibleUses.push(flow));\n    }\n\n    return {definitions: duChains, reaching, localMasks};\n}\n\n// find the instruction which created the result consumed by this instruction\nfunction findValueInstr(f: InstrFlow): InstrInstance | undefined {\n    let len = f.instr.parameters.length;\n    for (let i = f.instrIndex - 1; i >= 0; i--) {\n        const instr = f.expr.instructions[i];\n        if (instr.result) len--;\n        if (len === 0) return instr;\n        len += instr.parameters.length;\n    }\n    return undefined;\n}\n\nexport function copyPropagation(expr: WExpression): void {\n    const {definitions, reaching, localMasks} = reachingDefinitions(expr);\n    if (!definitions.length) return; // couldn't analyze\n\n    for (const def of definitions) {\n        if (def.type === \"arg\") continue;\n\n        if (def.possibleUses.length === 0) {\n            // never used so drop the assignment\n            dropAssignment(def.flow);\n            continue;\n        }\n\n        // check if there are definite uses which we would be able to inline / propagate\n        if (def.definiteUses.length === 0) continue;\n\n        const valueInstr = findValueInstr(def.flow);\n        if (valueInstr?.type === \"constant\") {\n            // constant propagation\n            const replacement = gInstr(def.flow.instr.parameters[0], \"const\", valueInstr.immediate.value);\n\n            for (const use of def.definiteUses) {\n                use.expr.replace(use.instrIndex, use.instrIndex + 1, replacement);\n            }\n        } else if (valueInstr?.type === \"index\" && (valueInstr.name === \"local.get\" || valueInstr.name === \"local.tee\")) {\n            // copy propagation\n            const getFlow = [...def.flow.flowPrevious].find(f => f.instr && f.instrIndex === def.flow.instrIndex - 1 && f.expr === def.flow.expr);\n            if (!getFlow) continue; // needed to look up the valid definitions\n            const getLocal = Number(valueInstr.immediate.value);\n            const getDefs = (reaching.get(getFlow) ?? 0n) & localMasks[getLocal];\n\n            const replacement = Instructions.local.get(getLocal);\n            let replacedAll = true;\n            for (const use of def.definiteUses) {\n                if (getDefs === ((reaching.get(use) ?? 0n) & localMasks[getLocal])) {\n                    // have to be careful to only replace where the same definition of getLocal is validate\n                    use.expr.replace(use.instrIndex, use.instrIndex + 1, replacement);\n                } else {\n                    replacedAll = false; // getLocal has been redefined so can't replace\n                }\n            }\n            if (!replacedAll) continue;\n        } else {\n            continue;\n        }\n\n        if (def.definiteUses.length === def.possibleUses.length) {\n            // can remove the assignment if no extra possible uses\n            dropAssignment(def.flow);\n        }\n    }\n}\n\nfunction dropAssignment(f: InstrFlow) {\n    if (f.instr.name === \"local.tee\") {\n        f.expr.replace(f.instrIndex, f.instrIndex + 1, Instructions.nop()); // use nop to avoid changing indices\n    } else if (f.instr.name === \"local.set\") {\n        f.expr.replace(f.instrIndex, f.instrIndex + 1, Instructions.drop());\n    }\n}\n","import {WExpression, Instructions, WFunction} from \"../wasm\";\nimport {WLocal} from \"../wasm/functions\";\nimport {deadCodeElimination} from \"./dead_code\";\nimport {getFlags} from \"./flags\";\nimport {realloc_locals, remapLocals} from \"./flow/local_allocation\";\nimport {pre} from \"./flow/pre\";\nimport {rangeSplitting} from \"./flow/range_splitting\";\nimport {copyPropagation} from \"./flow/reaching_defs\";\nimport {Optimiser} from \"./optimiser\";\nimport {peepholeMulti, peepholeOptimisers} from \"./peephole\";\n\nconst optimisers: Optimiser[] = [];\n\nexport function optimise(fn: WFunction): void {\n    const flags = getFlags(), expr = fn.body;\n\n    fn.instrCounts.push({name: \"before opt\", count: countInstructions(expr)});\n    for (const optimiser of optimisers) {\n        if (optimiser.enabled(flags)) {\n            optimiser.run(expr);\n            fn.instrCounts.push({name: optimiser.name, count: countInstructions(expr)});\n        }\n    }\n}\n\nfunction countInstructions(expr: WExpression): number {\n    let num = expr.instructions.length;\n    for (const instr of expr.instructions) {\n        if (instr.type === \"structured\") {\n            num += countInstructions(instr.immediate.expression);\n            if (instr.immediate.expression2) num += countInstructions(instr.immediate.expression2);\n        }\n    }\n    return num;\n}\n\nfunction peepholeOptimisations(expr: WExpression) {\n    const flags = getFlags();\n    peepholeMulti(expr, peepholeOptimisers.filter(x => x.enabled(flags)).map(x => [x.run, x.peepholeSize]));\n}\n\noptimisers.push({\n    name: \"Peephole optimisations\",\n    enabled: () => true,\n    run: peepholeOptimisations\n});\n\noptimisers.push({\n    name: \"Partial redundancy elimination\",\n    enabled: (flags) => flags.partial_redundancy_elimination,\n    run: pre\n});\n\noptimisers.push({\n    name: \"Dead code elimination\",\n    enabled: (flags) => flags.dead_code_elimination,\n    run: deadCodeElimination\n});\n\noptimisers.push({\n    name: \"Copy propagation\",\n    enabled: (flags) => flags.copy_propagation,\n    run: copyPropagation\n});\n\noptimisers.push({\n    name: \"Local live range splitting\",\n    enabled: (flags) => flags.live_range_splitting,\n    run: rangeSplitting\n});\n\noptimisers.push({\n    name: \"Reallocate locals\",\n    enabled: (flags) => flags.reallocate_locals,\n    run: realloc_locals // must be ran when there are no redundant variables, i.e. immediate after copy propagation\n});\n\noptimisers.push({\n    name: \"Dead code elimination 2nd pass\",\n    enabled: (flags) => flags.dead_code_elimination,\n    run: deadCodeElimination\n});\n\noptimisers.push({\n    name: \"Remove unused locals\",\n    enabled: (flags) => flags.unused_locals,\n    run: (expr) => {\n        const usedLocals = new Set<WLocal>();\n        for (const resource of [...expr.writes, ...expr.reads]) {\n            if (resource instanceof WLocal && !resource.isArgument) usedLocals.add(resource);\n        }\n        if (usedLocals.size === expr.builder.locals.length) return;\n\n        // store current list of locals to enable lookup when re-encoding\n        const oldLocals = expr.builder.args.slice();\n        oldLocals.push(...expr.builder.locals);\n\n        // remove any unused locals from builder\n        for (const local of expr.builder.locals.slice()) { // slice needed to avoid modifying whilst iterating\n            if (!usedLocals.has(local)) {\n                expr.builder.deleteLocal(local);\n            }\n        }\n\n        // now have to re-encode any local instructions\n        remapLocals(expr, oldLocals);\n    }\n});\n\noptimisers.push({\n    name: \"Peephole optimisations 2nd pass\",\n    enabled: (flags) => flags.peephole_2nd_pass,\n    run: peepholeOptimisations\n});\n","import {optimise} from \"../optimisation\";\nimport {getFlags} from \"../optimisation/flags\";\nimport {funcidx, localidx, byte, tableidx} from \"./base_types\";\nimport {encodeU32} from \"./encoding\";\nimport {WExpression, WInstruction, Instructions} from \"./instructions\";\nimport {ModuleBuilder} from \"./module\";\nimport {ValueType, FunctionType, encodeVec} from \"./wtypes\";\n\n\nexport class WImportedFunction {\n    constructor(readonly parent: ModuleBuilder, readonly type: FunctionType, readonly module: string, readonly name: string) {\n    }\n\n    getIndex(): funcidx {\n        return this.parent._funcIndex(this);\n    }\n\n    getTableIndex(): tableidx {\n        return this.parent._tableIndex(this);\n    }\n}\n\nexport class WFunction {\n    private _builder?: WFunctionBuilder;\n    readonly hints: {inline: boolean} = {inline: false};\n    readonly instrCounts: {name: string, count: number}[] = [];\n\n    constructor(readonly parent: ModuleBuilder, readonly type: FunctionType, readonly exportName?: string) {\n    }\n\n    getIndex(): funcidx {\n        return this.parent._funcIndex(this);\n    }\n\n    getTableIndex(): tableidx {\n        return this.parent._tableIndex(this);\n    }\n\n    define(bodyFn: (b: WFunctionBuilder) => WInstruction[]): void {\n        if (this._builder !== undefined) throw new Error(`Wasm function already defined`);\n        this._builder = new WFunctionBuilder(this, bodyFn);\n        optimise(this);\n\n        const expr = this._builder.expr; // clean up function returns\n        if (this.type[1].length > 0) {\n            // if function returns something\n            const finalInstr = expr.get(-1);\n            if (finalInstr.name === \"return\") {\n                // final return can be implicit\n                expr.pop();\n            } else if (expr.stack.length === 0 && finalInstr.name !== \"unreachable\") {\n                // no return at end of function or value left on stack, must return elsewhere\n                expr.push(Instructions.unreachable());\n            }\n        }\n    }\n\n    toBytes(): byte[] {\n        if (this._builder === undefined) throw new Error(`Wasm function body not defined`);\n\n        // RLE is used to compress locals\n        const locals: [count: bigint, type: ValueType][] = [];\n        let lastType: ValueType | null = null;\n        let count = 0n;\n        for (const localType of this.locals) {\n            if (localType === lastType) {\n                count++;\n            } else {\n                if (lastType) locals.push([count, lastType]);\n                lastType = localType;\n                count = 1n;\n            }\n        }\n        if (lastType) locals.push([count, lastType]);\n\n        // encode function body\n        const code: byte[] = encodeVec(locals.map(x => [...encodeU32(x[0]), x[1]])); // locals\n        code.push(...this._builder.expr.encoded); // expression\n        code.unshift(...encodeU32(BigInt(code.length)));\n        return code;\n    }\n\n    get locals(): ReadonlyArray<ValueType> {\n        return this._builder?.locals?.map(x => x.type) ?? [];\n    }\n\n    get body(): WExpression {\n        if (!this._builder) throw new Error(\"Wasm function body is not yet defined\");\n        return this._builder.expr;\n    }\n}\n\nexport class WFunctionBuilder {\n    private readonly _arguments: WLocal[];\n    private readonly _locals: WLocal[] = [];\n    private readonly _freeTempLocals: WLocal[] = [];\n    readonly expr: WExpression;\n\n    constructor(readonly fn: WFunction, bodyFn: (b: WFunctionBuilder) => WInstruction[]) {\n        this._arguments = fn.type[0].map(t => new WLocal(this._localidx.bind(this), t, true));\n\n        this.expr = new WExpression(null, 0, this);\n        this.expr.push(...bodyFn(this));\n    }\n\n    get locals(): ReadonlyArray<WLocal> {\n        return this._locals;\n    }\n\n    addLocal(t: ValueType): WLocal {\n        const local = new WLocal(this._localidx.bind(this), t, false);\n        this._locals.push(local);\n        return local;\n    }\n\n    getTempLocal(type: ValueType): WLocal {\n        const index = this._freeTempLocals.findIndex(x => x.type === type);\n        if (index < 0) {\n            // no previous temporary local can be used, allocate a new one\n            return this.addLocal(type);\n        } else {\n            // reuse temporary local\n            return this._freeTempLocals.splice(index, 1)[0];\n        }\n    }\n\n    freeTempLocal(local: WLocal): void {\n        if (getFlags().reallocate_locals) {\n            // don't actually reuse variables - we will reallocate locals later\n            return;\n        }\n        this._freeTempLocals.push(local);\n    }\n\n    deleteLocal(local: WLocal): void {\n        // WARNING! this will invalidate any instructions already encoded\n        const index = this._locals.indexOf(local);\n        if (index >= 0) this._locals.splice(index, 1);\n    }\n\n    wipeLocals(): void {\n        // WARNING! this will invalidate any instructions already encoded\n        this._locals.splice(0, this._locals.length);\n    }\n\n    get args(): ReadonlyArray<WLocal> {\n        return this._arguments;\n    }\n\n    get self(): {getIndex(): funcidx} {\n        return {getIndex: this.fn.getIndex.bind(this.fn)};\n    }\n\n    get type(): FunctionType {\n        return this.fn.type;\n    }\n\n    getLocal(index: localidx): WLocal {\n        const i = Number(index);\n        if (index < this._arguments.length) return this._arguments[i];\n        return this._locals[i - this._arguments.length];\n    }\n\n    private _localidx(l: WLocal) {\n        let idx = this._arguments.indexOf(l);\n        if (idx >= 0) return BigInt(idx) as localidx;\n        idx = this._locals.indexOf(l);\n        if (idx >= 0) return BigInt(this._arguments.length + idx) as localidx;\n        throw \"Local not found?\";\n    }\n}\n\nexport class WLocal {\n    constructor(private readonly lookup: (l: WLocal) => localidx, readonly type: ValueType, readonly isArgument: boolean) {\n    }\n\n    getIndex(): localidx {\n        return this.lookup(this);\n    }\n}\n","import {byte, typeidx, funcidx, globalidx, tableidx} from \"./base_types\";\nimport {encodeU32, encodeUtf8, encodeConstantInstr} from \"./encoding\";\nimport {WFunctionBuilder, WFunction, WImportedFunction} from \"./functions\";\nimport {WGlobal} from \"./global\";\nimport {WInstruction} from \"./instructions\";\nimport {encodeVec, ResultType, encodeFunctionType, FunctionType, MemoryType, encodeLimits, ValueType, i32Type} from \"./wtypes\";\n\nexport class ModuleBuilder {\n    private _functions: WFunction[] = [];\n    private _importedFunctions: WImportedFunction[] = [];\n    private _functionTable: (WFunction | WImportedFunction)[] = [];\n    private _functionTypes: FunctionType[] = [];\n    private _globals: WGlobal[] = [];\n    private _memory?: MemoryType;\n    private _dataSegments: [offset: number, contents: byte[]][] = [];\n    startFunction?: WFunction;\n    emitCallback?: () => void;\n\n    function(params: ResultType, returnValue: ResultType, bodyFn?: (b: WFunctionBuilder) => WInstruction[], exportName?: string): WFunction {\n        const type: FunctionType = [params, returnValue];\n        const fn = new WFunction(this, type, exportName);\n        this._functions.push(fn);\n        if (bodyFn) fn.define(bodyFn); // have to add to list before defining to enable recursive calls\n        return fn;\n    }\n\n    importFunction(param: ResultType, returnValue: ResultType, module: string, name: string): WImportedFunction {\n        if (this._functions.length > 0) throw new Error(\"Cannot define an imported functions after defining normal functions\");\n\n        const fn = new WImportedFunction(this, [param, returnValue], module, name);\n        this._importedFunctions.push(fn);\n        return fn;\n    }\n\n    global(type: ValueType, mutable: boolean, initialValue: number | bigint, exportName?: string): WGlobal {\n        const g = new WGlobal(this, type, mutable, initialValue, exportName);\n        this._globals.push(g);\n        return g;\n    }\n\n    setupMemory(initial64kPages: number, maximum64kPages?: number): void {\n        if (initial64kPages < 1 || (maximum64kPages !== undefined && maximum64kPages < initial64kPages)) {\n            throw new Error(\"Invalid memory size\");\n        }\n\n        if (maximum64kPages === undefined) {\n            this._memory = [BigInt(initial64kPages)];\n        } else {\n            this._memory = [BigInt(initial64kPages), BigInt(maximum64kPages)];\n        }\n    }\n\n    dataSegment(offset: number, contents: byte[] | number[]): void {\n        // remove 0s from the start\n        let startIdx = 0;\n        while (startIdx < contents.length && contents[startIdx] === 0) startIdx++;\n        // always slice to ensure we take a copy\n        contents = contents.slice(startIdx);\n        offset += startIdx;\n\n        // remove 0s from the end\n        while (contents.length && contents[contents.length - 1] === 0) contents.pop();\n\n        if (contents.length) this._dataSegments.push([offset, contents as byte[]]);\n    }\n\n    private byteList(): byte[] {\n        const imports = this._encodeImports();\n        const funcTypes = this._functions.map(x => encodeU32(this._typeIndex(x.type)));\n        const code = this._functions.map(x => x.toBytes());\n        if (this.emitCallback) this.emitCallback();\n\n        const startSection: byte[] = [];\n        if (this.startFunction) {\n            startSection.push(...encodeU32(this.startFunction.getIndex()));\n            // do section encoding manually as this is the only non-vector section\n            startSection.unshift(8 as byte, ...encodeU32(BigInt(startSection.length)));\n        }\n\n        // TODO name custom section for local names (+ fn names?)\n        return [\n            0x00, 0x61, 0x73, 0x6D, // magic\n            0x01, 0x00, 0x00, 0x00, // version\n            ...encodeSection(1, this._functionTypes.map(encodeFunctionType)), // type section\n            ...encodeSection(2, imports), // import section\n            ...encodeSection(3, funcTypes), // function section,\n            ...encodeSection(4, this._encodeTable()), // table section\n            ...encodeSection(5, this._memory ? [encodeLimits(this._memory)] : []), // memory section\n            ...encodeSection(6, this._globals.map(x => x.toBytes())), // globals section\n            ...encodeSection(7, this._encodeExports()), // export section\n            ...startSection, // 8, start function section\n            ...encodeSection(9, this._encodeElements()),\n            ...encodeSection(10, code), // code section\n            ...encodeSection(11, this._encodeDataSegments()) // data segments section\n        ] as byte[];\n    }\n\n    toBytes(): Uint8Array {\n        return new Uint8Array(this.byteList());\n    }\n\n    async execute(imports: WebAssembly.Imports): Promise<WebAssembly.Exports> {\n        const module = await WebAssembly.instantiate(this.toBytes(), imports);\n        return module.instance.exports;\n    }\n\n    private _encodeImports(): byte[][] {\n        const imports: byte[][] = [];\n\n        for (const i of this._importedFunctions) {\n            imports.push([...encodeUtf8(i.module), ...encodeUtf8(i.name), 0x00 as byte, ...encodeU32(this._typeIndex(i.type))]);\n        }\n\n        return imports;\n    }\n\n    private _encodeTable(): byte[][] {\n        if (this._functionTable.length === 0) return [];\n\n        const tableSize = BigInt(this._functionTable.length);\n        const table: byte[] = [0x70 as byte, ...encodeLimits([tableSize, tableSize])];\n        return [table];\n    }\n\n    private _encodeExports(): byte[][] {\n        const exports: byte[][] = [];\n\n        for (const i of this._functions) {\n            if (i.exportName) exports.push([...encodeUtf8(i.exportName), 0x00 as byte, ...encodeU32(i.getIndex())]);\n        }\n        for (const i of this._globals) {\n            if (i.exportName) exports.push([...encodeUtf8(i.exportName), 0x03 as byte, ...encodeU32(i.getIndex())]);\n        }\n        if (this._memory) exports.push([...encodeUtf8(\"__mem\"), 0x02 as byte, 0x00 as byte]);\n\n        return exports;\n    }\n\n    private _encodeElements(): byte[][] {\n        if (this._functionTable.length === 0) return [];\n\n        return [[0x00 as byte,\n            ...encodeConstantInstr(0, i32Type), 0x0B as byte, // i32.const expression\n            ...encodeVec(this._functionTable.map(x => encodeU32(x.getIndex())))]];\n    }\n\n    private _encodeDataSegments(): byte[][] {\n        if (this._dataSegments.length > 0 && this._memory === undefined) {\n            throw new Error(\"Cannot use data segments with memory disabled\");\n        }\n\n        // sort into offset order\n        this._dataSegments.sort((a,b) => a[0] - b[0]);\n\n        // merge segments\n        let lastEnd = -Infinity;\n        for (let i = 0; i < this._dataSegments.length; i++) {\n            const [offset, contents] = this._dataSegments[i];\n            if (lastEnd + 5 >= offset) { // between each segment min 5 byte overhead (0x00, 0x41, [offset], 0x0B, [size])\n                const previousContents = this._dataSegments[i - 1][1];\n                for (let i = lastEnd; i < offset; i++) previousContents.push(0 as byte);\n                previousContents.push(...contents);\n\n                this._dataSegments.splice(i, 1); // remove this segment now we have merged\n                i--;\n            }\n            lastEnd = offset + contents.length;\n        }\n\n        // convert each offset into `expression(i32.const offset)`\n        return this._dataSegments.map(([offset, contents]) => [0x00 as byte,\n            ...encodeConstantInstr(offset, i32Type), 0x0B as byte, // i32.const expression\n            ...encodeU32(BigInt(contents.length)), ...contents]); // byte vector\n    }\n\n    _funcIndex(fn: WFunction | WImportedFunction): funcidx {\n        let idx: number;\n        if (fn instanceof WImportedFunction) {\n            idx = this._importedFunctions.indexOf(fn);\n        } else {\n            idx = this._functions.indexOf(fn);\n        }\n        if (idx < 0) throw new Error(\"Function not found?\");\n        if (fn instanceof WFunction) idx += this._importedFunctions.length;\n        return BigInt(idx) as funcidx;\n    }\n\n    _tableIndex(fn: WFunction | WImportedFunction): tableidx {\n        let idx = this._functionTable.indexOf(fn);\n        if (idx < 0) {\n            idx = this._functionTable.push(fn) - 1;\n        }\n        return BigInt(idx) as tableidx;\n    }\n\n    _typeIndex(x: FunctionType): typeidx {\n        for (let i = 0; i < this._functionTypes.length; i++) {\n            const f = this._functionTypes[i];\n            if (f[0].length === x[0].length && f[0].every((v, i) => v === x[0][i]) &&\n                f[1].length === x[1].length && f[1].every((v, i) => v === x[1][i])) {\n                return BigInt(i) as typeidx;\n            }\n        }\n        return BigInt(this._functionTypes.push(x) - 1) as typeidx;\n    }\n\n    _globalIndex(g: WGlobal): globalidx {\n        const idx = this._globals.indexOf(g);\n        if (idx < 0) throw new Error(\"Global not found?\");\n        return BigInt(idx) as globalidx;\n    }\n\n    get functions(): ReadonlyArray<WFunction> {\n        return this._functions;\n    }\n\n    get functionImports(): ReadonlyArray<WImportedFunction> {\n        return this._importedFunctions;\n    }\n\n    _functionLookup(f: funcidx): WFunction | WImportedFunction {\n        if (f < this._importedFunctions.length) return this._importedFunctions[Number(f)];\n        return this._functions[Number(f) - this._importedFunctions.length];\n    }\n\n    _typeLookup(t: typeidx): FunctionType {\n        return this._functionTypes[Number(t)];\n    }\n\n    _globalLookup(g: globalidx): WGlobal {\n        return this._globals[Number(g)];\n    }\n\n    _inFunctionTable(f: WFunction | WImportedFunction): boolean {\n        return this._functionTable.indexOf(f) >= 0;\n    }\n\n    _removeFunction(f: WFunction): void {\n        const idx = this._functions.indexOf(f);\n        if (idx >= 0) this._functions.splice(idx, 1);\n    }\n}\n\nfunction encodeSection(id: number, vec: byte[][]): byte[] {\n    if (vec.length === 0) return [];\n\n    const contents = encodeVec(vec);\n    return [id as byte, ...encodeU32(BigInt(contents.length)), ...contents];\n}\n","import {ModuleBuilder, WFunction, WExpression, Instructions} from \"../../wasm\";\nimport type {funcidx} from \"../../wasm/base_types\";\nimport {remapLocals} from \"../flow/local_allocation\";\nimport {optimise} from \"../index\";\nimport {peephole} from \"../peephole\";\nimport {InstrSplicer} from \"../splicer\";\n\nexport function inlineFunctions(module: ModuleBuilder): void {\n    const map = FnInfo.infoMap(module);\n    const modifiedFns = new Set<WFunction>();\n\n    const splicer = new InstrSplicer();\n    for (const info of map.values()) {\n        for (const usage of info.inliningCandidates()) {\n            const argTypes = info.fn.type[0];\n            const newLocals = [...argTypes, ...info.fn.locals].map(x => usage.expr.builder.addLocal(x));\n            const returnType = info.fn.type[1][0] ?? null;\n\n            // create the structure for the inlining\n            const replacement = [];\n            for (let i = argTypes.length - 1; i >= 0; i--) {\n                replacement.push(Instructions.local.set(newLocals[i]));\n            }\n            replacement.push(Instructions.block(returnType, []));\n            splicer.splice(usage, 1, replacement);\n\n            const blockIndex = splicer.realIndex(usage) + argTypes.length;\n            const block = usage.expr.instructions[blockIndex];\n            if (!block || block.type !== \"structured\" || block.immediate.expression.instructions.length !== 0) {\n                throw new Error(\"Failed to inline function\");\n            }\n\n            // actually copy the function and modify as needed\n            info.fn.body.copyInto(block.immediate.expression);\n            remapLocals(block.immediate.expression, newLocals);\n            peephole(block.immediate.expression, ([instr], depth) => {\n                if (instr.name === \"return\") {\n                    // replace returns with br to the encapsulating block\n                    return [returnType ? Instructions.br(depth, returnType) : Instructions.br(depth)];\n                }\n            }, 1);\n\n            modifiedFns.add(usage.fn);\n        }\n    }\n\n    for (const fn of modifiedFns) { // clean up any modified functions\n        optimise(fn);\n    }\n    if (modifiedFns.size) removeUnusedFns(module);\n\n    // FIXME nested inlining?\n}\n\nexport function removeUnusedFns(module: ModuleBuilder): void {\n    const map = FnInfo.infoMap(module);\n    const functions = [...module.functions, ...module.functionImports].map(x => {\n        const info = map.get(x as WFunction);\n        if (info?.usages.length === 0 && !info.inTable && !info.exported) {\n            module._removeFunction(x as WFunction);\n            return undefined;\n        }\n        return x;\n    });\n\n    const startingIndex = functions.indexOf(undefined);\n    if (startingIndex === -1) return; // no functions to remove\n\n    for (let i = startingIndex + 1; i < functions.length; i++) {\n        const fn = functions[i];\n        const info = map.get(fn as WFunction);\n        if (!fn || !info) continue;\n\n        for (const usage of info.usages) {\n            usage.expr.replace(usage.instrIndex, usage.instrIndex + 1, Instructions.call(fn));\n        }\n    }\n}\n\ntype Usage = {fn: WFunction, fnInfo: FnInfo, expr: WExpression, instrIndex: number};\n\nclass FnInfo {\n    usages: Usage[] = [];\n    size: number = 0;\n    inTable: boolean;\n    exported: boolean;\n\n    constructor(readonly fn: WFunction, private readonly fnMap: Map<WFunction, FnInfo>) {\n        this.inTable = fn.parent._inFunctionTable(fn);\n        this.exported = fn.exportName !== undefined;\n    }\n\n    analyze() {\n        if (this.size > 0) return;\n\n        const exprQueue = [this.fn.body];\n        let expr;\n        while ((expr = exprQueue.shift()) !== undefined) {\n            this.size += expr.instructions.length;\n            for (const [i, instr] of expr.instructions.entries()) {\n                if (instr.type === \"structured\") {\n                    exprQueue.push(instr.immediate.expression);\n                    if (instr.immediate.expression2) exprQueue.push(instr.immediate.expression2);\n                } else if (instr.type === \"index\" && instr.name === \"call\") {\n                    const target = this.fn.parent._functionLookup(instr.immediate.value as funcidx);\n                    const fnInfo = this.fnMap.get(target as WFunction);\n                    if (fnInfo) fnInfo.usages.push({fn: this.fn, fnInfo, expr, instrIndex: i});\n                }\n            }\n        }\n    }\n\n    inliningCandidates(): Usage[] {\n        if (this.size > 50 || this.usages.length === 0) return []; // never inline\n\n        let score = this.size;\n        score += Math.min(this.fn.body.builder.args.length - 1, 0) * 5; // one argument is okay\n        score += this.fn.locals.length * 5;\n        if (this.fn.hints.inline) score -= 20;\n\n        if (score <= 8 || (score <= 16 && this.usages.length <= 3 && !this.inTable && !this.exported)) {\n            // inline all (non-recursive) cases\n            return this.usages.filter(({fn}) => fn !== this.fn);\n        }\n        return [];\n    }\n\n    static infoMap(module: ModuleBuilder) {\n        const map = new Map<WFunction, FnInfo>();\n        for (const fn of module.functions) map.set(fn, new FnInfo(fn, map));\n        for (const info of map.values()) info.analyze();\n        return map;\n    }\n}\n","import {getFlags} from \"../optimisation/flags\";\nimport {CConstant} from \"../ir/expressions\";\nimport * as c from \"../ir/statements\";\nimport {CArithmetic, CPointer} from \"../ir/types\";\nimport {Instructions, i32Type, i64Type} from \"../wasm\";\nimport {labelidx} from \"../wasm/base_types\";\nimport {WInstruction} from \"../wasm/instructions\";\nimport {subExpr, condition, expressionGeneration, gInstr} from \"./expressions\";\nimport {GenError} from \"./gen_error\";\nimport {WFnGenerator} from \"./generator\";\nimport {storageSetupScope, memcpy} from \"./storage\";\nimport {valueType, largeReturn} from \"./type_conversion\";\n\nfunction _compoundStatement(ctx: WFnGenerator, s: c.CCompoundStatement): WInstruction[] {\n    const [instr, finishCallback] = storageSetupScope(ctx, s.scope);\n    if (s.scope.labelledStatement === undefined) {\n        instr.push(...s.statements.flatMap(s2 => statementGeneration(ctx, s2)));\n    } else {\n        // place all the instructions before the labelled statement in a block to enable jumping forward\n        const blockStatements: c.CStatement[] = [];\n        // place all the instructions after and including the labelled statement in a loop to enable jumping back\n        const loopStatements: c.CStatement[] = [];\n        for (const statement of s.statements) {\n            if (loopStatements.length > 0 || s.scope.labelledStatement.body === statement) {\n                loopStatements.push(statement);\n            } else {\n                blockStatements.push(statement);\n            }\n        }\n\n        // only need to store the break depth once as they are at the same depth\n        instr.push(\n            Instructions.block(null, blockStatements.flatMap(s2 => statementGeneration(ctx, s2)), storeBreakDepth(s.scope.labelledStatement)),\n            Instructions.loop(null, loopStatements.flatMap(s2 => statementGeneration(ctx, s2)))\n        );\n    }\n    finishCallback();\n    return instr;\n}\n\nfunction _expressionStatement(ctx: WFnGenerator, s: c.CExpressionStatement): WInstruction[] {\n    return ctx.expression(s.expression, true);\n}\n\nfunction _nop(ctx: WFnGenerator, s: c.CNop): WInstruction[] {\n    return []; // [Instructions.nop()]\n}\n\nfunction _if(ctx: WFnGenerator, s: c.CIf): WInstruction[] {\n    const ifBody = s.ifBody === undefined ? [Instructions.nop()] : statementGeneration(ctx, s.ifBody);\n    const elseBody = s.elseBody === undefined ? undefined : statementGeneration(ctx, s.elseBody);\n\n    return [...condition(ctx, s.test), Instructions.if(null, ifBody, elseBody)];\n}\n\nfunction _forLoop(ctx: WFnGenerator, s: c.CForLoop): WInstruction[] {\n    if (s.body === undefined) throw new GenError(\"Invalid for loop body\", ctx, s.node);\n    const [instr, storageFinishCallback] = storageSetupScope(ctx, s.scope);\n\n    let init: WInstruction[] = [];\n    if (Array.isArray(s.init)) {\n        init = s.init.flatMap(e => ctx.expression(e.expression, true));\n    } else if (s.init !== undefined && !(s.init instanceof c.CNop)) {\n        init = ctx.expression(s.init.expression, true);\n    }\n\n    let test: WInstruction[] = [Instructions.i32.const(1n)];\n    if (s.test !== undefined && !(s.test instanceof c.CNop)) {\n        test = condition(ctx, s.test.expression);\n    }\n\n    let update: WInstruction[] = [];\n    if (s.update !== undefined) update = ctx.expression(s.update, true);\n\n    instr.push(...init,\n        Instructions.loop(null, [\n            ...test,\n            Instructions.if(null, [\n                Instructions.block(null, [\n                    ...statementGeneration(ctx, s.body),\n                ], storeContinueDepth(s)),\n                ...update,\n                Instructions.br(1) // jump back to start of loop\n            ], undefined, storeBreakDepth(s))\n        ])\n    );\n\n    storageFinishCallback();\n    return instr;\n}\n\nfunction _whileLoop(ctx: WFnGenerator, s: c.CWhileLoop): WInstruction[] {\n    if (s.body === undefined) throw new GenError(\"Invalid while loop body\", ctx, s.node);\n\n    return [Instructions.loop(null, [\n        ...condition(ctx, s.test),\n        Instructions.if(null, [\n            ...statementGeneration(ctx, s.body),\n            Instructions.br(1) // jump back to start of loop\n        ], undefined, storeBreakDepth(s))\n    ], storeContinueDepth(s))];\n}\n\nfunction _doLoop(ctx: WFnGenerator, s: c.CDoLoop): WInstruction[] {\n    if (s.body === undefined) throw new GenError(\"Invalid while loop body\", ctx, s.node);\n\n    return [Instructions.block(null, [\n        Instructions.loop(null, [\n            ...statementGeneration(ctx, s.body),\n            ...condition(ctx, s.test),\n            Instructions.br_if(0)\n        ], storeContinueDepth(s))\n    ], storeBreakDepth(s))];\n}\n\nfunction _switch(ctx: WFnGenerator, s: c.CSwitch): WInstruction[] {\n    const type = valueType(s.expression.type as CArithmetic);\n    return ctx.withTemporaryLocal(type, value => {\n        const initInstr: WInstruction[] = [\n            ...expressionGeneration(ctx, s.expression, false),\n            Instructions.local.set(value)\n        ];\n\n        let defaultIndex = s.children.findIndex(x => x.default);\n        if (defaultIndex === -1) defaultIndex = s.children.length;\n\n        const checks: WInstruction[] = [];\n        // check if we can use br_table\n        let minValue = 2n ** 65n, maxValue = -minValue, numCases = 0;\n        for (const child of s.children) {\n            for (const sCase of child.cases) {\n                if (sCase.value > maxValue) maxValue = BigInt(sCase.value);\n                if (sCase.value < minValue) minValue = BigInt(sCase.value);\n                numCases++;\n            }\n        }\n        if (maxValue - minValue <= Math.min(2 ** 16, numCases * 8) && getFlags().generation_switch_br_table) { // basic heuristic\n            // use br_table\n            checks.push(Instructions.local.get(value));\n            if (minValue < 0 || minValue > 16) { // adjust to start at zero\n                const typeInstrs = type === i32Type ? Instructions.i32 : Instructions.i64;\n                checks.push(typeInstrs.const(minValue), typeInstrs.sub());\n            } else {\n                minValue = 0n;\n            }\n            if (type === i64Type) checks.push(Instructions.i32.wrap_i64());\n\n            // build actual jump table\n            const table: number[] = Array(Number(maxValue - minValue) + 1).fill(defaultIndex);\n            for (const [depth, child] of s.children.entries()) {\n                for (const sCase of child.cases) {\n                    table[Number(sCase.value) - Number(minValue)] = depth;\n                }\n            }\n\n            checks.push(Instructions.br_table(defaultIndex, table));\n\n        } else {\n            // use manual jump table\n            for (const [depth, child] of s.children.entries()) {\n                for (const sCase of child.cases) {\n                    if (sCase.type instanceof CPointer) throw new GenError(\"Invalid switch case\", ctx, s.node);\n                    const constant = new CConstant(s.node, sCase.type, sCase.value);\n                    checks.push(Instructions.local.get(value), ...subExpr(ctx, constant, s.expression.type), gInstr(type, \"eq\"));\n                    checks.push(Instructions.br_if(depth));\n                }\n            }\n            // add default\n            checks.push(Instructions.br(defaultIndex));\n        }\n\n        // case bodies\n        let block = Instructions.block(null, checks);\n        for (let i = 0; i < s.children.length; i++) {\n            block = Instructions.block(null, [\n                block,\n                ...ctx.statement(s.children[i].body)\n            ], i === s.children.length - 1 ? storeBreakDepth(s) : undefined); // final case body is also break target\n        }\n\n        return [...initInstr, block];\n    });\n}\n\nfunction _goto(ctx: WFnGenerator, s: c.CGoto): WInstruction[] {\n    return [Instructions.br({\n        getIndex(depth: number): labelidx {\n            const statement = s.target as any as Record<typeof breakDepthSymbol, number | undefined>;\n            const targetDepth = statement[breakDepthSymbol];\n            if (targetDepth === undefined) throw new GenError(\"Failed to find target depth\", ctx, s.node);\n\n            return BigInt(depth - targetDepth) as labelidx;\n        }\n    })];\n}\n\nfunction _continue(ctx: WFnGenerator, s: c.CContinue): WInstruction[] {\n    return [Instructions.br({\n        getIndex(depth: number): labelidx {\n            const statement = s.loop as any as Record<typeof continueDepthSymbol, number | undefined>;\n            const targetDepth = statement[continueDepthSymbol];\n            if (targetDepth === undefined) throw new GenError(\"Failed to find continue depth\", ctx, s.node);\n\n            return BigInt(depth - targetDepth) as labelidx;\n        }\n    })];\n}\n\nfunction _break(ctx: WFnGenerator, s: c.CBreak): WInstruction[] {\n    return [Instructions.br({\n        getIndex(depth: number): labelidx {\n            const statement = s.target as any as Record<typeof breakDepthSymbol, number | undefined>;\n            const targetDepth = statement[breakDepthSymbol];\n            if (targetDepth === undefined) throw new GenError(\"Failed to find break depth\", ctx, s.node);\n\n            return BigInt(depth - targetDepth) as labelidx;\n        }\n    })];\n}\n\nfunction _return(ctx: WFnGenerator, s: c.CReturn): WInstruction[] {\n    if (s.value === undefined) {\n        return [Instructions.return()];\n    } else if (largeReturn(s.func.type.returnType)) {\n        // copy return value to large return parameter (the last parameter)\n        return [...memcpy(\n            subExpr(ctx, s.value, s.func.type.returnType),\n            [Instructions.local.get(s.func.type.parameterTypes.length)],\n            s.value.type.bytes),\n        Instructions.return()];\n    } else {\n        return [...subExpr(ctx, s.value, s.func.type.returnType), Instructions.return()];\n    }\n}\n\nexport function statementGeneration(ctx: WFnGenerator, s: c.CStatement): WInstruction[] {\n    if (s instanceof c.CCompoundStatement) return _compoundStatement(ctx, s);\n    else if (s instanceof c.CExpressionStatement) return _expressionStatement(ctx, s);\n    else if (s instanceof c.CNop) return _nop(ctx, s);\n    else if (s instanceof c.CIf) return _if(ctx, s);\n    else if (s instanceof c.CForLoop) return _forLoop(ctx, s);\n    else if (s instanceof c.CWhileLoop) return _whileLoop(ctx, s);\n    else if (s instanceof c.CDoLoop) return _doLoop(ctx, s);\n    else if (s instanceof c.CSwitch) return _switch(ctx, s);\n    else if (s instanceof c.CGoto) return _goto(ctx, s);\n    else if (s instanceof c.CContinue) return _continue(ctx, s);\n    else if (s instanceof c.CBreak) return _break(ctx, s);\n    else return _return(ctx, s);\n}\n\n// break and continue depth helpers\nconst breakDepthSymbol = Symbol(\"break depth\");\nconst continueDepthSymbol = Symbol(\"continue depth\");\n\nfunction storeBreakDepth<T extends c.CForLoop | c.CWhileLoop | c.CDoLoop | c.CSwitch | c.CLabelledStatement>(s: T): (c: {depth: number}) => void {\n    const statement = s as Record<typeof breakDepthSymbol, any>;\n    return ({depth}) => {\n        // passed the instruction's context, so the depth of the structured instruction is depth + 1\n        statement[breakDepthSymbol] = depth + 1;\n    };\n}\n\nfunction storeContinueDepth<T extends c.CForLoop | c.CWhileLoop | c.CDoLoop>(s: T): (c: {depth: number}) => void {\n    const statement = s as Record<typeof continueDepthSymbol, any>;\n    return ({depth}) => {\n        statement[continueDepthSymbol] = depth + 1;\n    };\n}\n","import type {Linker} from \"../linker\";\nimport {interproceduralOptimise} from \"../optimisation/interprocedural\";\nimport {getFlags} from \"../optimisation/flags\";\nimport {CFuncDefinition, CFuncDeclaration} from \"../ir/declarations\";\nimport type {CExpression} from \"../ir/expressions\";\nimport type {CStatement} from \"../ir/statements\";\nimport {CArithmetic, CFuncType, CPointer} from \"../ir/types\";\nimport {ModuleBuilder, WFunctionBuilder, WFunction, Instructions, WImportedFunction, ValueType, i32Type} from \"../wasm\";\nimport type {funcidx, tableidx, typeidx} from \"../wasm/base_types\";\nimport type {WLocal} from \"../wasm/functions\";\nimport type {WGlobal} from \"../wasm/global\";\nimport type {WInstruction} from \"../wasm/instructions\";\nimport {FunctionType} from \"../wasm/wtypes\";\nimport {expressionGeneration} from \"./expressions\";\nimport {GenError} from \"./gen_error\";\nimport {statementGeneration} from \"./statements\";\nimport {storageSetupStaticVar} from \"./storage\";\nimport {realType, returnType, largeReturn} from \"./type_conversion\";\n\nexport const SHADOW_STACK_SIZE = 2 ** 20;\nexport const FIRST_STATIC_ADDR = 32; // reserve first 32 bytes as 0\n\nexport class WGenerator {\n    readonly module: ModuleBuilder;\n    readonly functions = new Map<CFuncDefinition | CFuncDeclaration, WFunction | WImportedFunction>();\n\n    // current memory pointers\n    nextStaticAddr = FIRST_STATIC_ADDR;\n    _shadowStackPtr?: WGlobal;\n\n    constructor(linker: Linker) {\n        this.module = new ModuleBuilder();\n\n        const staticInitializers = [];\n        for (const variable of linker.emitVariables) {\n            const initializer = storageSetupStaticVar(this, variable);\n            if (initializer) staticInitializers.push(initializer);\n        }\n\n        // add all functions\n        for (const funcImport of linker.emitImports) this.importFunction(funcImport);\n        for (const func of linker.emitExportedFunctions) this.function(func, func.name);\n        for (const func of linker.emitFunctions) this.function(func);\n\n        // define non-imported functions\n        for (const [cfunc, wfunc] of this.functions.entries()) {\n            if (cfunc instanceof CFuncDefinition && wfunc instanceof WFunction) {\n                wfunc.define(b => this.functionBody(cfunc, b));\n            }\n        }\n\n        for (const initializer of staticInitializers) initializer();\n\n        interproceduralOptimise(this.module);\n\n        this.module.emitCallback = () => {\n            const staticSize = Math.ceil(this.nextStaticAddr / 1024) * 1024;\n            if (this._shadowStackPtr) {\n                const shadowStackStart = staticSize + 1024; // between 1024-2047 byte buffer\n                this._shadowStackPtr.initialValue = BigInt(shadowStackStart);\n                this.module.setupMemory(Math.ceil((shadowStackStart + SHADOW_STACK_SIZE) / 65536));\n            } else if (this.isMemoryUsed()) {\n                this.module.setupMemory(Math.ceil(staticSize / 65536));\n            }\n        };\n    }\n\n    get shadowStackPtr(): WGlobal {\n        if (!this._shadowStackPtr) {\n            this._shadowStackPtr = this.module.global(i32Type, true, 0n, \"__sp\");\n        }\n        return this._shadowStackPtr;\n    }\n\n    private isMemoryUsed(): boolean {\n        if (this._shadowStackPtr || this.nextStaticAddr > FIRST_STATIC_ADDR) return true;\n\n        for (const f of this.module.functions) {\n            for (const instr of f.body.instructionsRecursive()) {\n                if (instr.type === \"structured\") {\n                    // structured instructions include the resources used by child instructions\n                    // and can't directly read/write memory\n                    continue;\n                }\n                if (instr.name === \"call\" || instr.name === \"call_indirect\") {\n                    // call instructions include \"memory\" to ensure flow analysis is safe\n                    continue;\n                }\n                if (instr.reads.includes(\"memory\") || instr.writes.includes(\"memory\")) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    private function(func: CFuncDefinition, name?: string) {\n        if (largeReturn(func.type.returnType)) {\n            // would be hard to correctly call, so don't export\n            name = undefined;\n        }\n        if (name && !func.type.parameterTypes.every(t => t instanceof CArithmetic)) {\n            // ensure ssp is included for argument passing when exported unless arguments are all numbers\n            this.shadowStackPtr;\n        }\n\n        const wasmFunc = this.module.function(...WGenerator.funcType(func.type), undefined, name);\n        wasmFunc.hints.inline = func.hints.inline;\n        this.functions.set(func, wasmFunc);\n    }\n\n    private functionBody(s: CFuncDefinition, b: WFunctionBuilder): WInstruction[] {\n        const fnGenerator = new WFnGenerator(this, b, s.name);\n        const body = fnGenerator.statement(s.body);\n\n        if (fnGenerator.shadowStackUsage > 0 && getFlags().generation_zero_shadow_stack) {\n            // use memory.fill to ensure shadow stack space is 0 before fn runs\n            // not technically needed as automatic variables do not have default initializers\n            body.unshift(\n                Instructions.global.get(this.shadowStackPtr),\n                Instructions.i32.const(0),\n                Instructions.i32.const(fnGenerator.shadowStackUsage),\n                Instructions.memory.fill()\n            );\n        }\n        return body;\n    }\n\n    private importFunction(func: CFuncDeclaration) {\n        const wasmFunc = this.module.importFunction(\n            func.type.parameterTypes.map(realType),\n            returnType(func.type.returnType),\n            \"c2wasm\",\n            func.name);\n        this.functions.set(func, wasmFunc);\n    }\n\n    functionIndex(fn: CFuncDeclaration | CFuncDefinition): {getIndex(): funcidx} {\n        if (fn instanceof CFuncDeclaration && fn.definition !== undefined) fn = fn.definition.getFunction();\n\n        return {\n            getIndex: () => {\n                const wasmFunc = this.functions.get(fn);\n                if (wasmFunc === undefined) throw new GenError(`Function '${fn.name}' not emitted`, undefined, fn.node);\n                return wasmFunc.getIndex();\n            }\n        };\n    }\n\n    private static funcType(fnType: CFuncType): FunctionType {\n        const paramTypes = fnType.parameterTypes.map(realType);\n        if (largeReturn(fnType.returnType)) {\n            paramTypes.push(i32Type); // add additional argument for large return pointer\n        }\n\n        return [paramTypes, returnType(fnType.returnType)];\n    }\n\n    typeIndex(fnType: CFuncType): typeidx {\n        return this.module._typeIndex(WGenerator.funcType(fnType));\n    }\n\n    indirectIndex(fn: CFuncDeclaration | CFuncDefinition): tableidx {\n        if (fn instanceof CFuncDeclaration && fn.definition !== undefined) fn = fn.definition.getFunction();\n\n        const wasmFunc = this.functions.get(fn);\n        if (wasmFunc === undefined) throw new GenError(`Function '${fn.name}' not emitted`, undefined, fn.node);\n        return wasmFunc.getTableIndex();\n    }\n}\n\nexport class WFnGenerator {\n    shadowStackUsage: number = 0;\n\n    constructor(readonly gen: WGenerator, readonly builder: WFunctionBuilder, readonly fnName: string) {\n    }\n\n    statement(s: CStatement): WInstruction[] {\n        return statementGeneration(this, s);\n    }\n\n    expression(e: CExpression, discardResult: boolean): WInstruction[] {\n        return expressionGeneration(this, e, discardResult);\n    }\n\n    withTemporaryLocal<T>(type: ValueType, expressionFn: (local: WLocal) => T): T {\n        const local = this.builder.getTempLocal(type);\n        const expression = expressionFn(local);\n        this.builder.freeTempLocal(local);\n        return expression;\n    }\n}\n","import {ModuleBuilder} from \"../../wasm\";\nimport {getFlags} from \"../flags\";\nimport {inlineFunctions} from \"./functions\";\n\nexport function interproceduralOptimise(module: ModuleBuilder): void {\n    const flags = getFlags();\n    if (flags.inlining) inlineFunctions(module);\n}\n","import {CVarDefinition} from \"../declarations\";\nimport {CConstant} from \"../expressions\";\nimport {Scope} from \"../scope\";\nimport {CType, getArithmeticType, CPointer, addQualifier, CFuncType, CNotFuncType, CArray, CEnum, CStruct, CUnion, CCompoundMember, CVoid, CArithmetic} from \"../types\";\nimport {ParseTreeValidationError, pt} from \"../../parsing/\";\nimport {evalIntegerConstant} from \"./expr_transform\";\n\ntype GeneralTypeDecl = {\n    typeInfo: pt.SpecifierQualifiers | pt.DeclarationSpecifiers,\n    declarator?: pt.Declarator | pt.AbstractDeclarator\n};\n\n/** helper function for specifier & declarator type */\nexport function getType(o: GeneralTypeDecl, scope: Scope): CType {\n    let type = getSpecifierType(o.typeInfo, scope);\n    if (o.typeInfo.qualifierList.length) type = addQualifier(type, o.typeInfo.qualifierList[0]);\n    if (o.declarator) type = getDeclaratorType(type, o.declarator, scope);\n    return type;\n}\n\n/** transform the CType from a type specifier into the declarator type */\nexport function getDeclaratorType(type: CType, declarator: pt.Declarator | pt.AbstractDeclarator, scope: Scope): CType {\n    let d: pt.Declarator | pt.AbstractDeclarator | undefined = declarator;\n\n    while (d && !(d instanceof pt.IdentifierDeclarator)) {\n        if (d instanceof pt.PointerDeclarator || d instanceof pt.AbstractPointerDeclarator) {\n            let ptr: pt.Pointer | undefined = d.pointer;\n            while (ptr) {\n                type = new CPointer(ptr, type, ptr.qualifierList?.includes(\"const\"));\n                ptr = ptr.body;\n            }\n            d = d.body;\n\n        } else if (d instanceof pt.ArrayDeclarator || d instanceof pt.AbstractArrayDeclarator) {\n            type = new CArray(d, type);\n            if (d.length) {\n                type.length = Number(evalIntegerConstant(d.length, scope).value);\n                if (type.length <= 0) throw new ParseTreeValidationError(d.length, \"Invalid array length\");\n            }\n            d = d.body;\n\n        } else { // d instanceof pt.(Abstract)FunctionDeclarator\n            const parameterTypes = [];\n            let parameterNames = undefined;\n\n            for (const param of d.args ?? []) {\n                let type = getType(param, scope);\n                if (type instanceof CArray) {\n                    // in function parameters arrays are equivalent to pointers\n                    type = new CPointer(type.node, type.type);\n                } else if (type instanceof CFuncType) {\n                    throw new ParseTreeValidationError(param, \"Functions cannot be parameters\");\n                }\n                parameterTypes.push(type);\n\n                if (param.declarator && !param.declarator.abstractDeclarator) {\n                    parameterNames ??= [];\n                    parameterNames.push(getDeclaratorName(param.declarator));\n                }\n\n                if (parameterNames && parameterNames.length !== parameterTypes.length) {\n                    throw new ParseTreeValidationError(param, \"Unexpected mix of abstract & non-abstract declarators\");\n                }\n            }\n\n            if (parameterTypes.length === 1 && parameterTypes[0] instanceof CVoid) parameterTypes.shift();\n\n            if (parameterTypes.length === 0) {\n                // ensure parameterNames are always non-null in function definitions\n                parameterNames = [];\n            }\n\n            type = new CFuncType(d, type as CNotFuncType, parameterTypes, parameterNames, d.variadic);\n            d = d.body;\n        }\n    }\n    return type;\n}\n\nexport function getDeclaratorName(declarator: pt.Declarator | pt.InitDeclarator): string {\n    while (!(declarator instanceof pt.IdentifierDeclarator)) {\n        declarator = declarator.body;\n    }\n    return declarator.id;\n}\n\n/** Get the base type from the list of specifiers */\nfunction getSpecifierType(d: pt.SpecifierQualifiers | pt.DeclarationSpecifiers, scope: Scope): CType {\n    const specifiers = d.specifierList;\n    const singleSpecifier = specifiers.length === 1 ? specifiers[0] : undefined;\n\n    if (singleSpecifier instanceof pt.StructUnionSpecifier) {\n        const type = singleSpecifier.structure === \"struct\" ? CStruct : CUnion;\n        let structure = new type(singleSpecifier, singleSpecifier.id);\n        if (singleSpecifier.id) {\n            // lookup tag and if it already exists use the existing instance\n            const existing: CStruct | CUnion = scope.lookupTag(singleSpecifier.id, type as any, singleSpecifier) as any;\n            if (existing) {\n                structure = existing;\n            } else {\n                scope.addTag(structure);\n            }\n        }\n        if (!singleSpecifier.declarations) return structure;\n\n        const values: CCompoundMember[] = []; // populate struct/union members if provided\n        for (const declaration of singleSpecifier.declarations) {\n            const baseType = getType(declaration, scope);\n\n            for (const declarator of declaration.list) {\n                const type = getDeclaratorType(baseType, declarator, scope);\n                const name = getDeclaratorName(declarator);\n                if (type.incomplete || type.bytes === 0 || type instanceof CFuncType) {\n                    throw new ParseTreeValidationError(declarator, \"Type must be complete\");\n                }\n\n                values.push(new CCompoundMember(declaration, name, type));\n            }\n        }\n        structure.members = values;\n        structure.node = singleSpecifier; // set the parse node to point to the node which actually defined the members\n        return structure;\n\n    } else if (singleSpecifier instanceof pt.EnumSpecifier) {\n        let cEnum = new CEnum(singleSpecifier, singleSpecifier.id);\n        if (singleSpecifier.id) {\n            // lookup tag and if it already exists use its instance\n            const existing = scope.lookupTag(singleSpecifier.id, CEnum, singleSpecifier);\n            if (existing) {\n                cEnum = existing;\n            } else {\n                scope.addTag(cEnum);\n            }\n        }\n        if (!singleSpecifier.body) return CArithmetic.S32;\n\n        // enum members either provide their own value or use the last value + 1, starting at 0\n        let nextValue = 0n;\n        const values = [];\n        for (const e of singleSpecifier.body) { // populate enum\n            if (e.value) nextValue = evalIntegerConstant(e.value, scope).value;\n\n            // enum constants are `int`s!!!\n            const enumConstant = new CVarDefinition(e, e.id, addQualifier(CArithmetic.S32, \"const\"), \"static\", \"internal\");\n            enumConstant.staticValue = new CConstant(e, CArithmetic.S32, nextValue);\n\n            scope.addIdentifier(enumConstant); // add the enum member as a constant to the scope\n            values.push({name: e.id, value: nextValue++});\n        }\n        cEnum.values = values;\n        cEnum.node = singleSpecifier;\n        return CArithmetic.S32;\n\n    } else if (specifiers.every(x => typeof x === 'string')) {\n        // arithmetic or void\n        const type = getArithmeticType(specifiers as ReadonlyArray<pt.TypeSpecifier & string>);\n        if (type) return type;\n\n    } else if (specifiers.length === 1 && specifiers[0] instanceof pt.CustomTypeSpecifier) {\n        // typedef\n        return scope.lookupTypedef(specifiers[0].name);\n    }\n\n    throw new ParseTreeValidationError(d, \"Invalid specifier\");\n}\n","import {ParseNode, ParseTreeValidationError, pt} from \"../../parsing\";\nimport {\n    CExpression, CConstant, CIdentifier, CFunctionCall, CMemberAccess, CDereference, CConditional,\n    CAssignment, CStringLiteral, CIncrDecr, CAddressOf, CUnaryPlusMinus, CBitwiseNot, CLogicalNot, CSizeof, CAddSub,\n    CCast, CComma, CMulDiv, CMod, CShift, CRelational, CEquality, CBitwiseAndOr, CLogicalAndOr, CValue\n} from \"../expressions\";\nimport {Scope} from \"../scope\";\nimport {CArithmetic, CArray} from \"../types\";\nimport {constInteger} from \"./constant_expressions\";\nimport {getType} from \"./type_transform\";\n\n/** Transform expressions from the parse tree */\nexport function ptExpression(e: pt.Expression, scope: Scope): CExpression {\n    if (e instanceof pt.ConstantExpression) {\n        // pt.ConstantExpression is a wrapped class in the parse tree denoting where constant expressions are expected.\n        return ptExpression(e.expr, scope);\n\n    } else if (e instanceof pt.Constant) {\n        return ptConstant(e);\n\n    } else if (e instanceof pt.Identifier) {\n        const id = new CIdentifier(e, scope.lookupIdentifier(e.name, e));\n        if (scope.func) scope.func.dependencies.set(id.value, true);\n        return id;\n\n    } else if (e instanceof pt.StringLiteral) {\n        const arr: bigint[] = []; // split the literal into characters taking into account escape sequences\n        const charRegex = /[^\\\\\\n\"]|\\\\(?:[^x0-7\\n]|x[0-9a-fA-F]{1,2}|[0-7]{1,3})/y;\n        while (charRegex.lastIndex < e.value.length) {\n            const match = charRegex.exec(e.value);\n            if (match && charRegex.lastIndex !== 0) {\n                arr.push(BigInt(unescapeChar(match[0], e).codePointAt(0) ?? 0)); // unescape the char if needed\n            } else {\n                // regex didn't match the body for some reason, this shouldn't happen\n                throw new ParseTreeValidationError(e, \"Invalid string literal\");\n            }\n        }\n        arr.push(0n); // null terminator\n        return new CStringLiteral(e, arr);\n\n    } else if (e instanceof pt.UnaryExpression) {\n        return ptUnary(e, scope);\n\n    } else if (e instanceof pt.BinaryExpression) {\n        return ptBinary(e, scope);\n\n    } else if (e instanceof pt.SizeofExpression) {\n        if (e.body instanceof pt.Expression) { // sizeof [expression]\n            return new CSizeof(e, ptExpression(e.body, scope).type);\n        } else { // sizeof [type]\n            return new CSizeof(e, getType(e.body, scope));\n        }\n\n    } else if (e instanceof pt.CastExpression) {\n        return new CCast(e, getType(e.targetType, scope), ptExpression(e.body, scope));\n\n    } else if (e instanceof pt.FunctionCallExpression) {\n        return new CFunctionCall(e, ptExpression(e.fn, scope), (e.args ?? []).map(e => ptExpression(e, scope)));\n\n    } else if (e instanceof pt.MemberAccessExpression) {\n        let body = ptExpression(e.lhs, scope);\n        if (!e.pointer) { // transform into pointer access\n            body = new CAddressOf(e, body);\n        }\n        return new CMemberAccess(e, body, e.rhs);\n\n    } else if (e instanceof pt.ConditionalExpression) {\n        return new CConditional(e, ptExpression(e.condition, scope), ptExpression(e.trueValue, scope), ptExpression(e.falseValue, scope));\n\n    } else if (e instanceof pt.AssignmentExpression) {\n        return new CAssignment(e, ptExpression(e.lhs, scope), ptExpression(e.rhs, scope), e.assignType);\n\n    }\n\n    throw new ParseTreeValidationError(e, \"Invalid expression\");\n}\n\n/** Evaluate an expression at compile time to an integer constant */\nexport function evalIntegerConstant(c: pt.ConstantExpression, scope: Scope): CValue & {value: bigint} {\n    const expr = ptExpression(c.expr, scope);\n    return constInteger(expr);\n}\n\nfunction ptUnary(e: pt.UnaryExpression, scope: Scope): CExpression {\n    // transform unary expressions\n    const body = ptExpression(e.body, scope);\n    if (e.type === \"prefixIncrement\") return new CIncrDecr(e, body, \"++\", \"pre\");\n    if (e.type === \"prefixDecrement\") return new CIncrDecr(e, body, \"--\", \"pre\");\n    if (e.type === \"postfixIncrement\") return new CIncrDecr(e, body, \"++\", \"post\");\n    if (e.type === \"postfixDecrement\") return new CIncrDecr(e, body, \"--\", \"post\");\n    if (e.type === \"addressOf\") return new CAddressOf(e, body);\n    if (e.type === \"dereference\") return new CDereference(e, body);\n    if (e.type === \"unaryPlus\") return new CUnaryPlusMinus(e, body, \"+\");\n    if (e.type === \"unaryMinus\") return new CUnaryPlusMinus(e, body, \"-\");\n    if (e.type === \"bitwiseNot\") return new CBitwiseNot(e, body);\n    if (e.type === \"logicalNot\") return new CLogicalNot(e, body);\n\n    throw new ParseTreeValidationError(e, \"Invalid unary expression\");\n}\n\nfunction ptBinary(e: pt.BinaryExpression, scope: Scope): CExpression {\n    // transform binary expressions\n    const lhs = ptExpression(e.lhs, scope), rhs = ptExpression(e.rhs, scope);\n\n    if (e.type === \"mul\") return new CMulDiv(e, lhs, rhs, \"*\");\n    if (e.type === \"div\") return new CMulDiv(e, lhs, rhs, \"/\");\n    if (e.type === \"mod\") return new CMod(e, lhs, rhs);\n    if (e.type === \"add\") return new CAddSub(e, lhs, rhs, \"+\");\n    if (e.type === \"sub\") return new CAddSub(e, lhs, rhs, \"-\");\n    if (e.type === \"bitwiseShiftLeft\") return new CShift(e, lhs, rhs, \"left\");\n    if (e.type === \"bitwiseShiftRight\") return new CShift(e, lhs, rhs, \"right\");\n\n    if (e.type === \"relationalLT\") return new CRelational(e, lhs, rhs, \"LT\");\n    if (e.type === \"relationalGT\") return new CRelational(e, lhs, rhs, \"GT\");\n    if (e.type === \"relationalLEq\") return new CRelational(e, lhs, rhs, \"LEq\");\n    if (e.type === \"relationalGEq\") return new CRelational(e, lhs, rhs, \"GEq\");\n    if (e.type === \"relationalEq\") return new CEquality(e, lhs, rhs, \"==\");\n    if (e.type === \"relationalNEq\") return new CEquality(e, lhs, rhs, \"!=\");\n\n    if (e.type === \"bitwiseAnd\") return new CBitwiseAndOr(e, lhs, rhs, \"and\");\n    if (e.type === \"bitwiseXor\") return new CBitwiseAndOr(e, lhs, rhs, \"xor\");\n    if (e.type === \"bitwiseOr\") return new CBitwiseAndOr(e, lhs, rhs, \"or\");\n    if (e.type === \"logicalAnd\") return new CLogicalAndOr(e, lhs, rhs, \"and\");\n    if (e.type === \"logicalOr\") return new CLogicalAndOr(e, lhs, rhs, \"or\");\n\n    if (e.type === \"comma\") return new CComma(e, lhs, rhs);\n    if (e.type === \"arraySubscript\") {\n        // transform `a[b]` into `*(a+b)`\n        return new CDereference(e, new CAddSub(e, ptExpression(e.lhs, scope), ptExpression(e.rhs, scope), \"+\"));\n    }\n\n    throw new ParseTreeValidationError(e, \"Invalid binary expression\");\n}\n\n/** Transform a constant\n *\n * This is quite complicated because we have to work out what type to give the constant, following the rules set out in\n * the standard\n */\nexport function ptConstant(e: pt.Constant): CConstant {\n    let value = e.value;\n    let type: CArithmetic;\n\n    if (e.valueType === \"int\" || e.valueType === \"oct\" || e.valueType === \"hex\") {\n        let unsigned = false, long = false;\n        value = value.toLowerCase();\n        if (value.endsWith(\"u\")) {\n            value = value.slice(0, -1);\n            unsigned = true;\n        }\n        if (value.endsWith(\"l\")) {\n            value = value.slice(0, -1);\n            long = true;\n            // may be a second l for long long\n            if (value.endsWith(\"l\")) value = value.slice(0, -1);\n        }\n        if (!unsigned && value.endsWith(\"u\")) {\n            // check u again as u and l can appear in either order\n            value = value.slice(0, -1);\n            unsigned = true;\n        }\n\n        let num: bigint; // all integer constants are stored as BigInt\n        if (e.valueType !== \"oct\") {\n            // BigInt constructor natively handles decimal values and hexadecimal values prefixed with 0x\n            num = BigInt(value);\n        } else {\n            // Have to manually construct octal constants\n            num = 0n;\n            for (let i = 0; i < value.length - 1; i++) { // ignore the leading 0\n                num += BigInt(value[value.length - 1 - i]) * (8n ** BigInt(i));\n            }\n        }\n\n        // Choose the list of possible types from the suffixes and the constant type used (decimal, hex, octal)\n        let possibleTypes;\n        if (e.valueType === \"int\" && !unsigned && !long) {\n            possibleTypes = [CArithmetic.S32, CArithmetic.S64, CArithmetic.U64];\n        } else if (e.valueType !== \"int\" && !unsigned && !long) {\n            possibleTypes = [CArithmetic.S32, CArithmetic.U32, CArithmetic.S64, CArithmetic.U64];\n        } else if (unsigned && long) {\n            possibleTypes = [CArithmetic.U64];\n        } else if (long) {\n            possibleTypes = [CArithmetic.S64, CArithmetic.U64];\n        } else { // if (unsigned)\n            possibleTypes = [CArithmetic.U32, CArithmetic.U64];\n        }\n\n        // find smallest acceptable type which fits the value\n        for (const type of possibleTypes) {\n            if (num >= type.minValue && num <= type.maxValue) {\n                return new CConstant(e, type, num);\n            }\n        }\n        throw new ParseTreeValidationError(e, \"Integer constant too large for its type\");\n\n    } else if (e.valueType === \"float\") {\n        // floats default to double unless suffixed with \"f\"\n        if (value.endsWith(\"f\")) {\n            value = value.slice(0, -1);\n            type = CArithmetic.Fp32;\n        } else {\n            type = CArithmetic.Fp64;\n        }\n        return new CConstant(e, type, parseFloat(value));\n\n    } else if (e.valueType === \"char\") {\n        value = unescapeChar(value, e);\n        return new CConstant(e, CArithmetic.U8, BigInt(value.codePointAt(0)));\n    }\n\n    throw new ParseTreeValidationError(e, \"Invalid constant type?\");\n}\n\n/** Unescape strings as defined in the C standard */\nfunction unescapeChar(s: string, node?: ParseNode): string {\n    if (s.startsWith(\"\\\\\")) {\n        if (s === \"\\\\n\") return \"\\n\";\n        if (s === \"\\\\t\") return \"\\t\";\n        if (s === \"\\\\v\") return \"\\v\";\n        if (s === \"\\\\b\") return \"\\b\";\n        if (s === \"\\\\r\") return \"\\r\";\n        if (s === \"\\\\f\") return \"\\f\";\n        if (s === \"\\\\a\") return \"\\x07\";\n        if (s === \"\\\\\\\\\") return \"\\\\\";\n        if (s === \"\\\\?\") return \"?\";\n        if (s === \"\\\\'\") return \"'\";\n        if (s === '\\\\\"') return '\"';\n\n        let value: number;\n        if (s.startsWith(\"\\\\x\")) {\n            // hex constant\n            value = parseInt(s.slice(2), 16);\n        } else {\n            // octal constant\n            value = parseInt(s.slice(1), 8);\n        }\n\n        if (!isNaN(value) && value >= 0 && value <= 255) {\n            return String.fromCharCode(value);\n        }\n        throw new ParseTreeValidationError(node, \"Invalid character escape\");\n    }\n\n    const codePoint = s.codePointAt(0);\n    if (s.length !== 1 || codePoint === undefined || codePoint > 255) {\n        throw new ParseTreeValidationError(node, \"Invalid character\");\n    }\n    return s;\n}\n","import {parse} from \"../parsing\";\nimport {Expression, Constant, BinaryExpression, UnaryExpression, Identifier} from \"../parsing/parsetree\";\nimport {ptConstant} from \"../ir/transform/expr_transform\";\nimport {Preprocessor} from \"./preprocessor\";\n\nexport function ppEvaluate(x: string, preprocessor: Preprocessor): bigint {\n    const parseTree = parse(`int x = ${x};`);\n    if (parseTree.length !== 1 || parseTree[0].type !== \"declaration\" || parseTree[0].list.length !== 1 || parseTree[0].list[0].type !== \"initDeclarator\" || Array.isArray(parseTree[0].list[0].initializer)) {\n        throw preprocessor.error(\"Invalid #if conditional: `\" + x + \"`\");\n    }\n    const expression = parseTree[0].list[0].initializer as Expression;\n    return _eval(expression, preprocessor);\n}\n\nfunction _eval(n: Expression, preprocessor: Preprocessor): bigint {\n    if (n instanceof Constant && n.valueType !== \"float\") {\n        return BigInt(ptConstant(n).value);\n    } else if (n instanceof BinaryExpression) {\n        switch (n.type) {\n        case \"add\":\n            return _eval(n.lhs, preprocessor) + _eval(n.rhs, preprocessor);\n        case \"sub\":\n            return _eval(n.lhs, preprocessor) - _eval(n.rhs, preprocessor);\n        case \"mul\":\n            return _eval(n.lhs, preprocessor) * _eval(n.rhs, preprocessor);\n        case \"div\":\n            return _eval(n.lhs, preprocessor) / _eval(n.rhs, preprocessor);\n        case \"bitwiseAnd\":\n            return _eval(n.lhs, preprocessor) & _eval(n.rhs, preprocessor);\n        case \"bitwiseOr\":\n            return _eval(n.lhs, preprocessor) | _eval(n.rhs, preprocessor);\n        case \"bitwiseXor\":\n            return _eval(n.lhs, preprocessor) ^ _eval(n.rhs, preprocessor);\n        case \"bitwiseShiftLeft\":\n            return _eval(n.lhs, preprocessor) << _eval(n.rhs, preprocessor);\n        case \"bitwiseShiftRight\":\n            return _eval(n.lhs, preprocessor) >> _eval(n.rhs, preprocessor);\n        case \"relationalEq\":\n            return _eval(n.lhs, preprocessor) === _eval(n.rhs, preprocessor) ? 1n : 0n;\n        case \"relationalNEq\":\n            return _eval(n.lhs, preprocessor) !== _eval(n.rhs, preprocessor) ? 1n : 0n;\n        case \"relationalLT\":\n            return _eval(n.lhs, preprocessor) < _eval(n.rhs, preprocessor) ? 1n : 0n;\n        case \"relationalLEq\":\n            return _eval(n.lhs, preprocessor) <= _eval(n.rhs, preprocessor) ? 1n : 0n;\n        case \"relationalGT\":\n            return _eval(n.lhs, preprocessor) > _eval(n.rhs, preprocessor) ? 1n : 0n;\n        case \"relationalGEq\":\n            return _eval(n.lhs, preprocessor) >= _eval(n.rhs, preprocessor) ? 1n : 0n;\n        case \"logicalAnd\":\n            return (_eval(n.lhs, preprocessor) !== 0n && _eval(n.rhs, preprocessor) !== 0n) ? 1n : 0n;\n        case \"logicalOr\":\n            return (_eval(n.lhs, preprocessor) !== 0n || _eval(n.rhs, preprocessor) !== 0n) ? 1n : 0n;\n        }\n    } else if (n instanceof UnaryExpression) {\n        switch (n.type) {\n        case \"unaryPlus\":\n            return _eval(n.body, preprocessor);\n        case \"unaryMinus\":\n            return -(_eval(n.body, preprocessor));\n        case \"logicalNot\":\n            return _eval(n.body, preprocessor) === 0n ? 1n : 0n;\n        }\n    } else if (n instanceof Identifier) {\n        return 0n;\n    }\n\n    throw preprocessor.error(\"Invalid preprocessor expression\");\n}\n","// preprocessor tokens\nexport type Token = {\n    type?: \"identifier\", // with optional type\n    value: string\n};\n\n// various regexes used\nexport const PreProRegex = {\n    identifier: /^[a-zA-Z_][a-zA-Z0-9_]*/,\n    token: /^(?:\"(?:\\\\\"|[^\\n\"])*\"|[^ \\t\\v\\f\\na-zA-Z_]+)/,\n    whitespace: /^[ \\t\\v\\f]+/,\n    // used in first pass so is global and multiline\n    comments: /\\/\\*[^]*?\\*\\/|\\/\\/.*?$/gm,\n    // used to process conditions\n    condition: /defined(?:[ \\t]*\\([ \\t]*([a-zA-Z_][a-zA-Z0-9_]*)[ \\t]*\\)|[ \\t]+([a-zA-Z_][a-zA-Z0-9_]*))|(d?[^d]*)/gm\n};\n\n// functions to 'consume' text from an input line\ntype ConsumeFailed = { success: false, remainingLine: string };\ntype ConsumeSucceeded = { success: true, remainingLine: string } & Token;\n\n\nexport abstract class PreprocessorBase {\n\n    abstract error(message: string): Error;\n\n    /** Consume identifier, token or whitespace */\n    consumeAny(line: string): ConsumeSucceeded {\n        let match: ConsumeFailed | ConsumeSucceeded;\n        if ((match = this.consume(line, PreProRegex.identifier)).success) {\n            match.type = \"identifier\";\n            return match;\n        } else if ((match = this.consume(line, PreProRegex.token)).success) {\n            return match;\n        } else if ((match = this.consume(line, PreProRegex.whitespace)).success) {\n            return match;\n        }\n        throw this.error(\"Malformed input? Line does not match defined regular expressions.\\n`\" + line + \"`\");\n    }\n\n    /** Consume or throw error */\n    mustConsume(line: string, t: RegExp | string, errorName: string = t.toString()): ConsumeSucceeded {\n        const match = this.consume(line, t);\n        if (match.success) return match;\n\n        throw this.error(`Expected to find ${errorName} but found \\`${line}\\` instead`);\n    }\n\n    consume(line: string, t: RegExp | string): ConsumeFailed | ConsumeSucceeded {\n        if (typeof t === \"string\") {\n            if (line.startsWith(t)) {\n                return {success: true, value: t, remainingLine: line.substring(t.length)};\n            } else {\n                return {success: false, remainingLine: line};\n            }\n        }\n\n        const match = line.match(t);\n        if (match === null) {\n            return {success: false, remainingLine: line};\n        }\n        return {success: true, value: match[0], remainingLine: line.substring(match[0].length)};\n    }\n\n}\n","import {Token, PreProRegex} from \"./helpers\";\nimport type {Preprocessor} from \"./preprocessor\";\n\nexport class Definition {\n\n    constructor(readonly preprocessor: Preprocessor,\n                readonly identifier: string,\n                readonly replacement: Token[],\n                readonly parameters: string[]) {\n    }\n\n    expand(line: string): { output: string, line: string } {\n        if (this.parameters.length > 0) return this.expandWithParameters(line);\n\n        const output = this.replacement.map(x => x.value).join(\"\");\n        return {output, line};\n    }\n\n    private expandWithParameters(line: string) {\n        // check if macro call\n        const originalLine = line;\n        line = this.preprocessor.consume(line, PreProRegex.whitespace).remainingLine;\n        if (line.length === 0 || line[0] !== \"(\") {\n            // not referencing the definition\n            return {output: this.identifier, line: originalLine};\n        }\n        line = this.preprocessor.mustConsume(line, \"(\").remainingLine;\n\n        // consume args\n        const args: string[] = [];\n        for (let i = 0; i < this.parameters.length; i++) {\n            const match = this.consumeArgument(line);\n            args.push(match.value.trim());\n            if (i !== this.parameters.length - 1) {\n                line = this.preprocessor.mustConsume(match.remainingLine, \",\").remainingLine;\n            } else {\n                line = this.preprocessor.mustConsume(match.remainingLine, \")\").remainingLine;\n            }\n        }\n\n        // assemble output\n        let output = \"\";\n        for (const token of this.replacement) {\n            if (token.type === \"identifier\") {\n                const index = this.parameters.indexOf(token.value);\n                if (index >= 0) {\n                    output += this.preprocessor.expandDefinitions(args[index]);\n                    continue; // TODO repeat as needed\n                }\n            }\n            output += token.value;\n        }\n        return {output, line};\n    }\n\n    private consumeArgument(line: string): {value: string, remainingLine: string} {\n        const out = {value: \"\", remainingLine: line};\n        let inQuote = false, bracketDepth = 0;\n\n        while (out.remainingLine.length > 0 && (inQuote || bracketDepth !== 0 || (out.remainingLine[0] !== \",\" && out.remainingLine[0] !== \")\"))) {\n            const char = out.remainingLine[0];\n            let consumed = 1;\n\n            if (inQuote && char === `\\\\` && out.remainingLine[1] === `\"`) {\n                // escaped quote\n                consumed = 2;\n            } else if (!inQuote && char === `'`) {\n                consumed += Math.max(out.remainingLine.indexOf(`'`, 1), 0);\n            } else if (char === `\"`) {\n                inQuote = !inQuote;\n            } else if (char === `(` && !inQuote) {\n                bracketDepth++;\n            } else if (char === `)` && !inQuote) {\n                bracketDepth--;\n            }\n\n            out.value += out.remainingLine.substring(0, consumed);\n            out.remainingLine = out.remainingLine.substring(consumed);\n        }\n        return out;\n    }\n\n    equals(t: this): boolean {\n        return t.identifier === this.identifier &&\n            t.replacement.length === this.replacement.length &&\n            t.replacement.every((v, i) => v.value === this.replacement[i].value) &&\n            t.parameters.length === this.parameters.length &&\n            t.parameters.every((v, i) => v === this.parameters[i]);\n    }\n}\n","import {LIBRARY_HEADERS} from \"../c_library/standard_library\";\nimport {ppEvaluate} from \"./conditionals\";\nimport {Definition} from \"./definition\";\nimport {PreProRegex, PreprocessorBase} from \"./helpers\";\n\nexport class Preprocessor extends PreprocessorBase {\n    definitions = new Map<string, Definition>();\n\n    libraryFiles: Map<string, string>; // #include <...>\n    userFiles = new Map<string, string>(); // #include \"...\"\n\n    constructor(readonly filename: string, standardHeaders: boolean = true, customDefinitions?: {[key: string]: string}) {\n        super();\n        if (standardHeaders) {\n            this.libraryFiles = new Map<string, string>(LIBRARY_HEADERS);\n        } else {\n            this.libraryFiles = new Map<string, string>();\n        }\n\n        this.definitions.set(\"__FILE__\", new Definition(this, \"__FILE__\", [{value: `\"${filename}\"`}], []));\n        this.definitions.set(\"__c2wasm__\", new Definition(this, \"__c2wasm__\", [{value: \"1\"}], []));\n\n        if (customDefinitions) {\n            for (const [key, value] of Object.entries(customDefinitions)) {\n                this.definitions.set(key, new Definition(this, key, [{value}], []));\n            }\n        }\n    }\n\n    process(text: string, filename: string = this.filename): string {\n        // replace crlf with lf\n        text = text.replace(/\\r\\n/g, \"\\n\");\n        // remove comments\n        text = text.replace(PreProRegex.comments, \" \");\n        // remove line continuations\n        const lines = text.replace(/\\\\\\n/g, \"\").split(\"\\n\");\n\n        let output = \"\";\n        while (lines.length > 0) {\n            let line = lines.shift() as string;\n\n            if (line.startsWith(\"#\")) {\n                line = line.substring(1).trimStart();\n\n                let match: ReturnType<typeof Preprocessor.prototype[\"consume\"]>;\n                if ((match = this.consume(line, \"define\")).success) {\n                    this._define(match.remainingLine);\n                } else if ((match = this.consume(line, \"undef\")).success) {\n                    this._undef(match.remainingLine);\n                } else if ((match = this.consume(line, \"include\")).success) {\n                    output += this._include(match.remainingLine) + \"\\n\";\n                } else if ((match = this.consume(line, \"ifdef\")).success) {\n                    this._ifdef(match.remainingLine, true, lines);\n                } else if ((match = this.consume(line, \"ifndef\")).success) {\n                    this._ifdef(match.remainingLine, false, lines);\n                } else if ((match = this.consume(line, \"if\")).success) {\n                    output += this._if(match.remainingLine, lines);\n                } else if ((match = this.consume(line, \"pragma\")).success) {\n                    const l = this.mustConsume(match.remainingLine, PreProRegex.whitespace, \"whitespace\").remainingLine;\n                    if (l.trim() === \"once\") {\n                        // only include source file once\n                        const defName = `__pragma_once_${filename}__`;\n                        if (this.definitions.has(defName)) return output;\n                        this.definitions.set(defName, new Definition(this, defName, [], []));\n                    }\n                    // unknown pragmas must be ignored\n                } else if ((match = this.consume(line, \"error\")).success) {\n                    throw this.error(\"#\" + line);\n                } else if (line.trim().length > 1) {\n                    throw this.error(`Unknown preprocessor directive \"#${line}\"`);\n                }\n\n            } else {\n                output += this.expandDefinitions(line) + \"\\n\";\n            }\n        }\n        return output;\n    }\n\n    expandDefinitions(line: string, definitions = this.definitions): string {\n        let output = \"\";\n        while (line.length > 0) {\n            const token = this.consumeAny(line);\n            if (token?.type === \"identifier\") {\n                const def = definitions.get(token.value);\n                if (def !== undefined) {\n                    const e = def.expand(token.remainingLine);\n\n                    // \"once a given identifier has been replaced in a given expansion,\n                    // it is not replaced if it turns up again during rescanning\"\n                    const newDefinitions = new Map(definitions);\n                    newDefinitions.delete(token.value);\n\n                    let output1 = e.output, output2 = \"\";\n                    while (output1 !== output2) {\n                        output2 = output1;\n                        output1 = this.expandDefinitions(output1, newDefinitions);\n                    }\n\n                    output += output1;\n                    line = e.line;\n                    continue;\n                }\n            }\n            output += token?.value;\n            line = token.remainingLine;\n        }\n        return output;\n    }\n\n    error(message: string): Error {\n        return new class extends Error {\n            name = \"PreprocessorError\";\n        }(`In file '${this.filename}': ${message}`);\n    }\n\n    private _include(line: string): string {\n        line = this.mustConsume(line, PreProRegex.whitespace, \"whitespace\").remainingLine.trim();\n        if (line.startsWith('\"') && line.endsWith('\"')) {\n            return this._includeUser(line.substring(1, line.length - 1));\n        } else if (line.startsWith(\"<\") && line.endsWith(\">\")) {\n            return this._includeLib(line.substring(1, line.length - 1));\n        }\n\n        // if failed try expand macros\n        line = this.expandDefinitions(line);\n        if (line.startsWith('\"') && line.endsWith('\"')) {\n            return this._includeUser(line.substring(1, line.length - 1));\n        } else if (line.startsWith(\"<\") && line.endsWith(\">\")) {\n            return this._includeLib(line.substring(1, line.length - 1));\n        }\n\n        throw this.error(\"Invalid #include\");\n    }\n\n    private _includeLib(path: string) {\n        const file = this.libraryFiles.get(path);\n        if (file === undefined) throw this.error(\"Unknown path `\" + path + \"`\");\n        return this.process(file, `<${path}>`);\n    }\n\n    private _includeUser(path: string) {\n        const localPath = this.filename.replace(/[^/\\\\]*$/, path);\n        let file = this.userFiles.get(localPath);\n        if (file === undefined) {\n            file = this.userFiles.get(path);\n            if (file === undefined) return this._includeLib(path);\n        }\n        return this.process(file, path);\n    }\n    private _define(line: string) {\n        line = this.mustConsume(line, PreProRegex.whitespace, \"whitespace\").remainingLine;\n        const identifier = this.mustConsume(line, PreProRegex.identifier, \"identifier\");\n        const tokens = [];\n        const parameters: string[] = [];\n\n        if (identifier.remainingLine.trim().length > 0) {\n            if (identifier.remainingLine[0] === \"(\") {\n                // definition with parameters\n                line = this.mustConsume(identifier.remainingLine, \"(\").remainingLine;\n                while (line.length > 0) {\n                    line = this.consume(line, PreProRegex.whitespace).remainingLine;\n                    const parameter = this.mustConsume(line, PreProRegex.identifier, \"identifier\");\n                    parameters.push(parameter.value);\n                    line = this.consume(parameter.remainingLine, PreProRegex.whitespace).remainingLine;\n\n                    if (line.length === 0) {\n                        throw this.error(\"Unexpected end of line\");\n                    } else if (line[0] === \",\") {\n                        line = this.mustConsume(line, \",\").remainingLine;\n                    } else if (line[0] === \")\") {\n                        break;\n                    } else {\n                        throw this.error(\"Unexpected\");\n                    }\n                }\n                line = this.mustConsume(line, \")\").remainingLine;\n                if (line.length > 0) {\n                    line = this.mustConsume(line, PreProRegex.whitespace, \"whitespace\").remainingLine;\n                }\n\n            } else {\n                // normal definition\n                line = this.mustConsume(identifier.remainingLine, PreProRegex.whitespace, \"whitespace\").remainingLine;\n            }\n\n            // body\n            while (line.length > 0) {\n                const token = this.consumeAny(line);\n                if (token.type !== \"identifier\" || !parameters.includes(token.value)) {\n                    token.value = this.expandDefinitions(token.value);\n                }\n\n                tokens.push(token);\n                line = token.remainingLine;\n            }\n        }\n\n        const def = new Definition(this, identifier.value, tokens, parameters);\n        const existing = this.definitions.get(identifier.value);\n        if (existing !== undefined && !def.equals(existing)) {\n            throw this.error(\"Duplicate defines must be the same\");\n        }\n        this.definitions.set(identifier.value, def);\n    }\n\n    private _undef(line: string) {\n        line = this.mustConsume(line, PreProRegex.whitespace, \"whitespace\").remainingLine;\n        const identifier = this.mustConsume(line, PreProRegex.identifier, \"identifier\");\n        if (identifier.remainingLine.trim().length !== 0) throw this.error(\"Unexpected extra characters in undef\");\n        this.definitions.delete(identifier.value);\n    }\n\n    private _ifdef(line: string, ifdef: boolean, lines: string[]) {\n        line = this.mustConsume(line, PreProRegex.whitespace, \"whitespace\").remainingLine;\n        const identifier = this.mustConsume(line, PreProRegex.identifier, \"identifier\");\n        lines.unshift(`#if ${ifdef ? \"\" : \"!\"} defined ${identifier.value}`);\n    }\n\n    private _if(line: string, lines: string[]): string {\n        const expression = this.mustConsume(line, PreProRegex.whitespace, \"whitespace\").remainingLine;\n        let condition = this._condition(expression), anyCondition = condition, depth = 1, hadElse = false;\n\n        const body: string[] = [];\n        for (let i = 0; i < lines.length; i++) {\n            const line = lines[i].trimEnd();\n\n            if (line.startsWith(\"#if\")) {\n                depth++;\n\n            } else if (line === \"#endif\") {\n                depth--;\n                if (depth === 0) {\n                    // well formed ifdef\n                    lines.splice(0, i + 1);\n                    return this.process(body.join(\"\\n\"));\n                }\n\n            } else if (line === \"#else\" && depth === 1) {\n                if (hadElse) throw this.error(\"more than one #else statement\");\n                hadElse = true;\n\n                condition = !anyCondition;\n                anyCondition = true;\n                continue;\n            } else if (line.startsWith(\"#elif\") && depth === 1) {\n                if (anyCondition) {\n                    condition = false;\n                } else {\n                    const expression = this.mustConsume(lines[i].substring(5), PreProRegex.whitespace, \"whitespace\").remainingLine;\n                    condition = this._condition(expression);\n                    anyCondition ||= condition;\n                }\n                continue;\n            }\n\n            if (condition) body.push(lines[i]);\n        }\n\n        throw this.error(\"no matching #endif found\");\n    }\n\n    private _condition(s: string): boolean {\n        // deal with \"defined ...\"\n        let processed = \"\";\n        for (const match of s.matchAll(PreProRegex.condition)) {\n            if (match.length !== 4) throw this.error(\"invalid regex result when processing #if condition\");\n            const definitionName = match[1] ?? match[2];\n            if (definitionName) {\n                processed += this.definitions.has(definitionName) ? \" 1L \" : \" 0L \";\n            } else {\n                processed += match[3];\n            }\n        }\n        // expand remaining macros\n        processed = this.expandDefinitions(processed);\n        // try evaluate\n        try {\n            return ppEvaluate(processed, this) !== 0n;\n        } catch (e) {\n            throw this.error(\"Invalid condition `\" + s + \"`\");\n        }\n    }\n}\n","import {ParseTreeValidationError, pt} from \"../../parsing\";\nimport {CFuncDefinition, CArgument, CFuncDeclaration, CVarDefinition, CVarDeclaration} from \"../declarations\";\nimport {CAssignment, CIdentifier, CExpression, CInitializer, CStringLiteral, CConstant} from \"../expressions\";\nimport {INTERNAL_SCOPE} from \"../internal_scope\";\nimport {Scope} from \"../scope\";\nimport {CStatement, CCompoundStatement, CExpressionStatement, CNop, CIf, CForLoop, CWhileLoop, CDoLoop, CSwitch, CBreak, CContinue, CReturn, CGoto, CLabelledStatement} from \"../statements\";\nimport {ExpressionTypeError} from \"../type_checking\";\nimport {CFuncType, CVoid, CArray, CArithmetic, CPointer} from \"../types\";\nimport {ptExpression, evalIntegerConstant} from \"./expr_transform\";\nimport {getDeclaratorName, getDeclaratorType, getType} from \"./type_transform\";\n\n/** Main function, transform a parse tree translation unit into a root scope */\nexport function ptTransform(translationUnit: pt.TranslationUnit): Scope {\n    const fileScope = new Scope(undefined, INTERNAL_SCOPE);\n    for (const decl of translationUnit) {\n        if (decl instanceof pt.FunctionDefinition) {\n            ptFunction(decl, fileScope);\n        } else {\n            ptDeclaration(decl, fileScope, false);\n        }\n    }\n    return fileScope;\n}\n\n/** Add the pt declarations to the scope, and either store their static initializer on the variables or return a\n * list of assignments to add to the body of the current function to set their initial values */\nfunction ptDeclaration(declaration: pt.Declaration, scope: Scope, inFunction: boolean): CAssignment[] {\n    if (declaration.typeInfo.storageList[0] === \"typedef\") {\n        ptTypedef(declaration, scope);\n        return [];\n    }\n\n    const declType = getType(declaration, scope);\n    const assignments = [];\n    for (let entry of declaration.list) {\n        const name = getDeclaratorName(entry);\n\n        let initialValue: CExpression | CInitializer | undefined;\n        if (entry instanceof pt.InitDeclarator) {\n            initialValue = ptInitializer(entry, entry.initializer, scope);\n            entry = entry.body;\n        }\n\n        const type = getDeclaratorType(declType, entry, scope);\n        const initialType = initialValue?.type instanceof CPointer ? initialValue.type.original ?? initialValue.type : initialValue?.type;\n        if (initialType instanceof CArray && type instanceof CArray && type.incomplete) {\n            // initialize array length from initializer if incomplete\n            type.length = initialType.length;\n        }\n\n        if (type.incomplete) {\n            throw new ExpressionTypeError(type.node ?? entry, \"complete type\", \"incomplete type\");\n        } else if (type instanceof CFuncType) {\n            // function declarations\n            const linkage = declaration.typeInfo.storageList[0] === \"static\" ? \"internal\" : \"external\";\n            const fnImport = declaration.typeInfo.fnSpecifierList[0] === \"import\";\n            scope.addIdentifier(new CFuncDeclaration(entry, name, type, linkage, fnImport));\n        } else {\n            if (declaration.typeInfo.fnSpecifierList.length > 0) {\n                throw new ExpressionTypeError(entry, \"variable declaration with function specifier\");\n            }\n\n            // work out storage, linkage and if definition or declaration\n            let storage: \"static\" | \"local\";\n            let linkage: \"none\" | \"internal\" | \"external\";\n            let declType: typeof CVarDefinition | typeof CVarDeclaration;\n            if (declaration.typeInfo.storageList[0] === \"static\") {\n                storage = \"static\";\n                linkage = inFunction ? \"none\" : \"internal\";\n                declType = inFunction ? CVarDefinition : (initialValue !== undefined ? CVarDefinition : CVarDeclaration);\n            } else if (declaration.typeInfo.storageList[0] === \"extern\") {\n                storage = \"static\";\n                linkage = \"external\";\n                declType = CVarDeclaration;\n            } else {\n                storage = inFunction ? \"local\" : \"static\";\n                linkage = inFunction ? \"none\" : \"external\";\n                declType = inFunction ? CVarDefinition : (initialValue !== undefined ? CVarDefinition : CVarDeclaration);\n            }\n            const cvar = new declType(entry, name, type, storage, linkage);\n            scope.addIdentifier(cvar);\n\n            // if definition with initializer\n            if (initialValue) {\n                if (cvar instanceof CVarDeclaration) {\n                    throw new ExpressionTypeError(entry, \"declaration\", \"declaration with initializer\");\n                }\n                if (initialValue instanceof CInitializer) {\n                    initialValue.type = type;\n                }\n                if (initialValue instanceof CConstant && type instanceof CArithmetic && type !== initialValue.type) {\n                    // force constants to take the correct type\n                    initialValue = initialValue.changeType(type);\n                }\n\n                if (inFunction && cvar.storage !== \"static\") {\n                    const id: CExpression = new CIdentifier(entry, cvar);\n                    assignments.push(new CAssignment(entry, id, initialValue, undefined, true));\n                } else {\n                    // static initialization, must be constant and evaluated at compile time\n                    cvar.staticValue = initialValue;\n                    CAssignment.checkAssignmentValid(entry, type, cvar.staticValue);\n\n                    // setup variable dependencies\n                    for (const identifier of initialValue.identifiers()) {\n                        cvar.dependencies.set(identifier.value, true);\n                    }\n                }\n            }\n        }\n    }\n    return assignments;\n}\n\nfunction ptTypedef(node: pt.Declaration, scope: Scope) {\n    if (node.list.length === 0) throw new ParseTreeValidationError(node, \"typedef must define at least one identifier\");\n    const baseType = getType(node, scope);\n\n    for (const decl of node.list) {\n        if (decl instanceof pt.InitDeclarator) throw new ParseTreeValidationError(node, \"cannot initialize a typedef\");\n        const type = getDeclaratorType(baseType, decl, scope);\n        const name = getDeclaratorName(decl);\n        scope.addTypedef(name, type, decl);\n    }\n}\n\n/** Transform an initializer to either a CInitializer (for arrays, structs & unions) or a CExpression */\nfunction ptInitializer(node: pt.ParseNode, initializer: pt.Initializer, scope: Scope): CExpression | CInitializer {\n    if (Array.isArray(initializer)) {\n        return new CInitializer(node, initializer.map(x => ptInitializer(node, x, scope)));\n    } else {\n        return ptExpression(initializer as pt.Expression, scope);\n    }\n}\n\n/** Transform a function */\nfunction ptFunction(fn: pt.FunctionDefinition, scope: Scope): void {\n    if (fn.typeInfo.fnSpecifierList[0] === \"import\") {\n        throw new ExpressionTypeError(fn, \"function definition to not be marked `import`\");\n    }\n\n    // get and check the function's type\n    const type = getType(fn, scope);\n    if (!(type instanceof CFuncType)) throw new ParseTreeValidationError(fn, \"Unexpected declarator\");\n    // get the function name\n    const name = getDeclaratorName(fn.declarator);\n\n    let linkage: \"internal\" | \"external\";\n    if (fn.typeInfo.storageList[0] === \"static\") linkage = \"internal\";\n    else if (fn.typeInfo.storageList[0] === \"typedef\") throw new ParseTreeValidationError(fn, \"Invalid typedef\");\n    else linkage = \"external\";\n\n    const cfn = new CFuncDefinition(fn, name, type, linkage, scope);\n    cfn.hints.inline = fn.typeInfo.fnSpecifierList[0] === \"inline\";\n    scope.addIdentifier(cfn);\n\n    // add arguments as parameters to function's scope\n    if (!type.parameterNames) throw new ParseTreeValidationError(fn, \"Expected parameter names\");\n    for (let i = 0; i < type.parameterTypes.length; i++) {\n        cfn.body.scope.addIdentifier(new CArgument(fn, type.parameterNames[i], type.parameterTypes[i], i));\n    }\n\n    // parse function body body\n    ptCompound(fn.body, cfn);\n\n    // check function always returns\n    if (!(type.returnType instanceof CVoid) && !checkReturns(cfn.body)) {\n        throw new ParseTreeValidationError(fn.body, \"Non-void function may not return\");\n    }\n}\n\n/** Checks every branch through a function will definitely return */\nfunction checkReturns(statement: CStatement | undefined): boolean {\n    if (statement instanceof CReturn) {\n        return true;\n    } else if (statement instanceof CCompoundStatement) {\n        for (let i = 0; i < statement.statements.length; i++) {\n            if (checkReturns(statement.statements[i])) {\n                if (i + 1 < statement.statements.length) {\n                    // statements after return\n\n                    if (statement.statements[i + 1] === statement.scope.labelledStatement?.body) {\n                        // this is okay as the following statement is labelled, so can jump there\n                        continue; // check code after jumping to the label returns\n                    }\n\n                    // not okay - no way to reach statements after return\n                    throw new ParseTreeValidationError(statement.statements[i + 1].node, \"Statement after return\");\n                }\n                return true;\n            }\n        }\n    } else if (statement instanceof CIf) {\n        return checkReturns(statement.ifBody) && checkReturns(statement.elseBody);\n    } else if (statement instanceof CDoLoop) {\n        return checkReturns(statement.body);\n    } else if (statement instanceof CSwitch) {\n        // if every child returns and there's a default statement then switch is safe\n        return statement.children.every(x => checkReturns(x.body)) &&\n            statement.children.find(x => x.default) !== undefined;\n    }\n    return false;\n}\n\n/** Transform statements from the parse tree */\nfunction ptStatement(node: pt.Statement, parent: CStatement): CStatement {\n    if (node instanceof pt.CompoundStatement) {\n        return ptCompound(node, parent);\n\n    } else if (node instanceof pt.ExpressionStatement) {\n        return new CExpressionStatement(node, ptExpression(node.expression, parent.scope), parent);\n\n    } else if (node instanceof pt.IfStatement) {\n        const s = new CIf(node, ptExpression(node.expression, parent.scope), parent);\n        s.ifBody = ptStatement(node.ifBody, s);\n        if (node.elseBody) s.elseBody = ptStatement(node.elseBody, s);\n        return s;\n\n    } else if (node instanceof pt.ForLoop) {\n        const s = new CForLoop(node, parent);\n        if (node.init instanceof pt.ExpressionStatement || node.init instanceof pt.NoOp) {\n            s.init = ptStatement(node.init, s) as CExpressionStatement | CNop;\n        } else {\n            s.init = ptDeclaration(node.init, s.scope, true)\n                .map(e => new CExpressionStatement(e.node, e, s));\n        }\n        s.test = ptStatement(node.test, s) as CExpressionStatement | CNop;\n        if (node.update) s.update = ptExpression(node.update, s.scope);\n        s.body = ptStatement(node.body, s);\n        return s;\n\n    } else if (node instanceof pt.WhileLoop) {\n        const s = new CWhileLoop(node, ptExpression(node.test, parent.scope), parent);\n        s.body = ptStatement(node.body, s);\n        return s;\n\n    } else if (node instanceof pt.DoWhileLoop) {\n        const s = new CDoLoop(node, ptExpression(node.test, parent.scope), parent);\n        s.body = ptStatement(node.body, s);\n        return s;\n\n    } else if (node instanceof pt.GotoStatement) {\n        let p: CStatement | CFuncDefinition = parent; // find which statement this goto is targeting\n        while (p.scope.labelledStatement?.label !== node.target) {\n            if (p.parent instanceof CFuncDefinition) {\n                throw new ParseTreeValidationError(node, \"No properly structured control flow target for goto statement\");\n            }\n            p = p.parent;\n        }\n        return new CGoto(node, p.scope.labelledStatement, parent);\n\n    } else if (node instanceof pt.ContinueStatement) {\n        let p: CStatement = parent; // find which statement this node is continuing\n        while (!(p instanceof CForLoop || p instanceof CWhileLoop || p instanceof CDoLoop)) {\n            if (p.parent instanceof CFuncDefinition) {\n                throw new ParseTreeValidationError(node, \"No target for continue statement\");\n            }\n            p = p.parent;\n        }\n        return new CContinue(node, p, parent);\n\n    } else if (node instanceof pt.BreakStatement) {\n        let p: CStatement = parent;\n        while (!(p instanceof CForLoop || p instanceof CWhileLoop || p instanceof CDoLoop || p instanceof CSwitch)) {\n            if (p.parent instanceof CFuncDefinition) {\n                throw new ParseTreeValidationError(node, \"No target for break statement\");\n            }\n            p = p.parent;\n        }\n        return new CBreak(node, p, parent);\n\n    } else if (node instanceof pt.SwitchStatement) {\n        const s = new CSwitch(node, ptExpression(node.expression, parent.scope), parent);\n        ptSwitchBody(s, node, parent.scope);\n        return s;\n\n    } else if (node instanceof pt.ReturnStatement) {\n        let p: CStatement | CFuncDefinition = parent;\n        while (!(p instanceof CFuncDefinition)) p = p.parent;\n\n        const value = node.value ? ptExpression(node.value, parent.scope) : undefined;\n        return new CReturn(node, p, value, parent);\n\n    } else if (node instanceof pt.NoOp) {\n        return new CNop(node, parent);\n\n    } else if (node instanceof pt.CaseStatement) {\n        // allowed case/default statements handled in ptSwitchBody\n        throw new ParseTreeValidationError(node, \"Unexpected case statement\");\n    } else if (node instanceof pt.DefaultStatement) {\n        throw new ParseTreeValidationError(node, \"Unexpected default statement\");\n    }\n\n    throw new ParseTreeValidationError(node, \"Unknown statement type\");\n}\n\n/** Transform compound statements */\nfunction ptCompound(node: pt.CompoundStatement, parent: CStatement | CFuncDefinition): CCompoundStatement {\n    const c = parent instanceof CFuncDefinition ? parent.body : new CCompoundStatement(node, parent);\n\n    // need to check for labelled statements first to allow jumping forward\n    const labelled = node.body.filter(x => x instanceof pt.Statement && x.label !== undefined) as pt.Statement[];\n    if (labelled.length > 1) {\n        throw new ParseTreeValidationError(labelled[0], \"Only one labelled statement is supported per block\", labelled[1]);\n    } else if (labelled.length === 1) {\n        c.scope.labelledStatement = new CLabelledStatement(labelled[0], labelled[0].label as string);\n    }\n\n    for (const child of node.body) {\n        _compoundBody(child, c);\n    }\n    return c;\n}\n\n/** Transform a declaration or statement inside a compound statement */\nfunction _compoundBody(child: pt.Declaration | pt.Statement, c: CCompoundStatement) {\n    if (child instanceof pt.Declaration) {\n        for (const assignment of ptDeclaration(child, c.scope, true)) {\n            // add initializers to body of the statement to ensure they happen in the correct order\n            c.statements.push(new CExpressionStatement(assignment.node, assignment, c));\n        }\n    } else {\n        const statement = ptStatement(child, c);\n        c.statements.push(statement);\n\n        if (child.label !== undefined && c.scope.labelledStatement?.node === child) {\n            // now store the statement\n            c.scope.labelledStatement.body = statement;\n        }\n    }\n}\n\n/** Transform the body of a switch statement.\n *\n * This is quite complicated as case & default statements both absorb the following statement.\n * Furthermore, these statements are limited to being used at the top level inside the switch statement, whereas in C\n * you can place them inside other statements inside the switch block, creating arbitrary goto which is out of scope.\n */\nfunction ptSwitchBody(s: CSwitch, node: pt.SwitchStatement, scope: Scope) {\n    if (!(node.body instanceof pt.CompoundStatement)) {\n        throw new ParseTreeValidationError(node, \"Expected switch statement to have a compound statement body\");\n    }\n    const children = node.body.body.slice();\n    while (children.length > 0) { // iterate over the body of the switch statement\n        const child = children.shift();\n        if (child instanceof pt.CaseStatement || child instanceof pt.DefaultStatement) {\n            let block;\n            if (s.children.length > 0 && s.children[s.children.length - 1].body.statements.length === 0) {\n                // multiple cases in a row, use the last defined block\n                block = s.children[s.children.length - 1];\n            } else {\n                // last block already has children, make a new block\n                block = {cases: [], default: false, body: new CCompoundStatement(node, s)};\n                s.children.push(block);\n            }\n\n            if (child instanceof pt.CaseStatement) { // add the case or mark this block as accepting default\n                block.cases.push(evalIntegerConstant(child.value, scope));\n            } else {\n                block.default = true;\n            }\n\n            // case and default statements eat a statement\n            children.unshift(child.body);\n        } else if (child) {\n            // handle other statements as if this was a compound statement\n            if (s.children.length === 0) {\n                throw new ParseTreeValidationError(child, \"Unexpected first statement inside a switch statement\");\n            }\n            const compound = s.children[s.children.length - 1].body;\n            _compoundBody(child, compound);\n        }\n    }\n}\n","import {parse} from \"../parsing\";\nimport {Scope} from \"./scope\";\nimport {ptTransform} from \"./transform/transform\";\n\nexport function toIR(source: string): Scope {\n    const translationUnit = parse(source);\n    return ptTransform(translationUnit);\n}\n","import {CError} from \"./c_error\";\nimport {ParseNode} from \"./parsing\";\nimport {Preprocessor} from \"./preprocessor\";\nimport {toIR} from \"./ir\";\nimport {CFuncDefinition, CFuncDeclaration, CVarDeclaration, CVarDefinition, CFuncImport, CDeclaration, CArgument} from \"./ir/declarations\";\nimport {Scope} from \"./ir/scope\";\nimport {CStatement, CCompoundStatement, CForLoop, CIf, CWhileLoop, CDoLoop, CSwitch} from \"./ir/statements\";\n\ntype Emitable = CFuncDefinition | CFuncImport | CVarDefinition;\n\nexport class Linker {\n    private _emitExportedFunctions: CFuncDefinition[] = [];\n    private _emitFunctions: CFuncDefinition[] = [];\n    private _emitImports: CFuncDeclaration[] = [];\n    private _emitVariables: CVarDefinition[] = [];\n\n    private _linkables = new Map<string, ExternalFunction | ExternalVariable>();\n    private _linked = false;\n\n    constructor(readonly files: ReadonlyMap<string, string>, standardHeaders: boolean = true, customDefinitions?: {[key: string]: string}) {\n        for (const [path, code] of files.entries()) {\n            if (!path.endsWith(\".c\")) continue;\n\n            const preprocessor = new Preprocessor(path, standardHeaders, customDefinitions);\n            for (const [p2, c2] of files.entries()) preprocessor.userFiles.set(p2, c2);\n            const processed = preprocessor.process(code);\n            try {\n                this.process_scope(toIR(processed));\n            } catch (e) {\n                e.message = (e.message ?? \"\") + \"\\nIn file: \" + path;\n                throw e;\n            }\n        }\n    }\n\n    /** check complete or link with others */\n    public link(...linkers: Linker[]): void {\n        if (this._linked) throw new LinkingError(\"Already linked!\");\n        if (linkers && linkers.some(x => !x._linked)) throw new LinkingError(\"Cannot link against a not-linked Linker!\");\n\n        outerLoop: // link this with others\n        for (const linkable of this._linkables.values()) {\n            if (linkable.definition !== undefined) continue; // we've got a definition\n\n            for (const other of linkers) {\n                const linkable2 = other._linkables.get(linkable.id);\n                if (linkable2 !== undefined && linkable2.definition) {\n                    if (linkable instanceof ExternalFunction && linkable2 instanceof ExternalFunction) {\n                        // we've found a definition in the other linker we can use!\n                        linkable.setDefinition(linkable2.definition, other);\n                    } else if (linkable instanceof ExternalVariable && linkable2 instanceof ExternalVariable) {\n                        // have to be separate branches to please TS\n                        linkable.setDefinition(linkable2.definition, other);\n                    } else {\n                        throw new LinkingError(\"Tried to link incompatible types\", linkable.parseNode, linkable2.parseNode);\n                    }\n                    continue outerLoop;\n                }\n            }\n\n            if (linkable.externalType === \"variable\") {\n                // each external variable declaration is also a tentative definition, so initialize to zero\n                const cvar = new CVarDefinition(linkable.parseNode, linkable.id, linkable.type, \"static\", \"external\");\n                linkable.setDefinition(cvar, this);\n                continue;\n            } else if (linkable.externalType === \"function\" && linkable.declarationArray[0].fnImport) {\n                // define the function import if didn't already exist in other linker\n                linkable.setDefinition(new CFuncImport(linkable.declarationArray[0]), this);\n                continue;\n            }\n\n            throw new LinkingError(\"Failed to find definition\", linkable.parseNode);\n        }\n\n        // now work out which functions and imports to emit\n        const seen = new Map<Emitable, boolean>();\n        const toEmit: Emitable[] = [];\n        for (const linkable of this._linkables.values()) {\n            if (linkable.definition === undefined) {\n                throw new LinkingError(\"Invalid state - declaration has no definition in emit\", linkable.parseNode);\n            } else if (linkable.definitionLinker === this) {\n                seen.set(linkable.definition, true);\n                toEmit.unshift(linkable.definition);\n            }\n        }\n\n        while (toEmit.length) {\n            const dependency = toEmit.shift() as Emitable;\n            if (dependency instanceof CFuncImport) {\n                this._emitImports.push(dependency.declaration);\n            } else {\n                if (dependency.declType === \"variable\") {\n                    if (dependency.storage === \"static\") this._emitVariables.push(dependency);\n                } else if (dependency.linkage === \"external\" && this._linkables.get(dependency.name)?.definitionLinker === this) {\n                    this._emitExportedFunctions.push(dependency);\n                } else {\n                    this._emitFunctions.push(dependency);\n                }\n\n                for (const dep2 of dependency.dependencies.keys() as IterableIterator<CDeclaration>) {\n                    if (dep2 instanceof CFuncDeclaration || dep2 instanceof CVarDeclaration) {\n                        if (dep2.node.type === \"__internal__\") {\n                            // not a real function! __wasm__ etc\n                        } else if (dep2.definition === undefined) {\n                            throw new LinkingError(\"Invalid state - declaration doesn't have definition in emit\", dep2.node);\n                        } else if (!seen.has(dep2.definition)) {\n                            seen.set(dep2.definition, true);\n                            toEmit.push(dep2.definition);\n                        }\n                    } else if (!(dep2 instanceof CArgument) && !seen.has(dep2)) {\n                        seen.set(dep2, true);\n                        toEmit.push(dep2);\n                    }\n                }\n            }\n        }\n\n        this._linked = true;\n    }\n\n    get emitExportedFunctions(): ReadonlyArray<CFuncDefinition> {\n        return this._emitExportedFunctions;\n    }\n\n    get emitFunctions(): ReadonlyArray<CFuncDefinition> {\n        return this._emitFunctions;\n    }\n\n    get emitImports(): ReadonlyArray<CFuncDeclaration> {\n        return this._emitImports;\n    }\n\n    get emitVariables(): ReadonlyArray<CVarDefinition> {\n        return this._emitVariables;\n    }\n\n    private process_scope(scope: Scope) {\n        for (const decl of scope.declarations) {\n\n            if (decl instanceof CFuncDeclaration) {\n                if (decl.linkage === \"external\") {\n                    this.externalFn(decl).addDeclaration(decl);\n                } else if (decl.fnImport) {\n                    decl.definition = new CFuncImport(decl);\n                } else {\n                    throw new LinkingError(\"No definition of internally linked function\", decl.node);\n                }\n\n            } else if (decl instanceof CFuncDefinition) {\n                if (decl.linkage === \"external\") {\n                    this.externalFn(decl).setDefinition(decl, this);\n                }\n                this.process_fn_body(decl.body);\n\n            } else if (decl instanceof CVarDeclaration) { // \"tentative definition\" - if no def found initialize to 0\n                if (decl.linkage === \"external\") {\n                    this.externalVar(decl).addDeclaration(decl);\n                } else {\n                    // tentative definition with internal linkage\n                    decl.definition = new CVarDefinition(decl.node, decl.name, decl.type, decl.storage, decl.linkage);\n\n                    // don't emit now, will emit when linking if used\n                    // this._emitVariables.push(decl.definition);\n                }\n\n            } else if (decl instanceof CVarDefinition) {\n                if (decl.linkage === \"external\") {\n                    this.externalVar(decl).setDefinition(decl, this);\n                }\n                // if (decl.storage === \"static\") this._emitVariables.push(decl);\n\n            }\n        }\n    }\n\n    private process_fn_body(statement: CStatement) {\n        // find all scopes\n\n        if (statement instanceof CCompoundStatement) {\n            this.process_scope(statement.scope);\n            for (const child of statement.statements) this.process_fn_body(child);\n        } else if (statement instanceof CForLoop) {\n            this.process_scope(statement.scope);\n            if (statement.body) this.process_fn_body(statement.body);\n        } else if (statement instanceof CIf) {\n            if (statement.ifBody) this.process_fn_body(statement.ifBody);\n        } else if (statement instanceof CWhileLoop || statement instanceof CDoLoop) {\n            if (statement.body) this.process_fn_body(statement.body);\n        } else if (statement instanceof CSwitch) {\n            for (const child of statement.children) this.process_fn_body(child.body);\n        }\n    }\n\n    private externalFn(node: CFuncDeclaration | CFuncDefinition): ExternalFunction {\n        let result = this._linkables.get(node.name);\n        if (result === undefined) {\n            this._linkables.set(node.name, result = new ExternalFunction(node.name, node.type));\n        } else if (result instanceof ExternalVariable) {\n            throw new LinkingError(\"Tried to link function with variable\", node.node, result.parseNode);\n        } else if (!result.type.equals(node.type)) {\n            throw new LinkingError(\"Tried to link functions with incompatible types\", node.node, result.parseNode);\n        } else if ((node instanceof CFuncDefinition ? false : node.fnImport) !== (result.definition ? false : result.declarationArray[0].fnImport)) {\n            throw new LinkingError(\"Tried to link mix of functions marked import\", node.node, result.parseNode);\n        }\n        return result;\n    }\n\n    private externalVar(node: CVarDeclaration | CVarDefinition): ExternalVariable {\n        let result = this._linkables.get(node.name);\n        if (result === undefined) {\n            this._linkables.set(node.name, result = new ExternalVariable(node.name, node.type));\n        } else if (result instanceof ExternalFunction) {\n            throw new LinkingError(\"Tried to link variable with function\", node.node, result.parseNode);\n        } else if (!result.type.equals(node.type)) {\n            throw new LinkingError(\"Tried to link variables with incompatible types\", node.node, result.parseNode);\n        }\n        return result;\n    }\n}\n\nclass Linkable<Decl extends CVarDeclaration | CFuncDeclaration, Def extends Decl[\"definition\"]> {\n    protected readonly declarations: Decl[] = [];\n    protected _definition?: Def;\n    protected _defLinker?: Linker;\n\n    constructor(readonly id: string, readonly type: Decl[\"type\"]) {\n\n    }\n\n    addDeclaration(d: Decl) {\n        this.declarations.push(d);\n        if (this._definition) d.definition = this._definition;\n    }\n\n    setDefinition(d: NonNullable<Def>, defLinker: Linker) {\n        if (this._definition !== undefined) {\n            throw new LinkingError(\"Already defined!\", d.node, this.parseNode);\n        }\n        this._definition = d;\n        this._defLinker = defLinker;\n\n        this.declarations.forEach(x => {\n            x.definition = d;\n        });\n    }\n\n    get parseNode(): ParseNode {\n        if (this._definition) return this._definition.node;\n        if (this.declarations.length > 0) return this.declarations[0].node;\n        throw new LinkingError(\"Linkable without parse node? This shouldn't happen!\");\n    }\n\n    get definition(): Def | undefined {\n        return this._definition;\n    }\n\n    get definitionLinker(): Linker {\n        if (!this._defLinker) throw new Error(\"Definition not set\");\n        return this._defLinker;\n    }\n\n    get declarationArray(): ReadonlyArray<Decl> {\n        return this.declarations;\n    }\n}\n\nclass ExternalFunction extends Linkable<CFuncDeclaration, CFuncDefinition | CFuncImport> {\n    readonly externalType = \"function\";\n}\n\nclass ExternalVariable extends Linkable<CVarDeclaration, CVarDefinition> {\n    readonly externalType = \"variable\";\n}\n\nclass LinkingError extends CError {\n    name = \"LinkingError\";\n}\n","import {STANDARD_LIBRARY} from \"./c_library/standard_library\";\nimport {WGenerator} from \"./generation\";\nimport {Linker} from \"./linker\";\nimport {ModuleBuilder} from \"./wasm\";\n\nexport function compile(files: ReadonlyMap<string, string> | string,\n                        customDefinitions?: {[key: string]: string}): ModuleBuilder {\n    if (typeof files === \"string\") {\n        const f = new Map<string, string>();\n        f.set(\"main.c\", files);\n        files = f;\n    }\n\n    // \"linker\" also calls preprocessor, lexer, parser and pt transformation into IR\n    const linker = new Linker(files, true, customDefinitions);\n    linker.link(stdLibrary(customDefinitions));\n\n    const generator = new WGenerator(linker);\n    return generator.module;\n}\n\n/** No access to standard library! */\nexport function compileSnippet(source: string): ModuleBuilder {\n    const fileMap = new Map<string, string>();\n    fileMap.set(\"main.c\", source);\n\n    const linker = new Linker(fileMap, false);\n    linker.link();\n    return new WGenerator(linker).module;\n}\n\nconst _standardLibrary = new Map<string, Linker>();\nexport function stdLibrary(customDefinitions?: {[key: string]: string}): Linker {\n    const definitionsJson = JSON.stringify(customDefinitions);\n    let lib = _standardLibrary.get(definitionsJson);\n    if (!lib) {\n        lib = new Linker(STANDARD_LIBRARY, true, customDefinitions);\n        lib.link();\n        _standardLibrary.set(definitionsJson, lib);\n    }\n    return lib;\n}\n","export function injectArgs(instance: WebAssembly.Exports, args: string[]): [number, number] {\n    if (!(instance.__sp instanceof WebAssembly.Global) || typeof instance.__sp.value !== \"number\") {\n        throw new Error(\"Needs __sp global export\");\n    }\n    const pos = instance.__sp.value as number;\n    if (!(instance.__mem instanceof WebAssembly.Memory)) {\n        throw new Error(\"Needs __mem export\");\n    }\n    const mem = instance.__mem;\n    const array = new Uint8Array(mem.buffer);\n    const encoder = new TextEncoder();\n\n    // need 4 * (len + 1) bytes for the string pointers and then a null pointer\n    let pointerAddr = pos, stringAddr = pos + (4 * (args.length + 1));\n    for (let i = 0; i < args.length; i++) {\n        // inject pointer to char[]\n        array.set(encodeInt(stringAddr), pointerAddr);\n        pointerAddr += 4;\n\n        // inject char[]\n        const stringBytes = [...encoder.encode(args[i]), 0]; // null terminate string\n        array.set(stringBytes, stringAddr);\n        stringAddr += stringBytes.length;\n    }\n    // inject null pointer\n    array.set([0,0,0,0], pointerAddr);\n\n    // update stack pointer\n    stringAddr += 32; // padding\n    instance.__sp.value = Math.ceil(stringAddr / 4) * 4;\n\n    return [args.length, pos];\n}\n\nfunction encodeInt(num: number) {\n    const arr = new ArrayBuffer(4);\n    new DataView(arr).setUint32(0, num, true);\n    return new Uint8Array(arr);\n}\n\nexport function mainWrapper(instance: WebAssembly.Exports, args: string[]): number | bigint | void {\n    if ((instance.main as Function).length > 0) {\n        const [argc, argv] = injectArgs(instance, args);\n        return (instance as {main: (argc: number, argv: number) => number | bigint | void}).main(argc, argv);\n    } else {\n        return (instance as {main: () => number | bigint | void}).main();\n    }\n}\n","export class Files {\n    private nextHandle = 1000;\n    private handleMap = new Map<number, FileLike>();\n    private nameMap = new Map<string, number>();\n    private fileNameBuffer = \"\";\n\n    constructor(output: (char: string) => void, input?: () => string, files?: Map<string, Uint8Array | FileLike>) {\n        // handle 0 - stdin\n        if (input) {\n            const currentInput: number[] = [];\n            this.setupIoHandle(0, () => {\n                if (currentInput.length === 0) currentInput.push(...new TextEncoder().encode(input() ?? \"\"));\n                if (currentInput.length === 0) return -1;\n                return currentInput.shift() ?? -1;\n            }, () => false);\n        } else {\n            this.setupIoHandle(0, () => -1, () => false);\n        }\n\n        // handle 1 - stdout\n        this.setupIoHandle(1, () => -1, (c: number) => {\n            output(String.fromCharCode(c));\n            return true;\n        });\n\n        // handle 2 - stderr\n        this.setupIoHandle(2, () => -1, (c: number) => {\n            output(String.fromCharCode(c));\n            return true;\n        });\n\n        // handle 3 - filenames\n        this.setupIoHandle(3, () => -1, (c: number) => {\n            this.fileNameBuffer += String.fromCharCode(c);\n            return true;\n        });\n\n        if (files) {\n            for (const [fname, contents] of files.entries()) {\n                let file;\n                if (contents instanceof Uint8Array) {\n                    file = new File();\n                    file.bytes = [...contents];\n                } else {\n                    file = contents;\n                }\n                this.handleMap.set(this.nextHandle, file);\n                this.nameMap.set(fname, this.nextHandle++);\n            }\n        }\n    }\n\n    private setupIoHandle(handle: number, get: () => number | -1, put: (c: number) => boolean) {\n        this.handleMap.set(handle, {\n            get, put,\n            pos: () => 0n,\n            len: () => 0n,\n            set_pos: () => false\n        });\n    }\n\n    private getFilenames(n = 1): string[] {\n        const filenames = this.fileNameBuffer.split('\\0');\n        if (filenames.pop() !== \"\" || filenames.length !== n) {\n            throw new Error(\"Error in files wrapper\");\n        }\n        this.fileNameBuffer = \"\";\n        return filenames;\n    }\n\n    // imports\n\n    private __get_char(handle: number): number {\n        return this.handleMap.get(handle)?.get() ?? -1;\n    }\n\n    private __put_char(handle: number, char: number): number {\n        const file = this.handleMap.get(handle);\n        if (file) return file.put(char as number) ? 0 : -1;\n        return -1;\n    }\n\n    private __get_pos(handle: number): bigint {\n        return this.handleMap.get(handle)?.pos() ?? -1n;\n    }\n\n    private __get_len(handle: number): bigint {\n        return this.handleMap.get(handle)?.len() ?? -1n;\n    }\n\n    private __set_pos(handle: number, pos: bigint): number {\n        const file = this.handleMap.get(handle);\n        if (file) return file.set_pos(pos) ? 0 : -1;\n        return -1;\n    }\n\n    private __exists(): number {\n        const [filename] = this.getFilenames();\n        return this.nameMap.has(filename) ? 1 : 0;\n    }\n\n    private __move(): number {\n        const [oldName, newName] = this.getFilenames(2);\n        const handle = this.nameMap.get(oldName);\n        if (handle !== undefined) {\n            if (newName === \"\") {\n                // deleting file\n                this.nameMap.delete(oldName);\n                this.handleMap.delete(handle);\n                return 0; // success\n            } else if (!this.nameMap.has(newName)) {\n                // moving file\n                this.nameMap.delete(oldName);\n                this.nameMap.set(newName, handle);\n                return 0;\n            }\n        }\n        return -1; // failure\n    }\n\n    private __get_fhandle(): number {\n        const [filename] = this.getFilenames();\n        let handle = this.nameMap.get(filename);\n        if (handle === undefined) {\n            // create a new file\n            handle = this.nextHandle++;\n            this.nameMap.set(filename, handle);\n            this.handleMap.set(handle, new File());\n        }\n        // reset position\n        this.handleMap.get(handle)?.set_pos(0n);\n\n        return handle;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n    public getImports() {\n        return {\n            __get_char: this.__get_char.bind(this),\n            __put_char: this.__put_char.bind(this),\n            __get_pos: this.__get_pos.bind(this),\n            __get_len: this.__get_len.bind(this),\n            __set_pos: this.__set_pos.bind(this),\n            __exists: this.__exists.bind(this),\n            __move: this.__move.bind(this),\n            __get_fhandle: this.__get_fhandle.bind(this)\n        };\n    }\n\n    public getContents(filename: string): Uint8Array | undefined {\n        const file = this.handleMap.get(this.nameMap.get(filename) ?? -Infinity);\n        if (file instanceof File) return new Uint8Array(file.bytes);\n    }\n\n    public delete(filename: string): boolean {\n        const handle = this.nameMap.get(filename);\n        if (!handle) return false;\n\n        this.nameMap.delete(filename);\n        this.handleMap.delete(handle);\n        return true;\n    }\n}\n\nexport interface FileLike {\n    get(): number | -1;\n    put(c: number): boolean;\n    pos(): bigint;\n    len(): bigint;\n    set_pos(pos: bigint): boolean;\n}\n\nclass File implements FileLike {\n    private _bytes: number[] = [];\n    private _pos = 0n;\n\n    get(): number | -1 {\n        if (this._pos >= this._bytes.length) return -1;\n        const b = this._bytes[Number(this._pos)];\n        this._pos++;\n        return b;\n    }\n\n    put(c: number): boolean {\n        this._bytes[Number(this._pos)] = c;\n        this._pos++;\n        return true;\n    }\n\n    pos(): bigint {\n        return this._pos;\n    }\n\n    len(): bigint {\n        return BigInt(this._bytes.length);\n    }\n\n    set_pos(pos: bigint): boolean {\n        if (pos < 0 || pos > this._bytes.length) return false;\n        this._pos = pos;\n        return true;\n    }\n\n    get bytes(): number[] {\n        return this._bytes;\n    }\n\n    set bytes(value: number[]) {\n        this._bytes = value;\n        this._pos = 0n;\n    }\n}\n","import {setFlags} from \"../src\";\nimport {mainWrapper} from \"../src/c_library/runtime/args\";\nimport {Files} from \"../src/c_library/runtime/files\";\nimport {stdLibrary} from \"../src/compile\";\nimport {WGenerator} from \"../src/generation\";\nimport {Linker} from \"../src/linker\";\n\nfunction writeRow(text: string = \"\", body: string = \"\") {\n    const div = document.createElement(\"div\");\n    if (text) div.innerText = text;\n    if (body) div.innerHTML += '\\n' + body;\n\n    const parent = document.createElement(\"div\");\n    parent.appendChild(div);\n    parent.appendChild(document.createElement(\"hr\"));\n    document.body.appendChild(parent);\n    return div;\n}\n\nconst FILES = [\"jcapimin.c\", \"jcapistd.c\", \"jctrans.c\", \"jcparam.c\", \"jdatadst.c\", \"jcinit.c\", \"jcmaster.c\", \"jcmarker.c\", \"jcmainct.c\", \"jcprepct.c\", \"jccoefct.c\", \"jccolor.c\", \"jcsample.c\", \"jchuff.c\", \"jcphuff.c\", \"jcdctmgr.c\", \"jfdctfst.c\", \"jfdctflt.c\", \"jfdctint.c\", \"jdapimin.c\", \"jdapistd.c\", \"jdtrans.c\", \"jdatasrc.c\", \"jdmaster.c\", \"jdinput.c\", \"jdmarker.c\", \"jdhuff.c\", \"jdphuff.c\", \"jdmainct.c\", \"jdcoefct.c\", \"jdpostct.c\", \"jddctmgr.c\", \"jidctfst.c\", \"jidctflt.c\", \"jidctint.c\", \"jidctred.c\", \"jdsample.c\", \"jdcolor.c\", \"jquant1.c\", \"jquant2.c\", \"jdmerge.c\", \"jcomapi.c\", \"jutils.c\", \"jerror.c\", \"jmemmgr.c\", \"jmemnobs.c\", \"rdppm.c\", \"rdgif.c\", \"rdtarga.c\", \"rdrle.c\", \"rdbmp.c\", \"rdswitch.c\", \"wrppm.c\", \"wrgif.c\", \"wrtarga.c\", \"wrrle.c\", \"wrbmp.c\", \"rdcolmap.c\", \"cdjpeg.c\"];\nconst DEFINITIONS = {\"FILES\": \"1\"};\n\ndocument.body.innerHTML = `\n    <h1>JPEG Compression</h1>\n    <h4>Using libjpeg 6b compiled in the browser to WebAssembly using <a href=\"https://github.com/ictrobot/c2wasm\">c2wasm</a>.</h4>\n    <hr>\n`;\n\nlet downloadTime = performance.now();\nwriteRow(\"Fetching sources\");\nfetch(`examples/libjpeg.json?v=${new Date().getTime()}`).then(async response => {\n    const text = await response.text();\n\n    downloadTime = performance.now() - downloadTime;\n    writeRow(\"Downloaded sources \", `- ${(text.length / 1024).toFixed(2)} KiB in ${downloadTime.toFixed(2)}ms (${(text.length * 8 / 1024 / 1024 / (downloadTime / 1000)).toFixed(2)} Mb/s)`);\n\n    const sources = new Map(Object.entries(JSON.parse(text) as {[s: string]: string}));\n    writeRow(\"Source license:\", `\n        <style>.hidden { display: none; }</style>\n        <div onclick=\"[...this.children].forEach(x => x.classList.toggle('hidden'));\">\n            <p><i>Click to expand</i>...</p>\n            <pre class=\"hidden\">${sources.get(\"README\")?.match(/LEGAL ISSUES\\n=+\\n\\n([^]+)\\n\\n[A-Z]+\\n/)?.[1]}</pre>\n        </div>\n    `);\n\n    writeRow(\"Precompiling standard library\");\n    setTimeout(() => precompile(sources), 100);\n});\n\nasync function precompile(sources: Map<string, string>) {\n    let compileTime = performance.now();\n    try {\n        stdLibrary(DEFINITIONS);\n    } catch (e) {\n        writeRow(\"Failed \", `<pre>${e.stack}</pre>`);\n        return;\n    }\n    compileTime = performance.now() - compileTime;\n    writeRow(\"Compiled in\", `${compileTime.toFixed(2)} ms`);\n\n    setTimeout(() => compileModule(sources), 100);\n}\n\nfunction cdjpegLinker(allSources: Map<string, string>): Promise<Linker> {\n    writeRow(\"Compiling shared files\");\n\n    return new Promise<Linker>(resolve => setTimeout(() => {\n        const sources = new Map<string, string>();\n        for (const [filename, contents] of allSources.entries()) {\n            if (filename.endsWith(\".h\") || FILES.includes(filename)) sources.set(filename, contents);\n        }\n\n        let compileTime = performance.now();\n        const l = new Linker(sources, true, DEFINITIONS);\n        l.link(stdLibrary(DEFINITIONS));\n        compileTime = performance.now() - compileTime;\n        writeRow(\"Compiled in\", `${compileTime.toFixed(2)} ms`);\n\n        resolve(l);\n    }, 50));\n}\n\nasync function compileProgram(base: Linker, allSources: Map<string, string>, program: \"cjpeg\" | \"djpeg\"): Promise<WebAssembly.Module> {\n    writeRow(\"Compiling\", `<code>${program}</code>`);\n\n    const sources = new Map<string, string>();\n    for (const [filename, contents] of allSources.entries()) {\n        if (filename.endsWith(\".h\") || filename === `${program}.c`) sources.set(filename, contents);\n    }\n\n    return new Promise(resolve => setTimeout(async () => {\n        let module: WebAssembly.Module;\n        let compileTime = performance.now();\n        try {\n            const linker = new Linker(sources, true, DEFINITIONS);\n            linker.link(base, stdLibrary(DEFINITIONS)); // link with precompiled libjpeg and stdlib\n            const bytes = new WGenerator(linker).module.toBytes();\n            module = (await WebAssembly.compile(bytes));\n        } catch (e) {\n            writeRow(\"Failed \", `<pre>${e.stack}</pre>`);\n            return;\n        }\n        compileTime = performance.now() - compileTime;\n        writeRow(\"Compiled in\", `${compileTime.toFixed(2)} ms`);\n        resolve(module);\n    }, 50));\n}\n\nasync function compileModule(sources: Map<string, string>) {\n    setFlags(\"none\");\n\n    const base = await cdjpegLinker(sources);\n    const cjpeg = await compileProgram(base, sources, \"cjpeg\");\n    const djpeg = await compileProgram(base, sources, \"djpeg\");\n\n    const fileInput = document.createElement(\"input\");\n    fileInput.type = \"file\";\n    fileInput.accept = \"image/jpeg\";\n    fileInput.addEventListener(\"change\", e => {\n        const file = fileInput.files?.[0];\n        if (!file) return;\n        writeRow(\"Reading file \", `<code>${file.name}</code>`);\n\n        const reader = new FileReader();\n        reader.onloadend = (e) => {\n            const u8 = new Uint8Array(reader.result as ArrayBuffer);\n            writeRow(\"Successfully read \", `${(u8.length / 1024).toFixed(2)} KiB`);\n\n            fileInput.parentElement?.parentElement?.remove();\n            reader.onloadend = null;\n\n            setTimeout(() => decompress(cjpeg, djpeg, u8), 100);\n        };\n        reader.readAsArrayBuffer(file);\n    });\n    writeRow(\"Choose file:\\xa0\").appendChild(fileInput);\n}\n\nasync function decompress(cjpeg: WebAssembly.Module, djpeg: WebAssembly.Module, file: Uint8Array) {\n    console.log(module, file);\n\n    writeRow(\"Loading image using\", \"<code>djpeg</code>\");\n\n    const map = new Map<string, Uint8Array>();\n    map.set(\"input.jpg\", file);\n\n    let output = \"\";\n    function getOutput() {\n        const out = output;\n        output = \"\";\n        return out;\n    }\n\n    const files = new Files(c => output += c, undefined, map);\n    console.log(files);\n\n    setTimeout(async () => {\n        try {\n            const instance = await WebAssembly.instantiate(djpeg, {c2wasm: files.getImports()});\n            mainWrapper(instance.exports, [\"djpeg\", \"-bmp\", \"input.jpg\", \"input.bmp\"]);\n        } catch (e) { /* ignored */ }\n\n        if (output) writeRow(\"Output\", `<pre>${getOutput()}</pre>`);\n\n        if ((files.getContents(\"input.bmp\")?.length ?? 0) > 0) {\n            setTimeout(() => setupSlider(cjpeg, files, getOutput), 50);\n        }\n    }, 50);\n}\n\nasync function setupSlider(cjpeg: WebAssembly.Module, files: Files, getOutput: () => string) {\n    const sliderDiv = writeRow(\"JPEG quality: \");\n\n    const quality = document.createElement(\"input\");\n    quality.type = \"range\";\n    quality.min = \"1\";\n    quality.max = \"100\";\n    quality.style.width = \"50%\";\n    sliderDiv.appendChild(quality);\n\n    const qualityOutput = document.createElement(\"output\");\n    qualityOutput.value = quality.value;\n    sliderDiv.appendChild(qualityOutput);\n\n    const outputRow = writeRow();\n\n    const imageRow = writeRow();\n    const image = document.createElement(\"img\");\n    image.style.maxWidth = \"100vw\";\n    image.style.maxHeight = \"50vh\";\n    imageRow.appendChild(image);\n\n    async function change() {\n        qualityOutput.value = quality.value;\n        await compress(parseInt(quality.value), outputRow, image, cjpeg, files, getOutput);\n    }\n\n    quality.addEventListener(\"change\", change);\n    await change();\n\n    const downloadRow = writeRow(\"Downloads:\", '<br>');\n    const originalJPEG = document.createElement(\"button\");\n    originalJPEG.innerText = \"Original JPEG\";\n    originalJPEG.addEventListener('click', () => download(\"input.jpg\", files));\n    downloadRow.appendChild(originalJPEG);\n    const convertedBMP = document.createElement(\"button\");\n    convertedBMP.innerText = \"Converted BMP\";\n    convertedBMP.addEventListener('click', () => download(\"input.bmp\", files));\n    downloadRow.appendChild(convertedBMP);\n    const outputJPEG = document.createElement(\"button\");\n    outputJPEG.innerText = \"Output JPEG\";\n    outputJPEG.addEventListener('click', () => download(\"output.jpg\", files));\n    downloadRow.appendChild(outputJPEG);\n}\n\nasync function compress(quality: number, outputDiv: HTMLDivElement, image: HTMLImageElement, cjpeg: WebAssembly.Module, files: Files, getOutput: () => string) {\n    setTimeout(async () => {\n        files.delete(\"output.jpg\");\n\n        try {\n            const instance = await WebAssembly.instantiate(cjpeg, {c2wasm: {\n                ...files.getImports(),\n                __time: () => performance.now()\n            }});\n            mainWrapper(instance.exports, [\"cjpeg\", \"-q\", quality.toFixed(0), \"input.bmp\", \"output.jpg\"]);\n        } catch (e) { /* ignored */ }\n\n        const output = getOutput();\n        const num = Number.parseFloat(output);\n        if (!isNaN(num)) {\n            outputDiv.innerHTML = `<code>cjpeg</code> took ${num.toFixed(2)}ms`;\n        } else {\n            outputDiv.innerHTML = `<code>cjpeg</code> output:<br><pre>${output}</pre>`;\n        }\n\n        if ((files.getContents(\"output.jpg\")?.length ?? 0) > 0) {\n            const jpeg = files.getContents(\"output.jpg\") as Uint8Array;\n            const blob = new Blob([jpeg], {type: 'image/jpeg'});\n            image.src = URL.createObjectURL(blob);\n\n            outputDiv.innerHTML += `<br>Output JPEG is ${(jpeg.length / 1024).toFixed(2)} KiB`;\n        }\n    }, 50);\n}\n\nfunction download(filename: string, files: Files) {\n    const u8 = files.getContents(filename);\n    if (!u8) return;\n\n    const a = document.createElement('a');\n    a.href = URL.createObjectURL(new Blob([u8], {type: 'image/jpeg'}));\n    a.download = filename;\n    a.click();\n}\n","import type {Location} from \"./lexer\";\n\n// Classes used to build up the C parse tree - mostly just simple objects storing the relevant fields.\n\nexport abstract class ParseNode {\n    abstract readonly type: string;\n\n    constructor(readonly loc: Location) {\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        // return any children of the node\n    }\n}\n\n// Expressions\n\nexport abstract class Expression extends ParseNode {\n    // typescript does structural equality when type checking, so for this class to be different from\n    // the base ParseNode add a simple private field.\n    private readonly _expression: boolean = true;\n}\n\nexport class Identifier extends Expression {\n    readonly type = \"identifier\";\n\n    constructor(loc: Location, readonly name: string) {\n        super(loc);\n    }\n}\n\nexport class Constant extends Expression {\n    readonly type = \"constant\";\n\n    constructor(loc: Location, readonly value: string, readonly valueType: \"float\" | \"char\" | \"int\" | \"oct\" | \"hex\") {\n        super(loc);\n    }\n}\n\nexport class StringLiteral extends Expression {\n    readonly type = \"stringLiteral\";\n\n    constructor(loc: Location, readonly value: string) {\n        super(loc);\n    }\n}\n\nexport const UnaryOperations = [\n    \"postfixIncrement\", \"postfixDecrement\", \"prefixIncrement\", \"prefixDecrement\",\n    \"addressOf\", \"dereference\", \"unaryPlus\", \"unaryMinus\", \"bitwiseNot\", \"logicalNot\"] as const;\nexport type UnaryOp = typeof UnaryOperations[number];\nexport class UnaryExpression extends Expression {\n    private readonly _unaryExpr = true;\n\n    constructor(loc: Location, readonly type: UnaryOp, readonly body: Expression) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.body;\n    }\n}\n\nexport const BinaryOperations = [\"arraySubscript\", \"comma\",\n    \"mul\", \"div\", \"mod\", \"add\", \"sub\", \"bitwiseShiftLeft\", \"bitwiseShiftRight\",\n    \"relationalLT\", \"relationalGT\", \"relationalLEq\", \"relationalGEq\", \"relationalEq\", \"relationalNEq\",\n    \"bitwiseAnd\", \"bitwiseXor\", \"bitwiseOr\", \"logicalAnd\", \"logicalOr\"] as const;\nexport type BinaryOp = typeof BinaryOperations[number];\nexport class BinaryExpression extends Expression {\n    private readonly _binaryExpr = true;\n\n    constructor(loc: Location, readonly type: BinaryOp, readonly lhs: Expression, readonly rhs: Expression) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.lhs;\n        yield this.rhs;\n    }\n}\n\nexport class SizeofExpression extends Expression {\n    readonly type = \"sizeof\";\n\n    constructor(loc: Location, readonly body: Expression | TypeName) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.body;\n    }\n}\n\nexport class CastExpression extends Expression {\n    readonly type = \"cast\";\n\n    constructor(loc: Location, readonly targetType: TypeName, readonly body: Expression) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.targetType;\n        yield this.body;\n    }\n}\n\nexport class FunctionCallExpression extends Expression {\n    readonly type = \"functionCall\";\n\n    constructor(loc: Location, readonly fn: Expression, readonly args: ReadonlyArray<Expression> = []) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.fn;\n        yield* this.args;\n    }\n}\n\nexport class MemberAccessExpression extends Expression {\n    readonly type = \"access\";\n\n    constructor(loc: Location, readonly pointer: boolean, readonly lhs: Expression, readonly rhs: string) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.lhs;\n    }\n}\n\nexport class ConditionalExpression extends Expression {\n    readonly type = \"conditional\";\n\n    constructor(loc: Location, readonly condition: Expression, readonly trueValue: Expression, readonly falseValue: Expression) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.condition;\n        yield this.trueValue;\n        yield this.falseValue;\n    }\n}\n\nexport type AssignmentType = undefined | \"mul\" | \"div\" | \"mod\" | \"add\" | \"sub\" | \"leftShift\"| \"rightShift\" | \"bitwiseAnd\" | \"bitwiseXor\" | \"bitwiseOr\";\nexport class AssignmentExpression extends Expression {\n    readonly type = \"assign\";\n\n    constructor(loc: Location, readonly assignType: AssignmentType, readonly lhs: Expression, readonly rhs: Expression) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.lhs;\n        yield this.rhs;\n    }\n}\n\nexport class ConstantExpression extends Expression {\n    readonly type = \"constantExpr\";\n\n    constructor(loc: Location, readonly expr: Expression) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.expr;\n    }\n}\n\n// Declarations\nexport class CustomTypeSpecifier extends ParseNode {\n    readonly type = \"customType\";\n\n    public constructor(loc: Location, readonly name: string) {\n        super(loc);\n    }\n}\n\nexport type StorageClass = \"typedef\" | \"extern\" | \"static\"; // | \"auto\" | \"register\";\nexport type TypeSpecifier =\n    \"void\" | \"char\" | \"short\" | \"int\" | \"long\" | \"float\" | \"double\" | \"signed\" | \"unsigned\" | \"bool\" // | \"complex\" | \"imaginary\"]\n    | StructUnionSpecifier\n    | EnumSpecifier\n    | CustomTypeSpecifier;\nexport type TypeQualifier = \"const\"; // | \"restrict\" | \"volatile\";\nexport type FnSpecifier = \"import\" | \"inline\";\n\nexport class SpecifierQualifiers extends ParseNode {\n    readonly type = \"specifiersAndQualifiers\";\n\n    constructor(loc: Location,\n                readonly specifierList: ReadonlyArray<TypeSpecifier>,\n                readonly qualifierList: ReadonlyArray<TypeQualifier>) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        for (const specifier of this.specifierList) {\n            if (specifier instanceof ParseNode) yield specifier;\n        }\n    }\n}\n\nexport class DeclarationSpecifiers extends ParseNode {\n    readonly type = \"declarationSpecifiers\";\n\n    constructor(loc: Location,\n                readonly specifierList: ReadonlyArray<TypeSpecifier>,\n                readonly qualifierList: ReadonlyArray<TypeQualifier>,\n                readonly storageList: ReadonlyArray<StorageClass>,\n                readonly fnSpecifierList: ReadonlyArray<FnSpecifier>) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        for (const specifier of this.specifierList) {\n            if (specifier instanceof ParseNode) yield specifier;\n        }\n    }\n}\n\nexport class EnumSpecifier extends ParseNode {\n    type = \"enum\";\n\n    constructor(loc: Location, readonly id?: string, readonly body?: ReadonlyArray<Enumerator>) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        if (this.body) yield* this.body;\n    }\n}\n\nexport class Enumerator extends ParseNode {\n    type = \"enumerator\";\n\n    constructor(loc: Location, readonly id: string, readonly value?: ConstantExpression) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        if (this.value) yield this.value;\n    }\n}\n\nexport class Declaration extends ParseNode{\n    readonly type = \"declaration\";\n\n    constructor(loc: Location, readonly typeInfo: DeclarationSpecifiers, readonly list: ReadonlyArray<Declarator | InitDeclarator> = []) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.typeInfo;\n        yield* this.list;\n    }\n}\n\nexport class InitDeclarator extends ParseNode {\n    readonly type = \"initDeclarator\";\n\n    constructor(loc: Location, readonly body: Declarator, readonly initializer: Initializer) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.body;\n        yield* this.exploreInitializer();\n    }\n\n    private *exploreInitializer(initializer: Initializer = this.initializer): Iterable<ParseNode> {\n        if (initializer instanceof AssignmentExpression) {\n            yield initializer;\n        } else if (Array.isArray(initializer)) {\n            for (const x of initializer) yield* this.exploreInitializer(x);\n        }\n    }\n}\n\nexport class StructUnionSpecifier extends ParseNode {\n    readonly type = \"structUnionSpecifier\";\n\n    constructor(loc: Location, readonly structure: \"struct\" | \"union\", readonly id?: string, readonly declarations?: ReadonlyArray<StructDeclaration>) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        if (this.declarations) yield* this.declarations;\n    }\n}\n\nexport class StructDeclaration extends ParseNode {\n    readonly type = \"structDeclaration\";\n\n    constructor(loc: Location, readonly typeInfo: DeclarationSpecifiers, readonly list: ReadonlyArray<Declarator> = []) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.typeInfo;\n        yield* this.list;\n    }\n}\n\nexport type Declarator = PointerDeclarator | IdentifierDeclarator | ArrayDeclarator | FunctionDeclarator;\n\nexport class PointerDeclarator extends ParseNode {\n    readonly type = \"pointerDeclarator\";\n    readonly abstractDeclarator = false;\n\n    constructor(loc: Location, readonly pointer: Pointer, readonly body: Declarator) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.pointer;\n        yield this.body;\n    }\n}\n\nexport class IdentifierDeclarator extends ParseNode {\n    readonly type = \"identifierDeclarator\";\n    readonly abstractDeclarator = false;\n\n    constructor(loc: Location, readonly id: string) {\n        super(loc);\n    }\n}\n\nexport class ArrayDeclarator extends ParseNode {\n    readonly type = \"arrayDeclarator\";\n    readonly abstractDeclarator = false;\n\n    constructor(loc: Location, readonly body: Declarator, readonly length?: ConstantExpression) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.body;\n        if (this.length) yield this.length;\n    }\n}\n\nexport class FunctionDeclarator extends ParseNode {\n    readonly type = \"functionDeclarator\";\n    readonly abstractDeclarator = false;\n\n    constructor(loc: Location, readonly body: Declarator, readonly args?: ReadonlyArray<ParameterDeclaration>, readonly variadic: boolean = false) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.body;\n        for (const value of this.args ?? []) {\n            if (value instanceof ParseNode) yield value;\n        }\n    }\n}\n\nexport class ParameterDeclaration extends ParseNode {\n    readonly type = \"parameterDeclaration\";\n\n    constructor(loc: Location, readonly typeInfo: DeclarationSpecifiers, readonly declarator?: Declarator | AbstractDeclarator) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.typeInfo;\n        if (this.declarator) yield this.declarator;\n    }\n}\n\nexport class Pointer extends ParseNode {\n    readonly type = \"pointer\";\n\n    constructor(loc: Location, readonly qualifierList?: ReadonlyArray<TypeQualifier>, readonly body?: Pointer) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        if (this.body) yield this.body;\n    }\n}\n\nexport class TypeName extends ParseNode {\n    readonly type = \"typeName\";\n\n    constructor(loc: Location, readonly typeInfo: SpecifierQualifiers, readonly declarator?: AbstractDeclarator) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.typeInfo;\n        if (this.declarator) yield this.declarator;\n    }\n}\n\nexport type AbstractDeclarator = AbstractPointerDeclarator | AbstractArrayDeclarator | AbstractFunctionDeclarator;\n\nexport class AbstractPointerDeclarator extends ParseNode {\n    readonly type = \"abstractPointerDeclarator\";\n    readonly abstractDeclarator = true;\n\n    constructor(loc: Location, readonly pointer: Pointer, readonly body?: AbstractDeclarator) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.pointer;\n        if (this.body) yield this.body;\n    }\n}\n\nexport class AbstractArrayDeclarator extends ParseNode {\n    readonly type = \"abstractArrayDeclarator\";\n    readonly abstractDeclarator = true;\n\n    constructor(loc: Location, readonly body?: AbstractDeclarator, readonly length?: ConstantExpression) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        if (this.body) yield this.body;\n        if (this.length) yield this.length;\n    }\n}\n\nexport class AbstractFunctionDeclarator extends ParseNode {\n    readonly type = \"abstractFunctionDeclarator\";\n    readonly abstractDeclarator = true;\n\n    constructor(loc: Location, readonly body?: AbstractDeclarator, readonly args?: ReadonlyArray<ParameterDeclaration>, readonly variadic: boolean = false) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        if (this.body) yield this.body;\n        if (this.args) yield* this.args;\n    }\n}\n\nexport type Initializer = Expression | ReadonlyArray<Initializer>;\n\n// Statements\n\nexport abstract class Statement extends ParseNode {\n    private readonly _statement: boolean = true;\n    label?: string;\n\n    setLabel(label: string): this {\n        this.label = label;\n        return this;\n    }\n}\n\nexport class IfStatement extends Statement {\n    readonly type = \"ifStatement\";\n\n    constructor(loc: Location, readonly expression: Expression, readonly ifBody: Statement, readonly elseBody?: Statement) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.expression;\n        yield this.ifBody;\n        if (this.elseBody) yield this.elseBody;\n    }\n}\n\nexport class SwitchStatement extends Statement {\n    readonly type = \"switchStatement\";\n\n    constructor(loc: Location, readonly expression: Expression, readonly body: Statement) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.expression;\n        yield this.body;\n    }\n}\n\nexport class CaseStatement extends Statement {\n    readonly type = \"caseStatement\";\n\n    constructor(loc: Location, readonly value: ConstantExpression, readonly body: Statement) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.value;\n        yield this.body;\n    }\n}\n\nexport class DefaultStatement extends Statement {\n    readonly type = \"defaultStatement\";\n\n    constructor(loc: Location, readonly body: Statement) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.body;\n    }\n}\n\nexport class CompoundStatement extends Statement {\n    readonly type = \"compoundStatement\";\n\n    constructor(loc: Location, readonly body: ReadonlyArray<Statement | Declaration>) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield* this.body;\n    }\n}\n\nexport class ExpressionStatement extends Statement {\n    readonly type = \"expressionStatement\";\n\n    constructor(loc: Location, readonly expression: Expression) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.expression;\n    }\n}\n\nexport class NoOp extends Statement {\n    readonly type = \"nopStatement\";\n\n    constructor(loc: Location) {\n        super(loc);\n    }\n}\n\nexport class ForLoop extends Statement {\n    readonly type = \"forStatement\";\n\n    constructor(loc: Location,\n                readonly init: ExpressionStatement | NoOp | Declaration,\n                readonly test: ExpressionStatement | NoOp,\n                readonly update: Expression | undefined,\n                readonly body: Statement) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.init;\n        yield this.test;\n        if (this.update) yield this.update;\n        yield this.body;\n    }\n}\n\nexport class WhileLoop extends Statement {\n    readonly type = \"whileStatement\";\n\n    constructor(loc: Location, readonly test: Expression, readonly body: Statement) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.test;\n        yield this.body;\n    }\n}\n\nexport class DoWhileLoop extends Statement {\n    readonly type = \"doWhileStatement\";\n\n    constructor(loc: Location, readonly body: Statement, readonly test: Expression) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.body;\n        yield this.test;\n    }\n}\n\nexport class GotoStatement extends Statement {\n    readonly type = \"gotoStatement\";\n\n    constructor(loc: Location, readonly target: string) {\n        super(loc);\n    }\n}\n\nexport class ContinueStatement extends Statement {\n    readonly type = \"continueStatement\";\n}\n\nexport class BreakStatement extends Statement {\n    readonly type = \"breakStatement\";\n}\n\nexport class ReturnStatement extends Statement {\n    readonly type = \"returnStatement\";\n\n    constructor(loc: Location, readonly value?: Expression) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        if (this.value) yield this.value;\n    }\n}\n\nexport class FunctionDefinition extends ParseNode {\n    readonly type = \"functionDefinition\";\n\n    constructor(loc: Location,\n                readonly typeInfo: DeclarationSpecifiers,\n                readonly declarator: Declarator,\n                readonly body: CompoundStatement) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.typeInfo;\n        yield this.declarator;\n        yield this.body;\n    }\n}\n\nexport type TranslationUnit = ReadonlyArray<FunctionDefinition | Declaration>;\n","\n/* parser generated by jison 0.6.1-215 */\n\n/*\n * Returns a Parser object of the following structure:\n *\n *  Parser: {\n *    yy: {}     The so-called \"shared state\" or rather the *source* of it;\n *               the real \"shared state\" `yy` passed around to\n *               the rule actions, etc. is a derivative/copy of this one,\n *               not a direct reference!\n *  }\n *\n *  Parser.prototype: {\n *    yy: {},\n *    EOF: 1,\n *    TERROR: 2,\n *\n *    trace: function(errorMessage, ...),\n *\n *    JisonParserError: function(msg, hash),\n *\n *    quoteName: function(name),\n *               Helper function which can be overridden by user code later on: put suitable\n *               quotes around literal IDs in a description string.\n *\n *    originalQuoteName: function(name),\n *               The basic quoteName handler provided by JISON.\n *               `cleanupAfterParse()` will clean up and reset `quoteName()` to reference this function\n *               at the end of the `parse()`.\n *\n *    describeSymbol: function(symbol),\n *               Return a more-or-less human-readable description of the given symbol, when\n *               available, or the symbol itself, serving as its own 'description' for lack\n *               of something better to serve up.\n *\n *               Return NULL when the symbol is unknown to the parser.\n *\n *    symbols_: {associative list: name ==> number},\n *    terminals_: {associative list: number ==> name},\n *    nonterminals: {associative list: rule-name ==> {associative list: number ==> rule-alt}},\n *    terminal_descriptions_: (if there are any) {associative list: number ==> description},\n *    productions_: [...],\n *\n *    performAction: function parser__performAction(yytext, yyleng, yylineno, yyloc, yystate, yysp, yyvstack, yylstack, yystack, yysstack),\n *\n *               The function parameters and `this` have the following value/meaning:\n *               - `this`    : reference to the `yyval` internal object, which has members (`$` and `_$`)\n *                             to store/reference the rule value `$$` and location info `@$`.\n *\n *                 One important thing to note about `this` a.k.a. `yyval`: every *reduce* action gets\n *                 to see the same object via the `this` reference, i.e. if you wish to carry custom\n *                 data from one reduce action through to the next within a single parse run, then you\n *                 may get nasty and use `yyval` a.k.a. `this` for storing you own semi-permanent data.\n *\n *                 `this.yy` is a direct reference to the `yy` shared state object.\n *\n *                 `%parse-param`-specified additional `parse()` arguments have been added to this `yy`\n *                 object at `parse()` start and are therefore available to the action code via the\n *                 same named `yy.xxxx` attributes (where `xxxx` represents a identifier name from\n *                 the %parse-param` list.\n *\n *               - `yytext`  : reference to the lexer value which belongs to the last lexer token used\n *                             to match this rule. This is *not* the look-ahead token, but the last token\n *                             that's actually part of this rule.\n *\n *                 Formulated another way, `yytext` is the value of the token immediately preceeding\n *                 the current look-ahead token.\n *                 Caveats apply for rules which don't require look-ahead, such as epsilon rules.\n *\n *               - `yyleng`  : ditto as `yytext`, only now for the lexer.yyleng value.\n *\n *               - `yylineno`: ditto as `yytext`, only now for the lexer.yylineno value.\n *\n *               - `yyloc`   : ditto as `yytext`, only now for the lexer.yylloc lexer token location info.\n *\n *                               WARNING: since jison 0.4.18-186 this entry may be NULL/UNDEFINED instead\n *                               of an empty object when no suitable location info can be provided.\n *\n *               - `yystate` : the current parser state number, used internally for dispatching and\n *                               executing the action code chunk matching the rule currently being reduced.\n *\n *               - `yysp`    : the current state stack position (a.k.a. 'stack pointer')\n *\n *                 This one comes in handy when you are going to do advanced things to the parser\n *                 stacks, all of which are accessible from your action code (see the next entries below).\n *\n *                 Also note that you can access this and other stack index values using the new double-hash\n *                 syntax, i.e. `##$ === ##0 === yysp`, while `##1` is the stack index for all things\n *                 related to the first rule term, just like you have `$1`, `@1` and `#1`.\n *                 This is made available to write very advanced grammar action rules, e.g. when you want\n *                 to investigate the parse state stack in your action code, which would, for example,\n *                 be relevant when you wish to implement error diagnostics and reporting schemes similar\n *                 to the work described here:\n *\n *                 + Pottier, F., 2016. Reachability and error diagnosis in LR(1) automata.\n *                   In Journées Francophones des Languages Applicatifs.\n *\n *                 + Jeffery, C.L., 2003. Generating LR syntax error messages from examples.\n *                   ACM Transactions on Programming Languages and Systems (TOPLAS), 25(5), pp.631–640.\n *\n *               - `yyrulelength`: the current rule's term count, i.e. the number of entries occupied on the stack.\n *\n *                 This one comes in handy when you are going to do advanced things to the parser\n *                 stacks, all of which are accessible from your action code (see the next entries below).\n *\n *               - `yyvstack`: reference to the parser value stack. Also accessed via the `$1` etc.\n *                             constructs.\n *\n *               - `yylstack`: reference to the parser token location stack. Also accessed via\n *                             the `@1` etc. constructs.\n *\n *                             WARNING: since jison 0.4.18-186 this array MAY contain slots which are\n *                             UNDEFINED rather than an empty (location) object, when the lexer/parser\n *                             action code did not provide a suitable location info object when such a\n *                             slot was filled!\n *\n *               - `yystack` : reference to the parser token id stack. Also accessed via the\n *                             `#1` etc. constructs.\n *\n *                 Note: this is a bit of a **white lie** as we can statically decode any `#n` reference to\n *                 its numeric token id value, hence that code wouldn't need the `yystack` but *you* might\n *                 want access this array for your own purposes, such as error analysis as mentioned above!\n *\n *                 Note that this stack stores the current stack of *tokens*, that is the sequence of\n *                 already parsed=reduced *nonterminals* (tokens representing rules) and *terminals*\n *                 (lexer tokens *shifted* onto the stack until the rule they belong to is found and\n *                 *reduced*.\n *\n *               - `yysstack`: reference to the parser state stack. This one carries the internal parser\n *                             *states* such as the one in `yystate`, which are used to represent\n *                             the parser state machine in the *parse table*. *Very* *internal* stuff,\n *                             what can I say? If you access this one, you're clearly doing wicked things\n *\n *               - `...`     : the extra arguments you specified in the `%parse-param` statement in your\n *                             grammar definition file.\n *\n *    table: [...],\n *               State transition table\n *               ----------------------\n *\n *               index levels are:\n *               - `state`  --> hash table\n *               - `symbol` --> action (number or array)\n *\n *                 If the `action` is an array, these are the elements' meaning:\n *                 - index [0]: 1 = shift, 2 = reduce, 3 = accept\n *                 - index [1]: GOTO `state`\n *\n *                 If the `action` is a number, it is the GOTO `state`\n *\n *    defaultActions: {...},\n *\n *    parseError: function(str, hash, ExceptionClass),\n *    yyError: function(str, ...),\n *    yyRecovering: function(),\n *    yyErrOk: function(),\n *    yyClearIn: function(),\n *\n *    constructParseErrorInfo: function(error_message, exception_object, expected_token_set, is_recoverable),\n *               Helper function **which will be set up during the first invocation of the `parse()` method**.\n *               Produces a new errorInfo 'hash object' which can be passed into `parseError()`.\n *               See it's use in this parser kernel in many places; example usage:\n *\n *                   var infoObj = parser.constructParseErrorInfo('fail!', null,\n *                                     parser.collect_expected_token_set(state), true);\n *                   var retVal = parser.parseError(infoObj.errStr, infoObj, parser.JisonParserError);\n *\n *    originalParseError: function(str, hash, ExceptionClass),\n *               The basic `parseError` handler provided by JISON.\n *               `cleanupAfterParse()` will clean up and reset `parseError()` to reference this function\n *               at the end of the `parse()`.\n *\n *    options: { ... parser %options ... },\n *\n *    parse: function(input[, args...]),\n *               Parse the given `input` and return the parsed value (or `true` when none was provided by\n *               the root action, in which case the parser is acting as a *matcher*).\n *               You MAY use the additional `args...` parameters as per `%parse-param` spec of this grammar:\n *               these extra `args...` are added verbatim to the `yy` object reference as member variables.\n *\n *               WARNING:\n *               Parser's additional `args...` parameters (via `%parse-param`) MAY conflict with\n *               any attributes already added to `yy` by the jison run-time;\n *               when such a collision is detected an exception is thrown to prevent the generated run-time\n *               from silently accepting this confusing and potentially hazardous situation!\n *\n *               The lexer MAY add its own set of additional parameters (via the `%parse-param` line in\n *               the lexer section of the grammar spec): these will be inserted in the `yy` shared state\n *               object and any collision with those will be reported by the lexer via a thrown exception.\n *\n *    cleanupAfterParse: function(resultValue, invoke_post_methods, do_not_nuke_errorinfos),\n *               Helper function **which will be set up during the first invocation of the `parse()` method**.\n *               This helper API is invoked at the end of the `parse()` call, unless an exception was thrown\n *               and `%options no-try-catch` has been defined for this grammar: in that case this helper MAY\n *               be invoked by calling user code to ensure the `post_parse` callbacks are invoked and\n *               the internal parser gets properly garbage collected under these particular circumstances.\n *\n *    yyMergeLocationInfo: function(first_index, last_index, first_yylloc, last_yylloc, dont_look_back),\n *               Helper function **which will be set up during the first invocation of the `parse()` method**.\n *               This helper API can be invoked to calculate a spanning `yylloc` location info object.\n *\n *               Note: %epsilon rules MAY specify no `first_index` and `first_yylloc`, in which case\n *               this function will attempt to obtain a suitable location marker by inspecting the location stack\n *               backwards.\n *\n *               For more info see the documentation comment further below, immediately above this function's\n *               implementation.\n *\n *    lexer: {\n *        yy: {...},           A reference to the so-called \"shared state\" `yy` once\n *                             received via a call to the `.setInput(input, yy)` lexer API.\n *        EOF: 1,\n *        ERROR: 2,\n *        JisonLexerError: function(msg, hash),\n *        parseError: function(str, hash, ExceptionClass),\n *        setInput: function(input, [yy]),\n *        input: function(),\n *        unput: function(str),\n *        more: function(),\n *        reject: function(),\n *        less: function(n),\n *        pastInput: function(n),\n *        upcomingInput: function(n),\n *        showPosition: function(),\n *        test_match: function(regex_match_array, rule_index, ...),\n *        next: function(...),\n *        lex: function(...),\n *        begin: function(condition),\n *        pushState: function(condition),\n *        popState: function(),\n *        topState: function(),\n *        _currentRules: function(),\n *        stateStackSize: function(),\n *        cleanupAfterLex: function()\n *\n *        options: { ... lexer %options ... },\n *\n *        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START, ...),\n *        rules: [...],\n *        conditions: {associative list: name ==> set},\n *    }\n *  }\n *\n *\n *  token location info (@$, _$, etc.): {\n *    first_line: n,\n *    last_line: n,\n *    first_column: n,\n *    last_column: n,\n *    range: [start_number, end_number]\n *               (where the numbers are indexes into the input string, zero-based)\n *  }\n *\n * ---\n *\n * The `parseError` function receives a 'hash' object with these members for lexer and\n * parser errors:\n *\n *  {\n *    text:        (matched text)\n *    token:       (the produced terminal token, if any)\n *    token_id:    (the produced terminal token numeric ID, if any)\n *    line:        (yylineno)\n *    loc:         (yylloc)\n *  }\n *\n * parser (grammar) errors will also provide these additional members:\n *\n *  {\n *    expected:    (array describing the set of expected tokens;\n *                  may be UNDEFINED when we cannot easily produce such a set)\n *    state:       (integer (or array when the table includes grammar collisions);\n *                  represents the current internal state of the parser kernel.\n *                  can, for example, be used to pass to the `collect_expected_token_set()`\n *                  API to obtain the expected token set)\n *    action:      (integer; represents the current internal action which will be executed)\n *    new_state:   (integer; represents the next/planned internal state, once the current\n *                  action has executed)\n *    recoverable: (boolean: TRUE when the parser MAY have an error recovery rule\n *                  available for this particular error)\n *    state_stack: (array: the current parser LALR/LR internal state stack; this can be used,\n *                  for instance, for advanced error analysis and reporting)\n *    value_stack: (array: the current parser LALR/LR internal `$$` value stack; this can be used,\n *                  for instance, for advanced error analysis and reporting)\n *    location_stack: (array: the current parser LALR/LR internal location stack; this can be used,\n *                  for instance, for advanced error analysis and reporting)\n *    yy:          (object: the current parser internal \"shared state\" `yy`\n *                  as is also available in the rule actions; this can be used,\n *                  for instance, for advanced error analysis and reporting)\n *    lexer:       (reference to the current lexer instance used by the parser)\n *    parser:      (reference to the current parser instance)\n *  }\n *\n * while `this` will reference the current parser instance.\n *\n * When `parseError` is invoked by the lexer, `this` will still reference the related *parser*\n * instance, while these additional `hash` fields will also be provided:\n *\n *  {\n *    lexer:       (reference to the current lexer instance which reported the error)\n *  }\n *\n * When `parseError` is invoked by the parser due to a **JavaScript exception** being fired\n * from either the parser or lexer, `this` will still reference the related *parser*\n * instance, while these additional `hash` fields will also be provided:\n *\n *  {\n *    exception:   (reference to the exception thrown)\n *  }\n *\n * Please do note that in the latter situation, the `expected` field will be omitted as\n * this type of failure is assumed not to be due to *parse errors* but rather due to user\n * action code in either parser or lexer failing unexpectedly.\n *\n * ---\n *\n * You can specify parser options by setting / modifying the `.yy` object of your Parser instance.\n * These options are available:\n *\n * ### options which are global for all parser instances\n *\n *  Parser.pre_parse: function(yy)\n *                 optional: you can specify a pre_parse() function in the chunk following\n *                 the grammar, i.e. after the last `%%`.\n *  Parser.post_parse: function(yy, retval, parseInfo) { return retval; }\n *                 optional: you can specify a post_parse() function in the chunk following\n *                 the grammar, i.e. after the last `%%`. When it does not return any value,\n *                 the parser will return the original `retval`.\n *\n * ### options which can be set up per parser instance\n *\n *  yy: {\n *      pre_parse:  function(yy)\n *                 optional: is invoked before the parse cycle starts (and before the first\n *                 invocation of `lex()`) but immediately after the invocation of\n *                 `parser.pre_parse()`).\n *      post_parse: function(yy, retval, parseInfo) { return retval; }\n *                 optional: is invoked when the parse terminates due to success ('accept')\n *                 or failure (even when exceptions are thrown).\n *                 `retval` contains the return value to be produced by `Parser.parse()`;\n *                 this function can override the return value by returning another.\n *                 When it does not return any value, the parser will return the original\n *                 `retval`.\n *                 This function is invoked immediately before `parser.post_parse()`.\n *\n *      parseError: function(str, hash, ExceptionClass)\n *                 optional: overrides the default `parseError` function.\n *      quoteName: function(name),\n *                 optional: overrides the default `quoteName` function.\n *  }\n *\n *  parser.lexer.options: {\n *      pre_lex:  function()\n *                 optional: is invoked before the lexer is invoked to produce another token.\n *                 `this` refers to the Lexer object.\n *      post_lex: function(token) { return token; }\n *                 optional: is invoked when the lexer has produced a token `token`;\n *                 this function can override the returned token value by returning another.\n *                 When it does not return any (truthy) value, the lexer will return\n *                 the original `token`.\n *                 `this` refers to the Lexer object.\n *\n *      ranges: boolean\n *                 optional: `true` ==> token location info will include a .range[] member.\n *      flex: boolean\n *                 optional: `true` ==> flex-like lexing behaviour where the rules are tested\n *                 exhaustively to find the longest match.\n *      backtrack_lexer: boolean\n *                 optional: `true` ==> lexer regexes are tested in order and for invoked;\n *                 the lexer terminates the scan when a token is returned by the action code.\n *      xregexp: boolean\n *                 optional: `true` ==> lexer rule regexes are \"extended regex format\" requiring the\n *                 `XRegExp` library. When this `%option` has not been specified at compile time, all lexer\n *                 rule regexes have been written as standard JavaScript RegExp expressions.\n *  }\n */\n\n        \n    \n            var c_grammar = (function () {\n\n\n// See also:\n// http://stackoverflow.com/questions/1382107/whats-a-good-way-to-extend-error-in-javascript/#35881508\n// but we keep the prototype.constructor and prototype.name assignment lines too for compatibility\n// with userland code which might access the derived class in a 'classic' way.\nfunction JisonParserError(msg, hash) {\n    Object.defineProperty(this, 'name', {\n        enumerable: false,\n        writable: false,\n        value: 'JisonParserError'\n    });\n\n    if (msg == null) msg = '???';\n\n    Object.defineProperty(this, 'message', {\n        enumerable: false,\n        writable: true,\n        value: msg\n    });\n\n    this.hash = hash;\n\n    var stacktrace;\n    if (hash && hash.exception instanceof Error) {\n        var ex2 = hash.exception;\n        this.message = ex2.message || msg;\n        stacktrace = ex2.stack;\n    }\n    if (!stacktrace) {\n        if (Error.hasOwnProperty('captureStackTrace')) {        // V8/Chrome engine\n            Error.captureStackTrace(this, this.constructor);\n        } else {\n            stacktrace = (new Error(msg)).stack;\n        }\n    }\n    if (stacktrace) {\n        Object.defineProperty(this, 'stack', {\n            enumerable: false,\n            writable: false,\n            value: stacktrace\n        });\n    }\n}\n\nif (typeof Object.setPrototypeOf === 'function') {\n    Object.setPrototypeOf(JisonParserError.prototype, Error.prototype);\n} else {\n    JisonParserError.prototype = Object.create(Error.prototype);\n}\nJisonParserError.prototype.constructor = JisonParserError;\nJisonParserError.prototype.name = 'JisonParserError';\n\n\n\n\n        // helper: reconstruct the productions[] table\n        function bp(s) {\n            var rv = [];\n            var p = s.pop;\n            var r = s.rule;\n            for (var i = 0, l = p.length; i < l; i++) {\n                rv.push([\n                    p[i],\n                    r[i]\n                ]);\n            }\n            return rv;\n        }\n    \n\n\n        // helper: reconstruct the defaultActions[] table\n        function bda(s) {\n            var rv = {};\n            var d = s.idx;\n            var g = s.goto;\n            for (var i = 0, l = d.length; i < l; i++) {\n                var j = d[i];\n                rv[j] = g[i];\n            }\n            return rv;\n        }\n    \n\n\n        // helper: reconstruct the 'goto' table\n        function bt(s) {\n            var rv = [];\n            var d = s.len;\n            var y = s.symbol;\n            var t = s.type;\n            var a = s.state;\n            var m = s.mode;\n            var g = s.goto;\n            for (var i = 0, l = d.length; i < l; i++) {\n                var n = d[i];\n                var q = {};\n                for (var j = 0; j < n; j++) {\n                    var z = y.shift();\n                    switch (t.shift()) {\n                    case 2:\n                        q[z] = [\n                            m.shift(),\n                            g.shift()\n                        ];\n                        break;\n\n                    case 0:\n                        q[z] = a.shift();\n                        break;\n\n                    default:\n                        // type === 1: accept\n                        q[z] = [\n                            3\n                        ];\n                    }\n                }\n                rv.push(q);\n            }\n            return rv;\n        }\n    \n\n\n        // helper: runlength encoding with increment step: code, length: step (default step = 0)\n        // `this` references an array\n        function s(c, l, a) {\n            a = a || 0;\n            for (var i = 0; i < l; i++) {\n                this.push(c);\n                c += a;\n            }\n        }\n\n        // helper: duplicate sequence from *relative* offset and length.\n        // `this` references an array\n        function c(i, l) {\n            i = this.length - i;\n            for (l += i; i < l; i++) {\n                this.push(this[i]);\n            }\n        }\n\n        // helper: unpack an array using helpers and data, all passed in an array argument 'a'.\n        function u(a) {\n            var rv = [];\n            for (var i = 0, l = a.length; i < l; i++) {\n                var e = a[i];\n                // Is this entry a helper function?\n                if (typeof e === 'function') {\n                    i++;\n                    e.apply(rv, a[i]);\n                } else {\n                    rv.push(e);\n                }\n            }\n            return rv;\n        }\n    \n\nvar parser = {\n    // Code Generator Information Report\n    // ---------------------------------\n    //\n    // Options:\n    //\n    //   default action mode: ............. [\"none\",\"merge\"]\n    //   test-compile action mode: ........ \"parser:*,lexer:*\"\n    //   try..catch: ...................... true\n    //   default resolve on conflict: ..... true\n    //   on-demand look-ahead: ............ false\n    //   error recovery token skip maximum: 3\n    //   yyerror in parse actions is: ..... NOT recoverable,\n    //   yyerror in lexer actions and other non-fatal lexer are:\n    //   .................................. NOT recoverable,\n    //   debug grammar/output: ............ false\n    //   has partial LR conflict upgrade:   true\n    //   rudimentary token-stack support:   false\n    //   parser table compression mode: ... 2\n    //   export debug tables: ............. false\n    //   export *all* tables: ............. false\n    //   module type: ..................... commonjs\n    //   parser engine type: .............. lalr\n    //   output main() in the module: ..... true\n    //   has user-specified main(): ....... false\n    //   has user-specified require()/import modules for main():\n    //   .................................. false\n    //   number of expected conflicts: .... 0\n    //\n    //\n    // Parser Analysis flags:\n    //\n    //   no significant actions (parser is a language matcher only):\n    //   .................................. false\n    //   uses yyleng: ..................... false\n    //   uses yylineno: ................... false\n    //   uses yytext: ..................... true\n    //   uses yylloc: ..................... false\n    //   uses ParseError API: ............. false\n    //   uses YYERROR: .................... false\n    //   uses YYRECOVERING: ............... false\n    //   uses YYERROK: .................... false\n    //   uses YYCLEARIN: .................. false\n    //   tracks rule values: .............. true\n    //   assigns rule values: ............. true\n    //   uses location tracking: .......... true\n    //   assigns location: ................ true\n    //   uses yystack: .................... false\n    //   uses yysstack: ................... false\n    //   uses yysp: ....................... true\n    //   uses yyrulelength: ............... false\n    //   uses yyMergeLocationInfo API: .... true\n    //   has error recovery: .............. false\n    //   has error reporting: ............. false\n    //\n    // --------- END OF REPORT -----------\n\ntrace: function no_op_trace() { },\nJisonParserError: JisonParserError,\nyy: {},\noptions: {\n  type: \"lalr\",\n  hasPartialLrUpgradeOnConflict: true,\n  errorRecoveryTokenDiscardCount: 3\n},\nsymbols_: {\n  \"!\": 14,\n  \"!=\": 43,\n  \"$accept\": 0,\n  \"$end\": 1,\n  \"%\": 16,\n  \"%=\": 48,\n  \"&\": 9,\n  \"&&\": 44,\n  \"&=\": 53,\n  \"(\": 3,\n  \")\": 4,\n  \"*\": 10,\n  \"*=\": 46,\n  \"+\": 11,\n  \"++\": 35,\n  \"+=\": 49,\n  \",\": 8,\n  \"-\": 12,\n  \"--\": 36,\n  \"-=\": 50,\n  \"->\": 34,\n  \".\": 7,\n  \"...\": 76,\n  \"/\": 15,\n  \"/=\": 47,\n  \":\": 22,\n  \";\": 24,\n  \"<\": 17,\n  \"<<\": 38,\n  \"<<=\": 51,\n  \"<=\": 40,\n  \"=\": 23,\n  \"==\": 42,\n  \">\": 18,\n  \">=\": 41,\n  \">>\": 39,\n  \">>=\": 52,\n  \"?\": 21,\n  \"BREAK\": 87,\n  \"CASE\": 77,\n  \"CHAR\": 60,\n  \"CONST\": 73,\n  \"CONSTANT_CHAR\": 32,\n  \"CONSTANT_FLOAT\": 28,\n  \"CONSTANT_HEX\": 29,\n  \"CONSTANT_INT\": 31,\n  \"CONSTANT_OCTAL\": 30,\n  \"CONTINUE\": 86,\n  \"DEFAULT\": 78,\n  \"DO\": 83,\n  \"DOUBLE\": 65,\n  \"ELSE\": 80,\n  \"ENUM\": 72,\n  \"EOF\": 1,\n  \"EXTERN\": 57,\n  \"FLOAT\": 64,\n  \"FOR\": 84,\n  \"GOTO\": 85,\n  \"IDENTIFIER\": 27,\n  \"IF\": 79,\n  \"IMPORT\": 75,\n  \"INLINE\": 74,\n  \"INT\": 62,\n  \"LONG\": 63,\n  \"RETURN\": 88,\n  \"SHORT\": 61,\n  \"SIGNED\": 66,\n  \"SIZEOF\": 37,\n  \"STATIC\": 58,\n  \"STRING_LITERAL\": 33,\n  \"STRUCT\": 70,\n  \"SWITCH\": 81,\n  \"TYPEDEF\": 56,\n  \"TYPE_NAME\": 69,\n  \"UNION\": 71,\n  \"UNSIGNED\": 67,\n  \"VOID\": 59,\n  \"WHILE\": 82,\n  \"[\": 5,\n  \"]\": 6,\n  \"^\": 19,\n  \"^=\": 54,\n  \"_BOOL\": 68,\n  \"abstract_declarator\": 141,\n  \"additive_expression\": 101,\n  \"and_expression\": 105,\n  \"argument_expression_list\": 96,\n  \"assignment_expression\": 111,\n  \"assignment_operator\": 112,\n  \"ast_tree\": 89,\n  \"block_item\": 149,\n  \"block_item_list\": 148,\n  \"cast_expression\": 99,\n  \"compound_statement\": 147,\n  \"concat_string_literals\": 93,\n  \"conditional_expression\": 110,\n  \"constant\": 91,\n  \"constant_expression\": 114,\n  \"declaration\": 115,\n  \"declaration_specifiers\": 116,\n  \"declarator\": 133,\n  \"direct_abstract_declarator\": 142,\n  \"direct_declarator\": 134,\n  \"enum_specifier\": 128,\n  \"enumerator\": 130,\n  \"enumerator_list\": 129,\n  \"equality_expression\": 104,\n  \"error\": 2,\n  \"exclusive_or_expression\": 106,\n  \"expression\": 113,\n  \"expression_statement\": 150,\n  \"external_declaration\": 155,\n  \"function_definition\": 156,\n  \"function_specifier\": 132,\n  \"identifier\": 90,\n  \"inclusive_or_expression\": 107,\n  \"init_declarator\": 118,\n  \"init_declarator_list\": 117,\n  \"initializer\": 143,\n  \"initializer_list\": 144,\n  \"iteration_statement\": 152,\n  \"jump_statement\": 153,\n  \"labeled_statement\": 146,\n  \"logical_and_expression\": 108,\n  \"logical_or_expression\": 109,\n  \"multiplicative_expression\": 100,\n  \"parameter_declaration\": 139,\n  \"parameter_list\": 138,\n  \"parameter_type_list\": 137,\n  \"pointer\": 135,\n  \"postfix_expression\": 95,\n  \"primary_expression\": 94,\n  \"relational_expression\": 103,\n  \"selection_statement\": 151,\n  \"shift_expression\": 102,\n  \"specifier_qualifier_list\": 125,\n  \"statement\": 145,\n  \"storage_class_specifier\": 119,\n  \"string_literal\": 92,\n  \"struct_declaration\": 124,\n  \"struct_declaration_list\": 123,\n  \"struct_declarator\": 127,\n  \"struct_declarator_list\": 126,\n  \"struct_or_union\": 122,\n  \"struct_or_union_specifier\": 121,\n  \"translation_unit\": 154,\n  \"type_name\": 140,\n  \"type_qualifier\": 131,\n  \"type_qualifier_list\": 136,\n  \"type_specifier\": 120,\n  \"unary_expression\": 97,\n  \"unary_operator\": 98,\n  \"{\": 25,\n  \"|\": 20,\n  \"|=\": 55,\n  \"||\": 45,\n  \"}\": 26,\n  \"~\": 13\n},\nterminals_: {\n  1: \"EOF\",\n  2: \"error\",\n  3: \"(\",\n  4: \")\",\n  5: \"[\",\n  6: \"]\",\n  7: \".\",\n  8: \",\",\n  9: \"&\",\n  10: \"*\",\n  11: \"+\",\n  12: \"-\",\n  13: \"~\",\n  14: \"!\",\n  15: \"/\",\n  16: \"%\",\n  17: \"<\",\n  18: \">\",\n  19: \"^\",\n  20: \"|\",\n  21: \"?\",\n  22: \":\",\n  23: \"=\",\n  24: \";\",\n  25: \"{\",\n  26: \"}\",\n  27: \"IDENTIFIER\",\n  28: \"CONSTANT_FLOAT\",\n  29: \"CONSTANT_HEX\",\n  30: \"CONSTANT_OCTAL\",\n  31: \"CONSTANT_INT\",\n  32: \"CONSTANT_CHAR\",\n  33: \"STRING_LITERAL\",\n  34: \"->\",\n  35: \"++\",\n  36: \"--\",\n  37: \"SIZEOF\",\n  38: \"<<\",\n  39: \">>\",\n  40: \"<=\",\n  41: \">=\",\n  42: \"==\",\n  43: \"!=\",\n  44: \"&&\",\n  45: \"||\",\n  46: \"*=\",\n  47: \"/=\",\n  48: \"%=\",\n  49: \"+=\",\n  50: \"-=\",\n  51: \"<<=\",\n  52: \">>=\",\n  53: \"&=\",\n  54: \"^=\",\n  55: \"|=\",\n  56: \"TYPEDEF\",\n  57: \"EXTERN\",\n  58: \"STATIC\",\n  59: \"VOID\",\n  60: \"CHAR\",\n  61: \"SHORT\",\n  62: \"INT\",\n  63: \"LONG\",\n  64: \"FLOAT\",\n  65: \"DOUBLE\",\n  66: \"SIGNED\",\n  67: \"UNSIGNED\",\n  68: \"_BOOL\",\n  69: \"TYPE_NAME\",\n  70: \"STRUCT\",\n  71: \"UNION\",\n  72: \"ENUM\",\n  73: \"CONST\",\n  74: \"INLINE\",\n  75: \"IMPORT\",\n  76: \"...\",\n  77: \"CASE\",\n  78: \"DEFAULT\",\n  79: \"IF\",\n  80: \"ELSE\",\n  81: \"SWITCH\",\n  82: \"WHILE\",\n  83: \"DO\",\n  84: \"FOR\",\n  85: \"GOTO\",\n  86: \"CONTINUE\",\n  87: \"BREAK\",\n  88: \"RETURN\"\n},\nTERROR: 2,\n    EOF: 1,\n\n    // internals: defined here so the object *structure* doesn't get modified by parse() et al,\n    // thus helping JIT compilers like Chrome V8.\n    originalQuoteName: null,\n    originalParseError: null,\n    cleanupAfterParse: null,\n    constructParseErrorInfo: null,\n    yyMergeLocationInfo: null,\n\n    __reentrant_call_depth: 0,      // INTERNAL USE ONLY\n    __error_infos: [],              // INTERNAL USE ONLY: the set of parseErrorInfo objects created since the last cleanup\n    __error_recovery_infos: [],     // INTERNAL USE ONLY: the set of parseErrorInfo objects created since the last cleanup\n\n    // APIs which will be set up depending on user action code analysis:\n    //yyRecovering: 0,\n    //yyErrOk: 0,\n    //yyClearIn: 0,\n\n    // Helper APIs\n    // -----------\n\n    // Helper function which can be overridden by user code later on: put suitable quotes around\n    // literal IDs in a description string.\n    quoteName: function parser_quoteName(id_str) {\n        return '\"' + id_str + '\"';\n    },\n\n    // Return the name of the given symbol (terminal or non-terminal) as a string, when available.\n    //\n    // Return NULL when the symbol is unknown to the parser.\n    getSymbolName: function parser_getSymbolName(symbol) {\n        if (this.terminals_[symbol]) {\n            return this.terminals_[symbol];\n        }\n\n        // Otherwise... this might refer to a RULE token i.e. a non-terminal: see if we can dig that one up.\n        //\n        // An example of this may be where a rule's action code contains a call like this:\n        //\n        //      parser.getSymbolName(#$)\n        //\n        // to obtain a human-readable name of the current grammar rule.\n        var s = this.symbols_;\n        for (var key in s) {\n            if (s[key] === symbol) {\n                return key;\n            }\n        }\n        return null;\n    },\n\n    // Return a more-or-less human-readable description of the given symbol, when available,\n    // or the symbol itself, serving as its own 'description' for lack of something better to serve up.\n    //\n    // Return NULL when the symbol is unknown to the parser.\n    describeSymbol: function parser_describeSymbol(symbol) {\n        if (symbol !== this.EOF && this.terminal_descriptions_ && this.terminal_descriptions_[symbol]) {\n            return this.terminal_descriptions_[symbol];\n        }\n        else if (symbol === this.EOF) {\n            return 'end of input';\n        }\n        var id = this.getSymbolName(symbol);\n        if (id) {\n            return this.quoteName(id);\n        }\n        return null;\n    },\n\n    // Produce a (more or less) human-readable list of expected tokens at the point of failure.\n    //\n    // The produced list may contain token or token set descriptions instead of the tokens\n    // themselves to help turning this output into something that easier to read by humans\n    // unless `do_not_describe` parameter is set, in which case a list of the raw, *numeric*,\n    // expected terminals and nonterminals is produced.\n    //\n    // The returned list (array) will not contain any duplicate entries.\n    collect_expected_token_set: function parser_collect_expected_token_set(state, do_not_describe) {\n        var TERROR = this.TERROR;\n        var tokenset = [];\n        var check = {};\n        // Has this (error?) state been outfitted with a custom expectations description text for human consumption?\n        // If so, use that one instead of the less palatable token set.\n        if (!do_not_describe && this.state_descriptions_ && this.state_descriptions_[state]) {\n            return [\n                this.state_descriptions_[state]\n            ];\n        }\n        for (var p in this.table[state]) {\n            p = +p;\n            if (p !== TERROR) {\n                var d = do_not_describe ? p : this.describeSymbol(p);\n                if (d && !check[d]) {\n                    tokenset.push(d);\n                    check[d] = true;        // Mark this token description as already mentioned to prevent outputting duplicate entries.\n                }\n            }\n        }\n        return tokenset;\n    },\nproductions_: bp({\n  pop: u([\n  89,\n  89,\n  90,\n  s,\n  [91, 5],\n  92,\n  93,\n  93,\n  s,\n  [94, 4],\n  s,\n  [95, 8],\n  96,\n  96,\n  s,\n  [97, 6],\n  s,\n  [98, 6],\n  99,\n  99,\n  s,\n  [100, 4],\n  s,\n  [101, 3],\n  s,\n  [102, 3],\n  s,\n  [103, 5],\n  s,\n  [104, 3],\n  105,\n  105,\n  106,\n  106,\n  107,\n  107,\n  108,\n  108,\n  109,\n  109,\n  110,\n  110,\n  111,\n  111,\n  s,\n  [112, 11],\n  113,\n  113,\n  114,\n  115,\n  115,\n  s,\n  [116, 8],\n  117,\n  117,\n  118,\n  118,\n  s,\n  [119, 3],\n  s,\n  [120, 13],\n  s,\n  [121, 3],\n  122,\n  122,\n  123,\n  123,\n  124,\n  s,\n  [125, 4],\n  126,\n  126,\n  127,\n  s,\n  [128, 5],\n  129,\n  129,\n  130,\n  130,\n  131,\n  132,\n  132,\n  133,\n  133,\n  s,\n  [134, 6],\n  s,\n  [135, 4],\n  136,\n  136,\n  137,\n  137,\n  138,\n  138,\n  s,\n  [139, 3],\n  140,\n  140,\n  s,\n  [141, 3],\n  s,\n  [142, 9],\n  s,\n  [143, 3],\n  144,\n  144,\n  s,\n  [145, 6],\n  s,\n  [146, 3],\n  147,\n  147,\n  148,\n  148,\n  149,\n  149,\n  150,\n  150,\n  s,\n  [151, 3],\n  s,\n  [152, 6],\n  s,\n  [153, 5],\n  154,\n  154,\n  155,\n  155,\n  156\n]),\n  rule: u([\n  2,\n  s,\n  [1, 9],\n  c,\n  [10, 4],\n  3,\n  1,\n  4,\n  3,\n  4,\n  3,\n  3,\n  2,\n  2,\n  c,\n  [10, 3],\n  s,\n  [2, 4],\n  4,\n  s,\n  [1, 7],\n  4,\n  1,\n  s,\n  [3, 3],\n  c,\n  [4, 3],\n  c,\n  [3, 6],\n  c,\n  [8, 7],\n  c,\n  [36, 3],\n  c,\n  [4, 6],\n  5,\n  c,\n  [4, 3],\n  s,\n  [1, 11],\n  c,\n  [59, 3],\n  c,\n  [3, 3],\n  c,\n  [80, 3],\n  c,\n  [4, 4],\n  c,\n  [32, 4],\n  s,\n  [1, 15],\n  5,\n  4,\n  c,\n  [107, 4],\n  2,\n  3,\n  c,\n  [31, 4],\n  c,\n  [114, 4],\n  5,\n  5,\n  6,\n  c,\n  [40, 8],\n  c,\n  [17, 4],\n  c,\n  [130, 4],\n  c,\n  [125, 3],\n  c,\n  [67, 4],\n  c,\n  [21, 3],\n  c,\n  [139, 3],\n  c,\n  [22, 4],\n  c,\n  [46, 3],\n  3,\n  3,\n  4,\n  c,\n  [4, 4],\n  c,\n  [33, 3],\n  c,\n  [83, 8],\n  c,\n  [41, 3],\n  c,\n  [39, 5],\n  c,\n  [31, 3],\n  5,\n  7,\n  5,\n  5,\n  7,\n  6,\n  7,\n  6,\n  7,\n  c,\n  [49, 3],\n  c,\n  [20, 6],\n  3\n])\n}),\nperformAction: function parser__PerformAction(yytext, yyloc, yystate /* action[1] */, yysp, yyvstack, yylstack) {\n\n          /* this == yyval */\n\n          // the JS engine itself can go and remove these statements when `yy` turns out to be unused in any action code!\n          var yy = this.yy;\n          var yyparser = yy.parser;\n          var yylexer = yy.lexer;\n\n          \n\n          switch (yystate) {\ncase 0:\n    /*! Production::    $accept : ast_tree $end */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,-,-,LT,LA,-,-):\n    this.$ = undefined;\n    this._$ = yylstack[yysp - 1];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,-,-,LT,LA,-,-)\n    break;\n\ncase 1:\n    /*! Production::    ast_tree : translation_unit EOF */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,-,-,LT,LA,-,-):\n    this.$ = undefined;\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,-,-,LT,LA,-,-)\n    \n    \n    return yyvstack[yysp - 1];\n    break;\n\ncase 2:\n    /*! Production::    ast_tree : EOF */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,-,-,LT,LA,-,-):\n    this.$ = undefined;\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,-,-,LT,LA,-,-)\n    \n    \n    return [];\n    break;\n\ncase 3:\n    /*! Production::    identifier : IDENTIFIER */\ncase 9:\n    /*! Production::    string_literal : STRING_LITERAL */\ncase 100:\n    /*! Production::    storage_class_specifier : TYPEDEF */\ncase 101:\n    /*! Production::    storage_class_specifier : EXTERN */\ncase 102:\n    /*! Production::    storage_class_specifier : STATIC */\ncase 103:\n    /*! Production::    type_specifier : VOID */\ncase 104:\n    /*! Production::    type_specifier : CHAR */\ncase 105:\n    /*! Production::    type_specifier : SHORT */\ncase 106:\n    /*! Production::    type_specifier : INT */\ncase 107:\n    /*! Production::    type_specifier : LONG */\ncase 108:\n    /*! Production::    type_specifier : FLOAT */\ncase 109:\n    /*! Production::    type_specifier : DOUBLE */\ncase 110:\n    /*! Production::    type_specifier : SIGNED */\ncase 111:\n    /*! Production::    type_specifier : UNSIGNED */\ncase 142:\n    /*! Production::    function_specifier : IMPORT */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (yytext);\n    break;\n\ncase 4:\n    /*! Production::    constant : CONSTANT_FLOAT */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.Constant(this._$, yytext, \"float\"));\n    break;\n\ncase 5:\n    /*! Production::    constant : CONSTANT_HEX */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.Constant(this._$, yytext, \"hex\"));\n    break;\n\ncase 6:\n    /*! Production::    constant : CONSTANT_OCTAL */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.Constant(this._$, yytext, \"oct\"));\n    break;\n\ncase 7:\n    /*! Production::    constant : CONSTANT_INT */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.Constant(this._$, yytext, \"int\"));\n    break;\n\ncase 8:\n    /*! Production::    constant : CONSTANT_CHAR */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.Constant(this._$, yytext, \"char\"));\n    break;\n\ncase 10:\n    /*! Production::    concat_string_literals : string_literal */\ncase 13:\n    /*! Production::    primary_expression : constant */\ncase 16:\n    /*! Production::    postfix_expression : primary_expression */\ncase 26:\n    /*! Production::    unary_expression : postfix_expression */\ncase 38:\n    /*! Production::    cast_expression : unary_expression */\ncase 40:\n    /*! Production::    multiplicative_expression : cast_expression */\ncase 44:\n    /*! Production::    additive_expression : multiplicative_expression */\ncase 47:\n    /*! Production::    shift_expression : additive_expression */\ncase 50:\n    /*! Production::    relational_expression : shift_expression */\ncase 55:\n    /*! Production::    equality_expression : relational_expression */\ncase 58:\n    /*! Production::    and_expression : equality_expression */\ncase 60:\n    /*! Production::    exclusive_or_expression : and_expression */\ncase 62:\n    /*! Production::    inclusive_or_expression : exclusive_or_expression */\ncase 64:\n    /*! Production::    logical_and_expression : inclusive_or_expression */\ncase 66:\n    /*! Production::    logical_or_expression : logical_and_expression */\ncase 68:\n    /*! Production::    conditional_expression : logical_or_expression */\ncase 70:\n    /*! Production::    assignment_expression : conditional_expression */\ncase 83:\n    /*! Production::    expression : assignment_expression */\ncase 98:\n    /*! Production::    init_declarator : declarator */\ncase 113:\n    /*! Production::    type_specifier : struct_or_union_specifier */\ncase 114:\n    /*! Production::    type_specifier : enum_specifier */\ncase 130:\n    /*! Production::    struct_declarator : declarator */\ncase 144:\n    /*! Production::    declarator : direct_declarator */\ncase 167:\n    /*! Production::    abstract_declarator : direct_abstract_declarator */\ncase 178:\n    /*! Production::    initializer : assignment_expression */\ncase 183:\n    /*! Production::    statement : labeled_statement */\ncase 184:\n    /*! Production::    statement : compound_statement */\ncase 185:\n    /*! Production::    statement : expression_statement */\ncase 186:\n    /*! Production::    statement : selection_statement */\ncase 187:\n    /*! Production::    statement : iteration_statement */\ncase 188:\n    /*! Production::    statement : jump_statement */\ncase 196:\n    /*! Production::    block_item : declaration */\ncase 197:\n    /*! Production::    block_item : statement */\ncase 216:\n    /*! Production::    external_declaration : function_definition */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (yyvstack[yysp]);\n    break;\n\ncase 11:\n    /*! Production::    concat_string_literals : concat_string_literals string_literal */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (yyvstack[yysp - 1] + yyvstack[yysp]);\n    break;\n\ncase 12:\n    /*! Production::    primary_expression : identifier */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.Identifier(this._$, yytext));\n    break;\n\ncase 14:\n    /*! Production::    primary_expression : concat_string_literals */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.StringLiteral(this._$, yyvstack[yysp]));\n    break;\n\ncase 15:\n    /*! Production::    primary_expression : \"(\" expression \")\" */\ncase 146:\n    /*! Production::    direct_declarator : \"(\" declarator \")\" */\ncase 169:\n    /*! Production::    direct_abstract_declarator : \"(\" abstract_declarator \")\" */\ncase 179:\n    /*! Production::    initializer : \"{\" initializer_list \"}\" */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (yyvstack[yysp - 1]);\n    break;\n\ncase 17:\n    /*! Production::    postfix_expression : postfix_expression \"[\" expression \"]\" */\n\n    // default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);\n    // END of default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"arraySubscript\", yyvstack[yysp - 3], yyvstack[yysp - 1]));\n    break;\n\ncase 18:\n    /*! Production::    postfix_expression : postfix_expression \"(\" \")\" */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.FunctionCallExpression(this._$, yyvstack[yysp - 2]));\n    break;\n\ncase 19:\n    /*! Production::    postfix_expression : postfix_expression \"(\" argument_expression_list \")\" */\n\n    // default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);\n    // END of default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.FunctionCallExpression(this._$, yyvstack[yysp - 3], yyvstack[yysp - 1]));\n    break;\n\ncase 20:\n    /*! Production::    postfix_expression : postfix_expression \".\" identifier */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.MemberAccessExpression(this._$, false, yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 21:\n    /*! Production::    postfix_expression : postfix_expression \"->\" identifier */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.MemberAccessExpression(this._$, true, yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 22:\n    /*! Production::    postfix_expression : postfix_expression \"++\" */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.UnaryExpression(this._$, \"postfixIncrement\", yyvstack[yysp - 1]));\n    break;\n\ncase 23:\n    /*! Production::    postfix_expression : postfix_expression \"--\" */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.UnaryExpression(this._$, \"postfixDecrement\", yyvstack[yysp - 1]));\n    break;\n\ncase 24:\n    /*! Production::    argument_expression_list : assignment_expression */\ncase 96:\n    /*! Production::    init_declarator_list : init_declarator */\ncase 121:\n    /*! Production::    struct_declaration_list : struct_declaration */\ncase 128:\n    /*! Production::    struct_declarator_list : struct_declarator */\ncase 136:\n    /*! Production::    enumerator_list : enumerator */\ncase 155:\n    /*! Production::    type_qualifier_list : type_qualifier */\ncase 159:\n    /*! Production::    parameter_list : parameter_declaration */\ncase 181:\n    /*! Production::    initializer_list : initializer */\ncase 194:\n    /*! Production::    block_item_list : block_item */\ncase 214:\n    /*! Production::    translation_unit : external_declaration */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = ([yyvstack[yysp]]);\n    break;\n\ncase 25:\n    /*! Production::    argument_expression_list : argument_expression_list \",\" assignment_expression */\ncase 97:\n    /*! Production::    init_declarator_list : init_declarator_list \",\" init_declarator */\ncase 129:\n    /*! Production::    struct_declarator_list : struct_declarator_list \",\" struct_declarator */\ncase 137:\n    /*! Production::    enumerator_list : enumerator_list \",\" enumerator */\ncase 160:\n    /*! Production::    parameter_list : parameter_list \",\" parameter_declaration */\ncase 182:\n    /*! Production::    initializer_list : initializer_list \",\" initializer */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = ((yyvstack[yysp - 2].push(yyvstack[yysp]), yyvstack[yysp - 2]));\n    break;\n\ncase 27:\n    /*! Production::    unary_expression : \"++\" unary_expression */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.UnaryExpression(this._$, \"prefixIncrement\", yyvstack[yysp]));\n    break;\n\ncase 28:\n    /*! Production::    unary_expression : \"--\" unary_expression */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.UnaryExpression(this._$, \"prefixDecrement\", yyvstack[yysp]));\n    break;\n\ncase 29:\n    /*! Production::    unary_expression : unary_operator cast_expression */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.UnaryExpression(this._$, yyvstack[yysp - 1], yyvstack[yysp]));\n    break;\n\ncase 30:\n    /*! Production::    unary_expression : SIZEOF unary_expression */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.SizeofExpression(this._$, yyvstack[yysp]));\n    break;\n\ncase 31:\n    /*! Production::    unary_expression : SIZEOF \"(\" type_name \")\" */\n\n    // default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);\n    // END of default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.SizeofExpression(this._$, yyvstack[yysp - 1]));\n    break;\n\ncase 32:\n    /*! Production::    unary_operator : \"&\" */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"addressOf\");\n    break;\n\ncase 33:\n    /*! Production::    unary_operator : \"*\" */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"dereference\");\n    break;\n\ncase 34:\n    /*! Production::    unary_operator : \"+\" */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"unaryPlus\");\n    break;\n\ncase 35:\n    /*! Production::    unary_operator : \"-\" */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"unaryMinus\");\n    break;\n\ncase 36:\n    /*! Production::    unary_operator : \"~\" */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"bitwiseNot\");\n    break;\n\ncase 37:\n    /*! Production::    unary_operator : \"!\" */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"logicalNot\");\n    break;\n\ncase 39:\n    /*! Production::    cast_expression : \"(\" type_name \")\" cast_expression */\n\n    // default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);\n    // END of default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.CastExpression(this._$, yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 41:\n    /*! Production::    multiplicative_expression : multiplicative_expression \"*\" cast_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"mul\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 42:\n    /*! Production::    multiplicative_expression : multiplicative_expression \"/\" cast_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"div\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 43:\n    /*! Production::    multiplicative_expression : multiplicative_expression \"%\" cast_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"mod\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 45:\n    /*! Production::    additive_expression : additive_expression \"+\" multiplicative_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"add\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 46:\n    /*! Production::    additive_expression : additive_expression \"-\" multiplicative_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"sub\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 48:\n    /*! Production::    shift_expression : shift_expression \"<<\" additive_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"bitwiseShiftLeft\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 49:\n    /*! Production::    shift_expression : shift_expression \">>\" additive_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"bitwiseShiftRight\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 51:\n    /*! Production::    relational_expression : relational_expression \"<\" shift_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"relationalLT\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 52:\n    /*! Production::    relational_expression : relational_expression \">\" shift_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"relationalGT\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 53:\n    /*! Production::    relational_expression : relational_expression \"<=\" shift_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"relationalLEq\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 54:\n    /*! Production::    relational_expression : relational_expression \">=\" shift_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"relationalGEq\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 56:\n    /*! Production::    equality_expression : equality_expression \"==\" relational_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"relationalEq\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 57:\n    /*! Production::    equality_expression : equality_expression \"!=\" relational_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"relationalNEq\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 59:\n    /*! Production::    and_expression : and_expression \"&\" equality_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"bitwiseAnd\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 61:\n    /*! Production::    exclusive_or_expression : exclusive_or_expression \"^\" and_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"bitwiseXor\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 63:\n    /*! Production::    inclusive_or_expression : inclusive_or_expression \"|\" exclusive_or_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"bitwiseOr\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 65:\n    /*! Production::    logical_and_expression : logical_and_expression \"&&\" inclusive_or_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"logicalAnd\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 67:\n    /*! Production::    logical_or_expression : logical_or_expression \"||\" logical_and_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"logicalOr\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 69:\n    /*! Production::    conditional_expression : logical_or_expression \"?\" expression \":\" conditional_expression */\n\n    // default action (generated by JISON mode none/merge :: 5,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 4, yysp);\n    // END of default action (generated by JISON mode none/merge :: 5,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.ConditionalExpression(this._$, yyvstack[yysp - 4], yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 71:\n    /*! Production::    assignment_expression : unary_expression assignment_operator assignment_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.AssignmentExpression(this._$, yyvstack[yysp - 1], yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 72:\n    /*! Production::    assignment_operator : \"=\" */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (undefined);\n    break;\n\ncase 73:\n    /*! Production::    assignment_operator : \"*=\" */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"mul\");\n    break;\n\ncase 74:\n    /*! Production::    assignment_operator : \"/=\" */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"div\");\n    break;\n\ncase 75:\n    /*! Production::    assignment_operator : \"%=\" */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"mod\");\n    break;\n\ncase 76:\n    /*! Production::    assignment_operator : \"+=\" */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"add\");\n    break;\n\ncase 77:\n    /*! Production::    assignment_operator : \"-=\" */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"sub\");\n    break;\n\ncase 78:\n    /*! Production::    assignment_operator : \"<<=\" */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"leftShift\");\n    break;\n\ncase 79:\n    /*! Production::    assignment_operator : \">>=\" */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"rightShift\");\n    break;\n\ncase 80:\n    /*! Production::    assignment_operator : \"&=\" */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"bitwiseAnd\");\n    break;\n\ncase 81:\n    /*! Production::    assignment_operator : \"^=\" */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"bitwiseXor\");\n    break;\n\ncase 82:\n    /*! Production::    assignment_operator : \"|=\" */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"bitwiseOr\");\n    break;\n\ncase 84:\n    /*! Production::    expression : expression \",\" assignment_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"comma\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 85:\n    /*! Production::    constant_expression : conditional_expression */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.ConstantExpression(this._$, yyvstack[yysp]));\n    break;\n\ncase 86:\n    /*! Production::    declaration : declaration_specifiers \";\" */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.Declaration(this._$, yyvstack[yysp - 1]));\n    break;\n\ncase 87:\n    /*! Production::    declaration : declaration_specifiers init_declarator_list \";\" */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.Declaration(this._$, yyvstack[yysp - 2], yyvstack[yysp - 1]));\n    break;\n\ncase 88:\n    /*! Production::    declaration_specifiers : storage_class_specifier */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.DeclarationSpecifiers(this._$, [], [], [yyvstack[yysp]], []));\n    break;\n\ncase 89:\n    /*! Production::    declaration_specifiers : storage_class_specifier declaration_specifiers */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.DeclarationSpecifiers(this._$, yyvstack[yysp].specifierList, yyvstack[yysp].qualifierList, [yyvstack[yysp - 1], ...yyvstack[yysp].storageList], yyvstack[yysp].fnSpecifierList));\n    break;\n\ncase 90:\n    /*! Production::    declaration_specifiers : type_specifier */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.DeclarationSpecifiers(this._$, [yyvstack[yysp]], [], [], []));\n    break;\n\ncase 91:\n    /*! Production::    declaration_specifiers : type_specifier declaration_specifiers */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.DeclarationSpecifiers(this._$, [yyvstack[yysp - 1], ...yyvstack[yysp].specifierList], yyvstack[yysp].qualifierList, yyvstack[yysp].storageList, yyvstack[yysp].fnSpecifierList));\n    break;\n\ncase 92:\n    /*! Production::    declaration_specifiers : type_qualifier */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.DeclarationSpecifiers(this._$, [], [yyvstack[yysp]], [], []));\n    break;\n\ncase 93:\n    /*! Production::    declaration_specifiers : type_qualifier declaration_specifiers */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.DeclarationSpecifiers(this._$, yyvstack[yysp].specifierList, [yyvstack[yysp - 1], ...yyvstack[yysp].qualifierList], yyvstack[yysp].storageList, yyvstack[yysp].fnSpecifierList));\n    break;\n\ncase 94:\n    /*! Production::    declaration_specifiers : function_specifier */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.DeclarationSpecifiers(this._$, [], [], [], [yyvstack[yysp]]));\n    break;\n\ncase 95:\n    /*! Production::    declaration_specifiers : function_specifier declaration_specifiers */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.DeclarationSpecifiers(this._$, yyvstack[yysp].specifierList, yyvstack[yysp].qualifierList, yyvstack[yysp].storageList, [yyvstack[yysp - 1], ...yyvstack[yysp].fnSpecifierList]));\n    break;\n\ncase 99:\n    /*! Production::    init_declarator : declarator \"=\" initializer */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.InitDeclarator(this._$, yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 112:\n    /*! Production::    type_specifier : _BOOL */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"bool\");\n    break;\n\ncase 115:\n    /*! Production::    type_specifier : TYPE_NAME */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.CustomTypeSpecifier(this._$, yyvstack[yysp]));\n    break;\n\ncase 116:\n    /*! Production::    struct_or_union_specifier : struct_or_union identifier \"{\" struct_declaration_list \"}\" */\n\n    // default action (generated by JISON mode none/merge :: 5,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 4, yysp);\n    // END of default action (generated by JISON mode none/merge :: 5,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.StructUnionSpecifier(this._$, yyvstack[yysp - 4], yyvstack[yysp - 3], yyvstack[yysp - 1]));\n    break;\n\ncase 117:\n    /*! Production::    struct_or_union_specifier : struct_or_union \"{\" struct_declaration_list \"}\" */\n\n    // default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);\n    // END of default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.StructUnionSpecifier(this._$, yyvstack[yysp - 3], undefined, yyvstack[yysp - 1]));\n    break;\n\ncase 118:\n    /*! Production::    struct_or_union_specifier : struct_or_union identifier */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.StructUnionSpecifier(this._$, yyvstack[yysp - 1], yyvstack[yysp]));\n    break;\n\ncase 119:\n    /*! Production::    struct_or_union : STRUCT */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"struct\");\n    break;\n\ncase 120:\n    /*! Production::    struct_or_union : UNION */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"union\");\n    break;\n\ncase 122:\n    /*! Production::    struct_declaration_list : struct_declaration_list struct_declaration */\ncase 156:\n    /*! Production::    type_qualifier_list : type_qualifier_list type_qualifier */\ncase 195:\n    /*! Production::    block_item_list : block_item_list block_item */\ncase 215:\n    /*! Production::    translation_unit : translation_unit external_declaration */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = ((yyvstack[yysp - 1].push(yyvstack[yysp]), yyvstack[yysp - 1]));\n    break;\n\ncase 123:\n    /*! Production::    struct_declaration : specifier_qualifier_list struct_declarator_list \";\" */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.StructDeclaration(this._$, yyvstack[yysp - 2], yyvstack[yysp - 1]));\n    break;\n\ncase 124:\n    /*! Production::    specifier_qualifier_list : type_specifier specifier_qualifier_list */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.SpecifierQualifiers(this._$, [yyvstack[yysp - 1], ...yyvstack[yysp].specifierList], yyvstack[yysp].qualifierList));\n    break;\n\ncase 125:\n    /*! Production::    specifier_qualifier_list : type_specifier */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.SpecifierQualifiers(this._$, [yyvstack[yysp]], []));\n    break;\n\ncase 126:\n    /*! Production::    specifier_qualifier_list : type_qualifier specifier_qualifier_list */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.SpecifierQualifiers(this._$, yyvstack[yysp].specifierList, [yyvstack[yysp - 1], ...yyvstack[yysp].qualifierList]));\n    break;\n\ncase 127:\n    /*! Production::    specifier_qualifier_list : type_qualifier */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.SpecifierQualifiers(this._$, [], [yyvstack[yysp]]));\n    break;\n\ncase 131:\n    /*! Production::    enum_specifier : ENUM \"{\" enumerator_list \"}\" */\n\n    // default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);\n    // END of default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.EnumSpecifier(this._$, undefined, yyvstack[yysp - 1]));\n    break;\n\ncase 132:\n    /*! Production::    enum_specifier : ENUM identifier \"{\" enumerator_list \"}\" */\n\n    // default action (generated by JISON mode none/merge :: 5,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 4, yysp);\n    // END of default action (generated by JISON mode none/merge :: 5,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.EnumSpecifier(this._$, yyvstack[yysp - 3], yyvstack[yysp - 1]));\n    break;\n\ncase 133:\n    /*! Production::    enum_specifier : ENUM \"{\" enumerator_list \",\" \"}\" */\n\n    // default action (generated by JISON mode none/merge :: 5,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 4, yysp);\n    // END of default action (generated by JISON mode none/merge :: 5,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.EnumSpecifier(this._$, undefined, yyvstack[yysp - 2]));\n    break;\n\ncase 134:\n    /*! Production::    enum_specifier : ENUM identifier \"{\" enumerator_list \",\" \"}\" */\n\n    // default action (generated by JISON mode none/merge :: 6,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 5, yysp);\n    // END of default action (generated by JISON mode none/merge :: 6,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.EnumSpecifier(this._$, yyvstack[yysp - 4], yyvstack[yysp - 2]));\n    break;\n\ncase 135:\n    /*! Production::    enum_specifier : ENUM identifier */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.EnumSpecifier(this._$, yyvstack[yysp]));\n    break;\n\ncase 138:\n    /*! Production::    enumerator : identifier */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.Enumerator(this._$, yyvstack[yysp]));\n    break;\n\ncase 139:\n    /*! Production::    enumerator : identifier \"=\" constant_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.Enumerator(this._$, yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 140:\n    /*! Production::    type_qualifier : CONST */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"const\");\n    break;\n\ncase 141:\n    /*! Production::    function_specifier : INLINE */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"inline\");\n    break;\n\ncase 143:\n    /*! Production::    declarator : pointer direct_declarator */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.PointerDeclarator(this._$, yyvstack[yysp - 1], yyvstack[yysp]));\n    break;\n\ncase 145:\n    /*! Production::    direct_declarator : identifier */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.IdentifierDeclarator(this._$, yyvstack[yysp]));\n    break;\n\ncase 147:\n    /*! Production::    direct_declarator : direct_declarator \"[\" constant_expression \"]\" */\n\n    // default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);\n    // END of default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.ArrayDeclarator(this._$, yyvstack[yysp - 3], yyvstack[yysp - 1]));\n    break;\n\ncase 148:\n    /*! Production::    direct_declarator : direct_declarator \"[\" \"]\" */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.ArrayDeclarator(this._$, yyvstack[yysp - 2]));\n    break;\n\ncase 149:\n    /*! Production::    direct_declarator : direct_declarator \"(\" parameter_type_list \")\" */\n\n    // default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);\n    // END of default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.FunctionDeclarator(this._$, yyvstack[yysp - 3], yyvstack[yysp - 1], yyvstack[yysp - 1].variadic));\n    break;\n\ncase 150:\n    /*! Production::    direct_declarator : direct_declarator \"(\" \")\" */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.FunctionDeclarator(this._$, yyvstack[yysp - 2]));\n    break;\n\ncase 151:\n    /*! Production::    pointer : \"*\" */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.Pointer(this._$));\n    break;\n\ncase 152:\n    /*! Production::    pointer : \"*\" type_qualifier_list */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.Pointer(this._$, yyvstack[yysp]));\n    break;\n\ncase 153:\n    /*! Production::    pointer : \"*\" pointer */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.Pointer(this._$, undefined, yyvstack[yysp]));\n    break;\n\ncase 154:\n    /*! Production::    pointer : \"*\" type_qualifier_list pointer */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.Pointer(this._$, yyvstack[yysp - 1], yyvstack[yysp]));\n    break;\n\ncase 157:\n    /*! Production::    parameter_type_list : parameter_list */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = ((yyvstack[yysp].variadic = false, yyvstack[yysp]));\n    break;\n\ncase 158:\n    /*! Production::    parameter_type_list : parameter_list \",\" \"...\" */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = ((yyvstack[yysp - 2].variadic = true, yyvstack[yysp - 2]));\n    break;\n\ncase 161:\n    /*! Production::    parameter_declaration : declaration_specifiers declarator */\ncase 162:\n    /*! Production::    parameter_declaration : declaration_specifiers abstract_declarator */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.ParameterDeclaration(this._$, yyvstack[yysp - 1], yyvstack[yysp]));\n    break;\n\ncase 163:\n    /*! Production::    parameter_declaration : declaration_specifiers */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.ParameterDeclaration(this._$, yyvstack[yysp]));\n    break;\n\ncase 164:\n    /*! Production::    type_name : specifier_qualifier_list */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.TypeName(this._$, yyvstack[yysp]));\n    break;\n\ncase 165:\n    /*! Production::    type_name : specifier_qualifier_list abstract_declarator */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.TypeName(this._$, yyvstack[yysp - 1], yyvstack[yysp]));\n    break;\n\ncase 166:\n    /*! Production::    abstract_declarator : pointer */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.AbstractPointerDeclarator(this._$, yyvstack[yysp]));\n    break;\n\ncase 168:\n    /*! Production::    abstract_declarator : pointer direct_abstract_declarator */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.AbstractPointerDeclarator(this._$, yyvstack[yysp - 1], yyvstack[yysp]));\n    break;\n\ncase 170:\n    /*! Production::    direct_abstract_declarator : \"[\" \"]\" */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.AbstractArrayDeclarator(this._$));\n    break;\n\ncase 171:\n    /*! Production::    direct_abstract_declarator : \"[\" constant_expression \"]\" */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.AbstractArrayDeclarator(this._$, undefined, yyvstack[yysp - 1]));\n    break;\n\ncase 172:\n    /*! Production::    direct_abstract_declarator : direct_abstract_declarator \"[\" \"]\" */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.AbstractArrayDeclarator(this._$, yyvstack[yysp - 2]));\n    break;\n\ncase 173:\n    /*! Production::    direct_abstract_declarator : direct_abstract_declarator \"[\" constant_expression \"]\" */\n\n    // default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);\n    // END of default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.AbstractArrayDeclarator(this._$, yyvstack[yysp - 3], yyvstack[yysp - 1]));\n    break;\n\ncase 174:\n    /*! Production::    direct_abstract_declarator : \"(\" \")\" */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.AbstractFunctionDeclarator(this._$));\n    break;\n\ncase 175:\n    /*! Production::    direct_abstract_declarator : \"(\" parameter_type_list \")\" */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.AbstractFunctionDeclarator(this._$, undefined, yyvstack[yysp - 1], yyvstack[yysp - 1].variadic));\n    break;\n\ncase 176:\n    /*! Production::    direct_abstract_declarator : direct_abstract_declarator \"(\" \")\" */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.AbstractFunctionDeclarator(this._$, yyvstack[yysp - 2]));\n    break;\n\ncase 177:\n    /*! Production::    direct_abstract_declarator : direct_abstract_declarator \"(\" parameter_type_list \")\" */\n\n    // default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);\n    // END of default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.AbstractFunctionDeclarator(this._$, yyvstack[yysp - 3], yyvstack[yysp - 1], yyvstack[yysp - 1].variadic));\n    break;\n\ncase 180:\n    /*! Production::    initializer : \"{\" initializer_list \",\" \"}\" */\n\n    // default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);\n    // END of default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (yyvstack[yysp - 2]);\n    break;\n\ncase 189:\n    /*! Production::    labeled_statement : identifier \":\" statement */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (yyvstack[yysp].setLabel(yyvstack[yysp - 2]));\n    break;\n\ncase 190:\n    /*! Production::    labeled_statement : CASE constant_expression \":\" statement */\n\n    // default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);\n    // END of default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.CaseStatement(this._$, yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 191:\n    /*! Production::    labeled_statement : DEFAULT \":\" statement */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.DefaultStatement(this._$, yyvstack[yysp]));\n    break;\n\ncase 192:\n    /*! Production::    compound_statement : \"{\" \"}\" */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.CompoundStatement(this._$, []));\n    break;\n\ncase 193:\n    /*! Production::    compound_statement : \"{\" block_item_list \"}\" */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.CompoundStatement(this._$, yyvstack[yysp - 1]));\n    break;\n\ncase 198:\n    /*! Production::    expression_statement : \";\" */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.NoOp(this._$));\n    break;\n\ncase 199:\n    /*! Production::    expression_statement : expression \";\" */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.ExpressionStatement(this._$, yyvstack[yysp - 1]));\n    break;\n\ncase 200:\n    /*! Production::    selection_statement : IF \"(\" expression \")\" statement */\n\n    // default action (generated by JISON mode none/merge :: 5,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 4, yysp);\n    // END of default action (generated by JISON mode none/merge :: 5,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.IfStatement(this._$, yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 201:\n    /*! Production::    selection_statement : IF \"(\" expression \")\" statement ELSE statement */\n\n    // default action (generated by JISON mode none/merge :: 7,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 6, yysp);\n    // END of default action (generated by JISON mode none/merge :: 7,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.IfStatement(this._$, yyvstack[yysp - 4], yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 202:\n    /*! Production::    selection_statement : SWITCH \"(\" expression \")\" statement */\n\n    // default action (generated by JISON mode none/merge :: 5,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 4, yysp);\n    // END of default action (generated by JISON mode none/merge :: 5,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.SwitchStatement(this._$, yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 203:\n    /*! Production::    iteration_statement : WHILE \"(\" expression \")\" statement */\n\n    // default action (generated by JISON mode none/merge :: 5,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 4, yysp);\n    // END of default action (generated by JISON mode none/merge :: 5,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.WhileLoop(this._$, yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 204:\n    /*! Production::    iteration_statement : DO statement WHILE \"(\" expression \")\" \";\" */\n\n    // default action (generated by JISON mode none/merge :: 7,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 6, yysp);\n    // END of default action (generated by JISON mode none/merge :: 7,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.DoWhileLoop(this._$, yyvstack[yysp - 5], yyvstack[yysp - 2]));\n    break;\n\ncase 205:\n    /*! Production::    iteration_statement : FOR \"(\" expression_statement expression_statement \")\" statement */\ncase 207:\n    /*! Production::    iteration_statement : FOR \"(\" declaration expression_statement \")\" statement */\n\n    // default action (generated by JISON mode none/merge :: 6,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 5, yysp);\n    // END of default action (generated by JISON mode none/merge :: 6,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.ForLoop(this._$, yyvstack[yysp - 3], yyvstack[yysp - 2], undefined, yyvstack[yysp]));\n    break;\n\ncase 206:\n    /*! Production::    iteration_statement : FOR \"(\" expression_statement expression_statement expression \")\" statement */\ncase 208:\n    /*! Production::    iteration_statement : FOR \"(\" declaration expression_statement expression \")\" statement */\n\n    // default action (generated by JISON mode none/merge :: 7,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 6, yysp);\n    // END of default action (generated by JISON mode none/merge :: 7,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.ForLoop(this._$, yyvstack[yysp - 4], yyvstack[yysp - 3], yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 209:\n    /*! Production::    jump_statement : GOTO identifier \";\" */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.GotoStatement(this._$, yyvstack[yysp - 1]));\n    break;\n\ncase 210:\n    /*! Production::    jump_statement : CONTINUE \";\" */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.ContinueStatement(this._$));\n    break;\n\ncase 211:\n    /*! Production::    jump_statement : BREAK \";\" */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BreakStatement(this._$));\n    break;\n\ncase 212:\n    /*! Production::    jump_statement : RETURN \";\" */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.ReturnStatement(this._$));\n    break;\n\ncase 213:\n    /*! Production::    jump_statement : RETURN expression \";\" */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.ReturnStatement(this._$, yyvstack[yysp - 1]));\n    break;\n\ncase 217:\n    /*! Production::    external_declaration : declaration */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = ((yylexer.externalDeclaration(yyvstack[yysp]), yyvstack[yysp]));\n    break;\n\ncase 218:\n    /*! Production::    function_definition : declaration_specifiers declarator compound_statement */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.FunctionDefinition(this._$, yyvstack[yysp - 2], yyvstack[yysp - 1], yyvstack[yysp]));\n    break;\n\n}\n},\ntable: bt({\n  len: u([\n  34,\n  1,\n  32,\n  s,\n  [0, 4],\n  10,\n  s,\n  [35, 4],\n  s,\n  [0, 19],\n  3,\n  3,\n  s,\n  [0, 4],\n  5,\n  0,\n  2,\n  4,\n  7,\n  0,\n  10,\n  0,\n  7,\n  s,\n  [0, 5],\n  28,\n  23,\n  4,\n  28,\n  0,\n  40,\n  91,\n  0,\n  8,\n  7,\n  39,\n  32,\n  9,\n  0,\n  0,\n  1,\n  23,\n  23,\n  0,\n  9,\n  26,\n  26,\n  2,\n  0,\n  3,\n  4,\n  0,\n  0,\n  41,\n  0,\n  37,\n  8,\n  42,\n  25,\n  25,\n  26,\n  25,\n  c,\n  [25, 3],\n  s,\n  [0, 5],\n  10,\n  0,\n  0,\n  44,\n  61,\n  11,\n  s,\n  [0, 6],\n  12,\n  0,\n  14,\n  18,\n  20,\n  22,\n  25,\n  0,\n  0,\n  90,\n  c,\n  [25, 6],\n  s,\n  [0, 4],\n  39,\n  38,\n  1,\n  0,\n  2,\n  s,\n  [1, 3],\n  59,\n  1,\n  c,\n  [6, 3],\n  40,\n  c,\n  [113, 3],\n  1,\n  s,\n  [0, 3],\n  c,\n  [19, 3],\n  c,\n  [45, 3],\n  0,\n  0,\n  23,\n  0,\n  c,\n  [9, 3],\n  s,\n  [0, 4],\n  4,\n  38,\n  2,\n  2,\n  0,\n  38,\n  s,\n  [0, 11],\n  39,\n  35,\n  39,\n  40,\n  c,\n  [19, 3],\n  c,\n  [9, 3],\n  s,\n  [0, 3],\n  61,\n  34,\n  33,\n  c,\n  [68, 3],\n  7,\n  32,\n  31,\n  30,\n  30,\n  s,\n  [29, 4],\n  28,\n  28,\n  27,\n  27,\n  s,\n  [26, 3],\n  0,\n  0,\n  59,\n  1,\n  59,\n  0,\n  38,\n  s,\n  [39, 3],\n  1,\n  70,\n  c,\n  [85, 4],\n  c,\n  [46, 3],\n  30,\n  0,\n  0,\n  8,\n  4,\n  42,\n  c,\n  [51, 3],\n  8,\n  c,\n  [85, 5],\n  c,\n  [174, 3],\n  2,\n  9,\n  2,\n  c,\n  [99, 5],\n  1,\n  10,\n  11,\n  0,\n  26,\n  c,\n  [103, 3],\n  12,\n  14,\n  18,\n  18,\n  s,\n  [20, 4],\n  22,\n  22,\n  25,\n  c,\n  [168, 3],\n  c,\n  [67, 3],\n  c,\n  [56, 3],\n  2,\n  2,\n  1,\n  41,\n  41,\n  c,\n  [49, 5],\n  39,\n  32,\n  1,\n  c,\n  [156, 3],\n  c,\n  [77, 4],\n  0,\n  37,\n  0,\n  c,\n  [144, 5],\n  s,\n  [59, 3],\n  39,\n  40,\n  40,\n  c,\n  [21, 8],\n  0,\n  52,\n  c,\n  [47, 3],\n  59,\n  2,\n  59,\n  c,\n  [82, 3],\n  59,\n  1,\n  c,\n  [60, 3],\n  c,\n  [62, 3],\n  0,\n  0\n]),\n  symbol: u([\n  1,\n  s,\n  [56, 20, 1],\n  89,\n  115,\n  116,\n  s,\n  [119, 4, 1],\n  128,\n  131,\n  132,\n  154,\n  155,\n  156,\n  1,\n  c,\n  [35, 21],\n  c,\n  [34, 9],\n  155,\n  156,\n  3,\n  10,\n  24,\n  27,\n  90,\n  117,\n  118,\n  133,\n  134,\n  135,\n  3,\n  4,\n  5,\n  8,\n  c,\n  [13, 3],\n  c,\n  [48, 20],\n  c,\n  [47, 8],\n  c,\n  [35, 105],\n  25,\n  27,\n  90,\n  c,\n  [3, 3],\n  8,\n  23,\n  24,\n  25,\n  147,\n  8,\n  24,\n  3,\n  27,\n  90,\n  134,\n  c,\n  [52, 4],\n  c,\n  [14, 3],\n  c,\n  [59, 5],\n  27,\n  73,\n  131,\n  135,\n  136,\n  3,\n  10,\n  27,\n  90,\n  c,\n  [181, 9],\n  25,\n  c,\n  [77, 21],\n  c,\n  [17, 15],\n  s,\n  [120, 6, 1],\n  128,\n  131,\n  27,\n  90,\n  129,\n  130,\n  c,\n  [55, 28],\n  3,\n  s,\n  [9, 6, 1],\n  25,\n  s,\n  [27, 7, 1],\n  35,\n  36,\n  37,\n  s,\n  [90, 6, 1],\n  s,\n  [97, 15, 1],\n  143,\n  c,\n  [40, 7],\n  s,\n  [24, 10, 1],\n  c,\n  [42, 3],\n  c,\n  [80, 20],\n  77,\n  78,\n  79,\n  s,\n  [81, 8, 1],\n  c,\n  [73, 21],\n  113,\n  c,\n  [398, 9],\n  s,\n  [145, 9, 1],\n  c,\n  [221, 4],\n  c,\n  [403, 8],\n  c,\n  [246, 4],\n  6,\n  c,\n  [107, 6],\n  c,\n  [146, 30],\n  114,\n  4,\n  c,\n  [338, 28],\n  137,\n  138,\n  139,\n  c,\n  [317, 9],\n  4,\n  c,\n  [282, 23],\n  26,\n  c,\n  [24, 18],\n  c,\n  [23, 4],\n  c,\n  [142, 4],\n  126,\n  127,\n  c,\n  [143, 6],\n  10,\n  27,\n  c,\n  [36, 18],\n  c,\n  [35, 4],\n  c,\n  [26, 25],\n  8,\n  26,\n  8,\n  23,\n  26,\n  c,\n  [371, 5],\n  c,\n  [343, 39],\n  144,\n  4,\n  6,\n  s,\n  [8, 5, 1],\n  s,\n  [15, 10, 1],\n  26,\n  s,\n  [38, 18, 1],\n  112,\n  c,\n  [37, 3],\n  21,\n  22,\n  24,\n  26,\n  45,\n  s,\n  [3, 10, 1],\n  c,\n  [48, 11],\n  34,\n  35,\n  36,\n  c,\n  [51, 18],\n  c,\n  [128, 7],\n  c,\n  [127, 18],\n  c,\n  [25, 50],\n  99,\n  c,\n  [26, 25],\n  c,\n  [151, 7],\n  44,\n  45,\n  c,\n  [9, 3],\n  c,\n  [140, 3],\n  c,\n  [10, 4],\n  c,\n  [162, 21],\n  s,\n  [33, 4, 1],\n  c,\n  [163, 18],\n  92,\n  c,\n  [88, 17],\n  c,\n  [339, 15],\n  c,\n  [576, 22],\n  c,\n  [361, 6],\n  140,\n  c,\n  [115, 3],\n  c,\n  [94, 4],\n  c,\n  [126, 7],\n  9,\n  c,\n  [12, 18],\n  c,\n  [109, 4],\n  c,\n  [14, 4],\n  c,\n  [134, 6],\n  24,\n  26,\n  c,\n  [127, 6],\n  c,\n  [18, 12],\n  c,\n  [147, 8],\n  c,\n  [20, 4],\n  11,\n  12,\n  c,\n  [22, 20],\n  c,\n  [199, 11],\n  c,\n  [25, 10],\n  c,\n  [778, 85],\n  c,\n  [777, 7],\n  c,\n  [1182, 9],\n  5,\n  c,\n  [325, 16],\n  c,\n  [486, 46],\n  c,\n  [810, 13],\n  22,\n  c,\n  [1109, 3],\n  s,\n  [3, 3],\n  c,\n  [183, 8],\n  c,\n  [46, 10],\n  c,\n  [162, 33],\n  c,\n  [153, 3],\n  c,\n  [152, 5],\n  27,\n  90,\n  24,\n  24,\n  c,\n  [64, 8],\n  c,\n  [722, 31],\n  113,\n  c,\n  [963, 3],\n  6,\n  4,\n  4,\n  8,\n  c,\n  [895, 6],\n  c,\n  [1205, 4],\n  141,\n  142,\n  c,\n  [874, 23],\n  8,\n  24,\n  c,\n  [811, 3],\n  c,\n  [810, 8],\n  c,\n  [196, 31],\n  c,\n  [857, 3],\n  26,\n  c,\n  [42, 37],\n  111,\n  c,\n  [38, 38],\n  113,\n  c,\n  [39, 35],\n  c,\n  [74, 40],\n  4,\n  c,\n  [40, 22],\n  s,\n  [96, 16, 1],\n  27,\n  90,\n  27,\n  90,\n  c,\n  [157, 56],\n  c,\n  [794, 44],\n  c,\n  [100, 34],\n  c,\n  [34, 33],\n  4,\n  8,\n  4,\n  c,\n  [1252, 4],\n  c,\n  [443, 3],\n  c,\n  [43, 32],\n  c,\n  [32, 31],\n  c,\n  [31, 30],\n  c,\n  [30, 59],\n  c,\n  [29, 115],\n  c,\n  [28, 55],\n  c,\n  [27, 53],\n  c,\n  [26, 59],\n  c,\n  [993, 52],\n  22,\n  c,\n  [1053, 60],\n  c,\n  [918, 111],\n  c,\n  [39, 43],\n  82,\n  c,\n  [1204, 18],\n  c,\n  [1449, 20],\n  c,\n  [1438, 31],\n  150,\n  24,\n  8,\n  24,\n  s,\n  [56, 21, 1],\n  c,\n  [33, 8],\n  c,\n  [2155, 5],\n  c,\n  [2486, 3],\n  142,\n  c,\n  [8, 4],\n  c,\n  [2076, 5],\n  c,\n  [102, 21],\n  c,\n  [47, 8],\n  c,\n  [1299, 3],\n  c,\n  [2207, 3],\n  c,\n  [859, 3],\n  c,\n  [2280, 38],\n  c,\n  [2192, 4],\n  c,\n  [2191, 4],\n  c,\n  [1324, 11],\n  c,\n  [1658, 12],\n  c,\n  [2135, 22],\n  8,\n  22,\n  c,\n  [1948, 9],\n  6,\n  8,\n  c,\n  [974, 3],\n  c,\n  [1953, 10],\n  c,\n  [1848, 11],\n  c,\n  [587, 27],\n  4,\n  5,\n  c,\n  [205, 4],\n  10,\n  c,\n  [2403, 28],\n  c,\n  [197, 6],\n  c,\n  [1916, 56],\n  c,\n  [1934, 30],\n  c,\n  [20, 60],\n  c,\n  [1994, 22],\n  c,\n  [2016, 43],\n  c,\n  [2041, 34],\n  c,\n  [805, 50],\n  c,\n  [387, 3],\n  c,\n  [391, 3],\n  c,\n  [1924, 9],\n  c,\n  [697, 32],\n  150,\n  c,\n  [41, 42],\n  c,\n  [627, 4],\n  c,\n  [2865, 70],\n  c,\n  [549, 3],\n  c,\n  [856, 37],\n  c,\n  [1009, 45],\n  c,\n  [1106, 59],\n  c,\n  [59, 118],\n  c,\n  [2030, 56],\n  c,\n  [40, 56],\n  6,\n  4,\n  c,\n  [2640, 43],\n  s,\n  [80, 9, 1],\n  c,\n  [588, 3],\n  c,\n  [653, 60],\n  c,\n  [61, 120],\n  c,\n  [2629, 9],\n  c,\n  [475, 110]\n]),\n  type: u([\n  s,\n  [2, 21],\n  s,\n  [0, 13],\n  1,\n  c,\n  [35, 32],\n  c,\n  [15, 10],\n  s,\n  [2, 27],\n  c,\n  [45, 12],\n  c,\n  [35, 103],\n  c,\n  [3, 6],\n  c,\n  [5, 8],\n  c,\n  [52, 15],\n  c,\n  [69, 6],\n  c,\n  [76, 31],\n  c,\n  [92, 25],\n  c,\n  [55, 46],\n  c,\n  [338, 16],\n  c,\n  [314, 13],\n  s,\n  [2, 47],\n  s,\n  [0, 40],\n  c,\n  [43, 8],\n  c,\n  [73, 46],\n  c,\n  [491, 36],\n  c,\n  [333, 19],\n  c,\n  [409, 26],\n  c,\n  [142, 15],\n  c,\n  [97, 21],\n  c,\n  [26, 38],\n  c,\n  [35, 21],\n  c,\n  [253, 26],\n  c,\n  [329, 34],\n  s,\n  [2, 67],\n  c,\n  [112, 25],\n  c,\n  [25, 33],\n  c,\n  [51, 43],\n  c,\n  [146, 46],\n  c,\n  [576, 61],\n  s,\n  [2, 173],\n  c,\n  [777, 42],\n  c,\n  [1182, 34],\n  c,\n  [105, 50],\n  c,\n  [162, 65],\n  c,\n  [428, 23],\n  c,\n  [409, 35],\n  c,\n  [874, 32],\n  c,\n  [927, 19],\n  c,\n  [1006, 54],\n  c,\n  [42, 27],\n  c,\n  [576, 39],\n  c,\n  [74, 74],\n  c,\n  [40, 24],\n  c,\n  [1420, 3],\n  c,\n  [1389, 71],\n  c,\n  [794, 46],\n  c,\n  [34, 50],\n  c,\n  [1657, 13],\n  c,\n  [43, 29],\n  c,\n  [32, 31],\n  c,\n  [31, 30],\n  c,\n  [30, 59],\n  c,\n  [29, 115],\n  c,\n  [28, 55],\n  c,\n  [27, 53],\n  c,\n  [26, 69],\n  c,\n  [1357, 73],\n  c,\n  [623, 63],\n  c,\n  [918, 78],\n  c,\n  [922, 61],\n  c,\n  [1438, 53],\n  c,\n  [56, 33],\n  c,\n  [2037, 26],\n  c,\n  [902, 45],\n  c,\n  [314, 25],\n  c,\n  [1413, 8],\n  c,\n  [97, 20],\n  c,\n  [1822, 76],\n  c,\n  [116, 13],\n  c,\n  [200, 38],\n  s,\n  [2, 266],\n  c,\n  [865, 54],\n  c,\n  [48, 41],\n  c,\n  [89, 45],\n  c,\n  [2865, 60],\n  c,\n  [73, 33],\n  c,\n  [2165, 68],\n  c,\n  [1166, 59],\n  c,\n  [59, 105],\n  c,\n  [2030, 63],\n  c,\n  [938, 93],\n  c,\n  [2875, 93],\n  c,\n  [61, 121],\n  c,\n  [475, 88]\n]),\n  state: u([\n  1,\n  s,\n  [6, 4, 1],\n  25,\n  31,\n  26,\n  10,\n  11,\n  2,\n  s,\n  [4, 6, 1],\n  c,\n  [12, 5],\n  36,\n  5,\n  44,\n  39,\n  42,\n  37,\n  41,\n  40,\n  47,\n  c,\n  [16, 7],\n  48,\n  c,\n  [8, 7],\n  49,\n  c,\n  [8, 7],\n  50,\n  c,\n  [8, 7],\n  51,\n  54,\n  55,\n  44,\n  60,\n  65,\n  64,\n  63,\n  44,\n  66,\n  41,\n  40,\n  71,\n  25,\n  31,\n  68,\n  69,\n  70,\n  26,\n  72,\n  75,\n  73,\n  74,\n  97,\n  98,\n  107,\n  99,\n  89,\n  83,\n  81,\n  86,\n  s,\n  [115, 6, -1],\n  108,\n  101,\n  96,\n  88,\n  82,\n  80,\n  78,\n  77,\n  128,\n  c,\n  [22, 19],\n  142,\n  132,\n  119,\n  121,\n  c,\n  [76, 7],\n  120,\n  122,\n  123,\n  117,\n  118,\n  s,\n  [124, 4, 1],\n  44,\n  143,\n  144,\n  41,\n  40,\n  c,\n  [67, 6],\n  148,\n  c,\n  [45, 12],\n  147,\n  145,\n  153,\n  c,\n  [43, 7],\n  149,\n  151,\n  152,\n  155,\n  154,\n  c,\n  [112, 3],\n  157,\n  c,\n  [112, 4],\n  c,\n  [8, 3],\n  159,\n  c,\n  [7, 3],\n  44,\n  160,\n  161,\n  162,\n  c,\n  [133, 5],\n  163,\n  c,\n  [19, 5],\n  164,\n  c,\n  [137, 3],\n  168,\n  c,\n  [137, 22],\n  170,\n  169,\n  171,\n  c,\n  [24, 6],\n  191,\n  86,\n  c,\n  [8, 6],\n  193,\n  c,\n  [8, 7],\n  148,\n  86,\n  194,\n  c,\n  [9, 6],\n  195,\n  86,\n  199,\n  c,\n  [58, 20],\n  142,\n  200,\n  c,\n  [89, 3],\n  202,\n  26,\n  72,\n  201,\n  c,\n  [202, 34],\n  219,\n  c,\n  [201, 5],\n  39,\n  42,\n  c,\n  [202, 23],\n  221,\n  c,\n  [66, 22],\n  228,\n  s,\n  [122, 6, 1],\n  230,\n  c,\n  [125, 21],\n  234,\n  44,\n  238,\n  41,\n  240,\n  239,\n  241,\n  c,\n  [239, 7],\n  75,\n  248,\n  c,\n  [88, 20],\n  249,\n  c,\n  [58, 20],\n  254,\n  c,\n  [79, 21],\n  255,\n  c,\n  [64, 17],\n  256,\n  c,\n  [40, 21],\n  257,\n  c,\n  [22, 6],\n  259,\n  c,\n  [23, 14],\n  260,\n  261,\n  262,\n  c,\n  [290, 22],\n  c,\n  [312, 28],\n  263,\n  c,\n  [115, 16],\n  264,\n  c,\n  [17, 15],\n  265,\n  269,\n  268,\n  241,\n  c,\n  [19, 14],\n  271,\n  c,\n  [15, 13],\n  272,\n  c,\n  [14, 12],\n  273,\n  c,\n  [13, 12],\n  274,\n  c,\n  [13, 11],\n  275,\n  c,\n  [12, 11],\n  276,\n  c,\n  [12, 11],\n  277,\n  c,\n  [12, 11],\n  278,\n  c,\n  [12, 10],\n  279,\n  c,\n  [11, 10],\n  280,\n  c,\n  [11, 9],\n  281,\n  c,\n  [10, 9],\n  282,\n  c,\n  [10, 8],\n  283,\n  c,\n  [9, 8],\n  284,\n  c,\n  [9, 8],\n  285,\n  c,\n  [454, 22],\n  286,\n  s,\n  [122, 7, 1],\n  c,\n  [29, 21],\n  288,\n  c,\n  [29, 6],\n  c,\n  [295, 20],\n  289,\n  c,\n  [316, 21],\n  290,\n  c,\n  [22, 21],\n  291,\n  c,\n  [22, 21],\n  292,\n  c,\n  [22, 21],\n  132,\n  295,\n  c,\n  [665, 8],\n  294,\n  c,\n  [833, 8],\n  299,\n  44,\n  60,\n  300,\n  44,\n  c,\n  [13, 8],\n  66,\n  41,\n  240,\n  305,\n  151,\n  152,\n  303,\n  c,\n  [378, 15],\n  c,\n  [593, 6],\n  307,\n  44,\n  308,\n  c,\n  [854, 3],\n  c,\n  [621, 8],\n  c,\n  [841, 15],\n  311,\n  c,\n  [50, 8],\n  317,\n  300,\n  c,\n  [76, 8],\n  269,\n  c,\n  [74, 5],\n  c,\n  [251, 22],\n  318,\n  c,\n  [251, 26],\n  142,\n  132,\n  323,\n  c,\n  [23, 22],\n  324,\n  c,\n  [149, 20],\n  326,\n  c,\n  [110, 8],\n  328,\n  151,\n  152,\n  c,\n  [32, 19],\n  332,\n  c,\n  [75, 20],\n  333,\n  c,\n  [148, 22],\n  334,\n  c,\n  [428, 28],\n  335,\n  c,\n  [29, 28],\n  336,\n  c,\n  [206, 27],\n  337,\n  c,\n  [22, 21],\n  339,\n  c,\n  [22, 21],\n  341,\n  c,\n  [95, 22],\n  346,\n  c,\n  [124, 28],\n  348,\n  c,\n  [29, 28],\n  350,\n  c,\n  [29, 28],\n  352,\n  c,\n  [29, 28],\n  353,\n  c,\n  [29, 6]\n]),\n  mode: u([\n  s,\n  [1, 46],\n  s,\n  [2, 7],\n  c,\n  [27, 101],\n  c,\n  [31, 5],\n  1,\n  c,\n  [27, 7],\n  c,\n  [9, 3],\n  c,\n  [43, 8],\n  c,\n  [18, 5],\n  c,\n  [12, 8],\n  s,\n  [2, 20],\n  c,\n  [100, 22],\n  c,\n  [44, 38],\n  s,\n  [1, 57],\n  c,\n  [96, 6],\n  c,\n  [327, 43],\n  c,\n  [218, 8],\n  c,\n  [369, 35],\n  c,\n  [20, 35],\n  c,\n  [299, 11],\n  c,\n  [352, 20],\n  c,\n  [317, 10],\n  c,\n  [250, 19],\n  c,\n  [24, 7],\n  c,\n  [67, 6],\n  c,\n  [289, 19],\n  c,\n  [310, 86],\n  c,\n  [146, 12],\n  c,\n  [412, 22],\n  c,\n  [440, 60],\n  c,\n  [236, 15],\n  c,\n  [65, 20],\n  c,\n  [8, 22],\n  c,\n  [34, 18],\n  c,\n  [30, 22],\n  c,\n  [87, 7],\n  c,\n  [55, 20],\n  c,\n  [271, 60],\n  c,\n  [246, 30],\n  c,\n  [688, 75],\n  c,\n  [561, 7],\n  c,\n  [502, 7],\n  s,\n  [1, 217],\n  c,\n  [219, 219],\n  s,\n  [1, 232],\n  c,\n  [680, 7],\n  c,\n  [458, 70],\n  c,\n  [1605, 13],\n  c,\n  [1062, 14],\n  c,\n  [1676, 26],\n  c,\n  [123, 26],\n  c,\n  [1116, 48],\n  c,\n  [1134, 38],\n  c,\n  [20, 60],\n  c,\n  [1194, 23],\n  c,\n  [1216, 42],\n  c,\n  [1241, 80],\n  c,\n  [2006, 28],\n  c,\n  [690, 216],\n  s,\n  [2, 42],\n  c,\n  [538, 11],\n  s,\n  [1, 155]\n]),\n  goto: u([\n  3,\n  s,\n  [12, 13, 1],\n  27,\n  33,\n  34,\n  32,\n  28,\n  29,\n  30,\n  35,\n  c,\n  [21, 20],\n  45,\n  43,\n  38,\n  46,\n  s,\n  [88, 7],\n  c,\n  [31, 20],\n  s,\n  [90, 7],\n  c,\n  [27, 20],\n  s,\n  [92, 7],\n  c,\n  [27, 20],\n  s,\n  [94, 7],\n  c,\n  [27, 20],\n  52,\n  46,\n  53,\n  46,\n  98,\n  56,\n  98,\n  57,\n  59,\n  58,\n  45,\n  46,\n  62,\n  144,\n  61,\n  s,\n  [144, 4],\n  s,\n  [151, 4],\n  43,\n  151,\n  28,\n  45,\n  43,\n  46,\n  s,\n  [118, 6],\n  67,\n  s,\n  [118, 21],\n  c,\n  [74, 15],\n  46,\n  s,\n  [135, 6],\n  76,\n  s,\n  [135, 21],\n  100,\n  s,\n  [90, 6, 1],\n  79,\n  46,\n  s,\n  [102, 5, 1],\n  109,\n  84,\n  85,\n  87,\n  c,\n  [18, 7],\n  131,\n  57,\n  116,\n  c,\n  [20, 10],\n  c,\n  [159, 20],\n  129,\n  130,\n  s,\n  [133, 9, 1],\n  c,\n  [144, 3],\n  62,\n  143,\n  61,\n  s,\n  [143, 4],\n  100,\n  146,\n  c,\n  [62, 6],\n  c,\n  [59, 10],\n  150,\n  c,\n  [60, 20],\n  s,\n  [152, 4],\n  43,\n  152,\n  28,\n  156,\n  c,\n  [25, 15],\n  158,\n  c,\n  [16, 15],\n  c,\n  [88, 3],\n  s,\n  [125, 5],\n  c,\n  [23, 15],\n  s,\n  [127, 5],\n  c,\n  [20, 15],\n  166,\n  165,\n  138,\n  167,\n  138,\n  46,\n  c,\n  [206, 18],\n  s,\n  [38, 15],\n  172,\n  s,\n  [38, 10],\n  s,\n  [173, 10, 1],\n  s,\n  [68, 3],\n  183,\n  s,\n  [68, 3],\n  184,\n  186,\n  26,\n  185,\n  26,\n  187,\n  s,\n  [26, 16],\n  188,\n  189,\n  190,\n  s,\n  [26, 18],\n  192,\n  c,\n  [230, 16],\n  c,\n  [17, 17],\n  c,\n  [138, 7],\n  c,\n  [17, 10],\n  196,\n  c,\n  [17, 16],\n  s,\n  [66, 7],\n  197,\n  66,\n  s,\n  [64, 3],\n  198,\n  s,\n  [64, 6],\n  s,\n  [14, 21],\n  109,\n  s,\n  [14, 21],\n  c,\n  [96, 17],\n  c,\n  [272, 15],\n  s,\n  [62, 3],\n  203,\n  s,\n  [62, 7],\n  s,\n  [60, 3],\n  204,\n  s,\n  [60, 8],\n  s,\n  [58, 10],\n  205,\n  206,\n  58,\n  58,\n  s,\n  [55, 4],\n  207,\n  208,\n  s,\n  [55, 6],\n  209,\n  210,\n  s,\n  [55, 4],\n  s,\n  [50, 12],\n  211,\n  212,\n  s,\n  [50, 6],\n  s,\n  [47, 4],\n  213,\n  214,\n  s,\n  [47, 16],\n  s,\n  [44, 4],\n  215,\n  44,\n  44,\n  216,\n  217,\n  s,\n  [44, 16],\n  c,\n  [576, 9],\n  218,\n  c,\n  [576, 43],\n  38,\n  46,\n  s,\n  [12, 15],\n  220,\n  s,\n  [12, 23],\n  c,\n  [248, 17],\n  222,\n  224,\n  223,\n  225,\n  226,\n  227,\n  c,\n  [117, 9],\n  c,\n  [25, 10],\n  c,\n  [96, 11],\n  229,\n  46,\n  231,\n  232,\n  c,\n  [34, 7],\n  233,\n  c,\n  [33, 10],\n  c,\n  [860, 3],\n  235,\n  236,\n  157,\n  237,\n  242,\n  163,\n  243,\n  163,\n  43,\n  46,\n  244,\n  c,\n  [160, 15],\n  246,\n  245,\n  247,\n  c,\n  [590, 8],\n  c,\n  [50, 10],\n  251,\n  250,\n  253,\n  252,\n  c,\n  [21, 17],\n  c,\n  [17, 52],\n  258,\n  c,\n  [18, 16],\n  46,\n  c,\n  [109, 18],\n  c,\n  [482, 32],\n  c,\n  [49, 34],\n  266,\n  224,\n  267,\n  270,\n  164,\n  243,\n  43,\n  c,\n  [178, 69],\n  c,\n  [17, 193],\n  c,\n  [539, 23],\n  287,\n  c,\n  [31, 30],\n  c,\n  [129, 68],\n  293,\n  c,\n  [99, 8],\n  c,\n  [784, 30],\n  296,\n  224,\n  297,\n  c,\n  [23, 20],\n  298,\n  242,\n  166,\n  243,\n  166,\n  46,\n  302,\n  167,\n  301,\n  167,\n  242,\n  304,\n  243,\n  43,\n  46,\n  c,\n  [35, 20],\n  100,\n  306,\n  c,\n  [115, 16],\n  c,\n  [1337, 3],\n  309,\n  c,\n  [1293, 9],\n  310,\n  c,\n  [24, 10],\n  224,\n  312,\n  s,\n  [67, 7],\n  197,\n  67,\n  313,\n  224,\n  314,\n  315,\n  316,\n  s,\n  [65, 3],\n  198,\n  s,\n  [65, 6],\n  s,\n  [63, 3],\n  203,\n  s,\n  [63, 7],\n  c,\n  [193, 17],\n  270,\n  166,\n  243,\n  270,\n  c,\n  [124, 3],\n  c,\n  [123, 20],\n  s,\n  [61, 3],\n  204,\n  s,\n  [61, 8],\n  s,\n  [59, 10],\n  205,\n  206,\n  59,\n  59,\n  s,\n  [56, 4],\n  207,\n  208,\n  s,\n  [56, 6],\n  209,\n  210,\n  s,\n  [56, 4],\n  s,\n  [57, 4],\n  207,\n  208,\n  s,\n  [57, 6],\n  209,\n  210,\n  s,\n  [57, 4],\n  s,\n  [51, 12],\n  211,\n  212,\n  s,\n  [51, 6],\n  s,\n  [52, 12],\n  211,\n  212,\n  s,\n  [52, 6],\n  s,\n  [53, 12],\n  211,\n  212,\n  s,\n  [53, 6],\n  s,\n  [54, 12],\n  211,\n  212,\n  s,\n  [54, 6],\n  s,\n  [48, 4],\n  213,\n  214,\n  s,\n  [48, 16],\n  s,\n  [49, 4],\n  213,\n  214,\n  s,\n  [49, 16],\n  s,\n  [45, 4],\n  215,\n  45,\n  45,\n  216,\n  217,\n  s,\n  [45, 16],\n  s,\n  [46, 4],\n  215,\n  46,\n  46,\n  216,\n  217,\n  s,\n  [46, 16],\n  c,\n  [554, 30],\n  319,\n  224,\n  320,\n  224,\n  321,\n  224,\n  322,\n  c,\n  [492, 18],\n  c,\n  [18, 18],\n  302,\n  168,\n  301,\n  168,\n  100,\n  325,\n  c,\n  [358, 16],\n  327,\n  c,\n  [352, 20],\n  329,\n  330,\n  331,\n  c,\n  [738, 64],\n  c,\n  [30, 67],\n  c,\n  [107, 11],\n  338,\n  c,\n  [18, 17],\n  340,\n  c,\n  [18, 16],\n  342,\n  343,\n  s,\n  [200, 43],\n  344,\n  s,\n  [200, 8],\n  345,\n  224,\n  c,\n  [139, 30],\n  347,\n  c,\n  [32, 31],\n  349,\n  c,\n  [32, 31],\n  351,\n  c,\n  [264, 60]\n])\n}),\ndefaultActions: bda({\n  idx: u([\n  s,\n  [3, 4, 1],\n  s,\n  [12, 19, 1],\n  s,\n  [33, 4, 1],\n  38,\n  42,\n  44,\n  s,\n  [46, 5, 1],\n  55,\n  58,\n  64,\n  65,\n  69,\n  74,\n  77,\n  78,\n  80,\n  s,\n  [89, 7, 1],\n  97,\n  98,\n  s,\n  [102, 6, 1],\n  109,\n  115,\n  116,\n  118,\n  119,\n  120,\n  s,\n  [122, 6, 1],\n  131,\n  142,\n  143,\n  146,\n  147,\n  s,\n  [148, 4, 2],\n  155,\n  156,\n  158,\n  159,\n  s,\n  [161, 5, 1],\n  170,\n  s,\n  [172, 11, 1],\n  189,\n  190,\n  191,\n  193,\n  194,\n  195,\n  199,\n  218,\n  219,\n  223,\n  231,\n  232,\n  233,\n  235,\n  236,\n  238,\n  239,\n  244,\n  245,\n  s,\n  [247, 4, 1],\n  252,\n  254,\n  258,\n  260,\n  261,\n  262,\n  266,\n  268,\n  s,\n  [283, 4, 1],\n  288,\n  289,\n  s,\n  [296, 4, 1],\n  304,\n  306,\n  s,\n  [308, 4, 1],\n  313,\n  314,\n  316,\n  317,\n  318,\n  325,\n  327,\n  s,\n  [329, 5, 1],\n  335,\n  336,\n  342,\n  343,\n  346,\n  348,\n  s,\n  [350, 4, 1]\n]),\n  goto: u([\n  2,\n  214,\n  216,\n  217,\n  s,\n  [100, 16, 1],\n  140,\n  141,\n  142,\n  119,\n  120,\n  1,\n  215,\n  86,\n  96,\n  145,\n  3,\n  s,\n  [89, 4, 2],\n  218,\n  87,\n  153,\n  155,\n  121,\n  136,\n  99,\n  178,\n  70,\n  16,\n  s,\n  [32, 6, 1],\n  12,\n  13,\n  s,\n  [4, 5, 1],\n  10,\n  9,\n  40,\n  192,\n  194,\n  196,\n  197,\n  s,\n  [183, 6, 1],\n  198,\n  83,\n  97,\n  148,\n  85,\n  38,\n  150,\n  159,\n  154,\n  156,\n  146,\n  117,\n  122,\n  128,\n  130,\n  124,\n  126,\n  131,\n  181,\n  s,\n  [72, 11, 1],\n  22,\n  23,\n  s,\n  [27, 4, 1],\n  11,\n  193,\n  195,\n  199,\n  210,\n  211,\n  212,\n  147,\n  149,\n  161,\n  162,\n  116,\n  123,\n  133,\n  137,\n  139,\n  132,\n  179,\n  71,\n  18,\n  24,\n  20,\n  21,\n  15,\n  165,\n  41,\n  42,\n  43,\n  189,\n  191,\n  84,\n  209,\n  213,\n  158,\n  160,\n  174,\n  170,\n  129,\n  134,\n  180,\n  182,\n  17,\n  19,\n  31,\n  39,\n  190,\n  172,\n  176,\n  169,\n  175,\n  171,\n  69,\n  25,\n  202,\n  203,\n  173,\n  177,\n  205,\n  207,\n  201,\n  204,\n  206,\n  208\n])\n}),\nparseError: function parseError(str, hash, ExceptionClass) {\n    if (hash.recoverable) {\n        if (typeof this.trace === 'function') {\n            this.trace(str);\n        }\n        hash.destroy();             // destroy... well, *almost*!\n    } else {\n        if (typeof this.trace === 'function') {\n            this.trace(str);\n        }\n        if (!ExceptionClass) {\n            ExceptionClass = this.JisonParserError;\n        }\n        throw new ExceptionClass(str, hash);\n    }\n},\nparse: function parse(input) {\n    var self = this;\n    var stack = new Array(128);         // token stack: stores token which leads to state at the same index (column storage)\n    var sstack = new Array(128);        // state stack: stores states (column storage)\n\n    var vstack = new Array(128);        // semantic value stack\n    var lstack = new Array(128);        // location stack\n    var table = this.table;\n    var sp = 0;                         // 'stack pointer': index into the stacks\n    var yyloc;\n    var yytext;\n    \n\n\n    var symbol = 0;\n\n\n\n    var TERROR = this.TERROR;\n    var EOF = this.EOF;\n    var ERROR_RECOVERY_TOKEN_DISCARD_COUNT = (this.options.errorRecoveryTokenDiscardCount | 0) || 3;\n    var NO_ACTION = [0, 354 /* === table.length :: ensures that anyone using this new state will fail dramatically! */];\n\n    var lexer;\n    if (this.__lexer__) {\n        lexer = this.__lexer__;\n    } else {\n        lexer = this.__lexer__ = Object.create(this.lexer);\n    }\n\n    var sharedState_yy = {\n        parseError: undefined,\n        quoteName: undefined,\n        lexer: undefined,\n        parser: undefined,\n        pre_parse: undefined,\n        post_parse: undefined,\n        pre_lex: undefined,\n        post_lex: undefined      // WARNING: must be written this way for the code expanders to work correctly in both ES5 and ES6 modes!\n    };\n\n    var ASSERT;\n    if (typeof assert !== 'function') {\n        ASSERT = function JisonAssert(cond, msg) {\n            if (!cond) {\n                throw new Error('assertion failed: ' + (msg || '***'));\n            }\n        };\n    } else {\n        ASSERT = assert;\n    }\n\n    this.yyGetSharedState = function yyGetSharedState() {\n        return sharedState_yy;\n    };\n\n\n    // shallow clone objects, straight copy of simple `src` values\n    // e.g. `lexer.yytext` MAY be a complex value object,\n    // rather than a simple string/value.\n    function shallow_copy(src) {\n        if (typeof src === 'object') {\n            var dst = {};\n            for (var k in src) {\n                if (Object.prototype.hasOwnProperty.call(src, k)) {\n                    dst[k] = src[k];\n                }\n            }\n            return dst;\n        }\n        return src;\n    }\n    function shallow_copy_noclobber(dst, src) {\n        for (var k in src) {\n            if (typeof dst[k] === 'undefined' && Object.prototype.hasOwnProperty.call(src, k)) {\n                dst[k] = src[k];\n            }\n        }\n    }\n    function copy_yylloc(loc) {\n        var rv = shallow_copy(loc);\n        if (rv && rv.range) {\n            rv.range = rv.range.slice(0);\n        }\n        return rv;\n    }\n\n    // copy state\n    shallow_copy_noclobber(sharedState_yy, this.yy);\n\n    sharedState_yy.lexer = lexer;\n    sharedState_yy.parser = this;\n\n\n\n\n\n\n    // Does the shared state override the default `parseError` that already comes with this instance?\n    if (typeof sharedState_yy.parseError === 'function') {\n        this.parseError = function parseErrorAlt(str, hash, ExceptionClass) {\n            if (!ExceptionClass) {\n                ExceptionClass = this.JisonParserError;\n            }\n            return sharedState_yy.parseError.call(this, str, hash, ExceptionClass);\n        };\n    } else {\n        this.parseError = this.originalParseError;\n    }\n\n    // Does the shared state override the default `quoteName` that already comes with this instance?\n    if (typeof sharedState_yy.quoteName === 'function') {\n        this.quoteName = function quoteNameAlt(id_str) {\n            return sharedState_yy.quoteName.call(this, id_str);\n        };\n    } else {\n        this.quoteName = this.originalQuoteName;\n    }\n\n    // set up the cleanup function; make it an API so that external code can re-use this one in case of\n    // calamities or when the `%options no-try-catch` option has been specified for the grammar, in which\n    // case this parse() API method doesn't come with a `finally { ... }` block any more!\n    //\n    // NOTE: as this API uses parse() as a closure, it MUST be set again on every parse() invocation,\n    //       or else your `sharedState`, etc. references will be *wrong*!\n    this.cleanupAfterParse = function parser_cleanupAfterParse(resultValue, invoke_post_methods, do_not_nuke_errorinfos) {\n        var rv;\n\n        if (invoke_post_methods) {\n            var hash;\n\n            if (sharedState_yy.post_parse || this.post_parse) {\n                // create an error hash info instance: we re-use this API in a **non-error situation**\n                // as this one delivers all parser internals ready for access by userland code.\n                hash = this.constructParseErrorInfo(null /* no error! */, null /* no exception! */, null, false);\n            }\n\n            if (sharedState_yy.post_parse) {\n                rv = sharedState_yy.post_parse.call(this, sharedState_yy, resultValue, hash);\n                if (typeof rv !== 'undefined') resultValue = rv;\n            }\n            if (this.post_parse) {\n                rv = this.post_parse.call(this, sharedState_yy, resultValue, hash);\n                if (typeof rv !== 'undefined') resultValue = rv;\n            }\n\n            // cleanup:\n            if (hash && hash.destroy) {\n                hash.destroy();\n            }\n        }\n\n        if (this.__reentrant_call_depth > 1) return resultValue;        // do not (yet) kill the sharedState when this is a reentrant run.\n\n        // clean up the lingering lexer structures as well:\n        if (lexer.cleanupAfterLex) {\n            lexer.cleanupAfterLex(do_not_nuke_errorinfos);\n        }\n\n        // prevent lingering circular references from causing memory leaks:\n        if (sharedState_yy) {\n            sharedState_yy.lexer = undefined;\n            sharedState_yy.parser = undefined;\n            if (lexer.yy === sharedState_yy) {\n                lexer.yy = undefined;\n            }\n        }\n        sharedState_yy = undefined;\n        this.parseError = this.originalParseError;\n        this.quoteName = this.originalQuoteName;\n\n        // nuke the vstack[] array at least as that one will still reference obsoleted user values.\n        // To be safe, we nuke the other internal stack columns as well...\n        stack.length = 0;               // fastest way to nuke an array without overly bothering the GC\n        sstack.length = 0;\n        lstack.length = 0;\n        vstack.length = 0;\n        sp = 0;\n\n        // nuke the error hash info instances created during this run.\n        // Userland code must COPY any data/references\n        // in the error hash instance(s) it is more permanently interested in.\n        if (!do_not_nuke_errorinfos) {\n            for (var i = this.__error_infos.length - 1; i >= 0; i--) {\n                var el = this.__error_infos[i];\n                if (el && typeof el.destroy === 'function') {\n                    el.destroy();\n                }\n            }\n            this.__error_infos.length = 0;\n\n\n        }\n\n        return resultValue;\n    };\n\n    // merge yylloc info into a new yylloc instance.\n    //\n    // `first_index` and `last_index` MAY be UNDEFINED/NULL or these are indexes into the `lstack[]` location stack array.\n    //\n    // `first_yylloc` and `last_yylloc` MAY be UNDEFINED/NULL or explicit (custom or regular) `yylloc` instances, in which\n    // case these override the corresponding first/last indexes.\n    //\n    // `dont_look_back` is an optional flag (default: FALSE), which instructs this merge operation NOT to search\n    // through the parse location stack for a location, which would otherwise be used to construct the new (epsilon!)\n    // yylloc info.\n    //\n    // Note: epsilon rule's yylloc situation is detected by passing both `first_index` and `first_yylloc` as UNDEFINED/NULL.\n    this.yyMergeLocationInfo = function parser_yyMergeLocationInfo(first_index, last_index, first_yylloc, last_yylloc, dont_look_back) {\n        var i1 = first_index | 0,\n            i2 = last_index | 0;\n        var l1 = first_yylloc,\n            l2 = last_yylloc;\n        var rv;\n\n        // rules:\n        // - first/last yylloc entries override first/last indexes\n\n        if (!l1) {\n            if (first_index != null) {\n                for (var i = i1; i <= i2; i++) {\n                    l1 = lstack[i];\n                    if (l1) {\n                        break;\n                    }\n                }\n            }\n        }\n\n        if (!l2) {\n            if (last_index != null) {\n                for (var i = i2; i >= i1; i--) {\n                    l2 = lstack[i];\n                    if (l2) {\n                        break;\n                    }\n                }\n            }\n        }\n\n        // - detect if an epsilon rule is being processed and act accordingly:\n        if (!l1 && first_index == null) {\n            // epsilon rule span merger. With optional look-ahead in l2.\n            if (!dont_look_back) {\n                for (var i = (i1 || sp) - 1; i >= 0; i--) {\n                    l1 = lstack[i];\n                    if (l1) {\n                        break;\n                    }\n                }\n            }\n            if (!l1) {\n                if (!l2) {\n                    // when we still don't have any valid yylloc info, we're looking at an epsilon rule\n                    // without look-ahead and no preceding terms and/or `dont_look_back` set:\n                    // in that case we ca do nothing but return NULL/UNDEFINED:\n                    return undefined;\n                } else {\n                    // shallow-copy L2: after all, we MAY be looking\n                    // at unconventional yylloc info objects...\n                    rv = shallow_copy(l2);\n                    if (rv.range) {\n                        // shallow copy the yylloc ranges info to prevent us from modifying the original arguments' entries:\n                        rv.range = rv.range.slice(0);\n                    }\n                    return rv;\n                }\n            } else {\n                // shallow-copy L1, then adjust first col/row 1 column past the end.\n                rv = shallow_copy(l1);\n                rv.first_line = rv.last_line;\n                rv.first_column = rv.last_column;\n                if (rv.range) {\n                    // shallow copy the yylloc ranges info to prevent us from modifying the original arguments' entries:\n                    rv.range = rv.range.slice(0);\n                    rv.range[0] = rv.range[1];\n                }\n\n                if (l2) {\n                    // shallow-mixin L2, then adjust last col/row accordingly.\n                    shallow_copy_noclobber(rv, l2);\n                    rv.last_line = l2.last_line;\n                    rv.last_column = l2.last_column;\n                    if (rv.range && l2.range) {\n                        rv.range[1] = l2.range[1];\n                    }\n                }\n                return rv;\n            }\n        }\n\n        if (!l1) {\n            l1 = l2;\n            l2 = null;\n        }\n        if (!l1) {\n            return undefined;\n        }\n\n        // shallow-copy L1|L2, before we try to adjust the yylloc values: after all, we MAY be looking\n        // at unconventional yylloc info objects...\n        rv = shallow_copy(l1);\n\n        // first_line: ...,\n        // first_column: ...,\n        // last_line: ...,\n        // last_column: ...,\n        if (rv.range) {\n            // shallow copy the yylloc ranges info to prevent us from modifying the original arguments' entries:\n            rv.range = rv.range.slice(0);\n        }\n\n        if (l2) {\n            shallow_copy_noclobber(rv, l2);\n            rv.last_line = l2.last_line;\n            rv.last_column = l2.last_column;\n            if (rv.range && l2.range) {\n                rv.range[1] = l2.range[1];\n            }\n        }\n\n        return rv;\n    };\n\n    // NOTE: as this API uses parse() as a closure, it MUST be set again on every parse() invocation,\n    //       or else your `lexer`, `sharedState`, etc. references will be *wrong*!\n    this.constructParseErrorInfo = function parser_constructParseErrorInfo(msg, ex, expected, recoverable) {\n        var pei = {\n            errStr: msg,\n            exception: ex,\n            text: lexer.match,\n            value: lexer.yytext,\n            token: this.describeSymbol(symbol) || symbol,\n            token_id: symbol,\n            line: lexer.yylineno,\n            loc: copy_yylloc(lexer.yylloc),\n            expected: expected,\n            recoverable: recoverable,\n            state: state,\n            action: action,\n            new_state: newState,\n            symbol_stack: stack,\n            state_stack: sstack,\n            value_stack: vstack,\n            location_stack: lstack,\n            stack_pointer: sp,\n            yy: sharedState_yy,\n            lexer: lexer,\n            parser: this,\n\n            // and make sure the error info doesn't stay due to potential\n            // ref cycle via userland code manipulations.\n            // These would otherwise all be memory leak opportunities!\n            //\n            // Note that only array and object references are nuked as those\n            // constitute the set of elements which can produce a cyclic ref.\n            // The rest of the members is kept intact as they are harmless.\n            destroy: function destructParseErrorInfo() {\n                // remove cyclic references added to error info:\n                // info.yy = null;\n                // info.lexer = null;\n                // info.value = null;\n                // info.value_stack = null;\n                // ...\n                var rec = !!this.recoverable;\n                for (var key in this) {\n                    if (this.hasOwnProperty(key) && typeof key === 'object') {\n                        this[key] = undefined;\n                    }\n                }\n                this.recoverable = rec;\n            }\n        };\n        // track this instance so we can `destroy()` it once we deem it superfluous and ready for garbage collection!\n        this.__error_infos.push(pei);\n        return pei;\n    };\n\n\n\n\n\n\n\n\n\n\n\n\n\n    function getNonTerminalFromCode(symbol) {\n        var tokenName = self.getSymbolName(symbol);\n        if (!tokenName) {\n            tokenName = symbol;\n        }\n        return tokenName;\n    }\n\n\n    function stdLex() {\n        var token = lexer.lex();\n        // if token isn't its numeric value, convert\n        if (typeof token !== 'number') {\n            token = self.symbols_[token] || token;\n        }\n\n        return token || EOF;\n    }\n\n    function fastLex() {\n        var token = lexer.fastLex();\n        // if token isn't its numeric value, convert\n        if (typeof token !== 'number') {\n            token = self.symbols_[token] || token;\n        }\n\n        return token || EOF;\n    }\n\n    var lex = stdLex;\n\n\n    var state, action, r, t;\n    var yyval = {\n        $: true,\n        _$: undefined,\n        yy: sharedState_yy\n    };\n    var p;\n    var yyrulelen;\n    var this_production;\n    var newState;\n    var retval = false;\n\n\n    try {\n        this.__reentrant_call_depth++;\n\n        lexer.setInput(input, sharedState_yy);\n\n        // NOTE: we *assume* no lexer pre/post handlers are set up *after* \n        // this initial `setInput()` call: hence we can now check and decide\n        // whether we'll go with the standard, slower, lex() API or the\n        // `fast_lex()` one:\n        if (typeof lexer.canIUse === 'function') {\n            var lexerInfo = lexer.canIUse();\n            if (lexerInfo.fastLex && typeof fastLex === 'function') {\n                lex = fastLex;\n            }\n        } \n\n        yyloc = lexer.yylloc;\n        lstack[sp] = yyloc;\n        vstack[sp] = null;\n        sstack[sp] = 0;\n        stack[sp] = 0;\n        ++sp;\n\n        yytext = lexer.yytext;\n\n\n\n        if (this.pre_parse) {\n            this.pre_parse.call(this, sharedState_yy);\n        }\n        if (sharedState_yy.pre_parse) {\n            sharedState_yy.pre_parse.call(this, sharedState_yy);\n        }\n\n        newState = sstack[sp - 1];\n        for (;;) {\n            // retrieve state number from top of stack\n            state = newState;               // sstack[sp - 1];\n\n            // use default actions if available\n            if (this.defaultActions[state]) {\n                action = 2;\n                newState = this.defaultActions[state];\n            } else {\n                // The single `==` condition below covers both these `===` comparisons in a single\n                // operation:\n                //\n                //     if (symbol === null || typeof symbol === 'undefined') ...\n                if (!symbol) {\n                    symbol = lex();\n                }\n                // read action for current state and first input\n                t = (table[state] && table[state][symbol]) || NO_ACTION;\n                newState = t[1];\n                action = t[0];\n\n\n\n\n\n\n\n\n\n\n\n                // handle parse error\n                if (!action) {\n                    var errStr;\n                    var errSymbolDescr = (this.describeSymbol(symbol) || symbol);\n                    var expected = this.collect_expected_token_set(state);\n\n                    // Report error\n                    if (typeof lexer.yylineno === 'number') {\n                        errStr = 'Parse error on line ' + (lexer.yylineno + 1) + ': ';\n                    } else {\n                        errStr = 'Parse error: ';\n                    }\n                    if (typeof lexer.showPosition === 'function') {\n                        errStr += '\\n' + lexer.showPosition(79 - 10, 10) + '\\n';\n                    }\n                    if (expected.length) {\n                        errStr += 'Expecting ' + expected.join(', ') + ', got unexpected ' + errSymbolDescr;\n                    } else {\n                        errStr += 'Unexpected ' + errSymbolDescr;\n                    }\n                    // we cannot recover from the error!\n                    p = this.constructParseErrorInfo(errStr, null, expected, false);\n                    r = this.parseError(p.errStr, p, this.JisonParserError);\n                    if (typeof r !== 'undefined') {\n                        retval = r;\n                    }\n                    break;\n                }\n\n\n            }\n\n\n\n\n\n\n\n\n\n\n            switch (action) {\n            // catch misc. parse failures:\n            default:\n                // this shouldn't happen, unless resolve defaults are off\n                if (action instanceof Array) {\n                    p = this.constructParseErrorInfo('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol, null, null, false);\n                    r = this.parseError(p.errStr, p, this.JisonParserError);\n                    if (typeof r !== 'undefined') {\n                        retval = r;\n                    }\n                    break;\n                }\n                // Another case of better safe than sorry: in case state transitions come out of another error recovery process\n                // or a buggy LUT (LookUp Table):\n                p = this.constructParseErrorInfo('Parsing halted. No viable error recovery approach available due to internal system failure.', null, null, false);\n                r = this.parseError(p.errStr, p, this.JisonParserError);\n                if (typeof r !== 'undefined') {\n                    retval = r;\n                }\n                break;\n\n            // shift:\n            case 1:\n                stack[sp] = symbol;\n                vstack[sp] = lexer.yytext;\n                lstack[sp] = copy_yylloc(lexer.yylloc);\n                sstack[sp] = newState; // push state\n\n                ++sp;\n                symbol = 0;\n\n\n\n\n                // Pick up the lexer details for the current symbol as that one is not 'look-ahead' any more:\n\n                yytext = lexer.yytext;\n\n                yyloc = lexer.yylloc;\n                continue;\n\n            // reduce:\n            case 2:\n\n\n\n                this_production = this.productions_[newState - 1];  // `this.productions_[]` is zero-based indexed while states start from 1 upwards...\n                yyrulelen = this_production[1];\n\n\n\n\n\n\n\n\n\n\n                r = this.performAction.call(yyval, yytext, yyloc, newState, sp - 1, vstack, lstack);\n\n                if (typeof r !== 'undefined') {\n                    retval = r;\n                    break;\n                }\n\n                // pop off stack\n                sp -= yyrulelen;\n\n                // don't overwrite the `symbol` variable: use a local var to speed things up:\n                var ntsymbol = this_production[0];    // push nonterminal (reduce)\n                stack[sp] = ntsymbol;\n                vstack[sp] = yyval.$;\n                lstack[sp] = yyval._$;\n                // goto new state = table[STATE][NONTERMINAL]\n                newState = table[sstack[sp - 1]][ntsymbol];\n                sstack[sp] = newState;\n                ++sp;\n\n\n\n\n\n\n\n\n\n                continue;\n\n            // accept:\n            case 3:\n                if (sp !== -2) {\n                    retval = true;\n                    // Return the `$accept` rule's `$$` result, if available.\n                    //\n                    // Also note that JISON always adds this top-most `$accept` rule (with implicit,\n                    // default, action):\n                    //\n                    //     $accept: <startSymbol> $end\n                    //                  %{ $$ = $1; @$ = @1; %}\n                    //\n                    // which, combined with the parse kernel's `$accept` state behaviour coded below,\n                    // will produce the `$$` value output of the <startSymbol> rule as the parse result,\n                    // IFF that result is *not* `undefined`. (See also the parser kernel code.)\n                    //\n                    // In code:\n                    //\n                    //                  %{\n                    //                      @$ = @1;            // if location tracking support is included\n                    //                      if (typeof $1 !== 'undefined')\n                    //                          return $1;\n                    //                      else\n                    //                          return true;           // the default parse result if the rule actions don't produce anything\n                    //                  %}\n                    sp--;\n                    if (typeof vstack[sp] !== 'undefined') {\n                        retval = vstack[sp];\n                    }\n                }\n                break;\n            }\n\n            // break out of loop: we accept or fail with error\n            break;\n        }\n    } catch (ex) {\n        // report exceptions through the parseError callback too, but keep the exception intact\n        // if it is a known parser or lexer error which has been thrown by parseError() already:\n        if (ex instanceof this.JisonParserError) {\n            throw ex;\n        }\n        else if (lexer && typeof lexer.JisonLexerError === 'function' && ex instanceof lexer.JisonLexerError) {\n            throw ex;\n        }\n\n        p = this.constructParseErrorInfo('Parsing aborted due to exception.', ex, null, false);\n        retval = false;\n        r = this.parseError(p.errStr, p, this.JisonParserError);\n        if (typeof r !== 'undefined') {\n            retval = r;\n        }\n    } finally {\n        retval = this.cleanupAfterParse(retval, true, true);\n        this.__reentrant_call_depth--;\n    }   // /finally\n\n    return retval;\n}\n};\nparser.originalParseError = parser.parseError;\nparser.originalQuoteName = parser.quoteName;\n\nconst t = require(\"../parsetree\");\n\nfunction Parser() {\n  this.yy = {};\n}\nParser.prototype = parser;\nparser.Parser = Parser;\n\nreturn new Parser();\n})();\n\n        \n\n\nif (typeof require !== 'undefined' && typeof exports !== 'undefined') {\n  exports.parser = c_grammar;\n  exports.Parser = c_grammar.Parser;\n  exports.parse = function () {\n    return c_grammar.parse.apply(c_grammar, arguments);\n  };\n  \n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.hmd = (module) => {\n\tmodule = Object.create(module);\n\tif (!module.children) module.children = [];\n\tObject.defineProperty(module, 'exports', {\n\t\tenumerable: true,\n\t\tset: () => {\n\t\t\tthrow new Error('ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: ' + module.id);\n\t\t}\n\t});\n\treturn module;\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(715);\n"],"names":["STANDARD_LIBRARY","Map","Object","entries","LIBRARY_HEADERS","map","path","data","endsWith","set","DEFAULT","generation_try_constant_expr","generation_zero_shadow_stack","generation_switch_br_table","peephole_local_tee","peephole_i32_constants_ops","peephole_constants_add_mul","peephole_add_0","peephole_combine_adds","peephole_load_offset","peephole_constant_if","peephole_unused_blocks","partial_redundancy_elimination","copy_propagation","live_range_splitting","dead_code_elimination","reallocate_locals","unused_locals","peephole_2nd_pass","inlining","current","getFlags","encodeF32","n","buffer","ArrayBuffer","DataView","setFloat32","Uint8Array","encodeF64","setFloat64","encodeU32","Error","result","byte","Number","push","unsignedLeb128","encodeInt32Constant","BigInt","signedLeb128","encodeInt64Constant","encodeConstantInstr","type","i32Type","i64Type","f32Type","f64Type","toString","encodeUtf8","str","point","nextcode","i","length","charCodeAt","unshift","encodeResultType","r","encodeVec","x","encodeFunctionType","f","encodeLimits","l","undefined","values","flat","zeroArgs","name","opcode","parameters","reads","writes","instr","immediate","encoded","copy","this","zeroArgsSpecial","specialFn","context","constantArg","encodeFn","typeFn","value","memArg","valueType","align","offset","args","getIndex","idx","depth","idxArg","suffix","stackOps","extra","encodeBlockType","t","blockLoopInstr","constructor","body","contextFn","expression","expression2","ctx","copyInto","WExpression","builder","parent","_stack","_instructions","items","instrFn","createInstr","get","index","instructions","pop","replace","start","end","stack","slice","forEach","stackManipulation","newInstr","some","v","e","target","instructionsRecursive","reverse","join","flatMap","Set","Instructions","unreachable","nop","block","loop","if","elseOpcode","elseBody","ifInstr","br","br_if","br_table","defaultLbl","lblArray","defaultValue","valueTable","return","call","func","fn","_functionLookup","call_indirect","_typeLookup","drop","local","getLocal","tee","global","_globalLookup","memory","size","grow","fill","i32","load","load8_s","load8_u","load16_s","load16_u","store","store8","store16","const","eqz","eq","ne","lt_s","lt_u","gt_s","gt_u","le_s","le_u","ge_s","ge_u","clz","ctz","popcnt","add","sub","mul","div_s","div_u","rem_s","rem_u","and","or","xor","shl","shr_s","shr_u","rotl","rotr","wrap_i64","trunc_f32_s","trunc_f32_u","trunc_f64_s","trunc_f64_u","reinterpret_f32","extend8_s","extend16_s","trunc_sat_f32_s","trunc_sat_f32_u","trunc_sat_f64_s","trunc_sat_f64_u","i64","load32_s","load32_u","store32","extend_i32_s","extend_i32_u","reinterpret_f64","extend32_s","f32","lt","gt","le","ge","abs","neg","ceil","floor","trunc","nearest","sqrt","div","min","max","copysign","convert_i32_s","convert_i32_u","convert_i64_s","convert_i64_u","demote_f64","reinterpret_i32","f64","promote_f32","reinterpret_i64","deadCodeElimination","expr","usedLocals","stackItems","produces","consumes","currentStack","dfInstr","item","consumedBy","producedBy","remainingItem","needed","dataflow","instruction","resource","WLocal","markNeeded","markRecursively","write","has","read","replacement","changed","filter","peepholeOptimisers","peephole","peepholeMulti","fns","maxSize","reduce","a","b","Math","emulateInt","bits","branchedTo","startsWith","child","controlFlow","entryFlow","flowPrevious","flowNext","exitFlow","allFlows","brTargets","_expr2flow","previousFlow","followingFlow","flows","instrIndex","flow","nextFlow","child1","child2","shift","targetIdx","initial","find","next","entry","exit","all","simplifiedControlFlow","newAll","previous","indexOf","framework","cfg","intermediateMap","bitMap","direction","meetOperation","transferFunction","intermediateOverride","queue","X","before","beforeBits","after","remapLocals","mapping","enabled","flags","run","instr1","instr2","peepholeSize","instr3","s1","s2","u1","u2","instr4","includes","WGlobal","module","mutable","initialValue","exportName","_globalIndex","toBytes","g","InstrSplicer","offsetsMap","splice","loc","deleteCount","replacements","beginOffset","offsets","realIndex","analysis","exprs","TRANSP","expressions","fullyTransparent","transpMap","resources","transparent","COMP","computedMap","expIdx","positions","computed","ANTLOC","AVIN","AVOUT","ANTOUT","ANTIN","SAFEIN","SAFEOUT","SPAVIN","SPAVOUT","SPANTOUT","SPANTIN","INSERT","REPLACE","INSERT_EDGE","comp","spavin","spantout","insert","spavout","edgeList","j","insert_edge","localId","LocalRange","id","merge","other","getNewLocal","newLocal","CError","message","node","node2","super","locationString","label","lines","source","split","first_line","output","lnumDigits","log10","last_line","outputLine","lnum","padStart","Array","first_column","last_column","CFuncType","returnType","parameterTypes","parameterNames","variadic","typeName","bytes","alignment","incomplete","CVoid","checkTypeComplete","equals","every","pointerGeneration","addQualifier","CPointer","getQualifier","constant","original","qualifier","CArray","CCompoundMember","CStruct","members","_members","children","total","memberType","m","member","hasConstMember","CUnion","CEnum","_values","CArithmetic","minValue","BOOL","Infinity","maxValue","Fp32","Fp64","U8","S8","U16","S16","U32","S32","U64","S64","CSizeT","constType","Symbol","prototype","hasOwnProperty","baseType","setPrototypeOf","_base","integerPromotion","usualArithmeticConversion","t1","t2","getArithmeticType","specifierList","remove","s","check","ExpressionTypeError","wantedType","actualType","asArithmetic","asInteger","arithmetic","asPointer","asArithmeticOrPointer","asNonFunctionPointer","checkLvalue","lvalue","CConstant","changeType","newValue","CIdentifier","CStringLiteral","CFunctionCall","fnType","CAssignment","checkAssignmentValid","identifiers","CMemberAccess","bodyType","pointerType","structUnion","CIncrDecr","op","pos","CSizeof","CAddressOf","addressUsed","CDereference","CUnaryPlusMinus","CBitwiseNot","CLogicalNot","CCast","CMulDiv","lhs","rhs","CMod","CAddSub","CShift","dir","CRelational","commonType","CEquality","CBitwiseAndOr","CLogicalAndOr","CConditional","test","trueValue","falseValue","otherValue","assignmentType","initialAssignment","lhsType","CInitializer","rhsType","_checkAssignmentTypeValid","static","varType","CComma","_memberTypes","_type","memberTypes","typeCheck","c","desiredType","Scope","tags","typedefs","_getTag","tag","lookupTag","getPrototypeOf","ScopeError","addTag","_getId","lookupIdentifier","addIdentifier","existing","CFuncDeclaration","CFuncDefinition","linkage","definition","fnImport","CVarDeclaration","CVarDefinition","declarations","_getTypedef","lookupTypedef","addTypedef","CCompoundStatement","statements","scope","CExpressionStatement","CNop","CIf","CForLoop","CWhileLoop","CDoLoop","CGoto","CSwitch","CContinue","CBreak","CReturn","CLabelledStatement","storage","declType","_addressUsed","_definition","dependencies","CArgument","CFuncImport","declaration","getFunction","translationUnit","hints","inline","CONSTANT","fail","evalExpression","staticValue","normalizeType","evalInteger","e2","isNaN","bitmask","normalizeValueType","GenError","fnName","staticInitializer","init","targetType","pad","alignPad","initializer","addr","nextStaticAddr","stringBytes","stringLiteral","dataSegment","stringLiteralPtr","constExpression","evalExpr","getStaticAddress","indirectIndex","lhsValue","rhsValue","encode","method","d","setBigInt64","setBigUint64","setInt32","setUint32","setInt16","setUint16","setInt8","setUint8","implType","realType","conversion","inType","outType","arithmeticConversion","largeReturn","storageSetupStaticVar","setStorageLocation","address","storageSetupScope","temporaries","shadowStackUsage","shadowOffset","memcpy","gen","shadowStackPtr","getTempLocal","getStorageLocation","freeTempLocal","storageGet","ctype","locationExpr","location","fromExpression","getAddress","storageUpdate","transform","keepValue","withTemporaryLocal","tmp","addrTmp","locationSymbol","sourceAddr","destAddr","validatorMap","validate","nodeList","parents","validator","ParseTreeValidationError","validators","typeValidation","qualifierList","typeLookup","constExprValidation","storageList","fnSpecifierList","keywords","fromEntries","toUpperCase","rules","regex","RegExp","Lexer","line","col","text","lastIndex","match","exec","LexerError","groupIdx","group","reset","ParseNode","lexer","generatedParser","parse","input","hash","parser","WrappedLexer","types","lex","token","yytext","yylloc","yylineno","setInput","clear","externalDeclaration","typeInfo","declarator","list","parsetree","IdentifierDeclarator","fakeParseNode","INTERNAL_FNS","wasm","wasm_i32","wasm_i64","wasm_f32","wasm_f64","wasm_ssp","wasm_rload","INTERNAL_SCOPE","arbitrary","parameterArgs","parameterInstructions","instructionBytes","parm","discard","gInstr","functionCall","indirectValue","subExpr","internalExpression","internalFunctions","largeReturnPtr","shadowUsage","typeIndex","functionIndex","incrDecr","amount","gConst","storageGetThenUpdate","assignment","entryPointer","entryDeref","entryAssignment","expressionGeneration","access","valueExpr","valueInstr","storageSet","exprBody","identifier","stringAddress","memberAccess","addressOf","dereference","fInstr","unaryPlusMinus","wType","iInstr","bitwiseNot","isIValueType","logicalNot","sizeof","cast","mulDiv","mod","toExpr","side","addSub","relational","equality","bitwiseAndOr","condition","logicalAndOr","trueSideEffects","falseSideEffects","conditional","comma","anyNonZeroI32","w","findValueInstr","len","dropAssignment","optimisers","optimise","instrCounts","count","countInstructions","optimiser","num","peepholeOptimisations","top","exprQueue","instrLoop","startInstr","position","bit","matching","subExprMatches","arr1","arr2","results","exp","insertBefore","insertBetween","replacementFlows","addLocal","insertInstructions","replacementInstructions","insertAfter","fnLengthChange","i2","j2","inserted","removed","processResults","sort","diff","modificationRegions","expressionLen","regions","expr1","min1","max1","expr2","min2","max2","eliminateOverlapping","ifs","exprLength","definitions","reaching","localMasks","flowDefMap","duChains","locals","entryDefinitions","possibleUses","definiteUses","flowDef","defs","localDefs","reachingDefinitions","def","use","getFlow","getDefs","replacedAll","localsMap","definitionMap","ranges","prev","allLocals","wipeLocals","liveMap","numArgs","flag","clashGraph","clash","live","clashCopy","delete","oldLocal","clashesWith","isArgument","oldLocals","deleteLocal","WImportedFunction","_funcIndex","getTableIndex","_tableIndex","WFunction","define","bodyFn","_builder","WFunctionBuilder","finalInstr","lastType","localType","code","_locals","_freeTempLocals","_arguments","_localidx","bind","findIndex","self","lookup","ModuleBuilder","_functions","_importedFunctions","_functionTable","_functionTypes","_globals","_dataSegments","function","params","returnValue","importFunction","param","setupMemory","initial64kPages","maximum64kPages","_memory","contents","startIdx","byteList","imports","_encodeImports","funcTypes","_typeIndex","emitCallback","startSection","startFunction","encodeSection","_encodeTable","_encodeExports","_encodeElements","_encodeDataSegments","async","WebAssembly","instantiate","instance","exports","tableSize","lastEnd","previousContents","functions","functionImports","_inFunctionTable","_removeFunction","vec","inlineFunctions","FnInfo","infoMap","modifiedFns","splicer","info","usage","inliningCandidates","argTypes","newLocals","blockIndex","usages","inTable","exported","startingIndex","removeUnusedFns","fnMap","analyze","fnInfo","score","statementGeneration","finishCallback","labelledStatement","blockStatements","loopStatements","statement","storeBreakDepth","_compoundStatement","_expressionStatement","ifBody","_if","storageFinishCallback","isArray","update","storeContinueDepth","_forLoop","_whileLoop","_doLoop","initInstr","defaultIndex","default","checks","numCases","sCase","cases","typeInstrs","table","_switch","targetDepth","breakDepthSymbol","_goto","continueDepthSymbol","_continue","_break","_return","linker","staticInitializers","variable","emitVariables","funcImport","emitImports","emitExportedFunctions","emitFunctions","cfunc","wfunc","functionBody","interproceduralOptimise","staticSize","_shadowStackPtr","shadowStackStart","isMemoryUsed","wasmFunc","funcType","fnGenerator","WFnGenerator","paramTypes","discardResult","expressionFn","getType","o","specifiers","singleSpecifier","structure","getDeclaratorType","getDeclaratorName","cEnum","nextValue","evalIntegerConstant","enumConstant","getSpecifierType","ptr","pointer","abstractDeclarator","ptExpression","ptConstant","arr","charRegex","unescapeChar","codePointAt","ptUnary","ptBinary","assignType","constInteger","possibleTypes","unsigned","long","toLowerCase","parseFloat","parseInt","String","fromCharCode","codePoint","ppEvaluate","preprocessor","parseTree","error","_eval","Constant","BinaryExpression","UnaryExpression","Identifier","PreProRegex","Definition","expand","expandWithParameters","originalLine","consume","remainingLine","mustConsume","consumeArgument","trim","expandDefinitions","out","inQuote","bracketDepth","char","consumed","substring","Preprocessor","PreprocessorBase","consumeAny","success","errorName","filename","standardHeaders","customDefinitions","userFiles","libraryFiles","key","process","trimStart","_define","_undef","_include","_ifdef","defName","newDefinitions","output1","output2","_includeUser","_includeLib","file","localPath","tokens","parameter","ifdef","_condition","anyCondition","hadElse","trimEnd","processed","matchAll","definitionName","ptDeclaration","inFunction","decl","ptTypedef","assignments","ptInitializer","initialType","cvar","ptFunction","cfn","ptCompound","checkReturns","ptStatement","p","_compoundBody","ptSwitchBody","labelled","toIR","fileScope","ptTransform","files","_emitExportedFunctions","_emitFunctions","_emitImports","_emitVariables","_linkables","_linked","p2","c2","process_scope","link","linkers","LinkingError","outerLoop","linkable","linkable2","ExternalFunction","setDefinition","ExternalVariable","parseNode","externalType","declarationArray","seen","toEmit","definitionLinker","dependency","dep2","keys","externalFn","addDeclaration","process_fn_body","externalVar","Linkable","defLinker","_defLinker","_standardLibrary","stdLibrary","definitionsJson","JSON","stringify","lib","injectArgs","__sp","Global","__mem","Memory","mem","array","encoder","TextEncoder","pointerAddr","stringAddr","encodeInt","mainWrapper","main","argc","argv","Files","nextHandle","handleMap","nameMap","fileNameBuffer","currentInput","setupIoHandle","fname","File","handle","put","set_pos","getFilenames","filenames","__get_char","__put_char","__get_pos","__get_len","__set_pos","__exists","__move","oldName","newName","__get_fhandle","getImports","getContents","_bytes","_pos","writeRow","document","createElement","innerText","innerHTML","appendChild","FILES","DEFINITIONS","downloadTime","performance","now","compileProgram","base","allSources","program","sources","Promise","resolve","setTimeout","compileTime","compile","toFixed","download","u8","href","URL","createObjectURL","Blob","click","fetch","Date","getTime","then","response","cjpeg","djpeg","fileInput","accept","addEventListener","reader","FileReader","onloadend","parentElement","console","log","getOutput","c2wasm","sliderDiv","quality","style","width","qualityOutput","outputRow","imageRow","image","change","outputDiv","__time","jpeg","blob","src","compress","maxWidth","maxHeight","downloadRow","originalJPEG","convertedBMP","outputJPEG","setupSlider","decompress","readAsArrayBuffer","compileModule","precompile","Expression","_expression","StringLiteral","UnaryOperations","_unaryExpr","BinaryOperations","_binaryExpr","SizeofExpression","CastExpression","FunctionCallExpression","MemberAccessExpression","ConditionalExpression","AssignmentExpression","ConstantExpression","CustomTypeSpecifier","SpecifierQualifiers","specifier","DeclarationSpecifiers","EnumSpecifier","Enumerator","Declaration","InitDeclarator","exploreInitializer","StructUnionSpecifier","StructDeclaration","PointerDeclarator","ArrayDeclarator","FunctionDeclarator","ParameterDeclaration","Pointer","TypeName","AbstractPointerDeclarator","AbstractArrayDeclarator","AbstractFunctionDeclarator","Statement","_statement","setLabel","IfStatement","SwitchStatement","CaseStatement","DefaultStatement","CompoundStatement","ExpressionStatement","NoOp","ForLoop","WhileLoop","DoWhileLoop","GotoStatement","ContinueStatement","BreakStatement","ReturnStatement","FunctionDefinition","c_grammar","JisonParserError","msg","stacktrace","defineProperty","enumerable","writable","exception","ex2","captureStackTrace","u","rv","apply","create","trace","yy","options","hasPartialLrUpgradeOnConflict","errorRecoveryTokenDiscardCount","symbols_","terminals_","TERROR","EOF","originalQuoteName","originalParseError","cleanupAfterParse","constructParseErrorInfo","yyMergeLocationInfo","__reentrant_call_depth","__error_infos","__error_recovery_infos","quoteName","id_str","getSymbolName","symbol","describeSymbol","terminal_descriptions_","collect_expected_token_set","state","do_not_describe","tokenset","state_descriptions_","productions_","rule","bp","performAction","yyloc","yystate","yysp","yyvstack","yylstack","yyparser","yylexer","$","_$","y","mode","goto","q","z","bt","defaultActions","bda","parseError","ExceptionClass","recoverable","destroy","sstack","vstack","lstack","sp","NO_ACTION","__lexer__","sharedState_yy","pre_parse","post_parse","pre_lex","post_lex","shallow_copy","dst","k","shallow_copy_noclobber","copy_yylloc","range","fastLex","assert","yyGetSharedState","resultValue","invoke_post_methods","do_not_nuke_errorinfos","cleanupAfterLex","el","first_index","last_index","first_yylloc","last_yylloc","dont_look_back","i1","l1","l2","ex","expected","pei","errStr","token_id","action","new_state","newState","symbol_stack","state_stack","value_stack","location_stack","stack_pointer","rec","yyrulelen","this_production","yyval","retval","canIUse","errSymbolDescr","showPosition","ntsymbol","JisonLexerError","Parser","arguments","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","loaded","__webpack_modules__","hmd","obj","prop","toStringTag"],"sourceRoot":""}