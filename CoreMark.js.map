{"version":3,"file":"CoreMark.js","mappings":"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AIN,EAAkBI,EAAIlJ,KAAK0I,eAAeQ,GAC9CE,IAAMJ,EAAMI,KACZL,EAASpC,KAAKyC,GACdJ,EAAMI,IAAK,GAIvB,OAAOL,GAEfM,aA1gBQ,SAAY/C,GAIR,IAHA,IAAIO,EAAK,GACLqC,EAAI5C,EAAEgD,IACNC,EAAIjD,EAAEkD,KACD9C,EAAI,EAAGF,EAAI0C,EAAEhG,OAAQwD,EAAIF,EAAGE,IACjCG,EAAGF,KAAK,CACJuC,EAAExC,GACF6C,EAAE7C,KAGV,OAAOG,EAggBL4C,CAAG,CACfH,IAAK1C,EAAE,CACP,GACA,GACA,GACAN,EACA,CAAC,GAAI,GACL,GACA,GACA,GACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACL,GACA,GACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACL,GACA,GACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACN,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,IACN,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,GACN,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,GACN,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,GACN,IACA,IACA,IACAA,EACA,CAAC,IAAK,GACN,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACN,IACA,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,GACN,IACA,IACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACN,IACA,IACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACN,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACN,IACA,IACA,IACA,IACA,MAEAkD,KAAM5C,EAAE,CACR,EACAN,EACA,CAAC,EAAG,GACJC,EACA,CAAC,GAAI,GACL,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACAA,EACA,CAAC,GAAI,GACLD,EACA,CAAC,EAAG,GACJ,EACAA,EACA,CAAC,EAAG,GACJ,EACA,EACAA,EACA,CAAC,EAAG,GACJC,EACA,CAAC,EAAG,GACJA,EACA,CAAC,EAAG,GACJA,EACA,CAAC,EAAG,GACJA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,EAAG,GACJ,EACAA,EACA,CAAC,EAAG,GACJD,EACA,CAAC,EAAG,IACJC,EACA,CAAC,GAAI,GACLA,EACA,CAAC,EAAG,GACJA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,EAAG,GACJA,EACA,CAAC,GAAI,GACLD,EACA,CAAC,EAAG,IACJ,EACA,EACAC,EACA,CAAC,IAAK,GACN,EACA,EACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,IAAK,GACN,EACA,EACA,EACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACL,EACA,EACA,EACAA,EACA,CAAC,EAAG,GACJA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACL,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACL,MAGFmD,cAAe,SAA+BC,EAAQC,EAAOC,EAAyBC,EAAMC,EAAUC,GAK5F,IAAI3C,EAAKrH,KAAKqH,GACV4C,EAAW5C,EAAGF,OACd+C,EAAU7C,EAAG8C,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GF,KAAKqE,GAEZ,OAAOnE,EAk8EZuE,CAAG,CACRX,IAAK7D,EAAE,CACP,GACA,EACA,GACAN,EACA,CAAC,EAAG,GACJ,GACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,EAAG,IACJ,EACA,EACAA,EACA,CAAC,EAAG,GACJ,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACAA,EACA,CAAC,EAAG,GACJ,GACA,GACA,EACA,GACA,EACA,GACA,GACA,EACA,EACA,EACA,GACA,GACA,EACA,EACA,EACA,EACA,GACA,GACA,EACA,EACA,GACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,GACA,EACA,GACA,GACA,GACA,GACA,GACAC,EACA,CAAC,GAAI,GACLD,EACA,CAAC,EAAG,GACJ,GACA,EACA,EACA,GACA,GACA,GACAA,EACA,CAAC,EAAG,GACJ,GACA,EACA,GACA,GACA,GACA,GACA,GACA,EACA,EACA,GACAC,EACA,CAAC,GAAI,GACLD,EACA,CAAC,EAAG,GACJ,GACA,GACA,EACA,EACA,EACAA,EACA,CAAC,EAAG,GACJ,GACA,EACAC,EACA,CAAC,EAAG,GACJ,GACAA,EACA,CAAC,IAAK,GACN,EACAD,EACA,CAAC,EAAG,GACJC,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACL,EACA,EACA,GACA,EACAA,EACA,CAAC,EAAG,GACJD,EACA,CAAC,EAAG,GACJ,EACA,GACA,EACA,EACA,EACA,GACAA,EACA,CAAC,EAAG,IACJ,GACA,GACA,GACA,GACAC,EACA,CAAC,GAAI,GACLA,EACA,CAAC,EAAG,GACJD,EACA,CAAC,EAAG,GACJ,GACA,GACA,GACAC,EACA,CAAC,GAAI,GACL,EACA,GACA,GACA,GACA,GACAD,EACA,CAAC,GAAI,GACL,GACA,GACA,GACA,GACAA,EACA,CAAC,GAAI,GACL,EACA,EACA,GACA,EACA,GACA,EACA,GACAA,EACA,CAAC,GAAI,GACL,EACA,GACAC,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACL,GACA,EACA,EACA,EACA,EACA,GACAA,EACA,CAAC,GAAI,GACL,EACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,IAAK,GACN,EACA,EACA,EACAA,EACA,CAAC,GAAI,GACL,EACA,GACA,GACA,EACA,GACAA,EACA,CAAC,IAAK,GACN,GACA,GACA,GACA,GACAD,EACA,CAAC,GAAI,GACL,GACA,GACA,GACAC,EACA,CAAC,IAAK,GACNA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACL,EACA,EACA,EACA,GACA,GACAA,EACA,CAAC,GAAI,GACL,GACA,GACA,EACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,GAAI,GACL,EACA,GACA,EACAA,EACA,CAAC,IAAK,GACND,EACA,CAAC,GAAI,GACL,GACA,GACA,GACAC,EACA,CAAC,GAAI,GACL,EACA,GACAA,EACA,CAAC,GAAI,GACL,GACA,EACA,GACAA,EACA,CAAC,GAAI,GACL,GACA,EACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACL,EACA,IAEAiC,OAAQ5B,EAAE,CACV,EACAN,EACA,CAAC,GAAI,GAAI,GACT,GACA,IACA,IACAA,EACA,CAAC,IAAK,EAAG,GACT,IACA,IACA,IACA,IACA,IACA,IACA,EACAC,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,GACL,IACA,IACA,EACA,GACA,GACA,GACA,GACA,IACA,IACA,IACA,IACA,IACA,EACA,EACA,EACA,EACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,KACL,GACA,GACA,GACAA,EACA,CAAC,EAAG,GACJ,EACA,GACA,GACA,GACA,IACA,EACA,GACA,EACA,GACA,GACA,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACL,GACA,GACA,IACA,IACA,IACA,EACA,GACA,GACA,GACAA,EACA,CAAC,IAAK,GACN,GACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLD,EACA,CAAC,IAAK,EAAG,GACT,IACA,IACA,GACA,GACA,IACA,IACAC,EACA,CAAC,GAAI,IACL,EACAD,EACA,CAAC,EAAG,EAAG,GACP,GACAA,EACA,CAAC,GAAI,EAAG,GACR,GACA,GACA,GACAA,EACA,CAAC,GAAI,EAAG,GACRA,EACA,CAAC,GAAI,GAAI,GACT,IACAC,EACA,CAAC,GAAI,GACLD,EACA,CAAC,GAAI,GAAI,GACTC,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,IACL,GACA,GACA,GACAD,EACA,CAAC,GAAI,EAAG,GACRC,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,IAAK,GACND,EACA,CAAC,IAAK,EAAG,GACTC,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACN,EACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,IACN,IACA,EACAA,EACA,CAAC,IAAK,IACN,IACA,IACA,IACAA,EACA,CAAC,IAAK,GACN,EACAA,EACA,CAAC,IAAK,IACN,GACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,IAAK,GACN,IACA,IACAA,EACA,CAAC,IAAK,GACN,GACA,GACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,IACL,EACA,GACA,EACA,GACA,GACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,IACN,IACA,EACA,EACAD,EACA,CAAC,EAAG,EAAG,GACPA,EACA,CAAC,GAAI,GAAI,GACT,GACAA,EACA,CAAC,GAAI,GAAI,GACT,IACAC,EACA,CAAC,GAAI,GACL,GACA,GACA,GACA,GACA,GACAD,EACA,CAAC,EAAG,GAAI,GACRC,EACA,CAAC,GAAI,IACL,GACA,GACA,GACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,IACL,GACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,GACN,GACA,GACAA,EACA,CAAC,EAAG,GACJA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,IAAK,IACND,EACA,CAAC,GAAI,EAAG,GACRC,EACA,CAAC,IAAK,IACN,GACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,GACN,IACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,IAAK,GACN,EACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,IAAK,GACN,GACA,GACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,GAAI,GACL,GACA,GACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,KAAM,GACP,EACAA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACN,GACAA,EACA,CAAC,KAAM,GACPD,EACA,CAAC,EAAG,GACJC,EACA,CAAC,IAAK,GACNA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACN,GACA,GACA,GACA,GACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,IAAK,GACN,EACA,EACA,EACA,EACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,KAAM,GACP,IACA,IACAA,EACA,CAAC,IAAK,IACN,EACA,GACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,GACN,GACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACL,EACAA,EACA,CAAC,GAAI,IACLD,EACA,CAAC,GAAI,GAAI,GACT,GACA,GACA,GACA,GACAC,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,IACL,EACA,EACA,EACAA,EACA,CAAC,KAAM,GACPA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,KACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACN,GACAA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,IAAK,KACNA,EACA,CAAC,GAAI,IACL,GACAA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACP,IACA,GACA,EACA,GACAD,EACA,CAAC,GAAI,GAAI,GACTC,EACA,CAAC,GAAI,GACLA,EACA,CAAC,KAAM,GACPA,EACA,CAAC,KAAM,GACP,IACAA,EACA,CAAC,EAAG,GACJA,EACA,CAAC,KAAM,GACPA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,KAAM,GACPA,EACA,CAAC,KAAM,GACPA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,GACPA,EACA,CAAC,KAAM,GACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACP,EACA,GACAA,EACA,CAAC,KAAM,GACP,EACA,EACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,IAAK,IACN,EACA,EACAA,EACA,CAAC,IAAK,GACN,GACAA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,KAAM,GACPA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,GAAI,KACLA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,GAAI,IACL,EACA,EACAA,EACA,CAAC,KAAM,IACPD,EACA,CAAC,GAAI,EAAG,GACRC,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,KACLA,EACA,CAAC,KAAM,GACPA,EACA,CAAC,IAAK,OAENhH,KAAMqH,EAAE,CACRN,EACA,CAAC,EAAG,IACJA,EACA,CAAC,EAAG,IACJ,EACAC,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLD,EACA,CAAC,EAAG,IACJC,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,KACLA,EACA,CAAC,EAAG,GACJA,EACA,CAAC,EAAG,GACJA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACND,EACA,CAAC,EAAG,IACJA,EACA,CAAC,EAAG,IACJC,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACND,EACA,CAAC,EAAG,IACJC,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACND,EACA,CAAC,EAAG,KACJC,EACA,CAAC,IAAK,IACNA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,KAAM,GACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,KACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,KAAM,GACPA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACND,EACA,CAAC,EAAG,KACJC,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,GAAI,KACLA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,GAAI,KACLA,EACA,CAAC,IAAK,MAENsC,MAAOjC,EAAE,CACT,EACAN,EACA,CAAC,EAAG,EAAG,GACP,GACA,GACA,GACA,GACA,GACA,EACAA,EACA,CAAC,EAAG,EAAG,GACPC,EACA,CAAC,GAAI,GACL,GACA,EACA,GACA,GACA,GACA,GACA,GACA,GACA,GACAA,EACA,CAAC,GAAI,GACL,GACAA,EACA,CAAC,EAAG,GACJ,GACAA,EACA,CAAC,EAAG,GACJ,GACAA,EACA,CAAC,EAAG,GACJ,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,IACA,GACA,GACA,GACA,GACA,GACAD,EACA,CAAC,IAAK,GAAI,GACV,IACA,IACA,GACA,GACA,GACA,GACA,GACA,GACA,IACAC,EACA,CAAC,GAAI,IACL,IACA,IACA,IACA,IACAA,EACA,CAAC,GAAI,GACL,IACA,IACA,IACA,IACA,IACAD,EACA,CAAC,IAAK,EAAG,GACT,GACA,IACA,IACA,GACA,GACAC,EACA,CAAC,GAAI,GACL,IACAA,EACA,CAAC,GAAI,IACL,IACA,IACA,IACAA,EACA,CAAC,GAAI,GACL,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,GACN,IACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,EAAG,GACJ,IACAA,EACA,CAAC,EAAG,GACJ,GACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,GACN,IACAA,EACA,CAAC,GAAI,GACL,IACAA,EACA,CAAC,IAAK,GACN,IACAA,EACA,CAAC,IAAK,IACN,IACA,IACA,IACAA,EACA,CAAC,GAAI,GACL,IACA,GACAA,EACA,CAAC,EAAG,GACJ,IACAA,EACA,CAAC,EAAG,GACJ,IACA,GACA,IACAA,EACA,CAAC,EAAG,GACJ,IACA,GACA,IACAA,EACA,CAAC,GAAI,IACL,IACA,IACAA,EACA,CAAC,GAAI,GACL,IACA,GACA,GACA,IACAA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,IAAK,GACN,GACA,GACAA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,GAAI,IACL,IACAD,EACA,CAAC,IAAK,EAAG,GACT,IACAC,EACA,CAAC,IAAK,IACN,IACA,GACA,IACA,GACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,GACN,GACA,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,GACL,IACAA,EACA,CAAC,GAAI,IACL,IACA,IACA,IACAA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,GAAI,IACL,IACA,IACA,IACA,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,GACL,IACAA,EACA,CAAC,GAAI,GACL,IACAA,EACA,CAAC,GAAI,GACL,IACAA,EACA,CAAC,EAAG,GACJ,IACAA,EACA,CAAC,EAAG,GACJ,IACAA,EACA,CAAC,IAAK,IACN,IACAD,EACA,CAAC,IAAK,EAAG,GACTC,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACA,IACAA,EACA,CAAC,IAAK,GACN,IACAA,EACA,CAAC,IAAK,GACN,IACA,GACA,GACA,IACA,GACAA,EACA,CAAC,GAAI,GACL,GACA,GACA,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,GACN,IACA,GACA,IACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,GAAI,GACL,IACA,IACAA,EACA,CAAC,GAAI,GACL,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,IAAK,IACN,IACA,IACA,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,IAAK,GACN,IACA,IACA,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,KAELqE,KAAMhE,EAAE,CACRN,EACA,CAAC,EAAG,IACJA,EACA,CAAC,EAAG,GACJC,EACA,CAAC,GAAI,KACLA,EACA,CAAC,GAAI,GACL,EACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,EAAG,GACJA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACLD,EACA,CAAC,EAAG,IACJC,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,IACLD,EACA,CAAC,EAAG,IACJC,EACA,CAAC,GAAI,GACLA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,EAAG,IACJA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACND,EACA,CAAC,EAAG,KACJC,EACA,CAAC,IAAK,KACND,EACA,CAAC,EAAG,KACJC,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,IAAK,KACND,EACA,CAAC,EAAG,IACJC,EACA,CAAC,IAAK,IACND,EACA,CAAC,EAAG,OAEJwE,KAAMlE,EAAE,CACR,EACAN,EACA,CAAC,GAAI,GAAI,GACT,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACAC,EACA,CAAC,GAAI,IACL,GACA,GACA,GACA,GACAD,EACA,CAAC,GAAI,GACLC,EACA,CAAC,GAAI,IACLD,EACA,CAAC,GAAI,GACLC,EACA,CAAC,GAAI,IACLD,EACA,CAAC,GAAI,GACLC,EACA,CAAC,GAAI,IACLD,EACA,CAAC,GAAI,GACLC,EACA,CAAC,GAAI,IACL,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,IACA,GACAD,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACN,GACA,IACA,GACA,GACA,GACA,GACAA,EACA,CAAC,IAAK,GACN,GACAA,EACA,CAAC,IAAK,IACNC,EACA,CAAC,GAAI,IACL,GACAD,EACA,CAAC,IAAK,GACN,GACAA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,GAAI,EAAG,GACR,GACA,GACAA,EACA,CAAC,IAAK,EAAG,GACT,IACA,GACA,GACA,GACAC,EACA,CAAC,GAAI,GACL,IACA,GACA,IACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACN,IACA,IACAD,EACA,CAAC,IAAK,EAAG,GACTC,EACA,CAAC,IAAK,GACN,GACA,IACA,GACAD,EACA,CAAC,IAAK,GACN,IACA,IACAC,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACLD,EACA,CAAC,IAAK,GACN,GACA,IACA,GACA,IACAC,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,GACLD,EACA,CAAC,IAAK,GACNC,EACA,CAAC,GAAI,IACLD,EACA,CAAC,IAAK,GACNC,EACA,CAAC,GAAI,IACL,IACA,IACA,IACA,IACA,IACA,GACAA,EACA,CAAC,IAAK,IACND,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,GAAI,GACVA,EACA,CAAC,GAAI,GACL,IACAA,EACA,CAAC,GAAI,GACL,IACA,IACA,GACA,IACA,GACA,IACAA,EACA,CAAC,GAAI,IACL,IACA,IACA,IACAA,EACA,CAAC,GAAI,IACL,IACAC,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACLD,EACA,CAAC,GAAI,GACL,IACA,GACAA,EACA,CAAC,GAAI,GACL,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACLC,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACND,EACA,CAAC,GAAI,GACL,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACL,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,IACL,IACA,IACA,GACA,GACAA,EACA,CAAC,GAAI,GACL,IACA,IACAA,EACA,CAAC,GAAI,GACL,IACA,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,IACL,IACA,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACL,IACA,IACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,GACL,IACA,GACA,GACA,IACA,IACAA,EACA,CAAC,GAAI,IACLC,EACA,CAAC,IAAK,GACN,IACAA,EACA,CAAC,IAAK,IACN,GACA,GACAD,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACLC,EACA,CAAC,IAAK,IACN,IACA,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACL,IACA,GACA,IACA,IACAA,EACA,CAAC,GAAI,GACL,IACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,GACN,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,GACA,GACA,IACAA,EACA,CAAC,IAAK,IACN,IACA,IACA,IACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,GAAI,IACL,IACA,IACA,IACA,IACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,GACAA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,IACL,IACA,IACA,IACA,IACA,IACA,IACA,GACAA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,KACLA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,IAAK,IACN,IACA,IACA,IACAA,EACA,CAAC,GAAI,IACL,IACA,IACA,IACA,IACA,IACA,GACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,GACA,GACAA,EACA,CAAC,GAAI,IACL,IACA,IACAA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,KAAM,GACP,IACAA,EACA,CAAC,KAAM,GACP,IACAA,EACA,CAAC,GAAI,IACL,IACA,IACAD,EACA,CAAC,GAAI,GACL,IACA,GACA,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,GAAI,GACL,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACL,IACAA,EACA,CAAC,GAAI,GACLC,EACA,CAAC,IAAK,IACN,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,IACND,EACA,CAAC,GAAI,GACL,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,IACL,IACA,IACA,GACA,GACAA,EACA,CAAC,GAAI,GACL,IACA,IACAA,EACA,CAAC,GAAI,GACL,IACA,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACL,IACA,IACAA,EACA,CAAC,GAAI,GACL,IACA,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,IACL,IACA,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,IACL,IACA,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,IACL,IACA,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,IACL,IACA,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACL,IACA,IACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,GACL,IACA,IACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,GACL,IACA,GACA,GACA,IACA,IACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,GACL,IACA,GACA,GACA,IACA,IACAA,EACA,CAAC,GAAI,IACLC,EACA,CAAC,IAAK,IACN,IACA,IACA,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,IACL,IACA,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,IAAK,IACN,IACA,IACA,IACAA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACA,IACAD,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,IAAK,GACN,IACA,IACAC,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,IAAK,QAGR8E,eA5+IQ,SAAa/E,GAIT,IAHA,IAAIO,EAAK,GACLuC,EAAI9C,EAAEgF,IACNT,EAAIvE,EAAEwE,KACDpE,EAAI,EAAGF,EAAI4C,EAAElG,OAAQwD,EAAIF,EAAGE,IAAK,CAEtCG,EADQuC,EAAE1C,IACFmE,EAAEnE,GAEd,OAAOG,EAo+IH0E,CAAI,CAClBD,IAAK1E,EAAE,CACPN,EACA,CAAC,EAAG,EAAG,GACPA,EACA,CAAC,GAAI,GAAI,GACTA,EACA,CAAC,GAAI,EAAG,GACR,GACA,GACA,GACAA,EACA,CAAC,GAAI,EAAG,GACR,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACAA,EACA,CAAC,GAAI,EAAG,GACR,GACA,GACAA,EACA,CAAC,IAAK,EAAG,GACT,IACA,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,EAAG,GACT,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,EAAG,GACT,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,EAAG,GACT,IACAA,EACA,CAAC,IAAK,GAAI,GACV,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,EAAG,GACT,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,EAAG,GACT,IACA,IACAA,EACA,CAAC,IAAK,EAAG,GACT,IACA,IACAA,EACA,CAAC,IAAK,EAAG,GACT,IACA,IACA,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,EAAG,GACT,IACA,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,EAAG,KAETwE,KAAMlE,EAAE,CACR,EACA,IACA,IACA,IACAN,EACA,CAAC,IAAK,GAAI,GACV,IACA,IACA,IACA,IACA,IACA,EACA,IACA,GACA,GACA,IACA,EACAA,EACA,CAAC,GAAI,EAAG,GACR,IACA,GACA,IACA,IACA,IACA,IACA,GACA,IACA,GACA,GACAA,EACA,CAAC,GAAI,EAAG,GACR,GACA,GACAA,EACA,CAAC,EAAG,EAAG,GACP,GACA,EACA,GACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,EAAG,GACT,IACA,GACA,GACA,IACA,GACA,GACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,GAAI,GAAI,GACT,GACA,GACAA,EACA,CAAC,GAAI,EAAG,GACR,GACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,GACA,GACA,GACA,GACA,GACA,GACA,IACA,GACA,GACA,GACA,IACA,IACA,GACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,GACA,GACA,GACA,GACA,IACA,IACA,IACA,IACA,IACA,IACA,GACA,GACA,IACA,IACA,IACA,IACA,IACA,IACA,I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","sources":["webpack://@ictrobot/c2wasm/./src/parsing/parsetree.ts","webpack://@ictrobot/c2wasm/./src/parsing/gen/c_grammar.js","webpack://@ictrobot/c2wasm/webpack/bootstrap","webpack://@ictrobot/c2wasm/webpack/runtime/define property getters","webpack://@ictrobot/c2wasm/webpack/runtime/hasOwnProperty shorthand","webpack://@ictrobot/c2wasm/webpack/runtime/make namespace object","webpack://@ictrobot/c2wasm/./src/c_library/standard_library.ts","webpack://@ictrobot/c2wasm/./src/optimisation/flags.ts","webpack://@ictrobot/c2wasm/./src/wasm/encoding.ts","webpack://@ictrobot/c2wasm/./src/wasm/wtypes.ts","webpack://@ictrobot/c2wasm/./src/wasm/instr_helpers.ts","webpack://@ictrobot/c2wasm/./src/wasm/instructions.ts","webpack://@ictrobot/c2wasm/./src/optimisation/dead_code.ts","webpack://@ictrobot/c2wasm/./src/optimisation/peephole.ts","webpack://@ictrobot/c2wasm/./src/optimisation/flow/control_flow.ts","webpack://@ictrobot/c2wasm/./src/optimisation/flow/framework.ts","webpack://@ictrobot/c2wasm/./src/optimisation/flow/local_allocation.ts","webpack://@ictrobot/c2wasm/./src/wasm/global.ts","webpack://@ictrobot/c2wasm/./src/optimisation/splicer.ts","webpack://@ictrobot/c2wasm/./src/optimisation/flow/pre.ts","webpack://@ictrobot/c2wasm/./src/optimisation/flow/range_splitting.ts","webpack://@ictrobot/c2wasm/./src/c_error.ts","webpack://@ictrobot/c2wasm/./src/ir/types.ts","webpack://@ictrobot/c2wasm/./src/ir/type_checking.ts","webpack://@ictrobot/c2wasm/./src/ir/expressions.ts","webpack://@ictrobot/c2wasm/./src/ir/scope.ts","webpack://@ictrobot/c2wasm/./src/ir/statements.ts","webpack://@ictrobot/c2wasm/./src/ir/declarations.ts","webpack://@ictrobot/c2wasm/./src/ir/transform/constant_expressions.ts","webpack://@ictrobot/c2wasm/./src/generation/gen_error.ts","webpack://@ictrobot/c2wasm/./src/generation/static_initializer.ts","webpack://@ictrobot/c2wasm/./src/generation/type_conversion.ts","webpack://@ictrobot/c2wasm/./src/generation/storage.ts","webpack://@ictrobot/c2wasm/./src/parsing/validation.ts","webpack://@ictrobot/c2wasm/./src/parsing/lexer.ts","webpack://@ictrobot/c2wasm/./src/parsing/parser.ts","webpack://@ictrobot/c2wasm/./src/ir/internal_scope.ts","webpack://@ictrobot/c2wasm/./src/generation/wasm_functions.ts","webpack://@ictrobot/c2wasm/./src/generation/expressions.ts","webpack://@ictrobot/c2wasm/./src/optimisation/flow/reaching_defs.ts","webpack://@ictrobot/c2wasm/./src/optimisation/index.ts","webpack://@ictrobot/c2wasm/./src/wasm/functions.ts","webpack://@ictrobot/c2wasm/./src/wasm/module.ts","webpack://@ictrobot/c2wasm/./src/optimisation/interprocedural/functions.ts","webpack://@ictrobot/c2wasm/./src/generation/statements.ts","webpack://@ictrobot/c2wasm/./src/generation/generator.ts","webpack://@ictrobot/c2wasm/./src/optimisation/interprocedural/index.ts","webpack://@ictrobot/c2wasm/./src/ir/transform/type_transform.ts","webpack://@ictrobot/c2wasm/./src/ir/transform/expr_transform.ts","webpack://@ictrobot/c2wasm/./src/preprocessor/conditionals.ts","webpack://@ictrobot/c2wasm/./src/preprocessor/helpers.ts","webpack://@ictrobot/c2wasm/./src/preprocessor/definition.ts","webpack://@ictrobot/c2wasm/./src/preprocessor/preprocessor.ts","webpack://@ictrobot/c2wasm/./src/ir/transform/transform.ts","webpack://@ictrobot/c2wasm/./src/ir/index.ts","webpack://@ictrobot/c2wasm/./src/linker.ts","webpack://@ictrobot/c2wasm/./src/compile.ts","webpack://@ictrobot/c2wasm/./demos/CoreMark.ts"],"sourcesContent":["import type {Location} from \"./lexer\";\n\n// Classes used to build up the C parse tree - mostly just simple objects storing the relevant fields.\n\nexport abstract class ParseNode {\n    abstract readonly type: string;\n\n    constructor(readonly loc: Location) {\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        // return any children of the node\n    }\n}\n\n// Expressions\n\nexport abstract class Expression extends ParseNode {\n    // typescript does structural equality when type checking, so for this class to be different from\n    // the base ParseNode add a simple private field.\n    private readonly _expression: boolean = true;\n}\n\nexport class Identifier extends Expression {\n    readonly type = \"identifier\";\n\n    constructor(loc: Location, readonly name: string) {\n        super(loc);\n    }\n}\n\nexport class Constant extends Expression {\n    readonly type = \"constant\";\n\n    constructor(loc: Location, readonly value: string, readonly valueType: \"float\" | \"char\" | \"int\" | \"oct\" | \"hex\") {\n        super(loc);\n    }\n}\n\nexport class StringLiteral extends Expression {\n    readonly type = \"stringLiteral\";\n\n    constructor(loc: Location, readonly value: string) {\n        super(loc);\n    }\n}\n\nexport const UnaryOperations = [\n    \"postfixIncrement\", \"postfixDecrement\", \"prefixIncrement\", \"prefixDecrement\",\n    \"addressOf\", \"dereference\", \"unaryPlus\", \"unaryMinus\", \"bitwiseNot\", \"logicalNot\"] as const;\nexport type UnaryOp = typeof UnaryOperations[number];\nexport class UnaryExpression extends Expression {\n    private readonly _unaryExpr = true;\n\n    constructor(loc: Location, readonly type: UnaryOp, readonly body: Expression) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.body;\n    }\n}\n\nexport const BinaryOperations = [\"arraySubscript\", \"comma\",\n    \"mul\", \"div\", \"mod\", \"add\", \"sub\", \"bitwiseShiftLeft\", \"bitwiseShiftRight\",\n    \"relationalLT\", \"relationalGT\", \"relationalLEq\", \"relationalGEq\", \"relationalEq\", \"relationalNEq\",\n    \"bitwiseAnd\", \"bitwiseXor\", \"bitwiseOr\", \"logicalAnd\", \"logicalOr\"] as const;\nexport type BinaryOp = typeof BinaryOperations[number];\nexport class BinaryExpression extends Expression {\n    private readonly _binaryExpr = true;\n\n    constructor(loc: Location, readonly type: BinaryOp, readonly lhs: Expression, readonly rhs: Expression) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.lhs;\n        yield this.rhs;\n    }\n}\n\nexport class SizeofExpression extends Expression {\n    readonly type = \"sizeof\";\n\n    constructor(loc: Location, readonly body: Expression | TypeName) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.body;\n    }\n}\n\nexport class CastExpression extends Expression {\n    readonly type = \"cast\";\n\n    constructor(loc: Location, readonly targetType: TypeName, readonly body: Expression) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.targetType;\n        yield this.body;\n    }\n}\n\nexport class FunctionCallExpression extends Expression {\n    readonly type = \"functionCall\";\n\n    constructor(loc: Location, readonly fn: Expression, readonly args: ReadonlyArray<Expression> = []) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.fn;\n        yield* this.args;\n    }\n}\n\nexport class MemberAccessExpression extends Expression {\n    readonly type = \"access\";\n\n    constructor(loc: Location, readonly pointer: boolean, readonly lhs: Expression, readonly rhs: string) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.lhs;\n    }\n}\n\nexport class ConditionalExpression extends Expression {\n    readonly type = \"conditional\";\n\n    constructor(loc: Location, readonly condition: Expression, readonly trueValue: Expression, readonly falseValue: Expression) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.condition;\n        yield this.trueValue;\n        yield this.falseValue;\n    }\n}\n\nexport type AssignmentType = undefined | \"mul\" | \"div\" | \"mod\" | \"add\" | \"sub\" | \"leftShift\"| \"rightShift\" | \"bitwiseAnd\" | \"bitwiseXor\" | \"bitwiseOr\";\nexport class AssignmentExpression extends Expression {\n    readonly type = \"assign\";\n\n    constructor(loc: Location, readonly assignType: AssignmentType, readonly lhs: Expression, readonly rhs: Expression) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.lhs;\n        yield this.rhs;\n    }\n}\n\nexport class ConstantExpression extends Expression {\n    readonly type = \"constantExpr\";\n\n    constructor(loc: Location, readonly expr: Expression) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.expr;\n    }\n}\n\n// Declarations\nexport class CustomTypeSpecifier extends ParseNode {\n    readonly type = \"customType\";\n\n    public constructor(loc: Location, readonly name: string) {\n        super(loc);\n    }\n}\n\nexport type StorageClass = \"typedef\" | \"extern\" | \"static\"; // | \"auto\" | \"register\";\nexport type TypeSpecifier =\n    \"void\" | \"char\" | \"short\" | \"int\" | \"long\" | \"float\" | \"double\" | \"signed\" | \"unsigned\" | \"bool\" // | \"complex\" | \"imaginary\"]\n    | StructUnionSpecifier\n    | EnumSpecifier\n    | CustomTypeSpecifier;\nexport type TypeQualifier = \"const\"; // | \"restrict\" | \"volatile\";\nexport type FnSpecifier = \"import\" | \"inline\";\n\nexport class SpecifierQualifiers extends ParseNode {\n    readonly type = \"specifiersAndQualifiers\";\n\n    constructor(loc: Location,\n                readonly specifierList: ReadonlyArray<TypeSpecifier>,\n                readonly qualifierList: ReadonlyArray<TypeQualifier>) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        for (const specifier of this.specifierList) {\n            if (specifier instanceof ParseNode) yield specifier;\n        }\n    }\n}\n\nexport class DeclarationSpecifiers extends ParseNode {\n    readonly type = \"declarationSpecifiers\";\n\n    constructor(loc: Location,\n                readonly specifierList: ReadonlyArray<TypeSpecifier>,\n                readonly qualifierList: ReadonlyArray<TypeQualifier>,\n                readonly storageList: ReadonlyArray<StorageClass>,\n                readonly fnSpecifierList: ReadonlyArray<FnSpecifier>) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        for (const specifier of this.specifierList) {\n            if (specifier instanceof ParseNode) yield specifier;\n        }\n    }\n}\n\nexport class EnumSpecifier extends ParseNode {\n    type = \"enum\";\n\n    constructor(loc: Location, readonly id?: string, readonly body?: ReadonlyArray<Enumerator>) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        if (this.body) yield* this.body;\n    }\n}\n\nexport class Enumerator extends ParseNode {\n    type = \"enumerator\";\n\n    constructor(loc: Location, readonly id: string, readonly value?: ConstantExpression) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        if (this.value) yield this.value;\n    }\n}\n\nexport class Declaration extends ParseNode{\n    readonly type = \"declaration\";\n\n    constructor(loc: Location, readonly typeInfo: DeclarationSpecifiers, readonly list: ReadonlyArray<Declarator | InitDeclarator> = []) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.typeInfo;\n        yield* this.list;\n    }\n}\n\nexport class InitDeclarator extends ParseNode {\n    readonly type = \"initDeclarator\";\n\n    constructor(loc: Location, readonly body: Declarator, readonly initializer: Initializer) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.body;\n        yield* this.exploreInitializer();\n    }\n\n    private *exploreInitializer(initializer: Initializer = this.initializer): Iterable<ParseNode> {\n        if (initializer instanceof AssignmentExpression) {\n            yield initializer;\n        } else if (Array.isArray(initializer)) {\n            for (const x of initializer) yield* this.exploreInitializer(x);\n        }\n    }\n}\n\nexport class StructUnionSpecifier extends ParseNode {\n    readonly type = \"structUnionSpecifier\";\n\n    constructor(loc: Location, readonly structure: \"struct\" | \"union\", readonly id?: string, readonly declarations?: ReadonlyArray<StructDeclaration>) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        if (this.declarations) yield* this.declarations;\n    }\n}\n\nexport class StructDeclaration extends ParseNode {\n    readonly type = \"structDeclaration\";\n\n    constructor(loc: Location, readonly typeInfo: DeclarationSpecifiers, readonly list: ReadonlyArray<Declarator> = []) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.typeInfo;\n        yield* this.list;\n    }\n}\n\nexport type Declarator = PointerDeclarator | IdentifierDeclarator | ArrayDeclarator | FunctionDeclarator;\n\nexport class PointerDeclarator extends ParseNode {\n    readonly type = \"pointerDeclarator\";\n    readonly abstractDeclarator = false;\n\n    constructor(loc: Location, readonly pointer: Pointer, readonly body: Declarator) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.pointer;\n        yield this.body;\n    }\n}\n\nexport class IdentifierDeclarator extends ParseNode {\n    readonly type = \"identifierDeclarator\";\n    readonly abstractDeclarator = false;\n\n    constructor(loc: Location, readonly id: string) {\n        super(loc);\n    }\n}\n\nexport class ArrayDeclarator extends ParseNode {\n    readonly type = \"arrayDeclarator\";\n    readonly abstractDeclarator = false;\n\n    constructor(loc: Location, readonly body: Declarator, readonly length?: ConstantExpression) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.body;\n        if (this.length) yield this.length;\n    }\n}\n\nexport class FunctionDeclarator extends ParseNode {\n    readonly type = \"functionDeclarator\";\n    readonly abstractDeclarator = false;\n\n    constructor(loc: Location, readonly body: Declarator, readonly args?: ReadonlyArray<ParameterDeclaration>, readonly variadic: boolean = false) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.body;\n        for (const value of this.args ?? []) {\n            if (value instanceof ParseNode) yield value;\n        }\n    }\n}\n\nexport class ParameterDeclaration extends ParseNode {\n    readonly type = \"parameterDeclaration\";\n\n    constructor(loc: Location, readonly typeInfo: DeclarationSpecifiers, readonly declarator?: Declarator | AbstractDeclarator) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.typeInfo;\n        if (this.declarator) yield this.declarator;\n    }\n}\n\nexport class Pointer extends ParseNode {\n    readonly type = \"pointer\";\n\n    constructor(loc: Location, readonly qualifierList?: ReadonlyArray<TypeQualifier>, readonly body?: Pointer) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        if (this.body) yield this.body;\n    }\n}\n\nexport class TypeName extends ParseNode {\n    readonly type = \"typeName\";\n\n    constructor(loc: Location, readonly typeInfo: SpecifierQualifiers, readonly declarator?: AbstractDeclarator) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.typeInfo;\n        if (this.declarator) yield this.declarator;\n    }\n}\n\nexport type AbstractDeclarator = AbstractPointerDeclarator | AbstractArrayDeclarator | AbstractFunctionDeclarator;\n\nexport class AbstractPointerDeclarator extends ParseNode {\n    readonly type = \"abstractPointerDeclarator\";\n    readonly abstractDeclarator = true;\n\n    constructor(loc: Location, readonly pointer: Pointer, readonly body?: AbstractDeclarator) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.pointer;\n        if (this.body) yield this.body;\n    }\n}\n\nexport class AbstractArrayDeclarator extends ParseNode {\n    readonly type = \"abstractArrayDeclarator\";\n    readonly abstractDeclarator = true;\n\n    constructor(loc: Location, readonly body?: AbstractDeclarator, readonly length?: ConstantExpression) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        if (this.body) yield this.body;\n        if (this.length) yield this.length;\n    }\n}\n\nexport class AbstractFunctionDeclarator extends ParseNode {\n    readonly type = \"abstractFunctionDeclarator\";\n    readonly abstractDeclarator = true;\n\n    constructor(loc: Location, readonly body?: AbstractDeclarator, readonly args?: ReadonlyArray<ParameterDeclaration>, readonly variadic: boolean = false) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        if (this.body) yield this.body;\n        if (this.args) yield* this.args;\n    }\n}\n\nexport type Initializer = Expression | ReadonlyArray<Initializer>;\n\n// Statements\n\nexport abstract class Statement extends ParseNode {\n    private readonly _statement: boolean = true;\n    label?: string;\n\n    setLabel(label: string): this {\n        this.label = label;\n        return this;\n    }\n}\n\nexport class IfStatement extends Statement {\n    readonly type = \"ifStatement\";\n\n    constructor(loc: Location, readonly expression: Expression, readonly ifBody: Statement, readonly elseBody?: Statement) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.expression;\n        yield this.ifBody;\n        if (this.elseBody) yield this.elseBody;\n    }\n}\n\nexport class SwitchStatement extends Statement {\n    readonly type = \"switchStatement\";\n\n    constructor(loc: Location, readonly expression: Expression, readonly body: Statement) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.expression;\n        yield this.body;\n    }\n}\n\nexport class CaseStatement extends Statement {\n    readonly type = \"caseStatement\";\n\n    constructor(loc: Location, readonly value: ConstantExpression, readonly body: Statement) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.value;\n        yield this.body;\n    }\n}\n\nexport class DefaultStatement extends Statement {\n    readonly type = \"defaultStatement\";\n\n    constructor(loc: Location, readonly body: Statement) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.body;\n    }\n}\n\nexport class CompoundStatement extends Statement {\n    readonly type = \"compoundStatement\";\n\n    constructor(loc: Location, readonly body: ReadonlyArray<Statement | Declaration>) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield* this.body;\n    }\n}\n\nexport class ExpressionStatement extends Statement {\n    readonly type = \"expressionStatement\";\n\n    constructor(loc: Location, readonly expression: Expression) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.expression;\n    }\n}\n\nexport class NoOp extends Statement {\n    readonly type = \"nopStatement\";\n\n    constructor(loc: Location) {\n        super(loc);\n    }\n}\n\nexport class ForLoop extends Statement {\n    readonly type = \"forStatement\";\n\n    constructor(loc: Location,\n                readonly init: ExpressionStatement | NoOp | Declaration,\n                readonly test: ExpressionStatement | NoOp,\n                readonly update: Expression | undefined,\n                readonly body: Statement) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.init;\n        yield this.test;\n        if (this.update) yield this.update;\n        yield this.body;\n    }\n}\n\nexport class WhileLoop extends Statement {\n    readonly type = \"whileStatement\";\n\n    constructor(loc: Location, readonly test: Expression, readonly body: Statement) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.test;\n        yield this.body;\n    }\n}\n\nexport class DoWhileLoop extends Statement {\n    readonly type = \"doWhileStatement\";\n\n    constructor(loc: Location, readonly body: Statement, readonly test: Expression) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.body;\n        yield this.test;\n    }\n}\n\nexport class GotoStatement extends Statement {\n    readonly type = \"gotoStatement\";\n\n    constructor(loc: Location, readonly target: string) {\n        super(loc);\n    }\n}\n\nexport class ContinueStatement extends Statement {\n    readonly type = \"continueStatement\";\n}\n\nexport class BreakStatement extends Statement {\n    readonly type = \"breakStatement\";\n}\n\nexport class ReturnStatement extends Statement {\n    readonly type = \"returnStatement\";\n\n    constructor(loc: Location, readonly value?: Expression) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        if (this.value) yield this.value;\n    }\n}\n\nexport class FunctionDefinition extends ParseNode {\n    readonly type = \"functionDefinition\";\n\n    constructor(loc: Location,\n                readonly typeInfo: DeclarationSpecifiers,\n                readonly declarator: Declarator,\n                readonly body: CompoundStatement) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.typeInfo;\n        yield this.declarator;\n        yield this.body;\n    }\n}\n\nexport type TranslationUnit = ReadonlyArray<FunctionDefinition | Declaration>;\n","\n/* parser generated by jison 0.6.1-215 */\n\n/*\n * Returns a Parser object of the following structure:\n *\n *  Parser: {\n *    yy: {}     The so-called \"shared state\" or rather the *source* of it;\n *               the real \"shared state\" `yy` passed around to\n *               the rule actions, etc. is a derivative/copy of this one,\n *               not a direct reference!\n *  }\n *\n *  Parser.prototype: {\n *    yy: {},\n *    EOF: 1,\n *    TERROR: 2,\n *\n *    trace: function(errorMessage, ...),\n *\n *    JisonParserError: function(msg, hash),\n *\n *    quoteName: function(name),\n *               Helper function which can be overridden by user code later on: put suitable\n *               quotes around literal IDs in a description string.\n *\n *    originalQuoteName: function(name),\n *               The basic quoteName handler provided by JISON.\n *               `cleanupAfterParse()` will clean up and reset `quoteName()` to reference this function\n *               at the end of the `parse()`.\n *\n *    describeSymbol: function(symbol),\n *               Return a more-or-less human-readable description of the given symbol, when\n *               available, or the symbol itself, serving as its own 'description' for lack\n *               of something better to serve up.\n *\n *               Return NULL when the symbol is unknown to the parser.\n *\n *    symbols_: {associative list: name ==> number},\n *    terminals_: {associative list: number ==> name},\n *    nonterminals: {associative list: rule-name ==> {associative list: number ==> rule-alt}},\n *    terminal_descriptions_: (if there are any) {associative list: number ==> description},\n *    productions_: [...],\n *\n *    performAction: function parser__performAction(yytext, yyleng, yylineno, yyloc, yystate, yysp, yyvstack, yylstack, yystack, yysstack),\n *\n *               The function parameters and `this` have the following value/meaning:\n *               - `this`    : reference to the `yyval` internal object, which has members (`$` and `_$`)\n *                             to store/reference the rule value `$$` and location info `@$`.\n *\n *                 One important thing to note about `this` a.k.a. `yyval`: every *reduce* action gets\n *                 to see the same object via the `this` reference, i.e. if you wish to carry custom\n *                 data from one reduce action through to the next within a single parse run, then you\n *                 may get nasty and use `yyval` a.k.a. `this` for storing you own semi-permanent data.\n *\n *                 `this.yy` is a direct reference to the `yy` shared state object.\n *\n *                 `%parse-param`-specified additional `parse()` arguments have been added to this `yy`\n *                 object at `parse()` start and are therefore available to the action code via the\n *                 same named `yy.xxxx` attributes (where `xxxx` represents a identifier name from\n *                 the %parse-param` list.\n *\n *               - `yytext`  : reference to the lexer value which belongs to the last lexer token used\n *                             to match this rule. This is *not* the look-ahead token, but the last token\n *                             that's actually part of this rule.\n *\n *                 Formulated another way, `yytext` is the value of the token immediately preceeding\n *                 the current look-ahead token.\n *                 Caveats apply for rules which don't require look-ahead, such as epsilon rules.\n *\n *               - `yyleng`  : ditto as `yytext`, only now for the lexer.yyleng value.\n *\n *               - `yylineno`: ditto as `yytext`, only now for the lexer.yylineno value.\n *\n *               - `yyloc`   : ditto as `yytext`, only now for the lexer.yylloc lexer token location info.\n *\n *                               WARNING: since jison 0.4.18-186 this entry may be NULL/UNDEFINED instead\n *                               of an empty object when no suitable location info can be provided.\n *\n *               - `yystate` : the current parser state number, used internally for dispatching and\n *                               executing the action code chunk matching the rule currently being reduced.\n *\n *               - `yysp`    : the current state stack position (a.k.a. 'stack pointer')\n *\n *                 This one comes in handy when you are going to do advanced things to the parser\n *                 stacks, all of which are accessible from your action code (see the next entries below).\n *\n *                 Also note that you can access this and other stack index values using the new double-hash\n *                 syntax, i.e. `##$ === ##0 === yysp`, while `##1` is the stack index for all things\n *                 related to the first rule term, just like you have `$1`, `@1` and `#1`.\n *                 This is made available to write very advanced grammar action rules, e.g. when you want\n *                 to investigate the parse state stack in your action code, which would, for example,\n *                 be relevant when you wish to implement error diagnostics and reporting schemes similar\n *                 to the work described here:\n *\n *                 + Pottier, F., 2016. Reachability and error diagnosis in LR(1) automata.\n *                   In Journées Francophones des Languages Applicatifs.\n *\n *                 + Jeffery, C.L., 2003. Generating LR syntax error messages from examples.\n *                   ACM Transactions on Programming Languages and Systems (TOPLAS), 25(5), pp.631–640.\n *\n *               - `yyrulelength`: the current rule's term count, i.e. the number of entries occupied on the stack.\n *\n *                 This one comes in handy when you are going to do advanced things to the parser\n *                 stacks, all of which are accessible from your action code (see the next entries below).\n *\n *               - `yyvstack`: reference to the parser value stack. Also accessed via the `$1` etc.\n *                             constructs.\n *\n *               - `yylstack`: reference to the parser token location stack. Also accessed via\n *                             the `@1` etc. constructs.\n *\n *                             WARNING: since jison 0.4.18-186 this array MAY contain slots which are\n *                             UNDEFINED rather than an empty (location) object, when the lexer/parser\n *                             action code did not provide a suitable location info object when such a\n *                             slot was filled!\n *\n *               - `yystack` : reference to the parser token id stack. Also accessed via the\n *                             `#1` etc. constructs.\n *\n *                 Note: this is a bit of a **white lie** as we can statically decode any `#n` reference to\n *                 its numeric token id value, hence that code wouldn't need the `yystack` but *you* might\n *                 want access this array for your own purposes, such as error analysis as mentioned above!\n *\n *                 Note that this stack stores the current stack of *tokens*, that is the sequence of\n *                 already parsed=reduced *nonterminals* (tokens representing rules) and *terminals*\n *                 (lexer tokens *shifted* onto the stack until the rule they belong to is found and\n *                 *reduced*.\n *\n *               - `yysstack`: reference to the parser state stack. This one carries the internal parser\n *                             *states* such as the one in `yystate`, which are used to represent\n *                             the parser state machine in the *parse table*. *Very* *internal* stuff,\n *                             what can I say? If you access this one, you're clearly doing wicked things\n *\n *               - `...`     : the extra arguments you specified in the `%parse-param` statement in your\n *                             grammar definition file.\n *\n *    table: [...],\n *               State transition table\n *               ----------------------\n *\n *               index levels are:\n *               - `state`  --> hash table\n *               - `symbol` --> action (number or array)\n *\n *                 If the `action` is an array, these are the elements' meaning:\n *                 - index [0]: 1 = shift, 2 = reduce, 3 = accept\n *                 - index [1]: GOTO `state`\n *\n *                 If the `action` is a number, it is the GOTO `state`\n *\n *    defaultActions: {...},\n *\n *    parseError: function(str, hash, ExceptionClass),\n *    yyError: function(str, ...),\n *    yyRecovering: function(),\n *    yyErrOk: function(),\n *    yyClearIn: function(),\n *\n *    constructParseErrorInfo: function(error_message, exception_object, expected_token_set, is_recoverable),\n *               Helper function **which will be set up during the first invocation of the `parse()` method**.\n *               Produces a new errorInfo 'hash object' which can be passed into `parseError()`.\n *               See it's use in this parser kernel in many places; example usage:\n *\n *                   var infoObj = parser.constructParseErrorInfo('fail!', null,\n *                                     parser.collect_expected_token_set(state), true);\n *                   var retVal = parser.parseError(infoObj.errStr, infoObj, parser.JisonParserError);\n *\n *    originalParseError: function(str, hash, ExceptionClass),\n *               The basic `parseError` handler provided by JISON.\n *               `cleanupAfterParse()` will clean up and reset `parseError()` to reference this function\n *               at the end of the `parse()`.\n *\n *    options: { ... parser %options ... },\n *\n *    parse: function(input[, args...]),\n *               Parse the given `input` and return the parsed value (or `true` when none was provided by\n *               the root action, in which case the parser is acting as a *matcher*).\n *               You MAY use the additional `args...` parameters as per `%parse-param` spec of this grammar:\n *               these extra `args...` are added verbatim to the `yy` object reference as member variables.\n *\n *               WARNING:\n *               Parser's additional `args...` parameters (via `%parse-param`) MAY conflict with\n *               any attributes already added to `yy` by the jison run-time;\n *               when such a collision is detected an exception is thrown to prevent the generated run-time\n *               from silently accepting this confusing and potentially hazardous situation!\n *\n *               The lexer MAY add its own set of additional parameters (via the `%parse-param` line in\n *               the lexer section of the grammar spec): these will be inserted in the `yy` shared state\n *               object and any collision with those will be reported by the lexer via a thrown exception.\n *\n *    cleanupAfterParse: function(resultValue, invoke_post_methods, do_not_nuke_errorinfos),\n *               Helper function **which will be set up during the first invocation of the `parse()` method**.\n *               This helper API is invoked at the end of the `parse()` call, unless an exception was thrown\n *               and `%options no-try-catch` has been defined for this grammar: in that case this helper MAY\n *               be invoked by calling user code to ensure the `post_parse` callbacks are invoked and\n *               the internal parser gets properly garbage collected under these particular circumstances.\n *\n *    yyMergeLocationInfo: function(first_index, last_index, first_yylloc, last_yylloc, dont_look_back),\n *               Helper function **which will be set up during the first invocation of the `parse()` method**.\n *               This helper API can be invoked to calculate a spanning `yylloc` location info object.\n *\n *               Note: %epsilon rules MAY specify no `first_index` and `first_yylloc`, in which case\n *               this function will attempt to obtain a suitable location marker by inspecting the location stack\n *               backwards.\n *\n *               For more info see the documentation comment further below, immediately above this function's\n *               implementation.\n *\n *    lexer: {\n *        yy: {...},           A reference to the so-called \"shared state\" `yy` once\n *                             received via a call to the `.setInput(input, yy)` lexer API.\n *        EOF: 1,\n *        ERROR: 2,\n *        JisonLexerError: function(msg, hash),\n *        parseError: function(str, hash, ExceptionClass),\n *        setInput: function(input, [yy]),\n *        input: function(),\n *        unput: function(str),\n *        more: function(),\n *        reject: function(),\n *        less: function(n),\n *        pastInput: function(n),\n *        upcomingInput: function(n),\n *        showPosition: function(),\n *        test_match: function(regex_match_array, rule_index, ...),\n *        next: function(...),\n *        lex: function(...),\n *        begin: function(condition),\n *        pushState: function(condition),\n *        popState: function(),\n *        topState: function(),\n *        _currentRules: function(),\n *        stateStackSize: function(),\n *        cleanupAfterLex: function()\n *\n *        options: { ... lexer %options ... },\n *\n *        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START, ...),\n *        rules: [...],\n *        conditions: {associative list: name ==> set},\n *    }\n *  }\n *\n *\n *  token location info (@$, _$, etc.): {\n *    first_line: n,\n *    last_line: n,\n *    first_column: n,\n *    last_column: n,\n *    range: [start_number, end_number]\n *               (where the numbers are indexes into the input string, zero-based)\n *  }\n *\n * ---\n *\n * The `parseError` function receives a 'hash' object with these members for lexer and\n * parser errors:\n *\n *  {\n *    text:        (matched text)\n *    token:       (the produced terminal token, if any)\n *    token_id:    (the produced terminal token numeric ID, if any)\n *    line:        (yylineno)\n *    loc:         (yylloc)\n *  }\n *\n * parser (grammar) errors will also provide these additional members:\n *\n *  {\n *    expected:    (array describing the set of expected tokens;\n *                  may be UNDEFINED when we cannot easily produce such a set)\n *    state:       (integer (or array when the table includes grammar collisions);\n *                  represents the current internal state of the parser kernel.\n *                  can, for example, be used to pass to the `collect_expected_token_set()`\n *                  API to obtain the expected token set)\n *    action:      (integer; represents the current internal action which will be executed)\n *    new_state:   (integer; represents the next/planned internal state, once the current\n *                  action has executed)\n *    recoverable: (boolean: TRUE when the parser MAY have an error recovery rule\n *                  available for this particular error)\n *    state_stack: (array: the current parser LALR/LR internal state stack; this can be used,\n *                  for instance, for advanced error analysis and reporting)\n *    value_stack: (array: the current parser LALR/LR internal `$$` value stack; this can be used,\n *                  for instance, for advanced error analysis and reporting)\n *    location_stack: (array: the current parser LALR/LR internal location stack; this can be used,\n *                  for instance, for advanced error analysis and reporting)\n *    yy:          (object: the current parser internal \"shared state\" `yy`\n *                  as is also available in the rule actions; this can be used,\n *                  for instance, for advanced error analysis and reporting)\n *    lexer:       (reference to the current lexer instance used by the parser)\n *    parser:      (reference to the current parser instance)\n *  }\n *\n * while `this` will reference the current parser instance.\n *\n * When `parseError` is invoked by the lexer, `this` will still reference the related *parser*\n * instance, while these additional `hash` fields will also be provided:\n *\n *  {\n *    lexer:       (reference to the current lexer instance which reported the error)\n *  }\n *\n * When `parseError` is invoked by the parser due to a **JavaScript exception** being fired\n * from either the parser or lexer, `this` will still reference the related *parser*\n * instance, while these additional `hash` fields will also be provided:\n *\n *  {\n *    exception:   (reference to the exception thrown)\n *  }\n *\n * Please do note that in the latter situation, the `expected` field will be omitted as\n * this type of failure is assumed not to be due to *parse errors* but rather due to user\n * action code in either parser or lexer failing unexpectedly.\n *\n * ---\n *\n * You can specify parser options by setting / modifying the `.yy` object of your Parser instance.\n * These options are available:\n *\n * ### options which are global for all parser instances\n *\n *  Parser.pre_parse: function(yy)\n *                 optional: you can specify a pre_parse() function in the chunk following\n *                 the grammar, i.e. after the last `%%`.\n *  Parser.post_parse: function(yy, retval, parseInfo) { return retval; }\n *                 optional: you can specify a post_parse() function in the chunk following\n *                 the grammar, i.e. after the last `%%`. When it does not return any value,\n *                 the parser will return the original `retval`.\n *\n * ### options which can be set up per parser instance\n *\n *  yy: {\n *      pre_parse:  function(yy)\n *                 optional: is invoked before the parse cycle starts (and before the first\n *                 invocation of `lex()`) but immediately after the invocation of\n *                 `parser.pre_parse()`).\n *      post_parse: function(yy, retval, parseInfo) { return retval; }\n *                 optional: is invoked when the parse terminates due to success ('accept')\n *                 or failure (even when exceptions are thrown).\n *                 `retval` contains the return value to be produced by `Parser.parse()`;\n *                 this function can override the return value by returning another.\n *                 When it does not return any value, the parser will return the original\n *                 `retval`.\n *                 This function is invoked immediately before `parser.post_parse()`.\n *\n *      parseError: function(str, hash, ExceptionClass)\n *                 optional: overrides the default `parseError` function.\n *      quoteName: function(name),\n *                 optional: overrides the default `quoteName` function.\n *  }\n *\n *  parser.lexer.options: {\n *      pre_lex:  function()\n *                 optional: is invoked before the lexer is invoked to produce another token.\n *                 `this` refers to the Lexer object.\n *      post_lex: function(token) { return token; }\n *                 optional: is invoked when the lexer has produced a token `token`;\n *                 this function can override the returned token value by returning another.\n *                 When it does not return any (truthy) value, the lexer will return\n *                 the original `token`.\n *                 `this` refers to the Lexer object.\n *\n *      ranges: boolean\n *                 optional: `true` ==> token location info will include a .range[] member.\n *      flex: boolean\n *                 optional: `true` ==> flex-like lexing behaviour where the rules are tested\n *                 exhaustively to find the longest match.\n *      backtrack_lexer: boolean\n *                 optional: `true` ==> lexer regexes are tested in order and for invoked;\n *                 the lexer terminates the scan when a token is returned by the action code.\n *      xregexp: boolean\n *                 optional: `true` ==> lexer rule regexes are \"extended regex format\" requiring the\n *                 `XRegExp` library. When this `%option` has not been specified at compile time, all lexer\n *                 rule regexes have been written as standard JavaScript RegExp expressions.\n *  }\n */\n\n        \n    \n            var c_grammar = (function () {\n\n\n// See also:\n// http://stackoverflow.com/questions/1382107/whats-a-good-way-to-extend-error-in-javascript/#35881508\n// but we keep the prototype.constructor and prototype.name assignment lines too for compatibility\n// with userland code which might access the derived class in a 'classic' way.\nfunction JisonParserError(msg, hash) {\n    Object.defineProperty(this, 'name', {\n        enumerable: false,\n        writable: false,\n        value: 'JisonParserError'\n    });\n\n    if (msg == null) msg = '???';\n\n    Object.defineProperty(this, 'message', {\n        enumerable: false,\n        writable: true,\n        value: msg\n    });\n\n    this.hash = hash;\n\n    var stacktrace;\n    if (hash && hash.exception instanceof Error) {\n        var ex2 = hash.exception;\n        this.message = ex2.message || msg;\n        stacktrace = ex2.stack;\n    }\n    if (!stacktrace) {\n        if (Error.hasOwnProperty('captureStackTrace')) {        // V8/Chrome engine\n            Error.captureStackTrace(this, this.constructor);\n        } else {\n            stacktrace = (new Error(msg)).stack;\n        }\n    }\n    if (stacktrace) {\n        Object.defineProperty(this, 'stack', {\n            enumerable: false,\n            writable: false,\n            value: stacktrace\n        });\n    }\n}\n\nif (typeof Object.setPrototypeOf === 'function') {\n    Object.setPrototypeOf(JisonParserError.prototype, Error.prototype);\n} else {\n    JisonParserError.prototype = Object.create(Error.prototype);\n}\nJisonParserError.prototype.constructor = JisonParserError;\nJisonParserError.prototype.name = 'JisonParserError';\n\n\n\n\n        // helper: reconstruct the productions[] table\n        function bp(s) {\n            var rv = [];\n            var p = s.pop;\n            var r = s.rule;\n            for (var i = 0, l = p.length; i < l; i++) {\n                rv.push([\n                    p[i],\n                    r[i]\n                ]);\n            }\n            return rv;\n        }\n    \n\n\n        // helper: reconstruct the defaultActions[] table\n        function bda(s) {\n            var rv = {};\n            var d = s.idx;\n            var g = s.goto;\n            for (var i = 0, l = d.length; i < l; i++) {\n                var j = d[i];\n                rv[j] = g[i];\n            }\n            return rv;\n        }\n    \n\n\n        // helper: reconstruct the 'goto' table\n        function bt(s) {\n            var rv = [];\n            var d = s.len;\n            var y = s.symbol;\n            var t = s.type;\n            var a = s.state;\n            var m = s.mode;\n            var g = s.goto;\n            for (var i = 0, l = d.length; i < l; i++) {\n                var n = d[i];\n                var q = {};\n                for (var j = 0; j < n; j++) {\n                    var z = y.shift();\n                    switch (t.shift()) {\n                    case 2:\n                        q[z] = [\n                            m.shift(),\n                            g.shift()\n                        ];\n                        break;\n\n                    case 0:\n                        q[z] = a.shift();\n                        break;\n\n                    default:\n                        // type === 1: accept\n                        q[z] = [\n                            3\n                        ];\n                    }\n                }\n                rv.push(q);\n            }\n            return rv;\n        }\n    \n\n\n        // helper: runlength encoding with increment step: code, length: step (default step = 0)\n        // `this` references an array\n        function s(c, l, a) {\n            a = a || 0;\n            for (var i = 0; i < l; i++) {\n                this.push(c);\n                c += a;\n            }\n        }\n\n        // helper: duplicate sequence from *relative* offset and length.\n        // `this` references an array\n        function c(i, l) {\n            i = this.length - i;\n            for (l += i; i < l; i++) {\n                this.push(this[i]);\n            }\n        }\n\n        // helper: unpack an array using helpers and data, all passed in an array argument 'a'.\n        function u(a) {\n            var rv = [];\n            for (var i = 0, l = a.length; i < l; i++) {\n                var e = a[i];\n                // Is this entry a helper function?\n                if (typeof e === 'function') {\n                    i++;\n                    e.apply(rv, a[i]);\n                } else {\n                    rv.push(e);\n                }\n            }\n            return rv;\n        }\n    \n\nvar parser = {\n    // Code Generator Information Report\n    // ---------------------------------\n    //\n    // Options:\n    //\n    //   default action mode: ............. [\"none\",\"merge\"]\n    //   test-compile action mode: ........ \"parser:*,lexer:*\"\n    //   try..catch: ...................... true\n    //   default resolve on conflict: ..... true\n    //   on-demand look-ahead: ............ false\n    //   error recovery token skip maximum: 3\n    //   yyerror in parse actions is: ..... NOT recoverable,\n    //   yyerror in lexer actions and other non-fatal lexer are:\n    //   .................................. NOT recoverable,\n    //   debug grammar/output: ............ false\n    //   has partial LR conflict upgrade:   true\n    //   rudimentary token-stack support:   false\n    //   parser table compression mode: ... 2\n    //   export debug tables: ............. false\n    //   export *all* tables: ............. false\n    //   module type: ..................... commonjs\n    //   parser engine type: .............. lalr\n    //   output main() in the module: ..... true\n    //   has user-specified main(): ....... false\n    //   has user-specified require()/import modules for main():\n    //   .................................. false\n    //   number of expected conflicts: .... 0\n    //\n    //\n    // Parser Analysis flags:\n    //\n    //   no significant actions (parser is a language matcher only):\n    //   .................................. false\n    //   uses yyleng: ..................... false\n    //   uses yylineno: ................... false\n    //   uses yytext: ..................... true\n    //   uses yylloc: ..................... false\n    //   uses ParseError API: ............. false\n    //   uses YYERROR: .................... false\n    //   uses YYRECOVERING: ............... false\n    //   uses YYERROK: .................... false\n    //   uses YYCLEARIN: .................. false\n    //   tracks rule values: .............. true\n    //   assigns rule values: ............. true\n    //   uses location tracking: .......... true\n    //   assigns location: ................ true\n    //   uses yystack: .................... false\n    //   uses yysstack: ................... false\n    //   uses yysp: ....................... true\n    //   uses yyrulelength: ............... false\n    //   uses yyMergeLocationInfo API: .... true\n    //   has error recovery: .............. false\n    //   has error reporting: ............. false\n    //\n    // --------- END OF REPORT -----------\n\ntrace: function no_op_trace() { },\nJisonParserError: JisonParserError,\nyy: {},\noptions: {\n  type: \"lalr\",\n  hasPartialLrUpgradeOnConflict: true,\n  errorRecoveryTokenDiscardCount: 3\n},\nsymbols_: {\n  \"!\": 14,\n  \"!=\": 43,\n  \"$accept\": 0,\n  \"$end\": 1,\n  \"%\": 16,\n  \"%=\": 48,\n  \"&\": 9,\n  \"&&\": 44,\n  \"&=\": 53,\n  \"(\": 3,\n  \")\": 4,\n  \"*\": 10,\n  \"*=\": 46,\n  \"+\": 11,\n  \"++\": 35,\n  \"+=\": 49,\n  \",\": 8,\n  \"-\": 12,\n  \"--\": 36,\n  \"-=\": 50,\n  \"->\": 34,\n  \".\": 7,\n  \"...\": 76,\n  \"/\": 15,\n  \"/=\": 47,\n  \":\": 22,\n  \";\": 24,\n  \"<\": 17,\n  \"<<\": 38,\n  \"<<=\": 51,\n  \"<=\": 40,\n  \"=\": 23,\n  \"==\": 42,\n  \">\": 18,\n  \">=\": 41,\n  \">>\": 39,\n  \">>=\": 52,\n  \"?\": 21,\n  \"BREAK\": 87,\n  \"CASE\": 77,\n  \"CHAR\": 60,\n  \"CONST\": 73,\n  \"CONSTANT_CHAR\": 32,\n  \"CONSTANT_FLOAT\": 28,\n  \"CONSTANT_HEX\": 29,\n  \"CONSTANT_INT\": 31,\n  \"CONSTANT_OCTAL\": 30,\n  \"CONTINUE\": 86,\n  \"DEFAULT\": 78,\n  \"DO\": 83,\n  \"DOUBLE\": 65,\n  \"ELSE\": 80,\n  \"ENUM\": 72,\n  \"EOF\": 1,\n  \"EXTERN\": 57,\n  \"FLOAT\": 64,\n  \"FOR\": 84,\n  \"GOTO\": 85,\n  \"IDENTIFIER\": 27,\n  \"IF\": 79,\n  \"IMPORT\": 75,\n  \"INLINE\": 74,\n  \"INT\": 62,\n  \"LONG\": 63,\n  \"RETURN\": 88,\n  \"SHORT\": 61,\n  \"SIGNED\": 66,\n  \"SIZEOF\": 37,\n  \"STATIC\": 58,\n  \"STRING_LITERAL\": 33,\n  \"STRUCT\": 70,\n  \"SWITCH\": 81,\n  \"TYPEDEF\": 56,\n  \"TYPE_NAME\": 69,\n  \"UNION\": 71,\n  \"UNSIGNED\": 67,\n  \"VOID\": 59,\n  \"WHILE\": 82,\n  \"[\": 5,\n  \"]\": 6,\n  \"^\": 19,\n  \"^=\": 54,\n  \"_BOOL\": 68,\n  \"abstract_declarator\": 141,\n  \"additive_expression\": 101,\n  \"and_expression\": 105,\n  \"argument_expression_list\": 96,\n  \"assignment_expression\": 111,\n  \"assignment_operator\": 112,\n  \"ast_tree\": 89,\n  \"block_item\": 149,\n  \"block_item_list\": 148,\n  \"cast_expression\": 99,\n  \"compound_statement\": 147,\n  \"concat_string_literals\": 93,\n  \"conditional_expression\": 110,\n  \"constant\": 91,\n  \"constant_expression\": 114,\n  \"declaration\": 115,\n  \"declaration_specifiers\": 116,\n  \"declarator\": 133,\n  \"direct_abstract_declarator\": 142,\n  \"direct_declarator\": 134,\n  \"enum_specifier\": 128,\n  \"enumerator\": 130,\n  \"enumerator_list\": 129,\n  \"equality_expression\": 104,\n  \"error\": 2,\n  \"exclusive_or_expression\": 106,\n  \"expression\": 113,\n  \"expression_statement\": 150,\n  \"external_declaration\": 155,\n  \"function_definition\": 156,\n  \"function_specifier\": 132,\n  \"identifier\": 90,\n  \"inclusive_or_expression\": 107,\n  \"init_declarator\": 118,\n  \"init_declarator_list\": 117,\n  \"initializer\": 143,\n  \"initializer_list\": 144,\n  \"iteration_statement\": 152,\n  \"jump_statement\": 153,\n  \"labeled_statement\": 146,\n  \"logical_and_expression\": 108,\n  \"logical_or_expression\": 109,\n  \"multiplicative_expression\": 100,\n  \"parameter_declaration\": 139,\n  \"parameter_list\": 138,\n  \"parameter_type_list\": 137,\n  \"pointer\": 135,\n  \"postfix_expression\": 95,\n  \"primary_expression\": 94,\n  \"relational_expression\": 103,\n  \"selection_statement\": 151,\n  \"shift_expression\": 102,\n  \"specifier_qualifier_list\": 125,\n  \"statement\": 145,\n  \"storage_class_specifier\": 119,\n  \"string_literal\": 92,\n  \"struct_declaration\": 124,\n  \"struct_declaration_list\": 123,\n  \"struct_declarator\": 127,\n  \"struct_declarator_list\": 126,\n  \"struct_or_union\": 122,\n  \"struct_or_union_specifier\": 121,\n  \"translation_unit\": 154,\n  \"type_name\": 140,\n  \"type_qualifier\": 131,\n  \"type_qualifier_list\": 136,\n  \"type_specifier\": 120,\n  \"unary_expression\": 97,\n  \"unary_operator\": 98,\n  \"{\": 25,\n  \"|\": 20,\n  \"|=\": 55,\n  \"||\": 45,\n  \"}\": 26,\n  \"~\": 13\n},\nterminals_: {\n  1: \"EOF\",\n  2: \"error\",\n  3: \"(\",\n  4: \")\",\n  5: \"[\",\n  6: \"]\",\n  7: \".\",\n  8: \",\",\n  9: \"&\",\n  10: \"*\",\n  11: \"+\",\n  12: \"-\",\n  13: \"~\",\n  14: \"!\",\n  15: \"/\",\n  16: \"%\",\n  17: \"<\",\n  18: \">\",\n  19: \"^\",\n  20: \"|\",\n  21: \"?\",\n  22: \":\",\n  23: \"=\",\n  24: \";\",\n  25: \"{\",\n  26: \"}\",\n  27: \"IDENTIFIER\",\n  28: \"CONSTANT_FLOAT\",\n  29: \"CONSTANT_HEX\",\n  30: \"CONSTANT_OCTAL\",\n  31: \"CONSTANT_INT\",\n  32: \"CONSTANT_CHAR\",\n  33: \"STRING_LITERAL\",\n  34: \"->\",\n  35: \"++\",\n  36: \"--\",\n  37: \"SIZEOF\",\n  38: \"<<\",\n  39: \">>\",\n  40: \"<=\",\n  41: \">=\",\n  42: \"==\",\n  43: \"!=\",\n  44: \"&&\",\n  45: \"||\",\n  46: \"*=\",\n  47: \"/=\",\n  48: \"%=\",\n  49: \"+=\",\n  50: \"-=\",\n  51: \"<<=\",\n  52: \">>=\",\n  53: \"&=\",\n  54: \"^=\",\n  55: \"|=\",\n  56: \"TYPEDEF\",\n  57: \"EXTERN\",\n  58: \"STATIC\",\n  59: \"VOID\",\n  60: \"CHAR\",\n  61: \"SHORT\",\n  62: \"INT\",\n  63: \"LONG\",\n  64: \"FLOAT\",\n  65: \"DOUBLE\",\n  66: \"SIGNED\",\n  67: \"UNSIGNED\",\n  68: \"_BOOL\",\n  69: \"TYPE_NAME\",\n  70: \"STRUCT\",\n  71: \"UNION\",\n  72: \"ENUM\",\n  73: \"CONST\",\n  74: \"INLINE\",\n  75: \"IMPORT\",\n  76: \"...\",\n  77: \"CASE\",\n  78: \"DEFAULT\",\n  79: \"IF\",\n  80: \"ELSE\",\n  81: \"SWITCH\",\n  82: \"WHILE\",\n  83: \"DO\",\n  84: \"FOR\",\n  85: \"GOTO\",\n  86: \"CONTINUE\",\n  87: \"BREAK\",\n  88: \"RETURN\"\n},\nTERROR: 2,\n    EOF: 1,\n\n    // internals: defined here so the object *structure* doesn't get modified by parse() et al,\n    // thus helping JIT compilers like Chrome V8.\n    originalQuoteName: null,\n    originalParseError: null,\n    cleanupAfterParse: null,\n    constructParseErrorInfo: null,\n    yyMergeLocationInfo: null,\n\n    __reentrant_call_depth: 0,      // INTERNAL USE ONLY\n    __error_infos: [],              // INTERNAL USE ONLY: the set of parseErrorInfo objects created since the last cleanup\n    __error_recovery_infos: [],     // INTERNAL USE ONLY: the set of parseErrorInfo objects created since the last cleanup\n\n    // APIs which will be set up depending on user action code analysis:\n    //yyRecovering: 0,\n    //yyErrOk: 0,\n    //yyClearIn: 0,\n\n    // Helper APIs\n    // -----------\n\n    // Helper function which can be overridden by user code later on: put suitable quotes around\n    // literal IDs in a description string.\n    quoteName: function parser_quoteName(id_str) {\n        return '\"' + id_str + '\"';\n    },\n\n    // Return the name of the given symbol (terminal or non-terminal) as a string, when available.\n    //\n    // Return NULL when the symbol is unknown to the parser.\n    getSymbolName: function parser_getSymbolName(symbol) {\n        if (this.terminals_[symbol]) {\n            return this.terminals_[symbol];\n        }\n\n        // Otherwise... this might refer to a RULE token i.e. a non-terminal: see if we can dig that one up.\n        //\n        // An example of this may be where a rule's action code contains a call like this:\n        //\n        //      parser.getSymbolName(#$)\n        //\n        // to obtain a human-readable name of the current grammar rule.\n        var s = this.symbols_;\n        for (var key in s) {\n            if (s[key] === symbol) {\n                return key;\n            }\n        }\n        return null;\n    },\n\n    // Return a more-or-less human-readable description of the given symbol, when available,\n    // or the symbol itself, serving as its own 'description' for lack of something better to serve up.\n    //\n    // Return NULL when the symbol is unknown to the parser.\n    describeSymbol: function parser_describeSymbol(symbol) {\n        if (symbol !== this.EOF && this.terminal_descriptions_ && this.terminal_descriptions_[symbol]) {\n            return this.terminal_descriptions_[symbol];\n        }\n        else if (symbol === this.EOF) {\n            return 'end of input';\n        }\n        var id = this.getSymbolName(symbol);\n        if (id) {\n            return this.quoteName(id);\n        }\n        return null;\n    },\n\n    // Produce a (more or less) human-readable list of expected tokens at the point of failure.\n    //\n    // The produced list may contain token or token set descriptions instead of the tokens\n    // themselves to help turning this output into something that easier to read by humans\n    // unless `do_not_describe` parameter is set, in which case a list of the raw, *numeric*,\n    // expected terminals and nonterminals is produced.\n    //\n    // The returned list (array) will not contain any duplicate entries.\n    collect_expected_token_set: function parser_collect_expected_token_set(state, do_not_describe) {\n        var TERROR = this.TERROR;\n        var tokenset = [];\n        var check = {};\n        // Has this (error?) state been outfitted with a custom expectations description text for human consumption?\n        // If so, use that one instead of the less palatable token set.\n        if (!do_not_describe && this.state_descriptions_ && this.state_descriptions_[state]) {\n            return [\n                this.state_descriptions_[state]\n            ];\n        }\n        for (var p in this.table[state]) {\n            p = +p;\n            if (p !== TERROR) {\n                var d = do_not_describe ? p : this.describeSymbol(p);\n                if (d && !check[d]) {\n                    tokenset.push(d);\n                    check[d] = true;        // Mark this token description as already mentioned to prevent outputting duplicate entries.\n                }\n            }\n        }\n        return tokenset;\n    },\nproductions_: bp({\n  pop: u([\n  89,\n  89,\n  90,\n  s,\n  [91, 5],\n  92,\n  93,\n  93,\n  s,\n  [94, 4],\n  s,\n  [95, 8],\n  96,\n  96,\n  s,\n  [97, 6],\n  s,\n  [98, 6],\n  99,\n  99,\n  s,\n  [100, 4],\n  s,\n  [101, 3],\n  s,\n  [102, 3],\n  s,\n  [103, 5],\n  s,\n  [104, 3],\n  105,\n  105,\n  106,\n  106,\n  107,\n  107,\n  108,\n  108,\n  109,\n  109,\n  110,\n  110,\n  111,\n  111,\n  s,\n  [112, 11],\n  113,\n  113,\n  114,\n  115,\n  115,\n  s,\n  [116, 8],\n  117,\n  117,\n  118,\n  118,\n  s,\n  [119, 3],\n  s,\n  [120, 13],\n  s,\n  [121, 3],\n  122,\n  122,\n  123,\n  123,\n  124,\n  s,\n  [125, 4],\n  126,\n  126,\n  127,\n  s,\n  [128, 5],\n  129,\n  129,\n  130,\n  130,\n  131,\n  132,\n  132,\n  133,\n  133,\n  s,\n  [134, 6],\n  s,\n  [135, 4],\n  136,\n  136,\n  137,\n  137,\n  138,\n  138,\n  s,\n  [139, 3],\n  140,\n  140,\n  s,\n  [141, 3],\n  s,\n  [142, 9],\n  s,\n  [143, 3],\n  144,\n  144,\n  s,\n  [145, 6],\n  s,\n  [146, 3],\n  147,\n  147,\n  148,\n  148,\n  149,\n  149,\n  150,\n  150,\n  s,\n  [151, 3],\n  s,\n  [152, 6],\n  s,\n  [153, 5],\n  154,\n  154,\n  155,\n  155,\n  156\n]),\n  rule: u([\n  2,\n  s,\n  [1, 9],\n  c,\n  [10, 4],\n  3,\n  1,\n  4,\n  3,\n  4,\n  3,\n  3,\n  2,\n  2,\n  c,\n  [10, 3],\n  s,\n  [2, 4],\n  4,\n  s,\n  [1, 7],\n  4,\n  1,\n  s,\n  [3, 3],\n  c,\n  [4, 3],\n  c,\n  [3, 6],\n  c,\n  [8, 7],\n  c,\n  [36, 3],\n  c,\n  [4, 6],\n  5,\n  c,\n  [4, 3],\n  s,\n  [1, 11],\n  c,\n  [59, 3],\n  c,\n  [3, 3],\n  c,\n  [80, 3],\n  c,\n  [4, 4],\n  c,\n  [32, 4],\n  s,\n  [1, 15],\n  5,\n  4,\n  c,\n  [107, 4],\n  2,\n  3,\n  c,\n  [31, 4],\n  c,\n  [114, 4],\n  5,\n  5,\n  6,\n  c,\n  [40, 8],\n  c,\n  [17, 4],\n  c,\n  [130, 4],\n  c,\n  [125, 3],\n  c,\n  [67, 4],\n  c,\n  [21, 3],\n  c,\n  [139, 3],\n  c,\n  [22, 4],\n  c,\n  [46, 3],\n  3,\n  3,\n  4,\n  c,\n  [4, 4],\n  c,\n  [33, 3],\n  c,\n  [83, 8],\n  c,\n  [41, 3],\n  c,\n  [39, 5],\n  c,\n  [31, 3],\n  5,\n  7,\n  5,\n  5,\n  7,\n  6,\n  7,\n  6,\n  7,\n  c,\n  [49, 3],\n  c,\n  [20, 6],\n  3\n])\n}),\nperformAction: function parser__PerformAction(yytext, yyloc, yystate /* action[1] */, yysp, yyvstack, yylstack) {\n\n          /* this == yyval */\n\n          // the JS engine itself can go and remove these statements when `yy` turns out to be unused in any action code!\n          var yy = this.yy;\n          var yyparser = yy.parser;\n          var yylexer = yy.lexer;\n\n          \n\n          switch (yystate) {\ncase 0:\n    /*! Production::    $accept : ast_tree $end */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,-,-,LT,LA,-,-):\n    this.$ = undefined;\n    this._$ = yylstack[yysp - 1];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,-,-,LT,LA,-,-)\n    break;\n\ncase 1:\n    /*! Production::    ast_tree : translation_unit EOF */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,-,-,LT,LA,-,-):\n    this.$ = undefined;\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,-,-,LT,LA,-,-)\n    \n    \n    return yyvstack[yysp - 1];\n    break;\n\ncase 2:\n    /*! Production::    ast_tree : EOF */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,-,-,LT,LA,-,-):\n    this.$ = undefined;\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,-,-,LT,LA,-,-)\n    \n    \n    return [];\n    break;\n\ncase 3:\n    /*! Production::    identifier : IDENTIFIER */\ncase 9:\n    /*! Production::    string_literal : STRING_LITERAL */\ncase 100:\n    /*! Production::    storage_class_specifier : TYPEDEF */\ncase 101:\n    /*! Production::    storage_class_specifier : EXTERN */\ncase 102:\n    /*! Production::    storage_class_specifier : STATIC */\ncase 103:\n    /*! Production::    type_specifier : VOID */\ncase 104:\n    /*! Production::    type_specifier : CHAR */\ncase 105:\n    /*! Production::    type_specifier : SHORT */\ncase 106:\n    /*! Production::    type_specifier : INT */\ncase 107:\n    /*! Production::    type_specifier : LONG */\ncase 108:\n    /*! Production::    type_specifier : FLOAT */\ncase 109:\n    /*! Production::    type_specifier : DOUBLE */\ncase 110:\n    /*! Production::    type_specifier : SIGNED */\ncase 111:\n    /*! Production::    type_specifier : UNSIGNED */\ncase 142:\n    /*! Production::    function_specifier : IMPORT */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (yytext);\n    break;\n\ncase 4:\n    /*! Production::    constant : CONSTANT_FLOAT */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.Constant(this._$, yytext, \"float\"));\n    break;\n\ncase 5:\n    /*! Production::    constant : CONSTANT_HEX */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.Constant(this._$, yytext, \"hex\"));\n    break;\n\ncase 6:\n    /*! Production::    constant : CONSTANT_OCTAL */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.Constant(this._$, yytext, \"oct\"));\n    break;\n\ncase 7:\n    /*! Production::    constant : CONSTANT_INT */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.Constant(this._$, yytext, \"int\"));\n    break;\n\ncase 8:\n    /*! Production::    constant : CONSTANT_CHAR */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.Constant(this._$, yytext, \"char\"));\n    break;\n\ncase 10:\n    /*! Production::    concat_string_literals : string_literal */\ncase 13:\n    /*! Production::    primary_expression : constant */\ncase 16:\n    /*! Production::    postfix_expression : primary_expression */\ncase 26:\n    /*! Production::    unary_expression : postfix_expression */\ncase 38:\n    /*! Production::    cast_expression : unary_expression */\ncase 40:\n    /*! Production::    multiplicative_expression : cast_expression */\ncase 44:\n    /*! Production::    additive_expression : multiplicative_expression */\ncase 47:\n    /*! Production::    shift_expression : additive_expression */\ncase 50:\n    /*! Production::    relational_expression : shift_expression */\ncase 55:\n    /*! Production::    equality_expression : relational_expression */\ncase 58:\n    /*! Production::    and_expression : equality_expression */\ncase 60:\n    /*! Production::    exclusive_or_expression : and_expression */\ncase 62:\n    /*! Production::    inclusive_or_expression : exclusive_or_expression */\ncase 64:\n    /*! Production::    logical_and_expression : inclusive_or_expression */\ncase 66:\n    /*! Production::    logical_or_expression : logical_and_expression */\ncase 68:\n    /*! Production::    conditional_expression : logical_or_expression */\ncase 70:\n    /*! Production::    assignment_expression : conditional_expression */\ncase 83:\n    /*! Production::    expression : assignment_expression */\ncase 98:\n    /*! Production::    init_declarator : declarator */\ncase 113:\n    /*! Production::    type_specifier : struct_or_union_specifier */\ncase 114:\n    /*! Production::    type_specifier : enum_specifier */\ncase 130:\n    /*! Production::    struct_declarator : declarator */\ncase 144:\n    /*! Production::    declarator : direct_declarator */\ncase 167:\n    /*! Production::    abstract_declarator : direct_abstract_declarator */\ncase 178:\n    /*! Production::    initializer : assignment_expression */\ncase 183:\n    /*! Production::    statement : labeled_statement */\ncase 184:\n    /*! Production::    statement : compound_statement */\ncase 185:\n    /*! Production::    statement : expression_statement */\ncase 186:\n    /*! Production::    statement : selection_statement */\ncase 187:\n    /*! Production::    statement : iteration_statement */\ncase 188:\n    /*! Production::    statement : jump_statement */\ncase 196:\n    /*! Production::    block_item : declaration */\ncase 197:\n    /*! Production::    block_item : statement */\ncase 216:\n    /*! Production::    external_declaration : function_definition */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (yyvstack[yysp]);\n    break;\n\ncase 11:\n    /*! Production::    concat_string_literals : concat_string_literals string_literal */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (yyvstack[yysp - 1] + yyvstack[yysp]);\n    break;\n\ncase 12:\n    /*! Production::    primary_expression : identifier */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.Identifier(this._$, yytext));\n    break;\n\ncase 14:\n    /*! Production::    primary_expression : concat_string_literals */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.StringLiteral(this._$, yyvstack[yysp]));\n    break;\n\ncase 15:\n    /*! Production::    primary_expression : \"(\" expression \")\" */\ncase 146:\n    /*! Production::    direct_declarator : \"(\" declarator \")\" */\ncase 169:\n    /*! Production::    direct_abstract_declarator : \"(\" abstract_declarator \")\" */\ncase 179:\n    /*! Production::    initializer : \"{\" initializer_list \"}\" */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (yyvstack[yysp - 1]);\n    break;\n\ncase 17:\n    /*! Production::    postfix_expression : postfix_expression \"[\" expression \"]\" */\n\n    // default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);\n    // END of default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"arraySubscript\", yyvstack[yysp - 3], yyvstack[yysp - 1]));\n    break;\n\ncase 18:\n    /*! Production::    postfix_expression : postfix_expression \"(\" \")\" */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.FunctionCallExpression(this._$, yyvstack[yysp - 2]));\n    break;\n\ncase 19:\n    /*! Production::    postfix_expression : postfix_expression \"(\" argument_expression_list \")\" */\n\n    // default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);\n    // END of default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.FunctionCallExpression(this._$, yyvstack[yysp - 3], yyvstack[yysp - 1]));\n    break;\n\ncase 20:\n    /*! Production::    postfix_expression : postfix_expression \".\" identifier */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.MemberAccessExpression(this._$, false, yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 21:\n    /*! Production::    postfix_expression : postfix_expression \"->\" identifier */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.MemberAccessExpression(this._$, true, yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 22:\n    /*! Production::    postfix_expression : postfix_expression \"++\" */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.UnaryExpression(this._$, \"postfixIncrement\", yyvstack[yysp - 1]));\n    break;\n\ncase 23:\n    /*! Production::    postfix_expression : postfix_expression \"--\" */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.UnaryExpression(this._$, \"postfixDecrement\", yyvstack[yysp - 1]));\n    break;\n\ncase 24:\n    /*! Production::    argument_expression_list : assignment_expression */\ncase 96:\n    /*! Production::    init_declarator_list : init_declarator */\ncase 121:\n    /*! Production::    struct_declaration_list : struct_declaration */\ncase 128:\n    /*! Production::    struct_declarator_list : struct_declarator */\ncase 136:\n    /*! Production::    enumerator_list : enumerator */\ncase 155:\n    /*! Production::    type_qualifier_list : type_qualifier */\ncase 159:\n    /*! Production::    parameter_list : parameter_declaration */\ncase 181:\n    /*! Production::    initializer_list : initializer */\ncase 194:\n    /*! Production::    block_item_list : block_item */\ncase 214:\n    /*! Production::    translation_unit : external_declaration */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = ([yyvstack[yysp]]);\n    break;\n\ncase 25:\n    /*! Production::    argument_expression_list : argument_expression_list \",\" assignment_expression */\ncase 97:\n    /*! Production::    init_declarator_list : init_declarator_list \",\" init_declarator */\ncase 129:\n    /*! Production::    struct_declarator_list : struct_declarator_list \",\" struct_declarator */\ncase 137:\n    /*! Production::    enumerator_list : enumerator_list \",\" enumerator */\ncase 160:\n    /*! Production::    parameter_list : parameter_list \",\" parameter_declaration */\ncase 182:\n    /*! Production::    initializer_list : initializer_list \",\" initializer */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = ((yyvstack[yysp - 2].push(yyvstack[yysp]), yyvstack[yysp - 2]));\n    break;\n\ncase 27:\n    /*! Production::    unary_expression : \"++\" unary_expression */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.UnaryExpression(this._$, \"prefixIncrement\", yyvstack[yysp]));\n    break;\n\ncase 28:\n    /*! Production::    unary_expression : \"--\" unary_expression */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.UnaryExpression(this._$, \"prefixDecrement\", yyvstack[yysp]));\n    break;\n\ncase 29:\n    /*! Production::    unary_expression : unary_operator cast_expression */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.UnaryExpression(this._$, yyvstack[yysp - 1], yyvstack[yysp]));\n    break;\n\ncase 30:\n    /*! Production::    unary_expression : SIZEOF unary_expression */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.SizeofExpression(this._$, yyvstack[yysp]));\n    break;\n\ncase 31:\n    /*! Production::    unary_expression : SIZEOF \"(\" type_name \")\" */\n\n    // default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);\n    // END of default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.SizeofExpression(this._$, yyvstack[yysp - 1]));\n    break;\n\ncase 32:\n    /*! Production::    unary_operator : \"&\" */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"addressOf\");\n    break;\n\ncase 33:\n    /*! Production::    unary_operator : \"*\" */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"dereference\");\n    break;\n\ncase 34:\n    /*! Production::    unary_operator : \"+\" */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"unaryPlus\");\n    break;\n\ncase 35:\n    /*! Production::    unary_operator : \"-\" */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"unaryMinus\");\n    break;\n\ncase 36:\n    /*! Production::    unary_operator : \"~\" */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"bitwiseNot\");\n    break;\n\ncase 37:\n    /*! Production::    unary_operator : \"!\" */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"logicalNot\");\n    break;\n\ncase 39:\n    /*! Production::    cast_expression : \"(\" type_name \")\" cast_expression */\n\n    // default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);\n    // END of default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.CastExpression(this._$, yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 41:\n    /*! Production::    multiplicative_expression : multiplicative_expression \"*\" cast_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"mul\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 42:\n    /*! Production::    multiplicative_expression : multiplicative_expression \"/\" cast_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"div\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 43:\n    /*! Production::    multiplicative_expression : multiplicative_expression \"%\" cast_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"mod\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 45:\n    /*! Production::    additive_expression : additive_expression \"+\" multiplicative_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"add\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 46:\n    /*! Production::    additive_expression : additive_expression \"-\" multiplicative_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"sub\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 48:\n    /*! Production::    shift_expression : shift_expression \"<<\" additive_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"bitwiseShiftLeft\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 49:\n    /*! Production::    shift_expression : shift_expression \">>\" additive_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"bitwiseShiftRight\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 51:\n    /*! Production::    relational_expression : relational_expression \"<\" shift_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"relationalLT\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 52:\n    /*! Production::    relational_expression : relational_expression \">\" shift_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"relationalGT\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 53:\n    /*! Production::    relational_expression : relational_expression \"<=\" shift_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"relationalLEq\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 54:\n    /*! Production::    relational_expression : relational_expression \">=\" shift_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"relationalGEq\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 56:\n    /*! Production::    equality_expression : equality_expression \"==\" relational_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"relationalEq\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 57:\n    /*! Production::    equality_expression : equality_expression \"!=\" relational_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"relationalNEq\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 59:\n    /*! Production::    and_expression : and_expression \"&\" equality_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"bitwiseAnd\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 61:\n    /*! Production::    exclusive_or_expression : exclusive_or_expression \"^\" and_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"bitwiseXor\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 63:\n    /*! Production::    inclusive_or_expression : inclusive_or_expression \"|\" exclusive_or_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"bitwiseOr\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 65:\n    /*! Production::    logical_and_expression : logical_and_expression \"&&\" inclusive_or_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"logicalAnd\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 67:\n    /*! Production::    logical_or_expression : logical_or_expression \"||\" logical_and_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"logicalOr\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 69:\n    /*! Production::    conditional_expression : logical_or_expression \"?\" expression \":\" conditional_expression */\n\n    // default action (generated by JISON mode none/merge :: 5,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 4, yysp);\n    // END of default action (generated by JISON mode none/merge :: 5,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.ConditionalExpression(this._$, yyvstack[yysp - 4], yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 71:\n    /*! Production::    assignment_expression : unary_expression assignment_operator assignment_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.AssignmentExpression(this._$, yyvstack[yysp - 1], yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 72:\n    /*! Production::    assignment_operator : \"=\" */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (undefined);\n    break;\n\ncase 73:\n    /*! Production::    assignment_operator : \"*=\" */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"mul\");\n    break;\n\ncase 74:\n    /*! Production::    assignment_operator : \"/=\" */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"div\");\n    break;\n\ncase 75:\n    /*! Production::    assignment_operator : \"%=\" */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"mod\");\n    break;\n\ncase 76:\n    /*! Production::    assignment_operator : \"+=\" */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"add\");\n    break;\n\ncase 77:\n    /*! Production::    assignment_operator : \"-=\" */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"sub\");\n    break;\n\ncase 78:\n    /*! Production::    assignment_operator : \"<<=\" */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"leftShift\");\n    break;\n\ncase 79:\n    /*! Production::    assignment_operator : \">>=\" */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"rightShift\");\n    break;\n\ncase 80:\n    /*! Production::    assignment_operator : \"&=\" */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"bitwiseAnd\");\n    break;\n\ncase 81:\n    /*! Production::    assignment_operator : \"^=\" */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"bitwiseXor\");\n    break;\n\ncase 82:\n    /*! Production::    assignment_operator : \"|=\" */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"bitwiseOr\");\n    break;\n\ncase 84:\n    /*! Production::    expression : expression \",\" assignment_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"comma\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 85:\n    /*! Production::    constant_expression : conditional_expression */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.ConstantExpression(this._$, yyvstack[yysp]));\n    break;\n\ncase 86:\n    /*! Production::    declaration : declaration_specifiers \";\" */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.Declaration(this._$, yyvstack[yysp - 1]));\n    break;\n\ncase 87:\n    /*! Production::    declaration : declaration_specifiers init_declarator_list \";\" */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.Declaration(this._$, yyvstack[yysp - 2], yyvstack[yysp - 1]));\n    break;\n\ncase 88:\n    /*! Production::    declaration_specifiers : storage_class_specifier */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.DeclarationSpecifiers(this._$, [], [], [yyvstack[yysp]], []));\n    break;\n\ncase 89:\n    /*! Production::    declaration_specifiers : storage_class_specifier declaration_specifiers */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.DeclarationSpecifiers(this._$, yyvstack[yysp].specifierList, yyvstack[yysp].qualifierList, [yyvstack[yysp - 1], ...yyvstack[yysp].storageList], yyvstack[yysp].fnSpecifierList));\n    break;\n\ncase 90:\n    /*! Production::    declaration_specifiers : type_specifier */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.DeclarationSpecifiers(this._$, [yyvstack[yysp]], [], [], []));\n    break;\n\ncase 91:\n    /*! Production::    declaration_specifiers : type_specifier declaration_specifiers */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.DeclarationSpecifiers(this._$, [yyvstack[yysp - 1], ...yyvstack[yysp].specifierList], yyvstack[yysp].qualifierList, yyvstack[yysp].storageList, yyvstack[yysp].fnSpecifierList));\n    break;\n\ncase 92:\n    /*! Production::    declaration_specifiers : type_qualifier */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.DeclarationSpecifiers(this._$, [], [yyvstack[yysp]], [], []));\n    break;\n\ncase 93:\n    /*! Production::    declaration_specifiers : type_qualifier declaration_specifiers */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.DeclarationSpecifiers(this._$, yyvstack[yysp].specifierList, [yyvstack[yysp - 1], ...yyvstack[yysp].qualifierList], yyvstack[yysp].storageList, yyvstack[yysp].fnSpecifierList));\n    break;\n\ncase 94:\n    /*! Production::    declaration_specifiers : function_specifier */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.DeclarationSpecifiers(this._$, [], [], [], [yyvstack[yysp]]));\n    break;\n\ncase 95:\n    /*! Production::    declaration_specifiers : function_specifier declaration_specifiers */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.DeclarationSpecifiers(this._$, yyvstack[yysp].specifierList, yyvstack[yysp].qualifierList, yyvstack[yysp].storageList, [yyvstack[yysp - 1], ...yyvstack[yysp].fnSpecifierList]));\n    break;\n\ncase 99:\n    /*! Production::    init_declarator : declarator \"=\" initializer */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.InitDeclarator(this._$, yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 112:\n    /*! Production::    type_specifier : _BOOL */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"bool\");\n    break;\n\ncase 115:\n    /*! Production::    type_specifier : TYPE_NAME */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.CustomTypeSpecifier(this._$, yyvstack[yysp]));\n    break;\n\ncase 116:\n    /*! Production::    struct_or_union_specifier : struct_or_union identifier \"{\" struct_declaration_list \"}\" */\n\n    // default action (generated by JISON mode none/merge :: 5,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 4, yysp);\n    // END of default action (generated by JISON mode none/merge :: 5,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.StructUnionSpecifier(this._$, yyvstack[yysp - 4], yyvstack[yysp - 3], yyvstack[yysp - 1]));\n    break;\n\ncase 117:\n    /*! Production::    struct_or_union_specifier : struct_or_union \"{\" struct_declaration_list \"}\" */\n\n    // default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);\n    // END of default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.StructUnionSpecifier(this._$, yyvstack[yysp - 3], undefined, yyvstack[yysp - 1]));\n    break;\n\ncase 118:\n    /*! Production::    struct_or_union_specifier : struct_or_union identifier */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.StructUnionSpecifier(this._$, yyvstack[yysp - 1], yyvstack[yysp]));\n    break;\n\ncase 119:\n    /*! Production::    struct_or_union : STRUCT */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"struct\");\n    break;\n\ncase 120:\n    /*! Production::    struct_or_union : UNION */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"union\");\n    break;\n\ncase 122:\n    /*! Production::    struct_declaration_list : struct_declaration_list struct_declaration */\ncase 156:\n    /*! Production::    type_qualifier_list : type_qualifier_list type_qualifier */\ncase 195:\n    /*! Production::    block_item_list : block_item_list block_item */\ncase 215:\n    /*! Production::    translation_unit : translation_unit external_declaration */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = ((yyvstack[yysp - 1].push(yyvstack[yysp]), yyvstack[yysp - 1]));\n    break;\n\ncase 123:\n    /*! Production::    struct_declaration : specifier_qualifier_list struct_declarator_list \";\" */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.StructDeclaration(this._$, yyvstack[yysp - 2], yyvstack[yysp - 1]));\n    break;\n\ncase 124:\n    /*! Production::    specifier_qualifier_list : type_specifier specifier_qualifier_list */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.SpecifierQualifiers(this._$, [yyvstack[yysp - 1], ...yyvstack[yysp].specifierList], yyvstack[yysp].qualifierList));\n    break;\n\ncase 125:\n    /*! Production::    specifier_qualifier_list : type_specifier */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.SpecifierQualifiers(this._$, [yyvstack[yysp]], []));\n    break;\n\ncase 126:\n    /*! Production::    specifier_qualifier_list : type_qualifier specifier_qualifier_list */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.SpecifierQualifiers(this._$, yyvstack[yysp].specifierList, [yyvstack[yysp - 1], ...yyvstack[yysp].qualifierList]));\n    break;\n\ncase 127:\n    /*! Production::    specifier_qualifier_list : type_qualifier */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.SpecifierQualifiers(this._$, [], [yyvstack[yysp]]));\n    break;\n\ncase 131:\n    /*! Production::    enum_specifier : ENUM \"{\" enumerator_list \"}\" */\n\n    // default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);\n    // END of default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.EnumSpecifier(this._$, undefined, yyvstack[yysp - 1]));\n    break;\n\ncase 132:\n    /*! Production::    enum_specifier : ENUM identifier \"{\" enumerator_list \"}\" */\n\n    // default action (generated by JISON mode none/merge :: 5,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 4, yysp);\n    // END of default action (generated by JISON mode none/merge :: 5,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.EnumSpecifier(this._$, yyvstack[yysp - 3], yyvstack[yysp - 1]));\n    break;\n\ncase 133:\n    /*! Production::    enum_specifier : ENUM \"{\" enumerator_list \",\" \"}\" */\n\n    // default action (generated by JISON mode none/merge :: 5,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 4, yysp);\n    // END of default action (generated by JISON mode none/merge :: 5,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.EnumSpecifier(this._$, undefined, yyvstack[yysp - 2]));\n    break;\n\ncase 134:\n    /*! Production::    enum_specifier : ENUM identifier \"{\" enumerator_list \",\" \"}\" */\n\n    // default action (generated by JISON mode none/merge :: 6,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 5, yysp);\n    // END of default action (generated by JISON mode none/merge :: 6,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.EnumSpecifier(this._$, yyvstack[yysp - 4], yyvstack[yysp - 2]));\n    break;\n\ncase 135:\n    /*! Production::    enum_specifier : ENUM identifier */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.EnumSpecifier(this._$, yyvstack[yysp]));\n    break;\n\ncase 138:\n    /*! Production::    enumerator : identifier */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.Enumerator(this._$, yyvstack[yysp]));\n    break;\n\ncase 139:\n    /*! Production::    enumerator : identifier \"=\" constant_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.Enumerator(this._$, yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 140:\n    /*! Production::    type_qualifier : CONST */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"const\");\n    break;\n\ncase 141:\n    /*! Production::    function_specifier : INLINE */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"inline\");\n    break;\n\ncase 143:\n    /*! Production::    declarator : pointer direct_declarator */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.PointerDeclarator(this._$, yyvstack[yysp - 1], yyvstack[yysp]));\n    break;\n\ncase 145:\n    /*! Production::    direct_declarator : identifier */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.IdentifierDeclarator(this._$, yyvstack[yysp]));\n    break;\n\ncase 147:\n    /*! Production::    direct_declarator : direct_declarator \"[\" constant_expression \"]\" */\n\n    // default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);\n    // END of default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.ArrayDeclarator(this._$, yyvstack[yysp - 3], yyvstack[yysp - 1]));\n    break;\n\ncase 148:\n    /*! Production::    direct_declarator : direct_declarator \"[\" \"]\" */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.ArrayDeclarator(this._$, yyvstack[yysp - 2]));\n    break;\n\ncase 149:\n    /*! Production::    direct_declarator : direct_declarator \"(\" parameter_type_list \")\" */\n\n    // default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);\n    // END of default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.FunctionDeclarator(this._$, yyvstack[yysp - 3], yyvstack[yysp - 1], yyvstack[yysp - 1].variadic));\n    break;\n\ncase 150:\n    /*! Production::    direct_declarator : direct_declarator \"(\" \")\" */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.FunctionDeclarator(this._$, yyvstack[yysp - 2]));\n    break;\n\ncase 151:\n    /*! Production::    pointer : \"*\" */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.Pointer(this._$));\n    break;\n\ncase 152:\n    /*! Production::    pointer : \"*\" type_qualifier_list */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.Pointer(this._$, yyvstack[yysp]));\n    break;\n\ncase 153:\n    /*! Production::    pointer : \"*\" pointer */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.Pointer(this._$, undefined, yyvstack[yysp]));\n    break;\n\ncase 154:\n    /*! Production::    pointer : \"*\" type_qualifier_list pointer */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.Pointer(this._$, yyvstack[yysp - 1], yyvstack[yysp]));\n    break;\n\ncase 157:\n    /*! Production::    parameter_type_list : parameter_list */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = ((yyvstack[yysp].variadic = false, yyvstack[yysp]));\n    break;\n\ncase 158:\n    /*! Production::    parameter_type_list : parameter_list \",\" \"...\" */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = ((yyvstack[yysp - 2].variadic = true, yyvstack[yysp - 2]));\n    break;\n\ncase 161:\n    /*! Production::    parameter_declaration : declaration_specifiers declarator */\ncase 162:\n    /*! Production::    parameter_declaration : declaration_specifiers abstract_declarator */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.ParameterDeclaration(this._$, yyvstack[yysp - 1], yyvstack[yysp]));\n    break;\n\ncase 163:\n    /*! Production::    parameter_declaration : declaration_specifiers */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.ParameterDeclaration(this._$, yyvstack[yysp]));\n    break;\n\ncase 164:\n    /*! Production::    type_name : specifier_qualifier_list */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.TypeName(this._$, yyvstack[yysp]));\n    break;\n\ncase 165:\n    /*! Production::    type_name : specifier_qualifier_list abstract_declarator */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.TypeName(this._$, yyvstack[yysp - 1], yyvstack[yysp]));\n    break;\n\ncase 166:\n    /*! Production::    abstract_declarator : pointer */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.AbstractPointerDeclarator(this._$, yyvstack[yysp]));\n    break;\n\ncase 168:\n    /*! Production::    abstract_declarator : pointer direct_abstract_declarator */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.AbstractPointerDeclarator(this._$, yyvstack[yysp - 1], yyvstack[yysp]));\n    break;\n\ncase 170:\n    /*! Production::    direct_abstract_declarator : \"[\" \"]\" */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.AbstractArrayDeclarator(this._$));\n    break;\n\ncase 171:\n    /*! Production::    direct_abstract_declarator : \"[\" constant_expression \"]\" */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.AbstractArrayDeclarator(this._$, undefined, yyvstack[yysp - 1]));\n    break;\n\ncase 172:\n    /*! Production::    direct_abstract_declarator : direct_abstract_declarator \"[\" \"]\" */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.AbstractArrayDeclarator(this._$, yyvstack[yysp - 2]));\n    break;\n\ncase 173:\n    /*! Production::    direct_abstract_declarator : direct_abstract_declarator \"[\" constant_expression \"]\" */\n\n    // default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);\n    // END of default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.AbstractArrayDeclarator(this._$, yyvstack[yysp - 3], yyvstack[yysp - 1]));\n    break;\n\ncase 174:\n    /*! Production::    direct_abstract_declarator : \"(\" \")\" */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.AbstractFunctionDeclarator(this._$));\n    break;\n\ncase 175:\n    /*! Production::    direct_abstract_declarator : \"(\" parameter_type_list \")\" */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.AbstractFunctionDeclarator(this._$, undefined, yyvstack[yysp - 1], yyvstack[yysp - 1].variadic));\n    break;\n\ncase 176:\n    /*! Production::    direct_abstract_declarator : direct_abstract_declarator \"(\" \")\" */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.AbstractFunctionDeclarator(this._$, yyvstack[yysp - 2]));\n    break;\n\ncase 177:\n    /*! Production::    direct_abstract_declarator : direct_abstract_declarator \"(\" parameter_type_list \")\" */\n\n    // default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);\n    // END of default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.AbstractFunctionDeclarator(this._$, yyvstack[yysp - 3], yyvstack[yysp - 1], yyvstack[yysp - 1].variadic));\n    break;\n\ncase 180:\n    /*! Production::    initializer : \"{\" initializer_list \",\" \"}\" */\n\n    // default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);\n    // END of default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (yyvstack[yysp - 2]);\n    break;\n\ncase 189:\n    /*! Production::    labeled_statement : identifier \":\" statement */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (yyvstack[yysp].setLabel(yyvstack[yysp - 2]));\n    break;\n\ncase 190:\n    /*! Production::    labeled_statement : CASE constant_expression \":\" statement */\n\n    // default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);\n    // END of default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.CaseStatement(this._$, yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 191:\n    /*! Production::    labeled_statement : DEFAULT \":\" statement */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.DefaultStatement(this._$, yyvstack[yysp]));\n    break;\n\ncase 192:\n    /*! Production::    compound_statement : \"{\" \"}\" */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.CompoundStatement(this._$, []));\n    break;\n\ncase 193:\n    /*! Production::    compound_statement : \"{\" block_item_list \"}\" */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.CompoundStatement(this._$, yyvstack[yysp - 1]));\n    break;\n\ncase 198:\n    /*! Production::    expression_statement : \";\" */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.NoOp(this._$));\n    break;\n\ncase 199:\n    /*! Production::    expression_statement : expression \";\" */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.ExpressionStatement(this._$, yyvstack[yysp - 1]));\n    break;\n\ncase 200:\n    /*! Production::    selection_statement : IF \"(\" expression \")\" statement */\n\n    // default action (generated by JISON mode none/merge :: 5,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 4, yysp);\n    // END of default action (generated by JISON mode none/merge :: 5,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.IfStatement(this._$, yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 201:\n    /*! Production::    selection_statement : IF \"(\" expression \")\" statement ELSE statement */\n\n    // default action (generated by JISON mode none/merge :: 7,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 6, yysp);\n    // END of default action (generated by JISON mode none/merge :: 7,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.IfStatement(this._$, yyvstack[yysp - 4], yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 202:\n    /*! Production::    selection_statement : SWITCH \"(\" expression \")\" statement */\n\n    // default action (generated by JISON mode none/merge :: 5,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 4, yysp);\n    // END of default action (generated by JISON mode none/merge :: 5,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.SwitchStatement(this._$, yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 203:\n    /*! Production::    iteration_statement : WHILE \"(\" expression \")\" statement */\n\n    // default action (generated by JISON mode none/merge :: 5,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 4, yysp);\n    // END of default action (generated by JISON mode none/merge :: 5,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.WhileLoop(this._$, yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 204:\n    /*! Production::    iteration_statement : DO statement WHILE \"(\" expression \")\" \";\" */\n\n    // default action (generated by JISON mode none/merge :: 7,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 6, yysp);\n    // END of default action (generated by JISON mode none/merge :: 7,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.DoWhileLoop(this._$, yyvstack[yysp - 5], yyvstack[yysp - 2]));\n    break;\n\ncase 205:\n    /*! Production::    iteration_statement : FOR \"(\" expression_statement expression_statement \")\" statement */\ncase 207:\n    /*! Production::    iteration_statement : FOR \"(\" declaration expression_statement \")\" statement */\n\n    // default action (generated by JISON mode none/merge :: 6,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 5, yysp);\n    // END of default action (generated by JISON mode none/merge :: 6,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.ForLoop(this._$, yyvstack[yysp - 3], yyvstack[yysp - 2], undefined, yyvstack[yysp]));\n    break;\n\ncase 206:\n    /*! Production::    iteration_statement : FOR \"(\" expression_statement expression_statement expression \")\" statement */\ncase 208:\n    /*! Production::    iteration_statement : FOR \"(\" declaration expression_statement expression \")\" statement */\n\n    // default action (generated by JISON mode none/merge :: 7,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 6, yysp);\n    // END of default action (generated by JISON mode none/merge :: 7,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.ForLoop(this._$, yyvstack[yysp - 4], yyvstack[yysp - 3], yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 209:\n    /*! Production::    jump_statement : GOTO identifier \";\" */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.GotoStatement(this._$, yyvstack[yysp - 1]));\n    break;\n\ncase 210:\n    /*! Production::    jump_statement : CONTINUE \";\" */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.ContinueStatement(this._$));\n    break;\n\ncase 211:\n    /*! Production::    jump_statement : BREAK \";\" */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BreakStatement(this._$));\n    break;\n\ncase 212:\n    /*! Production::    jump_statement : RETURN \";\" */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.ReturnStatement(this._$));\n    break;\n\ncase 213:\n    /*! Production::    jump_statement : RETURN expression \";\" */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.ReturnStatement(this._$, yyvstack[yysp - 1]));\n    break;\n\ncase 217:\n    /*! Production::    external_declaration : declaration */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = ((yylexer.externalDeclaration(yyvstack[yysp]), yyvstack[yysp]));\n    break;\n\ncase 218:\n    /*! Production::    function_definition : declaration_specifiers declarator compound_statement */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.FunctionDefinition(this._$, yyvstack[yysp - 2], yyvstack[yysp - 1], yyvstack[yysp]));\n    break;\n\n}\n},\ntable: bt({\n  len: u([\n  34,\n  1,\n  32,\n  s,\n  [0, 4],\n  10,\n  s,\n  [35, 4],\n  s,\n  [0, 19],\n  3,\n  3,\n  s,\n  [0, 4],\n  5,\n  0,\n  2,\n  4,\n  7,\n  0,\n  10,\n  0,\n  7,\n  s,\n  [0, 5],\n  28,\n  23,\n  4,\n  28,\n  0,\n  40,\n  91,\n  0,\n  8,\n  7,\n  39,\n  32,\n  9,\n  0,\n  0,\n  1,\n  23,\n  23,\n  0,\n  9,\n  26,\n  26,\n  2,\n  0,\n  3,\n  4,\n  0,\n  0,\n  41,\n  0,\n  37,\n  8,\n  42,\n  25,\n  25,\n  26,\n  25,\n  c,\n  [25, 3],\n  s,\n  [0, 5],\n  10,\n  0,\n  0,\n  44,\n  61,\n  11,\n  s,\n  [0, 6],\n  12,\n  0,\n  14,\n  18,\n  20,\n  22,\n  25,\n  0,\n  0,\n  90,\n  c,\n  [25, 6],\n  s,\n  [0, 4],\n  39,\n  38,\n  1,\n  0,\n  2,\n  s,\n  [1, 3],\n  59,\n  1,\n  c,\n  [6, 3],\n  40,\n  c,\n  [113, 3],\n  1,\n  s,\n  [0, 3],\n  c,\n  [19, 3],\n  c,\n  [45, 3],\n  0,\n  0,\n  23,\n  0,\n  c,\n  [9, 3],\n  s,\n  [0, 4],\n  4,\n  38,\n  2,\n  2,\n  0,\n  38,\n  s,\n  [0, 11],\n  39,\n  35,\n  39,\n  40,\n  c,\n  [19, 3],\n  c,\n  [9, 3],\n  s,\n  [0, 3],\n  61,\n  34,\n  33,\n  c,\n  [68, 3],\n  7,\n  32,\n  31,\n  30,\n  30,\n  s,\n  [29, 4],\n  28,\n  28,\n  27,\n  27,\n  s,\n  [26, 3],\n  0,\n  0,\n  59,\n  1,\n  59,\n  0,\n  38,\n  s,\n  [39, 3],\n  1,\n  70,\n  c,\n  [85, 4],\n  c,\n  [46, 3],\n  30,\n  0,\n  0,\n  8,\n  4,\n  42,\n  c,\n  [51, 3],\n  8,\n  c,\n  [85, 5],\n  c,\n  [174, 3],\n  2,\n  9,\n  2,\n  c,\n  [99, 5],\n  1,\n  10,\n  11,\n  0,\n  26,\n  c,\n  [103, 3],\n  12,\n  14,\n  18,\n  18,\n  s,\n  [20, 4],\n  22,\n  22,\n  25,\n  c,\n  [168, 3],\n  c,\n  [67, 3],\n  c,\n  [56, 3],\n  2,\n  2,\n  1,\n  41,\n  41,\n  c,\n  [49, 5],\n  39,\n  32,\n  1,\n  c,\n  [156, 3],\n  c,\n  [77, 4],\n  0,\n  37,\n  0,\n  c,\n  [144, 5],\n  s,\n  [59, 3],\n  39,\n  40,\n  40,\n  c,\n  [21, 8],\n  0,\n  52,\n  c,\n  [47, 3],\n  59,\n  2,\n  59,\n  c,\n  [82, 3],\n  59,\n  1,\n  c,\n  [60, 3],\n  c,\n  [62, 3],\n  0,\n  0\n]),\n  symbol: u([\n  1,\n  s,\n  [56, 20, 1],\n  89,\n  115,\n  116,\n  s,\n  [119, 4, 1],\n  128,\n  131,\n  132,\n  154,\n  155,\n  156,\n  1,\n  c,\n  [35, 21],\n  c,\n  [34, 9],\n  155,\n  156,\n  3,\n  10,\n  24,\n  27,\n  90,\n  117,\n  118,\n  133,\n  134,\n  135,\n  3,\n  4,\n  5,\n  8,\n  c,\n  [13, 3],\n  c,\n  [48, 20],\n  c,\n  [47, 8],\n  c,\n  [35, 105],\n  25,\n  27,\n  90,\n  c,\n  [3, 3],\n  8,\n  23,\n  24,\n  25,\n  147,\n  8,\n  24,\n  3,\n  27,\n  90,\n  134,\n  c,\n  [52, 4],\n  c,\n  [14, 3],\n  c,\n  [59, 5],\n  27,\n  73,\n  131,\n  135,\n  136,\n  3,\n  10,\n  27,\n  90,\n  c,\n  [181, 9],\n  25,\n  c,\n  [77, 21],\n  c,\n  [17, 15],\n  s,\n  [120, 6, 1],\n  128,\n  131,\n  27,\n  90,\n  129,\n  130,\n  c,\n  [55, 28],\n  3,\n  s,\n  [9, 6, 1],\n  25,\n  s,\n  [27, 7, 1],\n  35,\n  36,\n  37,\n  s,\n  [90, 6, 1],\n  s,\n  [97, 15, 1],\n  143,\n  c,\n  [40, 7],\n  s,\n  [24, 10, 1],\n  c,\n  [42, 3],\n  c,\n  [80, 20],\n  77,\n  78,\n  79,\n  s,\n  [81, 8, 1],\n  c,\n  [73, 21],\n  113,\n  c,\n  [398, 9],\n  s,\n  [145, 9, 1],\n  c,\n  [221, 4],\n  c,\n  [403, 8],\n  c,\n  [246, 4],\n  6,\n  c,\n  [107, 6],\n  c,\n  [146, 30],\n  114,\n  4,\n  c,\n  [338, 28],\n  137,\n  138,\n  139,\n  c,\n  [317, 9],\n  4,\n  c,\n  [282, 23],\n  26,\n  c,\n  [24, 18],\n  c,\n  [23, 4],\n  c,\n  [142, 4],\n  126,\n  127,\n  c,\n  [143, 6],\n  10,\n  27,\n  c,\n  [36, 18],\n  c,\n  [35, 4],\n  c,\n  [26, 25],\n  8,\n  26,\n  8,\n  23,\n  26,\n  c,\n  [371, 5],\n  c,\n  [343, 39],\n  144,\n  4,\n  6,\n  s,\n  [8, 5, 1],\n  s,\n  [15, 10, 1],\n  26,\n  s,\n  [38, 18, 1],\n  112,\n  c,\n  [37, 3],\n  21,\n  22,\n  24,\n  26,\n  45,\n  s,\n  [3, 10, 1],\n  c,\n  [48, 11],\n  34,\n  35,\n  36,\n  c,\n  [51, 18],\n  c,\n  [128, 7],\n  c,\n  [127, 18],\n  c,\n  [25, 50],\n  99,\n  c,\n  [26, 25],\n  c,\n  [151, 7],\n  44,\n  45,\n  c,\n  [9, 3],\n  c,\n  [140, 3],\n  c,\n  [10, 4],\n  c,\n  [162, 21],\n  s,\n  [33, 4, 1],\n  c,\n  [163, 18],\n  92,\n  c,\n  [88, 17],\n  c,\n  [339, 15],\n  c,\n  [576, 22],\n  c,\n  [361, 6],\n  140,\n  c,\n  [115, 3],\n  c,\n  [94, 4],\n  c,\n  [126, 7],\n  9,\n  c,\n  [12, 18],\n  c,\n  [109, 4],\n  c,\n  [14, 4],\n  c,\n  [134, 6],\n  24,\n  26,\n  c,\n  [127, 6],\n  c,\n  [18, 12],\n  c,\n  [147, 8],\n  c,\n  [20, 4],\n  11,\n  12,\n  c,\n  [22, 20],\n  c,\n  [199, 11],\n  c,\n  [25, 10],\n  c,\n  [778, 85],\n  c,\n  [777, 7],\n  c,\n  [1182, 9],\n  5,\n  c,\n  [325, 16],\n  c,\n  [486, 46],\n  c,\n  [810, 13],\n  22,\n  c,\n  [1109, 3],\n  s,\n  [3, 3],\n  c,\n  [183, 8],\n  c,\n  [46, 10],\n  c,\n  [162, 33],\n  c,\n  [153, 3],\n  c,\n  [152, 5],\n  27,\n  90,\n  24,\n  24,\n  c,\n  [64, 8],\n  c,\n  [722, 31],\n  113,\n  c,\n  [963, 3],\n  6,\n  4,\n  4,\n  8,\n  c,\n  [895, 6],\n  c,\n  [1205, 4],\n  141,\n  142,\n  c,\n  [874, 23],\n  8,\n  24,\n  c,\n  [811, 3],\n  c,\n  [810, 8],\n  c,\n  [196, 31],\n  c,\n  [857, 3],\n  26,\n  c,\n  [42, 37],\n  111,\n  c,\n  [38, 38],\n  113,\n  c,\n  [39, 35],\n  c,\n  [74, 40],\n  4,\n  c,\n  [40, 22],\n  s,\n  [96, 16, 1],\n  27,\n  90,\n  27,\n  90,\n  c,\n  [157, 56],\n  c,\n  [794, 44],\n  c,\n  [100, 34],\n  c,\n  [34, 33],\n  4,\n  8,\n  4,\n  c,\n  [1252, 4],\n  c,\n  [443, 3],\n  c,\n  [43, 32],\n  c,\n  [32, 31],\n  c,\n  [31, 30],\n  c,\n  [30, 59],\n  c,\n  [29, 115],\n  c,\n  [28, 55],\n  c,\n  [27, 53],\n  c,\n  [26, 59],\n  c,\n  [993, 52],\n  22,\n  c,\n  [1053, 60],\n  c,\n  [918, 111],\n  c,\n  [39, 43],\n  82,\n  c,\n  [1204, 18],\n  c,\n  [1449, 20],\n  c,\n  [1438, 31],\n  150,\n  24,\n  8,\n  24,\n  s,\n  [56, 21, 1],\n  c,\n  [33, 8],\n  c,\n  [2155, 5],\n  c,\n  [2486, 3],\n  142,\n  c,\n  [8, 4],\n  c,\n  [2076, 5],\n  c,\n  [102, 21],\n  c,\n  [47, 8],\n  c,\n  [1299, 3],\n  c,\n  [2207, 3],\n  c,\n  [859, 3],\n  c,\n  [2280, 38],\n  c,\n  [2192, 4],\n  c,\n  [2191, 4],\n  c,\n  [1324, 11],\n  c,\n  [1658, 12],\n  c,\n  [2135, 22],\n  8,\n  22,\n  c,\n  [1948, 9],\n  6,\n  8,\n  c,\n  [974, 3],\n  c,\n  [1953, 10],\n  c,\n  [1848, 11],\n  c,\n  [587, 27],\n  4,\n  5,\n  c,\n  [205, 4],\n  10,\n  c,\n  [2403, 28],\n  c,\n  [197, 6],\n  c,\n  [1916, 56],\n  c,\n  [1934, 30],\n  c,\n  [20, 60],\n  c,\n  [1994, 22],\n  c,\n  [2016, 43],\n  c,\n  [2041, 34],\n  c,\n  [805, 50],\n  c,\n  [387, 3],\n  c,\n  [391, 3],\n  c,\n  [1924, 9],\n  c,\n  [697, 32],\n  150,\n  c,\n  [41, 42],\n  c,\n  [627, 4],\n  c,\n  [2865, 70],\n  c,\n  [549, 3],\n  c,\n  [856, 37],\n  c,\n  [1009, 45],\n  c,\n  [1106, 59],\n  c,\n  [59, 118],\n  c,\n  [2030, 56],\n  c,\n  [40, 56],\n  6,\n  4,\n  c,\n  [2640, 43],\n  s,\n  [80, 9, 1],\n  c,\n  [588, 3],\n  c,\n  [653, 60],\n  c,\n  [61, 120],\n  c,\n  [2629, 9],\n  c,\n  [475, 110]\n]),\n  type: u([\n  s,\n  [2, 21],\n  s,\n  [0, 13],\n  1,\n  c,\n  [35, 32],\n  c,\n  [15, 10],\n  s,\n  [2, 27],\n  c,\n  [45, 12],\n  c,\n  [35, 103],\n  c,\n  [3, 6],\n  c,\n  [5, 8],\n  c,\n  [52, 15],\n  c,\n  [69, 6],\n  c,\n  [76, 31],\n  c,\n  [92, 25],\n  c,\n  [55, 46],\n  c,\n  [338, 16],\n  c,\n  [314, 13],\n  s,\n  [2, 47],\n  s,\n  [0, 40],\n  c,\n  [43, 8],\n  c,\n  [73, 46],\n  c,\n  [491, 36],\n  c,\n  [333, 19],\n  c,\n  [409, 26],\n  c,\n  [142, 15],\n  c,\n  [97, 21],\n  c,\n  [26, 38],\n  c,\n  [35, 21],\n  c,\n  [253, 26],\n  c,\n  [329, 34],\n  s,\n  [2, 67],\n  c,\n  [112, 25],\n  c,\n  [25, 33],\n  c,\n  [51, 43],\n  c,\n  [146, 46],\n  c,\n  [576, 61],\n  s,\n  [2, 173],\n  c,\n  [777, 42],\n  c,\n  [1182, 34],\n  c,\n  [105, 50],\n  c,\n  [162, 65],\n  c,\n  [428, 23],\n  c,\n  [409, 35],\n  c,\n  [874, 32],\n  c,\n  [927, 19],\n  c,\n  [1006, 54],\n  c,\n  [42, 27],\n  c,\n  [576, 39],\n  c,\n  [74, 74],\n  c,\n  [40, 24],\n  c,\n  [1420, 3],\n  c,\n  [1389, 71],\n  c,\n  [794, 46],\n  c,\n  [34, 50],\n  c,\n  [1657, 13],\n  c,\n  [43, 29],\n  c,\n  [32, 31],\n  c,\n  [31, 30],\n  c,\n  [30, 59],\n  c,\n  [29, 115],\n  c,\n  [28, 55],\n  c,\n  [27, 53],\n  c,\n  [26, 69],\n  c,\n  [1357, 73],\n  c,\n  [623, 63],\n  c,\n  [918, 78],\n  c,\n  [922, 61],\n  c,\n  [1438, 53],\n  c,\n  [56, 33],\n  c,\n  [2037, 26],\n  c,\n  [902, 45],\n  c,\n  [314, 25],\n  c,\n  [1413, 8],\n  c,\n  [97, 20],\n  c,\n  [1822, 76],\n  c,\n  [116, 13],\n  c,\n  [200, 38],\n  s,\n  [2, 266],\n  c,\n  [865, 54],\n  c,\n  [48, 41],\n  c,\n  [89, 45],\n  c,\n  [2865, 60],\n  c,\n  [73, 33],\n  c,\n  [2165, 68],\n  c,\n  [1166, 59],\n  c,\n  [59, 105],\n  c,\n  [2030, 63],\n  c,\n  [938, 93],\n  c,\n  [2875, 93],\n  c,\n  [61, 121],\n  c,\n  [475, 88]\n]),\n  state: u([\n  1,\n  s,\n  [6, 4, 1],\n  25,\n  31,\n  26,\n  10,\n  11,\n  2,\n  s,\n  [4, 6, 1],\n  c,\n  [12, 5],\n  36,\n  5,\n  44,\n  39,\n  42,\n  37,\n  41,\n  40,\n  47,\n  c,\n  [16, 7],\n  48,\n  c,\n  [8, 7],\n  49,\n  c,\n  [8, 7],\n  50,\n  c,\n  [8, 7],\n  51,\n  54,\n  55,\n  44,\n  60,\n  65,\n  64,\n  63,\n  44,\n  66,\n  41,\n  40,\n  71,\n  25,\n  31,\n  68,\n  69,\n  70,\n  26,\n  72,\n  75,\n  73,\n  74,\n  97,\n  98,\n  107,\n  99,\n  89,\n  83,\n  81,\n  86,\n  s,\n  [115, 6, -1],\n  108,\n  101,\n  96,\n  88,\n  82,\n  80,\n  78,\n  77,\n  128,\n  c,\n  [22, 19],\n  142,\n  132,\n  119,\n  121,\n  c,\n  [76, 7],\n  120,\n  122,\n  123,\n  117,\n  118,\n  s,\n  [124, 4, 1],\n  44,\n  143,\n  144,\n  41,\n  40,\n  c,\n  [67, 6],\n  148,\n  c,\n  [45, 12],\n  147,\n  145,\n  153,\n  c,\n  [43, 7],\n  149,\n  151,\n  152,\n  155,\n  154,\n  c,\n  [112, 3],\n  157,\n  c,\n  [112, 4],\n  c,\n  [8, 3],\n  159,\n  c,\n  [7, 3],\n  44,\n  160,\n  161,\n  162,\n  c,\n  [133, 5],\n  163,\n  c,\n  [19, 5],\n  164,\n  c,\n  [137, 3],\n  168,\n  c,\n  [137, 22],\n  170,\n  169,\n  171,\n  c,\n  [24, 6],\n  191,\n  86,\n  c,\n  [8, 6],\n  193,\n  c,\n  [8, 7],\n  148,\n  86,\n  194,\n  c,\n  [9, 6],\n  195,\n  86,\n  199,\n  c,\n  [58, 20],\n  142,\n  200,\n  c,\n  [89, 3],\n  202,\n  26,\n  72,\n  201,\n  c,\n  [202, 34],\n  219,\n  c,\n  [201, 5],\n  39,\n  42,\n  c,\n  [202, 23],\n  221,\n  c,\n  [66, 22],\n  228,\n  s,\n  [122, 6, 1],\n  230,\n  c,\n  [125, 21],\n  234,\n  44,\n  238,\n  41,\n  240,\n  239,\n  241,\n  c,\n  [239, 7],\n  75,\n  248,\n  c,\n  [88, 20],\n  249,\n  c,\n  [58, 20],\n  254,\n  c,\n  [79, 21],\n  255,\n  c,\n  [64, 17],\n  256,\n  c,\n  [40, 21],\n  257,\n  c,\n  [22, 6],\n  259,\n  c,\n  [23, 14],\n  260,\n  261,\n  262,\n  c,\n  [290, 22],\n  c,\n  [312, 28],\n  263,\n  c,\n  [115, 16],\n  264,\n  c,\n  [17, 15],\n  265,\n  269,\n  268,\n  241,\n  c,\n  [19, 14],\n  271,\n  c,\n  [15, 13],\n  272,\n  c,\n  [14, 12],\n  273,\n  c,\n  [13, 12],\n  274,\n  c,\n  [13, 11],\n  275,\n  c,\n  [12, 11],\n  276,\n  c,\n  [12, 11],\n  277,\n  c,\n  [12, 11],\n  278,\n  c,\n  [12, 10],\n  279,\n  c,\n  [11, 10],\n  280,\n  c,\n  [11, 9],\n  281,\n  c,\n  [10, 9],\n  282,\n  c,\n  [10, 8],\n  283,\n  c,\n  [9, 8],\n  284,\n  c,\n  [9, 8],\n  285,\n  c,\n  [454, 22],\n  286,\n  s,\n  [122, 7, 1],\n  c,\n  [29, 21],\n  288,\n  c,\n  [29, 6],\n  c,\n  [295, 20],\n  289,\n  c,\n  [316, 21],\n  290,\n  c,\n  [22, 21],\n  291,\n  c,\n  [22, 21],\n  292,\n  c,\n  [22, 21],\n  132,\n  295,\n  c,\n  [665, 8],\n  294,\n  c,\n  [833, 8],\n  299,\n  44,\n  60,\n  300,\n  44,\n  c,\n  [13, 8],\n  66,\n  41,\n  240,\n  305,\n  151,\n  152,\n  303,\n  c,\n  [378, 15],\n  c,\n  [593, 6],\n  307,\n  44,\n  308,\n  c,\n  [854, 3],\n  c,\n  [621, 8],\n  c,\n  [841, 15],\n  311,\n  c,\n  [50, 8],\n  317,\n  300,\n  c,\n  [76, 8],\n  269,\n  c,\n  [74, 5],\n  c,\n  [251, 22],\n  318,\n  c,\n  [251, 26],\n  142,\n  132,\n  323,\n  c,\n  [23, 22],\n  324,\n  c,\n  [149, 20],\n  326,\n  c,\n  [110, 8],\n  328,\n  151,\n  152,\n  c,\n  [32, 19],\n  332,\n  c,\n  [75, 20],\n  333,\n  c,\n  [148, 22],\n  334,\n  c,\n  [428, 28],\n  335,\n  c,\n  [29, 28],\n  336,\n  c,\n  [206, 27],\n  337,\n  c,\n  [22, 21],\n  339,\n  c,\n  [22, 21],\n  341,\n  c,\n  [95, 22],\n  346,\n  c,\n  [124, 28],\n  348,\n  c,\n  [29, 28],\n  350,\n  c,\n  [29, 28],\n  352,\n  c,\n  [29, 28],\n  353,\n  c,\n  [29, 6]\n]),\n  mode: u([\n  s,\n  [1, 46],\n  s,\n  [2, 7],\n  c,\n  [27, 101],\n  c,\n  [31, 5],\n  1,\n  c,\n  [27, 7],\n  c,\n  [9, 3],\n  c,\n  [43, 8],\n  c,\n  [18, 5],\n  c,\n  [12, 8],\n  s,\n  [2, 20],\n  c,\n  [100, 22],\n  c,\n  [44, 38],\n  s,\n  [1, 57],\n  c,\n  [96, 6],\n  c,\n  [327, 43],\n  c,\n  [218, 8],\n  c,\n  [369, 35],\n  c,\n  [20, 35],\n  c,\n  [299, 11],\n  c,\n  [352, 20],\n  c,\n  [317, 10],\n  c,\n  [250, 19],\n  c,\n  [24, 7],\n  c,\n  [67, 6],\n  c,\n  [289, 19],\n  c,\n  [310, 86],\n  c,\n  [146, 12],\n  c,\n  [412, 22],\n  c,\n  [440, 60],\n  c,\n  [236, 15],\n  c,\n  [65, 20],\n  c,\n  [8, 22],\n  c,\n  [34, 18],\n  c,\n  [30, 22],\n  c,\n  [87, 7],\n  c,\n  [55, 20],\n  c,\n  [271, 60],\n  c,\n  [246, 30],\n  c,\n  [688, 75],\n  c,\n  [561, 7],\n  c,\n  [502, 7],\n  s,\n  [1, 217],\n  c,\n  [219, 219],\n  s,\n  [1, 232],\n  c,\n  [680, 7],\n  c,\n  [458, 70],\n  c,\n  [1605, 13],\n  c,\n  [1062, 14],\n  c,\n  [1676, 26],\n  c,\n  [123, 26],\n  c,\n  [1116, 48],\n  c,\n  [1134, 38],\n  c,\n  [20, 60],\n  c,\n  [1194, 23],\n  c,\n  [1216, 42],\n  c,\n  [1241, 80],\n  c,\n  [2006, 28],\n  c,\n  [690, 216],\n  s,\n  [2, 42],\n  c,\n  [538, 11],\n  s,\n  [1, 155]\n]),\n  goto: u([\n  3,\n  s,\n  [12, 13, 1],\n  27,\n  33,\n  34,\n  32,\n  28,\n  29,\n  30,\n  35,\n  c,\n  [21, 20],\n  45,\n  43,\n  38,\n  46,\n  s,\n  [88, 7],\n  c,\n  [31, 20],\n  s,\n  [90, 7],\n  c,\n  [27, 20],\n  s,\n  [92, 7],\n  c,\n  [27, 20],\n  s,\n  [94, 7],\n  c,\n  [27, 20],\n  52,\n  46,\n  53,\n  46,\n  98,\n  56,\n  98,\n  57,\n  59,\n  58,\n  45,\n  46,\n  62,\n  144,\n  61,\n  s,\n  [144, 4],\n  s,\n  [151, 4],\n  43,\n  151,\n  28,\n  45,\n  43,\n  46,\n  s,\n  [118, 6],\n  67,\n  s,\n  [118, 21],\n  c,\n  [74, 15],\n  46,\n  s,\n  [135, 6],\n  76,\n  s,\n  [135, 21],\n  100,\n  s,\n  [90, 6, 1],\n  79,\n  46,\n  s,\n  [102, 5, 1],\n  109,\n  84,\n  85,\n  87,\n  c,\n  [18, 7],\n  131,\n  57,\n  116,\n  c,\n  [20, 10],\n  c,\n  [159, 20],\n  129,\n  130,\n  s,\n  [133, 9, 1],\n  c,\n  [144, 3],\n  62,\n  143,\n  61,\n  s,\n  [143, 4],\n  100,\n  146,\n  c,\n  [62, 6],\n  c,\n  [59, 10],\n  150,\n  c,\n  [60, 20],\n  s,\n  [152, 4],\n  43,\n  152,\n  28,\n  156,\n  c,\n  [25, 15],\n  158,\n  c,\n  [16, 15],\n  c,\n  [88, 3],\n  s,\n  [125, 5],\n  c,\n  [23, 15],\n  s,\n  [127, 5],\n  c,\n  [20, 15],\n  166,\n  165,\n  138,\n  167,\n  138,\n  46,\n  c,\n  [206, 18],\n  s,\n  [38, 15],\n  172,\n  s,\n  [38, 10],\n  s,\n  [173, 10, 1],\n  s,\n  [68, 3],\n  183,\n  s,\n  [68, 3],\n  184,\n  186,\n  26,\n  185,\n  26,\n  187,\n  s,\n  [26, 16],\n  188,\n  189,\n  190,\n  s,\n  [26, 18],\n  192,\n  c,\n  [230, 16],\n  c,\n  [17, 17],\n  c,\n  [138, 7],\n  c,\n  [17, 10],\n  196,\n  c,\n  [17, 16],\n  s,\n  [66, 7],\n  197,\n  66,\n  s,\n  [64, 3],\n  198,\n  s,\n  [64, 6],\n  s,\n  [14, 21],\n  109,\n  s,\n  [14, 21],\n  c,\n  [96, 17],\n  c,\n  [272, 15],\n  s,\n  [62, 3],\n  203,\n  s,\n  [62, 7],\n  s,\n  [60, 3],\n  204,\n  s,\n  [60, 8],\n  s,\n  [58, 10],\n  205,\n  206,\n  58,\n  58,\n  s,\n  [55, 4],\n  207,\n  208,\n  s,\n  [55, 6],\n  209,\n  210,\n  s,\n  [55, 4],\n  s,\n  [50, 12],\n  211,\n  212,\n  s,\n  [50, 6],\n  s,\n  [47, 4],\n  213,\n  214,\n  s,\n  [47, 16],\n  s,\n  [44, 4],\n  215,\n  44,\n  44,\n  216,\n  217,\n  s,\n  [44, 16],\n  c,\n  [576, 9],\n  218,\n  c,\n  [576, 43],\n  38,\n  46,\n  s,\n  [12, 15],\n  220,\n  s,\n  [12, 23],\n  c,\n  [248, 17],\n  222,\n  224,\n  223,\n  225,\n  226,\n  227,\n  c,\n  [117, 9],\n  c,\n  [25, 10],\n  c,\n  [96, 11],\n  229,\n  46,\n  231,\n  232,\n  c,\n  [34, 7],\n  233,\n  c,\n  [33, 10],\n  c,\n  [860, 3],\n  235,\n  236,\n  157,\n  237,\n  242,\n  163,\n  243,\n  163,\n  43,\n  46,\n  244,\n  c,\n  [160, 15],\n  246,\n  245,\n  247,\n  c,\n  [590, 8],\n  c,\n  [50, 10],\n  251,\n  250,\n  253,\n  252,\n  c,\n  [21, 17],\n  c,\n  [17, 52],\n  258,\n  c,\n  [18, 16],\n  46,\n  c,\n  [109, 18],\n  c,\n  [482, 32],\n  c,\n  [49, 34],\n  266,\n  224,\n  267,\n  270,\n  164,\n  243,\n  43,\n  c,\n  [178, 69],\n  c,\n  [17, 193],\n  c,\n  [539, 23],\n  287,\n  c,\n  [31, 30],\n  c,\n  [129, 68],\n  293,\n  c,\n  [99, 8],\n  c,\n  [784, 30],\n  296,\n  224,\n  297,\n  c,\n  [23, 20],\n  298,\n  242,\n  166,\n  243,\n  166,\n  46,\n  302,\n  167,\n  301,\n  167,\n  242,\n  304,\n  243,\n  43,\n  46,\n  c,\n  [35, 20],\n  100,\n  306,\n  c,\n  [115, 16],\n  c,\n  [1337, 3],\n  309,\n  c,\n  [1293, 9],\n  310,\n  c,\n  [24, 10],\n  224,\n  312,\n  s,\n  [67, 7],\n  197,\n  67,\n  313,\n  224,\n  314,\n  315,\n  316,\n  s,\n  [65, 3],\n  198,\n  s,\n  [65, 6],\n  s,\n  [63, 3],\n  203,\n  s,\n  [63, 7],\n  c,\n  [193, 17],\n  270,\n  166,\n  243,\n  270,\n  c,\n  [124, 3],\n  c,\n  [123, 20],\n  s,\n  [61, 3],\n  204,\n  s,\n  [61, 8],\n  s,\n  [59, 10],\n  205,\n  206,\n  59,\n  59,\n  s,\n  [56, 4],\n  207,\n  208,\n  s,\n  [56, 6],\n  209,\n  210,\n  s,\n  [56, 4],\n  s,\n  [57, 4],\n  207,\n  208,\n  s,\n  [57, 6],\n  209,\n  210,\n  s,\n  [57, 4],\n  s,\n  [51, 12],\n  211,\n  212,\n  s,\n  [51, 6],\n  s,\n  [52, 12],\n  211,\n  212,\n  s,\n  [52, 6],\n  s,\n  [53, 12],\n  211,\n  212,\n  s,\n  [53, 6],\n  s,\n  [54, 12],\n  211,\n  212,\n  s,\n  [54, 6],\n  s,\n  [48, 4],\n  213,\n  214,\n  s,\n  [48, 16],\n  s,\n  [49, 4],\n  213,\n  214,\n  s,\n  [49, 16],\n  s,\n  [45, 4],\n  215,\n  45,\n  45,\n  216,\n  217,\n  s,\n  [45, 16],\n  s,\n  [46, 4],\n  215,\n  46,\n  46,\n  216,\n  217,\n  s,\n  [46, 16],\n  c,\n  [554, 30],\n  319,\n  224,\n  320,\n  224,\n  321,\n  224,\n  322,\n  c,\n  [492, 18],\n  c,\n  [18, 18],\n  302,\n  168,\n  301,\n  168,\n  100,\n  325,\n  c,\n  [358, 16],\n  327,\n  c,\n  [352, 20],\n  329,\n  330,\n  331,\n  c,\n  [738, 64],\n  c,\n  [30, 67],\n  c,\n  [107, 11],\n  338,\n  c,\n  [18, 17],\n  340,\n  c,\n  [18, 16],\n  342,\n  343,\n  s,\n  [200, 43],\n  344,\n  s,\n  [200, 8],\n  345,\n  224,\n  c,\n  [139, 30],\n  347,\n  c,\n  [32, 31],\n  349,\n  c,\n  [32, 31],\n  351,\n  c,\n  [264, 60]\n])\n}),\ndefaultActions: bda({\n  idx: u([\n  s,\n  [3, 4, 1],\n  s,\n  [12, 19, 1],\n  s,\n  [33, 4, 1],\n  38,\n  42,\n  44,\n  s,\n  [46, 5, 1],\n  55,\n  58,\n  64,\n  65,\n  69,\n  74,\n  77,\n  78,\n  80,\n  s,\n  [89, 7, 1],\n  97,\n  98,\n  s,\n  [102, 6, 1],\n  109,\n  115,\n  116,\n  118,\n  119,\n  120,\n  s,\n  [122, 6, 1],\n  131,\n  142,\n  143,\n  146,\n  147,\n  s,\n  [148, 4, 2],\n  155,\n  156,\n  158,\n  159,\n  s,\n  [161, 5, 1],\n  170,\n  s,\n  [172, 11, 1],\n  189,\n  190,\n  191,\n  193,\n  194,\n  195,\n  199,\n  218,\n  219,\n  223,\n  231,\n  232,\n  233,\n  235,\n  236,\n  238,\n  239,\n  244,\n  245,\n  s,\n  [247, 4, 1],\n  252,\n  254,\n  258,\n  260,\n  261,\n  262,\n  266,\n  268,\n  s,\n  [283, 4, 1],\n  288,\n  289,\n  s,\n  [296, 4, 1],\n  304,\n  306,\n  s,\n  [308, 4, 1],\n  313,\n  314,\n  316,\n  317,\n  318,\n  325,\n  327,\n  s,\n  [329, 5, 1],\n  335,\n  336,\n  342,\n  343,\n  346,\n  348,\n  s,\n  [350, 4, 1]\n]),\n  goto: u([\n  2,\n  214,\n  216,\n  217,\n  s,\n  [100, 16, 1],\n  140,\n  141,\n  142,\n  119,\n  120,\n  1,\n  215,\n  86,\n  96,\n  145,\n  3,\n  s,\n  [89, 4, 2],\n  218,\n  87,\n  153,\n  155,\n  121,\n  136,\n  99,\n  178,\n  70,\n  16,\n  s,\n  [32, 6, 1],\n  12,\n  13,\n  s,\n  [4, 5, 1],\n  10,\n  9,\n  40,\n  192,\n  194,\n  196,\n  197,\n  s,\n  [183, 6, 1],\n  198,\n  83,\n  97,\n  148,\n  85,\n  38,\n  150,\n  159,\n  154,\n  156,\n  146,\n  117,\n  122,\n  128,\n  130,\n  124,\n  126,\n  131,\n  181,\n  s,\n  [72, 11, 1],\n  22,\n  23,\n  s,\n  [27, 4, 1],\n  11,\n  193,\n  195,\n  199,\n  210,\n  211,\n  212,\n  147,\n  149,\n  161,\n  162,\n  116,\n  123,\n  133,\n  137,\n  139,\n  132,\n  179,\n  71,\n  18,\n  24,\n  20,\n  21,\n  15,\n  165,\n  41,\n  42,\n  43,\n  189,\n  191,\n  84,\n  209,\n  213,\n  158,\n  160,\n  174,\n  170,\n  129,\n  134,\n  180,\n  182,\n  17,\n  19,\n  31,\n  39,\n  190,\n  172,\n  176,\n  169,\n  175,\n  171,\n  69,\n  25,\n  202,\n  203,\n  173,\n  177,\n  205,\n  207,\n  201,\n  204,\n  206,\n  208\n])\n}),\nparseError: function parseError(str, hash, ExceptionClass) {\n    if (hash.recoverable) {\n        if (typeof this.trace === 'function') {\n            this.trace(str);\n        }\n        hash.destroy();             // destroy... well, *almost*!\n    } else {\n        if (typeof this.trace === 'function') {\n            this.trace(str);\n        }\n        if (!ExceptionClass) {\n            ExceptionClass = this.JisonParserError;\n        }\n        throw new ExceptionClass(str, hash);\n    }\n},\nparse: function parse(input) {\n    var self = this;\n    var stack = new Array(128);         // token stack: stores token which leads to state at the same index (column storage)\n    var sstack = new Array(128);        // state stack: stores states (column storage)\n\n    var vstack = new Array(128);        // semantic value stack\n    var lstack = new Array(128);        // location stack\n    var table = this.table;\n    var sp = 0;                         // 'stack pointer': index into the stacks\n    var yyloc;\n    var yytext;\n    \n\n\n    var symbol = 0;\n\n\n\n    var TERROR = this.TERROR;\n    var EOF = this.EOF;\n    var ERROR_RECOVERY_TOKEN_DISCARD_COUNT = (this.options.errorRecoveryTokenDiscardCount | 0) || 3;\n    var NO_ACTION = [0, 354 /* === table.length :: ensures that anyone using this new state will fail dramatically! */];\n\n    var lexer;\n    if (this.__lexer__) {\n        lexer = this.__lexer__;\n    } else {\n        lexer = this.__lexer__ = Object.create(this.lexer);\n    }\n\n    var sharedState_yy = {\n        parseError: undefined,\n        quoteName: undefined,\n        lexer: undefined,\n        parser: undefined,\n        pre_parse: undefined,\n        post_parse: undefined,\n        pre_lex: undefined,\n        post_lex: undefined      // WARNING: must be written this way for the code expanders to work correctly in both ES5 and ES6 modes!\n    };\n\n    var ASSERT;\n    if (typeof assert !== 'function') {\n        ASSERT = function JisonAssert(cond, msg) {\n            if (!cond) {\n                throw new Error('assertion failed: ' + (msg || '***'));\n            }\n        };\n    } else {\n        ASSERT = assert;\n    }\n\n    this.yyGetSharedState = function yyGetSharedState() {\n        return sharedState_yy;\n    };\n\n\n    // shallow clone objects, straight copy of simple `src` values\n    // e.g. `lexer.yytext` MAY be a complex value object,\n    // rather than a simple string/value.\n    function shallow_copy(src) {\n        if (typeof src === 'object') {\n            var dst = {};\n            for (var k in src) {\n                if (Object.prototype.hasOwnProperty.call(src, k)) {\n                    dst[k] = src[k];\n                }\n            }\n            return dst;\n        }\n        return src;\n    }\n    function shallow_copy_noclobber(dst, src) {\n        for (var k in src) {\n            if (typeof dst[k] === 'undefined' && Object.prototype.hasOwnProperty.call(src, k)) {\n                dst[k] = src[k];\n            }\n        }\n    }\n    function copy_yylloc(loc) {\n        var rv = shallow_copy(loc);\n        if (rv && rv.range) {\n            rv.range = rv.range.slice(0);\n        }\n        return rv;\n    }\n\n    // copy state\n    shallow_copy_noclobber(sharedState_yy, this.yy);\n\n    sharedState_yy.lexer = lexer;\n    sharedState_yy.parser = this;\n\n\n\n\n\n\n    // Does the shared state override the default `parseError` that already comes with this instance?\n    if (typeof sharedState_yy.parseError === 'function') {\n        this.parseError = function parseErrorAlt(str, hash, ExceptionClass) {\n            if (!ExceptionClass) {\n                ExceptionClass = this.JisonParserError;\n            }\n            return sharedState_yy.parseError.call(this, str, hash, ExceptionClass);\n        };\n    } else {\n        this.parseError = this.originalParseError;\n    }\n\n    // Does the shared state override the default `quoteName` that already comes with this instance?\n    if (typeof sharedState_yy.quoteName === 'function') {\n        this.quoteName = function quoteNameAlt(id_str) {\n            return sharedState_yy.quoteName.call(this, id_str);\n        };\n    } else {\n        this.quoteName = this.originalQuoteName;\n    }\n\n    // set up the cleanup function; make it an API so that external code can re-use this one in case of\n    // calamities or when the `%options no-try-catch` option has been specified for the grammar, in which\n    // case this parse() API method doesn't come with a `finally { ... }` block any more!\n    //\n    // NOTE: as this API uses parse() as a closure, it MUST be set again on every parse() invocation,\n    //       or else your `sharedState`, etc. references will be *wrong*!\n    this.cleanupAfterParse = function parser_cleanupAfterParse(resultValue, invoke_post_methods, do_not_nuke_errorinfos) {\n        var rv;\n\n        if (invoke_post_methods) {\n            var hash;\n\n            if (sharedState_yy.post_parse || this.post_parse) {\n                // create an error hash info instance: we re-use this API in a **non-error situation**\n                // as this one delivers all parser internals ready for access by userland code.\n                hash = this.constructParseErrorInfo(null /* no error! */, null /* no exception! */, null, false);\n            }\n\n            if (sharedState_yy.post_parse) {\n                rv = sharedState_yy.post_parse.call(this, sharedState_yy, resultValue, hash);\n                if (typeof rv !== 'undefined') resultValue = rv;\n            }\n            if (this.post_parse) {\n                rv = this.post_parse.call(this, sharedState_yy, resultValue, hash);\n                if (typeof rv !== 'undefined') resultValue = rv;\n            }\n\n            // cleanup:\n            if (hash && hash.destroy) {\n                hash.destroy();\n            }\n        }\n\n        if (this.__reentrant_call_depth > 1) return resultValue;        // do not (yet) kill the sharedState when this is a reentrant run.\n\n        // clean up the lingering lexer structures as well:\n        if (lexer.cleanupAfterLex) {\n            lexer.cleanupAfterLex(do_not_nuke_errorinfos);\n        }\n\n        // prevent lingering circular references from causing memory leaks:\n        if (sharedState_yy) {\n            sharedState_yy.lexer = undefined;\n            sharedState_yy.parser = undefined;\n            if (lexer.yy === sharedState_yy) {\n                lexer.yy = undefined;\n            }\n        }\n        sharedState_yy = undefined;\n        this.parseError = this.originalParseError;\n        this.quoteName = this.originalQuoteName;\n\n        // nuke the vstack[] array at least as that one will still reference obsoleted user values.\n        // To be safe, we nuke the other internal stack columns as well...\n        stack.length = 0;               // fastest way to nuke an array without overly bothering the GC\n        sstack.length = 0;\n        lstack.length = 0;\n        vstack.length = 0;\n        sp = 0;\n\n        // nuke the error hash info instances created during this run.\n        // Userland code must COPY any data/references\n        // in the error hash instance(s) it is more permanently interested in.\n        if (!do_not_nuke_errorinfos) {\n            for (var i = this.__error_infos.length - 1; i >= 0; i--) {\n                var el = this.__error_infos[i];\n                if (el && typeof el.destroy === 'function') {\n                    el.destroy();\n                }\n            }\n            this.__error_infos.length = 0;\n\n\n        }\n\n        return resultValue;\n    };\n\n    // merge yylloc info into a new yylloc instance.\n    //\n    // `first_index` and `last_index` MAY be UNDEFINED/NULL or these are indexes into the `lstack[]` location stack array.\n    //\n    // `first_yylloc` and `last_yylloc` MAY be UNDEFINED/NULL or explicit (custom or regular) `yylloc` instances, in which\n    // case these override the corresponding first/last indexes.\n    //\n    // `dont_look_back` is an optional flag (default: FALSE), which instructs this merge operation NOT to search\n    // through the parse location stack for a location, which would otherwise be used to construct the new (epsilon!)\n    // yylloc info.\n    //\n    // Note: epsilon rule's yylloc situation is detected by passing both `first_index` and `first_yylloc` as UNDEFINED/NULL.\n    this.yyMergeLocationInfo = function parser_yyMergeLocationInfo(first_index, last_index, first_yylloc, last_yylloc, dont_look_back) {\n        var i1 = first_index | 0,\n            i2 = last_index | 0;\n        var l1 = first_yylloc,\n            l2 = last_yylloc;\n        var rv;\n\n        // rules:\n        // - first/last yylloc entries override first/last indexes\n\n        if (!l1) {\n            if (first_index != null) {\n                for (var i = i1; i <= i2; i++) {\n                    l1 = lstack[i];\n                    if (l1) {\n                        break;\n                    }\n                }\n            }\n        }\n\n        if (!l2) {\n            if (last_index != null) {\n                for (var i = i2; i >= i1; i--) {\n                    l2 = lstack[i];\n                    if (l2) {\n                        break;\n                    }\n                }\n            }\n        }\n\n        // - detect if an epsilon rule is being processed and act accordingly:\n        if (!l1 && first_index == null) {\n            // epsilon rule span merger. With optional look-ahead in l2.\n            if (!dont_look_back) {\n                for (var i = (i1 || sp) - 1; i >= 0; i--) {\n                    l1 = lstack[i];\n                    if (l1) {\n                        break;\n                    }\n                }\n            }\n            if (!l1) {\n                if (!l2) {\n                    // when we still don't have any valid yylloc info, we're looking at an epsilon rule\n                    // without look-ahead and no preceding terms and/or `dont_look_back` set:\n                    // in that case we ca do nothing but return NULL/UNDEFINED:\n                    return undefined;\n                } else {\n                    // shallow-copy L2: after all, we MAY be looking\n                    // at unconventional yylloc info objects...\n                    rv = shallow_copy(l2);\n                    if (rv.range) {\n                        // shallow copy the yylloc ranges info to prevent us from modifying the original arguments' entries:\n                        rv.range = rv.range.slice(0);\n                    }\n                    return rv;\n                }\n            } else {\n                // shallow-copy L1, then adjust first col/row 1 column past the end.\n                rv = shallow_copy(l1);\n                rv.first_line = rv.last_line;\n                rv.first_column = rv.last_column;\n                if (rv.range) {\n                    // shallow copy the yylloc ranges info to prevent us from modifying the original arguments' entries:\n                    rv.range = rv.range.slice(0);\n                    rv.range[0] = rv.range[1];\n                }\n\n                if (l2) {\n                    // shallow-mixin L2, then adjust last col/row accordingly.\n                    shallow_copy_noclobber(rv, l2);\n                    rv.last_line = l2.last_line;\n                    rv.last_column = l2.last_column;\n                    if (rv.range && l2.range) {\n                        rv.range[1] = l2.range[1];\n                    }\n                }\n                return rv;\n            }\n        }\n\n        if (!l1) {\n            l1 = l2;\n            l2 = null;\n        }\n        if (!l1) {\n            return undefined;\n        }\n\n        // shallow-copy L1|L2, before we try to adjust the yylloc values: after all, we MAY be looking\n        // at unconventional yylloc info objects...\n        rv = shallow_copy(l1);\n\n        // first_line: ...,\n        // first_column: ...,\n        // last_line: ...,\n        // last_column: ...,\n        if (rv.range) {\n            // shallow copy the yylloc ranges info to prevent us from modifying the original arguments' entries:\n            rv.range = rv.range.slice(0);\n        }\n\n        if (l2) {\n            shallow_copy_noclobber(rv, l2);\n            rv.last_line = l2.last_line;\n            rv.last_column = l2.last_column;\n            if (rv.range && l2.range) {\n                rv.range[1] = l2.range[1];\n            }\n        }\n\n        return rv;\n    };\n\n    // NOTE: as this API uses parse() as a closure, it MUST be set again on every parse() invocation,\n    //       or else your `lexer`, `sharedState`, etc. references will be *wrong*!\n    this.constructParseErrorInfo = function parser_constructParseErrorInfo(msg, ex, expected, recoverable) {\n        var pei = {\n            errStr: msg,\n            exception: ex,\n            text: lexer.match,\n            value: lexer.yytext,\n            token: this.describeSymbol(symbol) || symbol,\n            token_id: symbol,\n            line: lexer.yylineno,\n            loc: copy_yylloc(lexer.yylloc),\n            expected: expected,\n            recoverable: recoverable,\n            state: state,\n            action: action,\n            new_state: newState,\n            symbol_stack: stack,\n            state_stack: sstack,\n            value_stack: vstack,\n            location_stack: lstack,\n            stack_pointer: sp,\n            yy: sharedState_yy,\n            lexer: lexer,\n            parser: this,\n\n            // and make sure the error info doesn't stay due to potential\n            // ref cycle via userland code manipulations.\n            // These would otherwise all be memory leak opportunities!\n            //\n            // Note that only array and object references are nuked as those\n            // constitute the set of elements which can produce a cyclic ref.\n            // The rest of the members is kept intact as they are harmless.\n            destroy: function destructParseErrorInfo() {\n                // remove cyclic references added to error info:\n                // info.yy = null;\n                // info.lexer = null;\n                // info.value = null;\n                // info.value_stack = null;\n                // ...\n                var rec = !!this.recoverable;\n                for (var key in this) {\n                    if (this.hasOwnProperty(key) && typeof key === 'object') {\n                        this[key] = undefined;\n                    }\n                }\n                this.recoverable = rec;\n            }\n        };\n        // track this instance so we can `destroy()` it once we deem it superfluous and ready for garbage collection!\n        this.__error_infos.push(pei);\n        return pei;\n    };\n\n\n\n\n\n\n\n\n\n\n\n\n\n    function getNonTerminalFromCode(symbol) {\n        var tokenName = self.getSymbolName(symbol);\n        if (!tokenName) {\n            tokenName = symbol;\n        }\n        return tokenName;\n    }\n\n\n    function stdLex() {\n        var token = lexer.lex();\n        // if token isn't its numeric value, convert\n        if (typeof token !== 'number') {\n            token = self.symbols_[token] || token;\n        }\n\n        return token || EOF;\n    }\n\n    function fastLex() {\n        var token = lexer.fastLex();\n        // if token isn't its numeric value, convert\n        if (typeof token !== 'number') {\n            token = self.symbols_[token] || token;\n        }\n\n        return token || EOF;\n    }\n\n    var lex = stdLex;\n\n\n    var state, action, r, t;\n    var yyval = {\n        $: true,\n        _$: undefined,\n        yy: sharedState_yy\n    };\n    var p;\n    var yyrulelen;\n    var this_production;\n    var newState;\n    var retval = false;\n\n\n    try {\n        this.__reentrant_call_depth++;\n\n        lexer.setInput(input, sharedState_yy);\n\n        // NOTE: we *assume* no lexer pre/post handlers are set up *after* \n        // this initial `setInput()` call: hence we can now check and decide\n        // whether we'll go with the standard, slower, lex() API or the\n        // `fast_lex()` one:\n        if (typeof lexer.canIUse === 'function') {\n            var lexerInfo = lexer.canIUse();\n            if (lexerInfo.fastLex && typeof fastLex === 'function') {\n                lex = fastLex;\n            }\n        } \n\n        yyloc = lexer.yylloc;\n        lstack[sp] = yyloc;\n        vstack[sp] = null;\n        sstack[sp] = 0;\n        stack[sp] = 0;\n        ++sp;\n\n        yytext = lexer.yytext;\n\n\n\n        if (this.pre_parse) {\n            this.pre_parse.call(this, sharedState_yy);\n        }\n        if (sharedState_yy.pre_parse) {\n            sharedState_yy.pre_parse.call(this, sharedState_yy);\n        }\n\n        newState = sstack[sp - 1];\n        for (;;) {\n            // retrieve state number from top of stack\n            state = newState;               // sstack[sp - 1];\n\n            // use default actions if available\n            if (this.defaultActions[state]) {\n                action = 2;\n                newState = this.defaultActions[state];\n            } else {\n                // The single `==` condition below covers both these `===` comparisons in a single\n                // operation:\n                //\n                //     if (symbol === null || typeof symbol === 'undefined') ...\n                if (!symbol) {\n                    symbol = lex();\n                }\n                // read action for current state and first input\n                t = (table[state] && table[state][symbol]) || NO_ACTION;\n                newState = t[1];\n                action = t[0];\n\n\n\n\n\n\n\n\n\n\n\n                // handle parse error\n                if (!action) {\n                    var errStr;\n                    var errSymbolDescr = (this.describeSymbol(symbol) || symbol);\n                    var expected = this.collect_expected_token_set(state);\n\n                    // Report error\n                    if (typeof lexer.yylineno === 'number') {\n                        errStr = 'Parse error on line ' + (lexer.yylineno + 1) + ': ';\n                    } else {\n                        errStr = 'Parse error: ';\n                    }\n                    if (typeof lexer.showPosition === 'function') {\n                        errStr += '\\n' + lexer.showPosition(79 - 10, 10) + '\\n';\n                    }\n                    if (expected.length) {\n                        errStr += 'Expecting ' + expected.join(', ') + ', got unexpected ' + errSymbolDescr;\n                    } else {\n                        errStr += 'Unexpected ' + errSymbolDescr;\n                    }\n                    // we cannot recover from the error!\n                    p = this.constructParseErrorInfo(errStr, null, expected, false);\n                    r = this.parseError(p.errStr, p, this.JisonParserError);\n                    if (typeof r !== 'undefined') {\n                        retval = r;\n                    }\n                    break;\n                }\n\n\n            }\n\n\n\n\n\n\n\n\n\n\n            switch (action) {\n            // catch misc. parse failures:\n            default:\n                // this shouldn't happen, unless resolve defaults are off\n                if (action instanceof Array) {\n                    p = this.constructParseErrorInfo('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol, null, null, false);\n                    r = this.parseError(p.errStr, p, this.JisonParserError);\n                    if (typeof r !== 'undefined') {\n                        retval = r;\n                    }\n                    break;\n                }\n                // Another case of better safe than sorry: in case state transitions come out of another error recovery process\n                // or a buggy LUT (LookUp Table):\n                p = this.constructParseErrorInfo('Parsing halted. No viable error recovery approach available due to internal system failure.', null, null, false);\n                r = this.parseError(p.errStr, p, this.JisonParserError);\n                if (typeof r !== 'undefined') {\n                    retval = r;\n                }\n                break;\n\n            // shift:\n            case 1:\n                stack[sp] = symbol;\n                vstack[sp] = lexer.yytext;\n                lstack[sp] = copy_yylloc(lexer.yylloc);\n                sstack[sp] = newState; // push state\n\n                ++sp;\n                symbol = 0;\n\n\n\n\n                // Pick up the lexer details for the current symbol as that one is not 'look-ahead' any more:\n\n                yytext = lexer.yytext;\n\n                yyloc = lexer.yylloc;\n                continue;\n\n            // reduce:\n            case 2:\n\n\n\n                this_production = this.productions_[newState - 1];  // `this.productions_[]` is zero-based indexed while states start from 1 upwards...\n                yyrulelen = this_production[1];\n\n\n\n\n\n\n\n\n\n\n                r = this.performAction.call(yyval, yytext, yyloc, newState, sp - 1, vstack, lstack);\n\n                if (typeof r !== 'undefined') {\n                    retval = r;\n                    break;\n                }\n\n                // pop off stack\n                sp -= yyrulelen;\n\n                // don't overwrite the `symbol` variable: use a local var to speed things up:\n                var ntsymbol = this_production[0];    // push nonterminal (reduce)\n                stack[sp] = ntsymbol;\n                vstack[sp] = yyval.$;\n                lstack[sp] = yyval._$;\n                // goto new state = table[STATE][NONTERMINAL]\n                newState = table[sstack[sp - 1]][ntsymbol];\n                sstack[sp] = newState;\n                ++sp;\n\n\n\n\n\n\n\n\n\n                continue;\n\n            // accept:\n            case 3:\n                if (sp !== -2) {\n                    retval = true;\n                    // Return the `$accept` rule's `$$` result, if available.\n                    //\n                    // Also note that JISON always adds this top-most `$accept` rule (with implicit,\n                    // default, action):\n                    //\n                    //     $accept: <startSymbol> $end\n                    //                  %{ $$ = $1; @$ = @1; %}\n                    //\n                    // which, combined with the parse kernel's `$accept` state behaviour coded below,\n                    // will produce the `$$` value output of the <startSymbol> rule as the parse result,\n                    // IFF that result is *not* `undefined`. (See also the parser kernel code.)\n                    //\n                    // In code:\n                    //\n                    //                  %{\n                    //                      @$ = @1;            // if location tracking support is included\n                    //                      if (typeof $1 !== 'undefined')\n                    //                          return $1;\n                    //                      else\n                    //                          return true;           // the default parse result if the rule actions don't produce anything\n                    //                  %}\n                    sp--;\n                    if (typeof vstack[sp] !== 'undefined') {\n                        retval = vstack[sp];\n                    }\n                }\n                break;\n            }\n\n            // break out of loop: we accept or fail with error\n            break;\n        }\n    } catch (ex) {\n        // report exceptions through the parseError callback too, but keep the exception intact\n        // if it is a known parser or lexer error which has been thrown by parseError() already:\n        if (ex instanceof this.JisonParserError) {\n            throw ex;\n        }\n        else if (lexer && typeof lexer.JisonLexerError === 'function' && ex instanceof lexer.JisonLexerError) {\n            throw ex;\n        }\n\n        p = this.constructParseErrorInfo('Parsing aborted due to exception.', ex, null, false);\n        retval = false;\n        r = this.parseError(p.errStr, p, this.JisonParserError);\n        if (typeof r !== 'undefined') {\n            retval = r;\n        }\n    } finally {\n        retval = this.cleanupAfterParse(retval, true, true);\n        this.__reentrant_call_depth--;\n    }   // /finally\n\n    return retval;\n}\n};\nparser.originalParseError = parser.parseError;\nparser.originalQuoteName = parser.quoteName;\n\nconst t = require(\"../parsetree\");\n\nfunction Parser() {\n  this.yy = {};\n}\nParser.prototype = parser;\nparser.Parser = Parser;\n\nreturn new Parser();\n})();\n\n        \n\n\nif (typeof require !== 'undefined' && typeof exports !== 'undefined') {\n  exports.parser = c_grammar;\n  exports.Parser = c_grammar.Parser;\n  exports.parse = function () {\n    return c_grammar.parse.apply(c_grammar, arguments);\n  };\n  \n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import lib from \"./_standard_library.json\";\n\nexport const STANDARD_LIBRARY = new Map(Object.entries(lib)) as ReadonlyMap<string, string>;\n\nexport const LIBRARY_HEADERS = (() => {\n    const map = new Map<string, string>();\n    for (const [path, data] of STANDARD_LIBRARY.entries()) {\n        if (path.endsWith(\".h\")) map.set(path, data);\n    }\n    return map as ReadonlyMap<string, string>;\n})();\n","const DEFAULT = {\n    generation_try_constant_expr: true,\n    generation_zero_shadow_stack: false,\n    generation_switch_br_table: false,\n\n    peephole_local_tee: true,\n    peephole_i32_constants_ops: true,\n    peephole_constants_add_mul: true,\n    peephole_add_0: true,\n    peephole_combine_adds: true,\n    peephole_load_offset: true,\n    peephole_constant_if: true,\n    peephole_unused_blocks: true,\n\n    partial_redundancy_elimination: true,\n    copy_propagation: true,\n    live_range_splitting: true,\n    dead_code_elimination: true,\n    reallocate_locals: true,\n    unused_locals: true,\n\n    peephole_2nd_pass: true,\n\n    // interprocedural\n    inlining: false,\n} as const;\n\nexport type OptimisationFlags = {[k in keyof typeof DEFAULT]: boolean};\n\nlet current: OptimisationFlags = DEFAULT;\n\nexport function setFlags(flags: Partial<OptimisationFlags> | \"none\" | \"default\"): void {\n    if (typeof flags === \"object\") {\n        current = {...current, ...flags};\n    } else if (flags === \"default\") {\n        current = DEFAULT;\n    } else if (flags === \"none\") {\n        current = {...current, ...Object.fromEntries(Object.keys(DEFAULT).map(name => [name, false]))};\n    }\n\n    // ensure valid configuration of flags\n    if (current.reallocate_locals && !current.copy_propagation) {\n        // realloc_locals presumes that variables are dead if not accessed, so copy_propagation\n        // is required to remove definitions which are never used.\n        current = {...current, copy_propagation: true};\n    }\n}\n\nexport function getFlags(): OptimisationFlags {\n    // return a copy\n    return {...current};\n}\n\nexport function getDefaultFlags(): OptimisationFlags {\n    return {...DEFAULT};\n}\n","import type {byte} from \"./base_types\";\nimport {ValueType, i32Type, i64Type, f32Type, f64Type} from \"./wtypes\";\n\nexport function encodeF32(n: number): byte[] {\n    const buffer = new ArrayBuffer(4);\n    new DataView(buffer).setFloat32(0, n, true);\n    return [...new Uint8Array(buffer)] as byte[];\n}\n\nexport function encodeF64(n: number): byte[] {\n    const buffer = new ArrayBuffer(8);\n    new DataView(buffer).setFloat64(0, n, true);\n    return [...new Uint8Array(buffer)] as byte[];\n}\n\n// unsigned 32 bit integer, used in wasm module format\nexport function encodeU32(n: bigint): byte[] {\n    if (n > 2n ** 32n - 1n || n < 0n) {\n        throw new Error(`Value ${n} outside of range for u32`);\n    }\n    return unsignedLeb128(n) as byte[];\n}\n\n// \"uninterpreted\" values, i.e. could be signed or not signed. Stored as signed. Used for constants\nexport function encodeInt32Constant(n: bigint | number): byte[] {\n    if (typeof n === \"number\") n = BigInt(n);\n\n    if (n < 2n ** 32n && n > 2n ** 31n - 1n) {\n        // need to reinterpret unsigned number as a signed number\n        n -= 2n ** 32n;\n    } else if (n > 2n ** 31n - 1n || n < -(2n ** 31n)) {\n        throw new Error(`Value ${n} outside of range for 32bit uninterpreted int`);\n    }\n    return signedLeb128(n) as byte[];\n}\n\nexport function encodeInt64Constant(n: bigint): byte[] {\n    if (n < 2n ** 64n && n > 2n ** 63n - 1n) {\n        // need to reinterpret unsigned number as a signed number\n        n -= 2n ** 64n;\n    } else if (n > 2n ** 63n - 1n || n < -(2n ** 63n)) {\n        throw new Error(`Value ${n} outside of range for 64bit uninterpreted int`);\n    }\n    return signedLeb128(n) as byte[];\n}\n\nexport function encodeConstantInstr(n: number | bigint, type: ValueType): byte[] {\n    if (type === i32Type) {\n        return [0x41 as byte, ...encodeInt32Constant(n)];\n    } else if (type === i64Type && typeof n === \"bigint\") {\n        return [0x42 as byte, ...encodeInt64Constant(n)];\n    } else if (type === f32Type && typeof n === \"number\") {\n        return [0x43 as byte, ...encodeF32(n)];\n    } else if (type === f64Type && typeof n === \"number\") {\n        return [0x44 as byte, ...encodeF64(n)];\n    } else {\n        throw new Error(`Invalid value type (${type.toString(16)}) or initial value (${n})`);\n    }\n}\n\nexport function encodeUtf8(str: string): byte[] {\n    // modified from https://developer.mozilla.org/en-US/docs/Web/API/TextEncoder#Polyfill\n    const result = [];\n    for (let point = 0, nextcode = 0, i = 0; i < str.length;) {\n        point = str.charCodeAt(i++);\n        if (point >= 0xD800 && point <= 0xDBFF) {\n            if (i === str.length) {\n                result.push(0xef, 0xbf, 0xbd);\n                break;\n            }\n            nextcode = str.charCodeAt(i);\n            if (nextcode >= 0xDC00 && nextcode <= 0xDFFF) {\n                point = (point - 0xD800) * 0x400 + nextcode - 0xDC00 + 0x10000;\n                i += 1;\n                if (point > 0xffff) {\n                    result.push((0x1e << 3) | (point >>> 18), (0x2 << 6) | ((point >>> 12) & 0x3f), (0x2 << 6) | ((point >>> 6) & 0x3f), (0x2 << 6) | (point & 0x3f));\n                    continue;\n                }\n            } else {\n                result.push(0xef, 0xbf, 0xbd);\n                continue;\n            }\n        }\n        if (point <= 0x007f) {\n            result.push((0x0 << 7) | point);\n        } else if (point <= 0x07ff) {\n            result.push((0x6 << 5) | (point >>> 6), (0x2 << 6) | (point & 0x3f));\n        } else {\n            result.push((0xe << 4) | (point >>> 12), (0x2 << 6) | ((point >>> 6) & 0x3f), (0x2 << 6) | (point & 0x3f));\n        }\n    }\n    // WebAssembly stores strings as a vector of bytes, so need to add the length\n    // (stored as u32) at the start\n    result.unshift(...encodeU32(BigInt(result.length)));\n    return result as byte[];\n}\n\nexport function unsignedLeb128(n: bigint): number[] {\n    const result: number[] = [];\n\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        const byte = Number(n & 0x7Fn);\n        n >>= 7n;\n        if (n === 0n) {\n            result.push(byte);\n            return result;\n        }\n        result.push(byte | 0x80);\n    }\n}\n\nexport function signedLeb128(n: bigint): number[] {\n    const result: number[] = [];\n\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        const byte = Number(n & 0x7Fn);\n        n >>= 7n;\n        if ((n === 0n && (byte & 0x40) === 0) || (n === -1n && (byte & 0x40) !== 0)) {\n            result.push(byte);\n            return result;\n        }\n        result.push(byte | 0x80);\n    }\n}\n","import type {byte} from \"./base_types\";\nimport {encodeU32} from \"./encoding\";\n\nexport type ValueType = byte & { __type_value_type__: void };\nexport const i32Type = 0x7F as ValueType;\nexport const i64Type = 0x7E as ValueType;\nexport const f32Type = 0x7D as ValueType;\nexport const f64Type = 0x7C as ValueType;\n\n\nexport type ResultType = ValueType[];\n\nexport function encodeResultType(r: ResultType): byte[] {\n    return encodeVec(r.map(x => [x]));\n}\n\n\nexport type FunctionType = [parameters: ResultType, results: ResultType];\n\nexport function encodeFunctionType(f: FunctionType): byte[] {\n    return [0x60 as byte, ...encodeResultType(f[0]), ...encodeResultType(f[1])];\n}\n\n\nexport type Limits = [minimum: bigint, maximum?: bigint];\nexport type MemoryType = Limits;\n\nexport function encodeLimits(l: Limits): byte[] {\n    if (l[1] === undefined) {\n        return [0x00 as byte, ...encodeU32(l[0])];\n    } else {\n        return [0x01 as byte, ...encodeU32(l[0]), ...encodeU32(l[1])];\n    }\n}\n\n\nexport type GlobalType = [type: ValueType, mutable: boolean];\n\nexport function encodeGlobal(g: GlobalType): byte[] {\n    return [g[0], g[1] ? 0x01 as byte : 0x00 as byte];\n}\n\n\nexport function encodeVec(values: byte[][]): byte[] {\n    return [...encodeU32(BigInt(values.length)), ...values.flat()];\n}\n","import {byte, labelidx} from \"./base_types\";\nimport {encodeU32} from \"./encoding\";\nimport {WFunctionBuilder, WLocal} from \"./functions\";\nimport {WGlobal} from \"./global\";\nimport {ValueType, i32Type, encodeVec} from \"./wtypes\";\n\nexport type ReadResource = \"memory\" | WLocal | WGlobal;\nexport type WriteResource = \"jump\" | \"arbitraryCode\" | ReadResource;\n\ntype Context = {\n    depth: number;\n    builder: WFunctionBuilder,\n    stack: ReadonlyArray<ValueType>;\n};\ntype InstrContext<T> = (c: Context) => T;\nexport type PartialInstr = InstrContext<InstrInstance>;\n\nexport interface BaseInstance<T extends BaseInstance<T>> {\n    readonly name: string;\n    readonly type: string;\n    readonly immediate: object;\n\n    /* Instruction as bytes */\n    encoded: ReadonlyArray<byte>;\n    /* Values consumed from stack, parameters[n-1] being top of the stack */\n    readonly parameters: ReadonlyArray<ValueType>;\n    /* Value pushed onto stack if any */\n    readonly result: ValueType | null;\n\n    readonly reads: ReadonlyArray<ReadResource>;\n    /* Resource written to */\n    readonly writes: ReadonlyArray<WriteResource>;\n\n    /* deep copy a function without re-evaluate parameters */\n    copy(): InstrContext<T>;\n}\n\nexport type InstrInstance = ZeroArgInstance | ConstantInstance<bigint | number> | MemInstance | IdxInstance | TableInstance | StructureInstance;\n\n// Zero argument instructions\ninterface ZeroArgInstance extends BaseInstance<ZeroArgInstance> {\n    type: \"zeroArg\";\n    immediate: {};\n}\n\nexport function zeroArgs(name: string, opcode: number[], parameters: ReadonlyArray<ValueType>, result: ValueType | null,\n                         reads: ReadResource[] = [], writes: WriteResource[] = []): () => InstrContext<ZeroArgInstance> {\n    const instr: ZeroArgInstance = {\n        name,\n        type: \"zeroArg\", immediate: {},\n        encoded: opcode as byte[],\n        parameters, result,\n        reads, writes,\n\n        copy() {\n            return () => this;\n        }\n    };\n    return () => () => instr;\n}\n\ntype DataFlow = {parameters: ValueType[], result: ValueType | null, reads: ReadResource[], writes: WriteResource[]};\nexport function zeroArgsSpecial(name: string, opcode: number[], specialFn: InstrContext<DataFlow>): () => InstrContext<ZeroArgInstance> {\n    return () => (context) => {\n        const {parameters, result, reads, writes} = specialFn(context);\n        return {\n            name, type: \"zeroArg\", immediate: {},\n            encoded: opcode as byte[],\n            parameters, result,\n            reads, writes,\n\n            copy() {\n                return () => this;\n            }\n        };\n    };\n}\n\n// Arithmetic constant instructions\ninterface ConstantInstance<T extends bigint | number> extends BaseInstance<ConstantInstance<T>> {\n    type: \"constant\";\n    immediate: {readonly value: T};\n    result: ValueType;\n}\n\nexport function constantArg<T extends bigint | number>(name: string, opcode: number[],\n                                                       encodeFn: (x: T) => byte[],\n                                                       typeFn: (x: T) => T,\n                                                       result: ValueType): (x: T) => InstrContext<ConstantInstance<T>> {\n    return (value) => () => ({\n        name, type: \"constant\",\n        immediate: {value: typeFn(value)},\n        encoded: [...opcode as byte[], ...encodeFn(value)],\n        parameters: [], result,\n        reads: [], writes: [],\n\n        copy() {\n            return () => this;\n        }\n    });\n}\n\n// Memory argument instructions\ninterface MemInstance extends BaseInstance<MemInstance> {\n    type: \"memory\";\n    immediate: {readonly align: bigint, readonly offset: bigint};\n}\n\nexport function memArg(name: string, opcode: number[],\n                       type: \"load\" | \"store\", valueType: ValueType): (align: number | bigint, offset: number | bigint) => InstrContext<MemInstance> {\n    return (align, offset) => {\n        if (typeof align === \"number\") align = BigInt(align);\n        if (typeof offset === \"number\") offset = BigInt(offset);\n        const encoded = [...opcode as byte[], ...encodeU32(align), ...encodeU32(offset)];\n        const args = {align, offset};\n\n        return () => ({\n            name, encoded,\n            type: \"memory\", immediate: args,\n            parameters: type === \"load\" ? [i32Type] : [i32Type, valueType],\n            result: type === \"load\" ? valueType : null,\n            reads: type === \"load\" ? [\"memory\"] : [],\n            writes: type === \"load\" ? [] : [\"memory\"],\n\n            copy() {\n                return () => this;\n            }\n        });\n    };\n}\n\n// Index argument instructions\n\n// either an index (instance of T), an object with a getter for the index\n// or a plain number to make the api easier to use\ntype Index<T extends bigint> = number | T | {getIndex(depth: number): T};\ninterface IdxInstance extends BaseInstance<IdxInstance> {\n    type: \"index\";\n    immediate: {readonly value: bigint};\n}\n\nfunction getIndex<T extends bigint>(idx: Index<T>, depth: number): T {\n    let value: T;\n    if (typeof idx === \"number\") {\n        value = BigInt(idx) as T;\n    } else if (typeof idx === \"bigint\") {\n        value = idx as T;\n    } else {\n        value = idx.getIndex(depth);\n    }\n    return value;\n}\n\ntype IndexFn<T extends bigint, X> = (c: Context & {value: T, extra: X}) => DataFlow;\nexport function idxArg<T extends bigint, X extends any[]>(name: string, opcode: number[], suffix: number[],\n                                                          stackOps: IndexFn<T, X>): (x: Index<T>, ...extra: X) => InstrContext<IdxInstance> {\n    return (x, ...extra) => context => {\n        const value = getIndex(x, context.depth);\n        const encoded = [...opcode as byte[], ...encodeU32(value), ...suffix as byte[]];\n        const {parameters, result, reads, writes} = stackOps({value, extra, ...context});\n\n        return {\n            name, encoded,\n            type: \"index\", immediate: {value},\n            parameters, result,\n            reads, writes,\n\n            copy() {\n                return () => this;\n            }\n        };\n    };\n}\n\ninterface TableInstance extends BaseInstance<TableInstance> {\n    type: \"table\";\n    immediate: {readonly defaultValue: bigint, readonly valueTable: ReadonlyArray<bigint>};\n}\n\nexport function brTableInstr(opcode: number): (defaultLbl: Index<labelidx>, lblArray: Index<labelidx>[]) => InstrContext<TableInstance> {\n    return (defaultLbl, lblArray) => context => {\n        const defaultValue = getIndex(defaultLbl, context.depth);\n        const valueTable = lblArray.map(x => getIndex(x, context.depth));\n        const encoded = [opcode as byte, ...encodeVec(valueTable.map(encodeU32)), ...encodeU32(defaultValue)];\n\n        return {\n            name: \"br_table\", encoded,\n            type: \"table\", immediate: {defaultValue, valueTable},\n            parameters: [i32Type], result: null,\n            reads: [], writes: [\"jump\"],\n\n            copy() {\n                return () => this;\n            }\n        };\n    };\n}\n\n// Structured instructions\ntype StructureInstance = BlockLoopInstance | IfInstance;\ninterface BlockLoopInstance extends BaseInstance<BlockLoopInstance> {\n    type: \"structured\";\n    name: \"block\" | \"loop\";\n    immediate: {readonly type: ValueType | null, readonly expression: WExpression, readonly expression2: undefined};\n}\n\ninterface IfInstance extends BaseInstance<IfInstance> {\n    type: \"structured\";\n    name: \"if\";\n    immediate: {readonly type: ValueType | null, readonly expression: WExpression, readonly expression2: WExpression | undefined};\n}\n\nfunction encodeBlockType(t: ValueType | null): byte[] {\n    if (t === null) return [0x40 as byte];\n    return [t];\n}\n\nexport function blockLoopInstr(opcode: number, name: \"block\" | \"loop\"): (type: ValueType | null, body: (PartialInstr | InstrInstance)[], contextFn?: InstrContext<void>) => InstrContext<BlockLoopInstance> {\n    const constructor = (type: ValueType | null, body: (PartialInstr | InstrInstance)[], contextFn?: InstrContext<void>) => (context: Context) => {\n        if (contextFn) contextFn(context); // used to store depth\n\n        const instr: BlockLoopInstance = {\n            name, type: \"structured\",\n            parameters: [], result: type,\n\n            get encoded() {\n                return [opcode as byte, ...encodeBlockType(type), ...expression.encoded];\n            },\n            get immediate() {\n                return {type, expression, expression2: undefined};\n            },\n            get reads() {\n                return expression.reads;\n            },\n            get writes() {\n                return expression.writes;\n            },\n\n            copy() {\n                return (ctx) => {\n                    const x = constructor(type, [])(ctx);\n                    expression.copyInto(x.immediate.expression);\n                    return x;\n                };\n            }\n        };\n        const expression = new WExpression(instr, context.depth + 1, context.builder);\n        expression.push(...body);\n        return instr;\n    };\n\n    return constructor;\n}\n\nexport function ifInstr(opcode: number, elseOpcode: number): (type: ValueType | null, body: (PartialInstr | InstrInstance)[], elseBody?: (PartialInstr | InstrInstance)[], contextFn?: InstrContext<void>) => InstrContext<IfInstance> {\n    const constructor = (type: ValueType | null, body: (PartialInstr | InstrInstance)[], elseBody?: (PartialInstr | InstrInstance)[], contextFn?: InstrContext<void>) => (context: Context) => {\n        if (contextFn) contextFn(context); // used to store depth\n\n        const instr: IfInstance = {\n            name: \"if\", type: \"structured\",\n            parameters: [i32Type], result: type,\n\n            get encoded() {\n                const instr = [opcode as byte, ...encodeBlockType(type), ...expression.encoded];\n                if (expression2) {\n                    instr.pop(); // replace 0x0B marking end of expression1 with 0x05 for else\n                    instr.push(elseOpcode as byte, ...expression2.encoded);\n                }\n                return instr;\n            },\n            get immediate() {\n                return {type, expression, expression2};\n            },\n            get reads() {\n                if (expression2) {\n                    return [...new Set([...expression.reads, ...expression2.reads])];\n                }\n                return expression.reads;\n            },\n            get writes() {\n                if (expression2) {\n                    return [...new Set([...expression.writes, ...expression2.writes])];\n                }\n                return expression.writes;\n            },\n\n            copy() {\n                return (ctx) => {\n                    const x = constructor(type, [], expression2 ? [] : undefined)(ctx);\n                    expression.copyInto(x.immediate.expression);\n                    if (expression2) expression2.copyInto(x.immediate.expression2 as WExpression);\n                    return x;\n                };\n            }\n        };\n\n        const expression = new WExpression(instr, context.depth + 1, context.builder);\n        expression.push(...body);\n        let expression2: WExpression | undefined;\n        if (elseBody) {\n            expression2 = new WExpression(instr, context.depth + 1, context.builder);\n            expression2.push(...elseBody);\n        }\n        return instr;\n    };\n\n    return constructor;\n}\n\n\n// Expressions\nexport class WExpression {\n    private _stack: ValueType[] = [];\n    private _instructions: InstrInstance[] = [];\n\n    constructor(readonly parent: StructureInstance | null, readonly depth: number, readonly builder: WFunctionBuilder) {\n    }\n\n    push(...items: (PartialInstr | InstrInstance)[]): void {\n        for (const instrFn of items) {\n            this._instructions.push(this.createInstr(instrFn, this._stack));\n        }\n    }\n\n    get(index: number): InstrInstance {\n        if (index < 0) index += this.instructions.length;\n        return this._instructions[index];\n    }\n\n    pop(): InstrInstance | undefined {\n        const instr = this._instructions.pop();\n        if (!instr) return undefined;\n\n        if (instr.result) this._stack.pop();\n        this._stack.push(...instr.parameters);\n        return instr;\n    }\n\n    replace(start: number, end: number, ...items: (PartialInstr | InstrInstance)[]): void {\n        if (start < 0 || end < start || start > this._instructions.length) {\n            throw new Error(\"Invalid replacement indices\");\n        }\n\n        // stack and instructions before\n        const stack: ValueType[] = []; // new instructions going at start of expression, so stack will be empty\n        const instructions: InstrInstance[] = this._instructions.slice(0, start);\n        instructions.forEach(x => this.stackManipulation(x, stack));\n\n        // new instructions\n        items.forEach(newInstr => instructions.push(this.createInstr(newInstr, stack)));\n\n        // instructions after\n        try {\n            for (let i = end, instr; i < this._instructions.length; i++) {\n                this.stackManipulation(instr = this._instructions[i], stack);\n                instructions.push(instr);\n            }\n\n            // check stack the same\n            if (this._stack.length !== stack.length || this._stack.some((v, i) => v !== stack[i])) {\n                throw new Error(\"Stack different\");\n            }\n\n            this._instructions = instructions;\n        } catch (e) {\n            throw new Error(`Invalid replacement due to: \\n\\n${e.stack}\\n`);\n        }\n    }\n\n    copyInto(target: WExpression): void {\n        for (const instr of this.instructions) target.push(instr.copy());\n    }\n\n    *instructionsRecursive(): IterableIterator<InstrInstance> {\n        for (const instr of this.instructions) {\n            yield instr;\n            if (instr.type === \"structured\") {\n                yield* instr.immediate.expression.instructionsRecursive();\n                if (instr.immediate.expression2) yield* instr.immediate.expression2.instructionsRecursive();\n            }\n        }\n    }\n\n    private stackManipulation(instr: InstrInstance, stack: ValueType[]) {\n        // check stack parameters\n        for (let i = instr.parameters.length - 1; i >= 0; i--) {\n            if (instr.parameters[i] !== stack.pop()) {\n                throw new Error(`Stack does not match Wasm instruction (${instr.name}) parameters\\nPrevious instructions: ${this._instructions.map(x => x.name).reverse().join(\", \")}`);\n            }\n        }\n        // push result if any\n        if (instr.result) stack.push(instr.result);\n    }\n\n    private createInstr(instr: PartialInstr | InstrInstance, stack: ValueType[]): InstrInstance {\n        if (typeof instr === \"function\") {\n            // PartialInstr - get instance of the instruction\n            instr = instr({\n                depth: this.depth,\n                builder: this.builder,\n                stack\n            });\n        }\n        this.stackManipulation(instr, stack);\n        return instr;\n    }\n\n    get instructions(): ReadonlyArray<InstrInstance> {\n        return this._instructions;\n    }\n\n    get stack(): ReadonlyArray<ValueType> {\n        return this._stack;\n    }\n\n    get encoded(): byte[] {\n        const encoded = this._instructions.flatMap(x => x.encoded);\n        encoded.push(0x0B as byte);\n        return encoded;\n    }\n\n    get reads(): ReadonlyArray<ReadResource> {\n        const reads = this._instructions.flatMap(x => x.reads);\n        return [...new Set(reads)];\n    }\n\n    get writes(): ReadonlyArray<WriteResource> {\n        const writes = this._instructions.flatMap(x => x.writes);\n        return [...new Set(writes)];\n    }\n}\n","import {labelidx, funcidx, typeidx, localidx, globalidx} from \"./base_types\";\nimport {encodeF32, encodeF64, encodeInt64Constant, encodeInt32Constant} from \"./encoding\";\nimport {zeroArgs, blockLoopInstr, ifInstr, idxArg, zeroArgsSpecial, memArg, constantArg, PartialInstr, brTableInstr} from \"./instr_helpers\";\nimport {i32Type, i64Type, f32Type, f64Type, ValueType} from \"./wtypes\";\n\nexport type WInstruction = PartialInstr;\nexport {WExpression} from \"./instr_helpers\";\n\nexport const Instructions = {\n    // control instructions\n    unreachable: zeroArgs(\"unreachable\", [0x00], [], null),\n    nop: zeroArgs(\"nop\", [0x01], [], null),\n    block: blockLoopInstr(0x02, \"block\"),\n    loop: blockLoopInstr(0x03, \"loop\"),\n    if: ifInstr(0x04, 0x05),\n    br: idxArg<labelidx, ValueType[]>(\"br\", [0x0C], [], ({extra}) => ({\n        // if this br consumes a result, it must be passed into the function call as it cannot be inferred\n        parameters: extra, result: null,\n        reads: [], writes: [\"jump\"]\n    })),\n    br_if: idxArg<labelidx, []>(\"br_if\",[0x0D], [], () => ({\n        parameters: [], result: null,\n        reads: [], writes: [\"jump\"]\n    })),\n    br_table: brTableInstr(0x0E),\n    return: zeroArgsSpecial(\"return\", [0x0F], ({builder}) => ({\n        parameters: builder.type[1], result: null,\n        reads: [], writes: [\"jump\"]\n    })),\n    call: idxArg<funcidx, []>(\"call\", [0x10], [], ({builder, value}) => {\n        const func = builder.fn.parent._functionLookup(value); // function that we are calling may write to memory\n        return {parameters: func.type[0], result: func.type[1][0] ?? null, reads: [], writes: [\"jump\", \"memory\"]};\n    }),\n    call_indirect: idxArg<typeidx, []>(\"call_indirect\", [0x11], [0x00], ({builder, value}) => {\n        const type = builder.fn.parent._typeLookup(value);\n        return {parameters: [...type[0], i32Type], result: type[1][0] ?? null, reads: [], writes: [\"jump\", \"memory\"]};\n    }),\n\n\n    // parametric instructions\n    drop: zeroArgsSpecial(\"drop\", [0x1A], ({stack}) => {\n        if (stack.length <= 0) throw new Error(\"Drop on empty stack\");\n\n        return {\n            parameters: [stack[stack.length - 1]], result: null,\n            reads: [], writes: []\n        };\n    }),\n    // select: zeroArgsSpecial(\"select\", ...),\n\n\n    // variable instructions\n    local: {\n        get: idxArg<localidx, []>(\"local.get\", [0x20], [], ({builder, value}) => {\n            const local = builder.getLocal(value);\n            return {parameters: [], result: local.type, reads: [local], writes: []};\n        }),\n        set: idxArg<localidx, []>(\"local.set\", [0x21], [], ({builder, value}) => {\n            const local = builder.getLocal(value);\n            return {parameters: [local.type], result: null, reads: [], writes: [local]};\n        }),\n        tee: idxArg<localidx, []>(\"local.tee\", [0x22], [], ({builder, value}) => {\n            const local = builder.getLocal(value);\n            return {parameters: [local.type], result: local.type, reads: [], writes: [local]};\n        }),\n    } as const,\n    global: {\n        get: idxArg<globalidx, []>(\"global.get\", [0x23], [], ({builder, value}) => {\n            const global = builder.fn.parent._globalLookup(value);\n            return {parameters: [], result: global.type, reads: [global], writes: []};\n        }),\n        set: idxArg<globalidx, []>(\"global.set\", [0x24], [], ({builder, value}) => {\n            const global = builder.fn.parent._globalLookup(value);\n            return {parameters: [global.type], result: null, reads: [], writes: [global]};\n        }),\n    } as const,\n\n\n    // memory instructions\n    memory: {\n        size: zeroArgs(\"memory.size\",[0x3F, 0x00], [], i32Type, [\"memory\"], []),\n        grow: zeroArgs(\"memory.grow\", [0x40, 0x00], [i32Type], i32Type, [\"memory\"], [\"memory\"]),\n        copy: zeroArgs(\"memory.copy\", [0xFC, 0x0A, 0x00, 0x00], [i32Type, i32Type, i32Type], null, [\"memory\"], [\"memory\"]),\n        fill: zeroArgs(\"memory.fill\", [0xFC, 0x0B, 0x00], [i32Type, i32Type, i32Type], null, [], [\"memory\"])\n    } as const,\n\n\n    i32: {\n        load: memArg(\"i32.load\", [0x28],\"load\", i32Type),\n        load8_s: memArg(\"i32.load8_s\", [0x2C], \"load\", i32Type),\n        load8_u: memArg(\"i32.load8_u\", [0x2D], \"load\", i32Type),\n        load16_s: memArg(\"i32.load16_s\", [0x2E], \"load\", i32Type),\n        load16_u: memArg(\"i32.load16_u\", [0x2F], \"load\", i32Type),\n        store: memArg(\"i32.store\", [0x36], \"store\", i32Type),\n        store8: memArg(\"i32.store8\", [0x3A], \"store\", i32Type),\n        store16: memArg(\"i32.store16\", [0x3B], \"store\", i32Type),\n\n        const: constantArg<number|bigint>(\"i32.const\", [0x41], encodeInt32Constant, BigInt, i32Type),\n\n        eqz: zeroArgs(\"i32.eqz\", [0x45], [i32Type], i32Type),\n        eq: zeroArgs(\"i32.eq\", [0x46], [i32Type, i32Type], i32Type),\n        ne: zeroArgs(\"i32.ne\", [0x47], [i32Type, i32Type], i32Type),\n        lt_s: zeroArgs(\"i32.lt_s\", [0x48], [i32Type, i32Type], i32Type),\n        lt_u: zeroArgs(\"i32.lt_u\", [0x49], [i32Type, i32Type], i32Type),\n        gt_s: zeroArgs(\"i32.gt_s\", [0x4A], [i32Type, i32Type], i32Type),\n        gt_u: zeroArgs(\"i32.gt_u\", [0x4B], [i32Type, i32Type], i32Type),\n        le_s: zeroArgs(\"i32.le_s\", [0x4C], [i32Type, i32Type], i32Type),\n        le_u: zeroArgs(\"i32.le_u\", [0x4D], [i32Type, i32Type], i32Type),\n        ge_s: zeroArgs(\"i32.ge_s\", [0x4E], [i32Type, i32Type], i32Type),\n        ge_u: zeroArgs(\"i32.ge_u\", [0x4F], [i32Type, i32Type], i32Type),\n\n        clz: zeroArgs(\"i32.clz\", [0x67], [i32Type], i32Type),\n        ctz: zeroArgs(\"i32.ctz\", [0x68], [i32Type], i32Type),\n        popcnt: zeroArgs(\"i32.popcnt\", [0x69], [i32Type], i32Type),\n        add: zeroArgs(\"i32.add\", [0x6A], [i32Type, i32Type], i32Type),\n        sub: zeroArgs(\"i32.sub\", [0x6B], [i32Type, i32Type], i32Type),\n        mul: zeroArgs(\"i32.mul\", [0x6C], [i32Type, i32Type], i32Type),\n        div_s: zeroArgs(\"i32.div_s\", [0x6D], [i32Type, i32Type], i32Type),\n        div_u: zeroArgs(\"i32.div_u\", [0x6E], [i32Type, i32Type], i32Type),\n        rem_s: zeroArgs(\"i32.rem_s\", [0x6F], [i32Type, i32Type], i32Type),\n        rem_u: zeroArgs(\"i32.rem_u\", [0x70], [i32Type, i32Type], i32Type),\n        and: zeroArgs(\"i32.and\", [0x71], [i32Type, i32Type], i32Type),\n        or: zeroArgs(\"i32.or\", [0x72], [i32Type, i32Type], i32Type),\n        xor: zeroArgs(\"i32.xor\", [0x73], [i32Type, i32Type], i32Type),\n        shl: zeroArgs(\"i32.shl\", [0x74], [i32Type, i32Type], i32Type),\n        shr_s: zeroArgs(\"i32.shr_s\", [0x75], [i32Type, i32Type], i32Type),\n        shr_u: zeroArgs(\"i32.shr_u\", [0x76], [i32Type, i32Type], i32Type),\n        rotl: zeroArgs(\"i32.rotl\", [0x77], [i32Type, i32Type], i32Type),\n        rotr: zeroArgs(\"i32.rotr\", [0x78], [i32Type, i32Type], i32Type),\n\n        wrap_i64: zeroArgs(\"i32.wrap_i64\", [0xA7], [i64Type], i32Type),\n        trunc_f32_s: zeroArgs(\"i32.trunc_f32_s\", [0xA8], [f32Type], i32Type),\n        trunc_f32_u: zeroArgs(\"i32.trunc_f32_u\", [0xA9], [f32Type], i32Type),\n        trunc_f64_s: zeroArgs(\"i32.trunc_f64_s\", [0xAA], [f64Type], i32Type),\n        trunc_f64_u: zeroArgs(\"i32.trunc_f64_u\", [0xAB], [f64Type], i32Type),\n\n        reinterpret_f32: zeroArgs(\"i32.reinterpret_f32\", [0xBC], [f32Type], i32Type),\n        extend8_s: zeroArgs(\"i32.extend8_s\", [0xC0], [i32Type], i32Type),\n        extend16_s: zeroArgs(\"i32.extend16_s\", [0xC1], [i32Type], i32Type),\n\n        // Non-trapping Float-to-int Conversions\n        trunc_sat_f32_s: zeroArgs(\"i32.trunc_sat_f32_s\", [0xFC, 0], [f32Type], i32Type),\n        trunc_sat_f32_u: zeroArgs(\"i32.trunc_sat_f32_u\", [0xFC, 1], [f32Type], i32Type),\n        trunc_sat_f64_s: zeroArgs(\"i32.trunc_sat_f64_s\", [0xFC, 2], [f64Type], i32Type),\n        trunc_sat_f64_u: zeroArgs(\"i32.trunc_sat_f64_u\", [0xFC, 3], [f64Type], i32Type),\n    } as const,\n\n    i64: {\n        load: memArg(\"i64.load\", [0x29], \"load\", i64Type),\n        load8_s: memArg(\"i64.load8_s\", [0x30], \"load\", i64Type),\n        load8_u: memArg(\"i64.load8_u\", [0x31], \"load\", i64Type),\n        load16_s: memArg(\"i64.load16_s\", [0x32], \"load\", i64Type),\n        load16_u: memArg(\"i64.load16_u\", [0x33], \"load\", i64Type),\n        load32_s: memArg(\"i64.load32_s\", [0x34], \"load\", i64Type),\n        load32_u: memArg(\"i64.load32_u\", [0x35], \"load\", i64Type),\n        store: memArg(\"i64.store\", [0x37], \"store\", i64Type),\n        store8: memArg(\"i64.store8\", [0x3C], \"store\", i64Type),\n        store16: memArg(\"i64.store16\", [0x3D], \"store\", i64Type),\n        store32: memArg(\"i64.store32\", [0x3E], \"store\", i64Type),\n\n        const: constantArg<bigint>(\"i64.const\", [0x42], encodeInt64Constant, BigInt, i64Type),\n\n        eqz: zeroArgs(\"i64.eqz\", [0x50], [i64Type], i32Type),\n        eq: zeroArgs(\"i64.eq\", [0x51], [i64Type, i64Type], i32Type),\n        ne: zeroArgs(\"i64.ne\", [0x52], [i64Type, i64Type], i32Type),\n        lt_s: zeroArgs(\"i64.lt_s\", [0x53], [i64Type, i64Type], i32Type),\n        lt_u: zeroArgs(\"i64.lt_u\", [0x54], [i64Type, i64Type], i32Type),\n        gt_s: zeroArgs(\"i64.gt_s\", [0x55], [i64Type, i64Type], i32Type),\n        gt_u: zeroArgs(\"i64.gt_u\", [0x56], [i64Type, i64Type], i32Type),\n        le_s: zeroArgs(\"i64.le_s\", [0x57], [i64Type, i64Type], i32Type),\n        le_u: zeroArgs(\"i64.le_u\", [0x58], [i64Type, i64Type], i32Type),\n        ge_s: zeroArgs(\"i64.ge_s\", [0x59], [i64Type, i64Type], i32Type),\n        ge_u: zeroArgs(\"i64.ge_u\", [0x5A], [i64Type, i64Type], i32Type),\n\n        clz: zeroArgs(\"i64.clz\", [0x79], [i64Type], i64Type),\n        ctz: zeroArgs(\"i64.ctz\", [0x7A], [i64Type], i64Type),\n        popcnt: zeroArgs(\"i64.popcnt\", [0x7B], [i64Type], i64Type),\n        add: zeroArgs(\"i64.add\", [0x7C], [i64Type, i64Type], i64Type),\n        sub: zeroArgs(\"i64.sub\", [0x7D], [i64Type, i64Type], i64Type),\n        mul: zeroArgs(\"i64.mul\", [0x7E], [i64Type, i64Type], i64Type),\n        div_s: zeroArgs(\"i64.div_s\", [0x7F], [i64Type, i64Type], i64Type),\n        div_u: zeroArgs(\"i64.div_u\", [0x80], [i64Type, i64Type], i64Type),\n        rem_s: zeroArgs(\"i64.rem_s\", [0x81], [i64Type, i64Type], i64Type),\n        rem_u: zeroArgs(\"i64.rem_u\", [0x82], [i64Type, i64Type], i64Type),\n        and: zeroArgs(\"i64.and\", [0x83], [i64Type, i64Type], i64Type),\n        or: zeroArgs(\"i64.or\", [0x84], [i64Type, i64Type], i64Type),\n        xor: zeroArgs(\"i64.xor\", [0x85], [i64Type, i64Type], i64Type),\n        shl: zeroArgs(\"i64.shl\", [0x86], [i64Type, i64Type], i64Type),\n        shr_s: zeroArgs(\"i64.shr_s\", [0x87], [i64Type, i64Type], i64Type),\n        shr_u: zeroArgs(\"i64.shr_u\", [0x88], [i64Type, i64Type], i64Type),\n        rotl: zeroArgs(\"i64.rotl\", [0x89], [i64Type, i64Type], i64Type),\n        rotr: zeroArgs(\"i64.rotr\", [0x8A], [i64Type, i64Type], i64Type),\n\n        extend_i32_s: zeroArgs(\"i64.extend_i32_s\", [0xAC], [i32Type], i64Type),\n        extend_i32_u: zeroArgs(\"i64.extend_i32_u\", [0xAD], [i32Type], i64Type),\n        trunc_f32_s: zeroArgs(\"i64.trunc_f32_s\", [0xAE], [f32Type], i64Type),\n        trunc_f32_u: zeroArgs(\"i64.trunc_f32_u\", [0xAF], [f32Type], i64Type),\n        trunc_f64_s: zeroArgs(\"i64.trunc_f64_s\", [0xB0], [f64Type], i64Type),\n        trunc_f64_u: zeroArgs(\"i64.trunc_f64_u\", [0xB1], [f64Type], i64Type),\n\n        reinterpret_f64: zeroArgs(\"i64.reinterpret_f64\", [0xBD], [f64Type], i64Type),\n        extend8_s: zeroArgs(\"i64.extend8_s\", [0xC2], [i64Type], i64Type),\n        extend16_s: zeroArgs(\"i64.extend16_s\", [0xC3], [i64Type], i64Type),\n        extend32_s: zeroArgs(\"i64.extend32_s\", [0xC4], [i64Type], i64Type),\n\n        // Non-trapping Float-to-int Conversions\n        trunc_sat_f32_s: zeroArgs(\"i32.trunc_sat_f32_s\", [0xFC, 4], [f32Type], i64Type),\n        trunc_sat_f32_u: zeroArgs(\"i32.trunc_sat_f32_u\", [0xFC, 5], [f32Type], i64Type),\n        trunc_sat_f64_s: zeroArgs(\"i32.trunc_sat_f64_s\", [0xFC, 6], [f64Type], i64Type),\n        trunc_sat_f64_u: zeroArgs(\"i32.trunc_sat_f64_u\", [0xFC, 7], [f64Type], i64Type),\n    } as const,\n\n    f32: {\n        load: memArg(\"f32.load\", [0x2A], \"load\", f32Type),\n        store: memArg(\"f32.store\", [0x38], \"store\", f32Type),\n\n        const: constantArg<number>(\"f32.const\", [0x43], encodeF32, Number, f32Type),\n\n        eq: zeroArgs(\"f32.eq\", [0x5B], [f32Type, f32Type], i32Type),\n        ne: zeroArgs(\"f32.ne\", [0x5C], [f32Type, f32Type], i32Type),\n        lt: zeroArgs(\"f32.lt\", [0x5D], [f32Type, f32Type], i32Type),\n        gt: zeroArgs(\"f32.gt\", [0x5E], [f32Type, f32Type], i32Type),\n        le: zeroArgs(\"f32.le\", [0x5F], [f32Type, f32Type], i32Type),\n        ge: zeroArgs(\"f32.ge\", [0x60], [f32Type, f32Type], i32Type),\n\n        abs: zeroArgs(\"f32.abs\", [0x8B], [f32Type], f32Type),\n        neg: zeroArgs(\"f32.neg\", [0x8C], [f32Type], f32Type),\n        ceil: zeroArgs(\"f32.ceil\", [0x8D], [f32Type], f32Type),\n        floor: zeroArgs(\"f32.floor\", [0x8E], [f32Type], f32Type),\n        trunc: zeroArgs(\"f32.trunc\", [0x8F], [f32Type], f32Type),\n        nearest: zeroArgs(\"f32.nearest\", [0x90], [f32Type], f32Type),\n        sqrt: zeroArgs(\"f32.sqrt\", [0x91], [f32Type], f32Type),\n        add: zeroArgs(\"f32.add\", [0x92], [f32Type, f32Type], f32Type),\n        sub: zeroArgs(\"f32.sub\", [0x93], [f32Type, f32Type], f32Type),\n        mul: zeroArgs(\"f32.mul\", [0x94], [f32Type, f32Type], f32Type),\n        div: zeroArgs(\"f32.div\", [0x95], [f32Type, f32Type], f32Type),\n        min: zeroArgs(\"f32.min\", [0x96], [f32Type, f32Type], f32Type),\n        max: zeroArgs(\"f32.max\", [0x97], [f32Type, f32Type], f32Type),\n        copysign: zeroArgs(\"f32.copysign\", [0x98], [f32Type, f32Type], f32Type),\n\n        convert_i32_s: zeroArgs(\"f32.convert_i32_s\", [0xB2], [i32Type], f32Type),\n        convert_i32_u: zeroArgs(\"f32.convert_i32_u\", [0xB3], [i32Type], f32Type),\n        convert_i64_s: zeroArgs(\"f32.convert_i64_s\", [0xB4], [i64Type], f32Type),\n        convert_i64_u: zeroArgs(\"f32.convert_i64_u\", [0xB5], [i64Type], f32Type),\n        demote_f64: zeroArgs(\"f32.demote_f64\", [0xB6], [f64Type], f32Type),\n\n        reinterpret_i32: zeroArgs(\"f32.reinterpret_i32\", [0xBE], [i32Type], f32Type),\n    } as const,\n\n    f64: {\n        load: memArg(\"f64.load\", [0x2B], \"load\", f64Type),\n        store: memArg(\"f64.store\", [0x39], \"store\", f64Type),\n\n        const: constantArg<number>(\"f64.const\", [0x44], encodeF64, Number, f64Type),\n\n        eq: zeroArgs(\"f64.eq\", [0x61], [f64Type, f64Type], i32Type),\n        ne: zeroArgs(\"f64.ne\", [0x62], [f64Type, f64Type], i32Type),\n        lt: zeroArgs(\"f64.lt\", [0x63], [f64Type, f64Type], i32Type),\n        gt: zeroArgs(\"f64.gt\", [0x64], [f64Type, f64Type], i32Type),\n        le: zeroArgs(\"f64.le\", [0x65], [f64Type, f64Type], i32Type),\n        ge: zeroArgs(\"f64.ge\", [0x66], [f64Type, f64Type], i32Type),\n\n        abs: zeroArgs(\"f64.abs\", [0x99], [f64Type], f64Type),\n        neg: zeroArgs(\"f64.neg\", [0x9A], [f64Type], f64Type),\n        ceil: zeroArgs(\"f64.ceil\", [0x9B], [f64Type], f64Type),\n        floor: zeroArgs(\"f64.floor\", [0x9C], [f64Type], f64Type),\n        trunc: zeroArgs(\"f64.trunc\", [0x9D], [f64Type], f64Type),\n        nearest: zeroArgs(\"f64.nearest\", [0x9E], [f64Type], f64Type),\n        sqrt: zeroArgs(\"f64.sqrt\", [0x9F], [f64Type], f64Type),\n        add: zeroArgs(\"f64.add\", [0xA0], [f64Type, f64Type], f64Type),\n        sub: zeroArgs(\"f64.sub\", [0xA1], [f64Type, f64Type], f64Type),\n        mul: zeroArgs(\"f64.mul\", [0xA2], [f64Type, f64Type], f64Type),\n        div: zeroArgs(\"f64.div\", [0xA3], [f64Type, f64Type], f64Type),\n        min: zeroArgs(\"f64.min\", [0xA4], [f64Type, f64Type], f64Type),\n        max: zeroArgs(\"f64.max\", [0xA5], [f64Type, f64Type], f64Type),\n        copysign: zeroArgs(\"f64.copysign\", [0xA6], [f64Type, f64Type], f64Type),\n\n        convert_i32_s: zeroArgs(\"f64.convert_i32_s\", [0xB7], [i32Type], f64Type),\n        convert_i32_u: zeroArgs(\"f64.convert_i32_u\", [0xB8], [i32Type], f64Type),\n        convert_i64_s: zeroArgs(\"f64.convert_i64_s\", [0xB9], [i64Type], f64Type),\n        convert_i64_u: zeroArgs(\"f64.convert_i64_u\", [0xBA], [i64Type], f64Type),\n        promote_f32: zeroArgs(\"f64.promote_f32\", [0xBB], [f32Type], f64Type),\n\n        reinterpret_i64: zeroArgs(\"f64.reinterpret_i64\", [0xBF], [i64Type], f64Type),\n    } as const\n\n} as const;\n","import {WExpression, ValueType, Instructions} from \"../wasm\";\nimport {WLocal} from \"../wasm/functions\";\nimport {InstrInstance, PartialInstr} from \"../wasm/instr_helpers\";\n\nexport function deadCodeElimination(expr: WExpression, usedLocals = new Set<WLocal>()): void {\n    const [instructions, stackItems] = dataflow(expr);\n\n    // instructions which write to a non-local resource are definitely needed\n    for (const instruction of instructions) {\n        if (instruction.instr.writes.some(resource => !(resource instanceof WLocal))) {\n            markNeeded(instruction);\n        }\n    }\n    markRecursively(stackItems);\n\n    // instructions writing to locals which are read after are also needed\n    for (let i = instructions.length - 1; i >= 0; i--) {\n        const instruction = instructions[i], instr = instruction.instr;\n\n        if (!instruction.needed) {\n            for (const write of instr.writes) {\n                if (write instanceof WLocal && usedLocals.has(write)) {\n                    markNeeded(instruction);\n                    markRecursively(stackItems);\n                    break;\n                }\n            }\n        }\n\n        if (instruction.needed) {\n            // recursively check subexpressions now before other locals are marked as used\n            if (instr.type === \"structured\") {\n                // special case: loops may repeat code so just presume all locals are needed before recurring\n                if (instr.name === \"loop\") {\n                    for (const read of instr.reads) {\n                        if (read instanceof WLocal) usedLocals.add(read);\n                    }\n                }\n\n                deadCodeElimination(instr.immediate.expression, usedLocals);\n                if (instr.immediate.expression2) deadCodeElimination(instr.immediate.expression2, usedLocals);\n\n                if (instr.name === \"loop\") continue;\n            }\n\n            for (const read of instr.reads) {\n                if (read instanceof WLocal) usedLocals.add(read);\n            }\n        }\n    }\n\n    if (instructions.some(instr => !instr.needed)) {\n        // discard unneeded instructions if any\n        const replacement: (PartialInstr | InstrInstance)[] = [];\n        for (const instruction of instructions) {\n            if (instruction.needed || instruction.instr.name === \"unreachable\") { // also preserve \"unreachable\" instructions\n                replacement.push(instruction.instr);\n\n                if (instruction.produces && !instruction.produces.needed) {\n                    replacement.push(Instructions.drop());\n                }\n            }\n        }\n        expr.replace(0, expr.instructions.length, ...replacement);\n    }\n}\n\nfunction dataflow(expr: WExpression): [DFInstruction[], DFStackItem[]] {\n    const instructions = expr.instructions.map(instr => ({instr, produces: undefined, consumes: []} as DFInstruction));\n    const stackItems: DFStackItem[] = [];\n\n    const currentStack: DFStackItem[] = [];\n    for (const dfInstr of instructions) {\n        for (let i = 0; i < dfInstr.instr.parameters.length; i++) {\n            const item = currentStack.pop() as DFStackItem;\n            item.consumedBy = dfInstr;\n            dfInstr.consumes.push(item);\n        }\n\n        if (dfInstr.instr.result !== null) {\n            dfInstr.produces = {\n                type: dfInstr.instr.result,\n                producedBy: dfInstr,\n                index: stackItems.length\n            };\n            currentStack.push(dfInstr.produces);\n            stackItems.push(dfInstr.produces);\n        }\n    }\n\n    // mark anything left on the stack as definitely needed\n    for (const remainingItem of currentStack) remainingItem.needed = true;\n\n    return [instructions, stackItems];\n}\n\nfunction markNeeded(instr: DFInstruction) {\n    instr.needed = true;\n    for (const item of instr.consumes) item.needed = true;\n}\n\nfunction markRecursively(items: DFStackItem[]) {\n    let changed = 1;\n    while (changed) {\n        changed = 0;\n        for (const item of items.filter(item => item.needed && !item.producedBy.needed)) {\n            markNeeded(item.producedBy);\n            changed++;\n        }\n    }\n}\n\ninterface DFInstruction {\n    instr: InstrInstance;\n    produces: DFStackItem | undefined;\n    consumes: DFStackItem[];\n    needed?: true;\n}\n\ninterface DFStackItem {\n    type: ValueType;\n    producedBy: DFInstruction;\n    consumedBy?: DFInstruction;\n    index: number;\n    needed?: true;\n}\n","import {Instructions, f32Type, f64Type, i32Type, WExpression, i64Type} from \"../wasm\";\nimport {labelidx} from \"../wasm/base_types\";\nimport {WLocal} from \"../wasm/functions\";\nimport {InstrInstance, PartialInstr} from \"../wasm/instr_helpers\";\nimport {OptimisationFlags} from \"./flags\";\n\ntype PeepholeCallback = (instr: InstrInstance[], depth: number) => (InstrInstance | PartialInstr)[] | undefined;\ninterface PeepholeOptimiser {\n    name: string,\n    enabled: (flags: OptimisationFlags) => boolean,\n    run: PeepholeCallback,\n    peepholeSize: number\n}\n\nexport const peepholeOptimisers: PeepholeOptimiser[] = [];\n\nexport function peephole(expr: WExpression, fn: PeepholeCallback, size: number, depth = 0): void {\n    for (let i = 0; i <= expr.instructions.length - size; i++) {\n        const replacement = fn(expr.instructions.slice(i, i + size), depth);\n        if (replacement !== undefined) expr.replace(i, i + size, ...replacement);\n    }\n\n    for (const instruction of expr.instructions) {\n        if (instruction.type === \"structured\") {\n            peephole(instruction.immediate.expression, fn, size, depth + 1);\n            if (instruction.immediate.expression2) peephole(instruction.immediate.expression2, fn, size, depth + 1);\n        }\n    }\n}\n\nexport function peepholeMulti(expr: WExpression, fns: [fn: PeepholeCallback, size: number][], depth = 0): void {\n    const maxSize = fns.map(x => x[1]).reduce((a, b) => Math.max(a, b), 1);\n\n    // optimise inside structured instructions first in case this eliminates branches etc which enable\n    // more optimisations to occur at this level\n    for (const instruction of expr.instructions) {\n        if (instruction.type === \"structured\") {\n            peepholeMulti(instruction.immediate.expression, fns, depth + 1);\n            if (instruction.immediate.expression2) peepholeMulti(instruction.immediate.expression2, fns, depth + 1);\n        }\n    }\n\n    for (let i = 0; i < expr.instructions.length; i++) {\n        for (const [fn, size] of fns) {\n            if (i + size > expr.instructions.length) continue;\n\n            const replacement = fn(expr.instructions.slice(i, i + size), depth);\n            if (replacement !== undefined) {\n                expr.replace(i, i + size, ...replacement);\n\n                i -= maxSize; // repeat optimisers with new instructions\n                if (i < -1) i = -1;\n                break;\n            }\n        }\n    }\n}\n\npeepholeOptimisers.push({\n    name: \"[local.set, local.get] => [local.tee]\",\n    enabled: (flags) => flags.peephole_local_tee,\n    run: ([instr1, instr2]) => {\n        if (instr1.name === \"local.set\" && instr2.name === \"local.get\") {\n            const resource = instr1.writes[0];\n            if (!(resource instanceof WLocal) || instr2.reads[0] !== resource) return;\n            return [Instructions.local.tee(resource)];\n        } else if (instr1.name === \"local.tee\" && instr2.name === \"drop\") {\n            // convert back to a single local.set if the result is now discarded\n            const resource = instr1.writes[0];\n            if (!(resource instanceof WLocal)) return;\n            return [Instructions.local.set(resource)];\n        }\n    },\n    peepholeSize: 2\n});\n\npeepholeOptimisers.push({\n    name: \"?.const 0, ?.add\",\n    enabled: (flags) => flags.peephole_add_0,\n    run: ([instr1, instr2]) => {\n        // eslint-disable-next-line eqeqeq\n        if (instr1.type !== \"constant\" || instr1.immediate.value != 0) return;\n        if (instr2.name.endsWith(\".add\")) return [];\n    },\n    peepholeSize: 2\n});\n\npeepholeOptimisers.push({\n    name: \"i32.const, i32.const, i32.[op]\",\n    enabled: (flags) => flags.peephole_i32_constants_ops,\n    run: ([instr1, instr2, instr3]) => {\n        if (instr1.type !== \"constant\" || instr2.type !== \"constant\" || !instr3.name.startsWith(\"i32.\")) return;\n        if (instr1.result !== i32Type || instr2.result !== i32Type) return;\n\n        const s1 = Number(instr1.immediate.value), s2 = Number(instr2.immediate.value);\n        const u1 = (BigInt(s1) + 2n ** 32n) % (2n ** 32n), u2 = (BigInt(s2) + 2n ** 32n) % (2n ** 32n);\n\n        switch (instr3.name) {\n        case \"i32.eq\":\n            return [Instructions.i32.const(s1 === s2 ? 1 : 0)];\n        case \"i32.ne\":\n            return [Instructions.i32.const(s1 !== s2 ? 1 : 0)];\n        case \"i32.lt_s\":\n            return [Instructions.i32.const(s1 < s2 ? 1 : 0)];\n        case \"i32.lt_u\":\n            return [Instructions.i32.const(u1 < u2 ? 1 : 0)];\n        case \"i32.gt_s\":\n            return [Instructions.i32.const(s1 > s2 ? 1 : 0)];\n        case \"i32.gt_u\":\n            return [Instructions.i32.const(u1 > u2 ? 1 : 0)];\n        case \"i32.le_s\":\n            return [Instructions.i32.const(s1 <= s2 ? 1 : 0)];\n        case \"i32.le_u\":\n            return [Instructions.i32.const(u1 <= u2 ? 1 : 0)];\n        case \"i32.ge_s\":\n            return [Instructions.i32.const(s1 >= s2 ? 1 : 0)];\n        case \"i32.ge_u\":\n            return [Instructions.i32.const(u1 >= u2 ? 1 : 0)];\n        case \"i32.add\":\n            return [Instructions.i32.const((s1 + s2) | 0)];\n        case \"i32.sub\":\n            return [Instructions.i32.const((s1 - s2) | 0)];\n        case \"i32.mul\":\n            return [Instructions.i32.const((u1 * u2) & (2n ** 32n - 1n))];\n        case \"i32.div_s\":\n            if (s2 === 0) return;\n            return [Instructions.i32.const((s1 / s2) | 0)];\n        case \"i32.div_u\":\n            if (s2 === 0) return;\n            return [Instructions.i32.const(u1 / u2)];\n        case \"i32.rem_s\":\n            if (s2 === 0) return;\n            return [Instructions.i32.const(s1 % s2)];\n        case \"i32.rem_u\":\n            if (s2 === 0) return;\n            return [Instructions.i32.const(u1 % u2)];\n        case \"i32.and\":\n            return [Instructions.i32.const(s1 & s2)];\n        case \"i32.or\":\n            return [Instructions.i32.const(s1 | s2)];\n        case \"i32.xor\":\n            return [Instructions.i32.const(s1 ^ s2)];\n        case \"i32.shl\":\n            return [Instructions.i32.const(s1 << s2)];\n        case \"i32.shr_s\":\n            return [Instructions.i32.const(s1 >> s2)];\n        case \"i32.shr_u\":\n            return [Instructions.i32.const(s1 >>> s2)];\n        }\n    },\n    peepholeSize: 3\n});\n\npeepholeOptimisers.push({\n    name: \"i32.const, i32.eqz\",\n    enabled: (flags) => flags.peephole_i32_constants_ops,\n    run: ([instr1, instr2]) => {\n        if (instr1.type !== \"constant\" || !instr2.name.endsWith(\".eqz\")) return;\n        // eslint-disable-next-line eqeqeq\n        return [Instructions.i32.const(instr1.immediate.value == 0 ? 1 : 0)];\n    },\n    peepholeSize: 2\n});\n\npeepholeOptimisers.push({\n    name: \"?.const, ?.const, ?.add/mul\",\n    enabled: (flags) => flags.peephole_constants_add_mul,\n    run: ([instr1, instr2, instr3]) => {\n        // eslint-disable-next-line eqeqeq\n        if (instr1.type !== \"constant\" || instr2.type !== \"constant\") return;\n\n        let value;\n        if (instr3.name.endsWith(\".add\")) {\n            if (instr1.result === f32Type) {\n                return [Instructions.f32.const(Number(instr1.immediate.value) + Number(instr2.immediate.value))];\n            } else if (instr1.result === f64Type) {\n                return [Instructions.f64.const(Number(instr1.immediate.value) + Number(instr2.immediate.value))];\n            }\n\n            value = BigInt(instr1.immediate.value) + BigInt(instr2.immediate.value);\n        } else if (instr3.name.endsWith(\".mul\")) {\n            if (instr1.result === f32Type) {\n                return [Instructions.f32.const(Number(instr1.immediate.value) * Number(instr2.immediate.value))];\n            } else if (instr1.result === f64Type) {\n                return [Instructions.f64.const(Number(instr1.immediate.value) * Number(instr2.immediate.value))];\n            }\n\n            value = BigInt(instr1.immediate.value) * BigInt(instr2.immediate.value);\n        } else {\n            return;\n        }\n\n        if (instr1.result === i32Type) {\n            return [Instructions.i32.const(emulateInt(32n, value))];\n        } else {\n            return [Instructions.i64.const(emulateInt(64n, value))];\n        }\n    },\n    peepholeSize: 3\n});\n\npeepholeOptimisers.push({\n    name: \"i32.const, i32.add, i32.const, i32.add\",\n    enabled: (flags) => flags.peephole_combine_adds,\n    run: ([instr1, instr2, instr3, instr4]) => {\n        // eslint-disable-next-line eqeqeq\n        if (instr1.type !== \"constant\" || instr3.type !== \"constant\") return;\n        if (instr2.name !== \"i32.add\" || instr4.name !== \"i32.add\") return;\n        return [\n            Instructions.i32.const(emulateInt(32n, BigInt(instr1.immediate.value) + BigInt(instr3.immediate.value))),\n            Instructions.i32.add()\n        ];\n    },\n    peepholeSize: 4\n});\n\npeepholeOptimisers.push({\n    name: \"..., i32.const, i32.add, *.load offset\",\n    enabled: (flags) => flags.peephole_load_offset,\n    run: ([instr1, instr2, instr3]) => {\n        if (instr1.type !== \"constant\" || instr1.result !== i32Type) return;\n        if (instr2.name !== \"i32.add\") return;\n        if (instr3.type !== \"memory\" || !instr3.name.includes(\".load\")) return;\n\n        const offset = instr3.immediate.offset + BigInt(instr1.immediate.value);\n        if (offset > 127) return; // only inline small offsets\n\n        if (instr3.result === i32Type) {\n            if (instr3.name === \"i32.load\") return [Instructions.i32.load(instr3.immediate.align, offset)];\n            if (instr3.name === \"i32.load8_s\") return [Instructions.i32.load8_s(instr3.immediate.align, offset)];\n            if (instr3.name === \"i32.load8_u\") return [Instructions.i32.load8_u(instr3.immediate.align, offset)];\n            if (instr3.name === \"i32.load16_s\") return [Instructions.i32.load16_s(instr3.immediate.align, offset)];\n            if (instr3.name === \"i32.load16_u\") return [Instructions.i32.load16_u(instr3.immediate.align, offset)];\n        } else if (instr3.result === i64Type) {\n            if (instr3.name === \"i64.load\") return [Instructions.i64.load(instr3.immediate.align, offset)];\n            if (instr3.name === \"i64.load8_s\") return [Instructions.i64.load8_s(instr3.immediate.align, offset)];\n            if (instr3.name === \"i64.load16_s\") return [Instructions.i64.load16_s(instr3.immediate.align, offset)];\n            if (instr3.name === \"i64.load16_u\") return [Instructions.i64.load16_u(instr3.immediate.align, offset)];\n            if (instr3.name === \"i64.load32_s\") return [Instructions.i64.load32_s(instr3.immediate.align, offset)];\n            if (instr3.name === \"i64.load32_u\") return [Instructions.i64.load32_u(instr3.immediate.align, offset)];\n        } else if (instr3.result === f32Type) {\n            return [Instructions.f32.load(instr3.immediate.align, offset)];\n        } else if (instr3.result === f64Type) {\n            return [Instructions.f64.load(instr3.immediate.align, offset)];\n        }\n    },\n    peepholeSize: 3\n});\n\npeepholeOptimisers.push({\n    name: \"remove unused blocks and loops\",\n    enabled: (flags) => flags.peephole_unused_blocks,\n    run: ([instr]) => {\n        if (instr.type !== \"structured\" || instr.name === \"if\") return;\n        if (branchedTo(instr)) return;\n\n        return eliminateStructuredInstruction(instr.immediate.expression);\n    },\n    peepholeSize: 1\n});\n\npeepholeOptimisers.push({\n    name: \"remove constant ifs\",\n    enabled: (flags) => flags.peephole_constant_if,\n    run: ([instr1, instr2]) => {\n        if (instr1.type !== \"constant\" || instr1.result !== i32Type) return;\n        if (instr2.type !== \"structured\" || instr2.name !== \"if\") return;\n\n        let body;\n        // eslint-disable-next-line eqeqeq\n        if (instr1.immediate.value != 0) {\n            // if statement always true\n            body = instr2.immediate.expression;\n        } else if (instr2.immediate.expression2) {\n            // if statement always false and else clause present\n            body = instr2.immediate.expression2;\n        } else {\n            // always false and no else clause\n            return [];\n        }\n\n        // replace constant if with a block with the body of the corresponding clause which is needed encase the\n        // if statement was branched too, otherwise `peephole_unused_blocks` will remove it\n        return [Instructions.block(instr2.immediate.type, body.instructions.slice())];\n    },\n    peepholeSize: 2\n});\n\nfunction emulateInt(bits: bigint, value: bigint) {\n    const bitmask = (2n ** bits) - 1n;\n    return value & bitmask;\n}\n\nfunction branchedTo(instr: InstrInstance, depth = -1n): boolean {\n    if (instr.type === \"index\" && instr.name.startsWith(\"br\")) {\n        return instr.immediate.value === depth;\n    }\n    if (instr.type === \"table\" && instr.name === \"br_table\") {\n        return instr.immediate.defaultValue === depth || instr.immediate.valueTable.some(x => x === depth);\n    }\n    if (instr.type !== \"structured\") return false;\n\n    const {expression, expression2} = instr.immediate;\n    if (expression.instructions.some(child => branchedTo(child, depth + 1n))) return true;\n    if (expression2 === undefined) return false;\n    return expression2.instructions.some(child => branchedTo(child, depth + 1n));\n}\n\nexport function eliminateStructuredInstruction(expr: WExpression): InstrInstance[] {\n    // decrement the values of branch instructions which branch outside\n    peephole(expr, ([child], depth) => {\n        if (child.type === \"index\") {\n            if (child.immediate.value < depth) return;\n\n            if (child.name === \"br\") {\n                // ...child.parameters => preserve whether the br consumes a result\n                return [Instructions.br(child.immediate.value - 1n as labelidx, ...child.parameters)];\n            } else if (child.name === \"br_if\") {\n                return [Instructions.br_if(child.immediate.value - 1n as labelidx)];\n            }\n        } else if (child.type === \"table\" && child.name === \"br_table\") {\n            const {defaultValue, valueTable} = child.immediate;\n            return [Instructions.br_table(\n                (defaultValue < depth ? defaultValue : defaultValue - 1n) as labelidx,\n                valueTable.map(v => (v < depth ? v : v - 1n) as labelidx)\n            )];\n        }\n    }, 1);\n\n    return expr.instructions.slice();\n}\n","import {WExpression} from \"../../wasm\";\nimport {InstrInstance} from \"../../wasm/instr_helpers\";\n\nexport function controlFlow(expr: WExpression): ControlFlowGraph {\n    const entryFlow: MarkerFlow = {type: \"entry\", instr: undefined, flowPrevious: [], flowNext: []};\n    const exitFlow: MarkerFlow = {type: \"exit\", instr: undefined, flowPrevious: [], flowNext: []};\n    const allFlows: Flow[] = [entryFlow, exitFlow];\n    const brTargets: Flow[] = [];\n\n    function _expr2flow(expr: WExpression, previousFlow: Flow, followingFlow: Flow) {\n        const instructions = expr.instructions;\n        const flows: Flow[] = [];\n\n        for (const [instrIndex, instr] of instructions.entries()) {\n            flows.push({instr, instrIndex, expr, type: \"instr\", flowPrevious: [], flowNext: []});\n        }\n        allFlows.push(...flows);\n        flows.push(followingFlow);\n\n        for (let i = 0; i < instructions.length; i++) {\n            const instr = instructions[i];\n            const flow = flows[i];\n            const nextFlow = flows[i + 1];\n\n            if (instr.type === \"structured\" && instr.name === \"if\") {\n                // br to if jumps to the first instruction after the loop\n                brTargets.unshift(nextFlow);\n                const child1 = _expr2flow(instr.immediate.expression, flow, nextFlow);\n                const child2 = instr.immediate.expression2 && _expr2flow(instr.immediate.expression2, flow, nextFlow);\n                brTargets.shift();\n\n                if (child1 && child2) continue;\n\n            } else if (instr.type === \"structured\") {\n                // br to a loop jumps back to the loop, br to block jumps to the first instruction after the loop\n                brTargets.unshift(instr.name === \"loop\" ? flow : nextFlow);\n                const child = _expr2flow(instr.immediate.expression, flow, nextFlow);\n                brTargets.shift();\n\n                if (child) continue;\n\n            } else if (instr.type === \"index\" && instr.name.startsWith(\"br\")) {\n                const target = brTargets[Number(instr.immediate.value)];\n                if (!target) throw new Error(\"No such target for br?\");\n                flow.flowNext.push(target);\n\n                if (instr.name !== \"br_if\") continue;\n\n            } else if (instr.type === \"table\" && instr.name === \"br_table\") {\n                for (const targetIdx of [instr.immediate.defaultValue, ...instr.immediate.valueTable]) {\n                    const target = brTargets[Number(targetIdx)];\n                    if (!target) throw new Error(\"No such target for br_table?\");\n                    flow.flowNext.push(target);\n                }\n                continue;\n\n            } else if (instr.name === \"return\") {\n                flow.flowNext.push(exitFlow);\n                continue;\n            }\n\n            // flow passes through to next\n            flow.flowNext.push(flows[i + 1]);\n        }\n\n        const initial = flows.find(x => x.type === \"instr\");\n        if (initial) previousFlow.flowNext.push(initial);\n        return !!initial;\n    }\n\n    _expr2flow(expr, entryFlow, exitFlow);\n\n    // populate flowPrevious\n    for (const flow of allFlows) {\n        for (const next of flow.flowNext) {\n            next.flowPrevious.push(flow);\n        }\n    }\n\n    return {entry: entryFlow, exit: exitFlow, all: allFlows.filter(x => x.type === \"instr\") as InstrFlow[]};\n}\n\nexport function simplifiedControlFlow(expr: WExpression, filter: (instr: InstrInstance) => boolean): ControlFlowGraph {\n    const {entry, exit, all} = controlFlow(expr);\n    const newAll: InstrFlow[] = [];\n\n    for (const flow of all) {\n        if (flow.flowPrevious.length === 1 && flow.flowNext.length === 1 && !filter(flow.instr)) {\n            const previous = flow.flowPrevious[0];\n            const next = flow.flowNext[0];\n\n            previous.flowNext[previous.flowNext.indexOf(flow)] = next;\n            next.flowPrevious[next.flowPrevious.indexOf(flow)] = previous;\n        } else {\n            newAll.push(flow);\n        }\n    }\n\n    return {entry, exit, all: newAll};\n}\n\nexport interface InstrFlow {\n    type: \"instr\"\n    instr: InstrInstance;\n    expr: WExpression;\n    instrIndex: number;\n\n    // instructions which could be the previous executed instruction\n    flowPrevious: Flow[];\n    // instructions which could be the next executed instruction\n    flowNext: Flow[];\n}\n\nexport interface MarkerFlow {\n    type: \"entry\" | \"exit\";\n    instr: undefined;\n\n    flowPrevious: Flow[];\n    flowNext: Flow[];\n}\n\nexport type Flow = InstrFlow | MarkerFlow;\nexport type ControlFlowGraph = {entry: MarkerFlow, exit: MarkerFlow, all: InstrFlow[]};\n","import type {ControlFlowGraph, InstrFlow, Flow} from \"./control_flow\";\n\nexport function framework(\n    cfg: ControlFlowGraph,\n    intermediateMap: Map<Flow, bigint> | null,\n    bitMap: Map<Flow, bigint>,\n    direction: \"forwards\" | \"backwards\",\n    meetOperation: \"union\" | \"intersection\",\n    transferFunction: (f: Flow, x: bigint) => bigint,\n    intermediateOverride?: (f: Flow, x: bigint) => bigint\n): void {\n\n    const queue: Flow[] = (direction === \"forwards\" ? cfg.entry.flowNext : cfg.exit.flowPrevious)\n        .filter(x => x.instr);\n\n    let flow: Flow | undefined;\n    while ((flow = queue.shift()) !== undefined) {\n        let X = meetOperation === \"union\" ? 0n : -1n;\n        for (const before of (direction === \"forwards\" ? flow.flowPrevious : flow.flowNext)) {\n            const beforeBits = bitMap.get(before as InstrFlow) ?? 0n;\n\n            if (meetOperation === \"union\") {\n                X |= beforeBits;\n            } else { // intersection\n                X &= beforeBits;\n            }\n        }\n\n        // used by PRE to force some values to false if not safe\n        if (intermediateOverride) X = intermediateOverride(flow, X);\n        // also used by PRE analysis\n        if (intermediateMap) intermediateMap.set(flow, X);\n\n        X = transferFunction(flow, X);\n\n        if (X !== bitMap.get(flow)) {\n            bitMap.set(flow, X);\n\n            for (const after of (direction === \"forwards\" ? flow.flowNext : flow.flowPrevious)) {\n                if (after.instr) queue.push(after);\n            }\n        }\n    }\n}\n\n/*\n// Implementation using JS sets instead of bits\n\nexport function framework<T>(\n    cfg: ControlFlowGraph,\n    setMap: Map<Flow, Set<T>>,\n    direction: \"forwards\" | \"backwards\",\n    meetOperation: \"union\" | \"intersection\",\n    transferFunction: (f: InstrFlow, x: Set<T>) => Set<T>\n): void {\n\n    const queue = new Set<InstrFlow>();\n\n    for (const starting of (direction === \"forwards\" ? cfg.entry.flowNext : cfg.exit.flowPrevious)) {\n        if (starting.instr) queue.add(starting);\n    }\n\n    let next: IteratorResult<InstrFlow, InstrFlow>;\n    while ((next = queue.keys().next()).value) {\n        const flow = next.value;\n        queue.delete(flow);\n\n        let X = undefined;\n        for (const before of (direction === \"forwards\" ? flow.flowPrevious : flow.flowNext)) {\n            const beforeSet = setMap.get(before as InstrFlow);\n\n            if (X === undefined) {\n                X = beforeSet;\n            } else if (meetOperation === \"union\") {\n                if (!beforeSet) continue;\n                for (const v of beforeSet) {\n                    X.add(v);\n                }\n            } else if (meetOperation === \"intersection\") {\n                if (beforeSet) {\n                    for (const v of X) {\n                        if (!beforeSet.has(v)) X.delete(v);\n                    }\n                } else {\n                    X.clear();\n                }\n            }\n        }\n\n        X = transferFunction(flow, X ?? new Set<T>());\n\n        if (!setEquals(X, setMap.get(flow))) {\n            setMap.set(flow, X);\n\n            for (const after of (direction === \"forwards\" ? flow.flowNext : flow.flowPrevious)) {\n                if (after.instr) queue.add(after);\n            }\n        }\n    }\n}\n\nfunction setEquals<T>(a: Set<T>, b?: Set<T>): boolean {\n    if (!b || a.size !== b.size) return false;\n    for (const x of a) {\n        if (!b.has(x)) return false;\n    }\n    return true;\n}\n*/\n","import {WExpression, ValueType, Instructions} from \"../../wasm\";\nimport {WLocal} from \"../../wasm/functions\";\nimport {peephole} from \"../peephole\";\nimport {Flow, simplifiedControlFlow} from \"./control_flow\";\nimport {framework} from \"./framework\";\n\ntype ClashNode = {local: number, type: ValueType, clash: Set<number>};\n\nexport function realloc_locals(expr: WExpression): void {\n    if (expr.builder.locals.length <= 1) return;\n\n    const cfg = simplifiedControlFlow(expr, x => x.name.startsWith(\"local.\"));\n    const liveMap = new Map<Flow, bigint>();\n    const numArgs = BigInt(expr.builder.args.length);\n\n    // LVA\n    framework(cfg, null, liveMap, \"backwards\", \"union\", (f, x) => {\n        // (out-live \\ def) U ref\n        if (f.instr && f.instr.type === \"index\") {\n            const flag = 1n << (f.instr.immediate.value - numArgs);\n            if (f.instr.name === \"local.get\") { // ref\n                return x | flag;\n            } else if (f.instr.name === \"local.set\" || f.instr.name === \"local.tee\") { // def\n                return x & ~flag;\n            }\n        }\n        return x;\n    });\n\n    // make clash graph\n    const clashGraph: ClashNode[] = expr.builder.locals\n        .map(({type}, local) => ({local, type: type, clash: new Set()}));\n    for (let bits of liveMap.values()) {\n        if (bits === 0n) continue;\n\n        const live: number[] = [];\n        for (let i = 0; bits; i++) {\n            if (bits & 1n) live.push(i);\n            bits >>= 1n;\n        }\n        if (live.length <= 1) continue;\n\n        for (const i of live) {\n            for (const j of live) i !== j && clashGraph[i].clash.add(j);\n        }\n    }\n\n    // push vertex with the least edges onto a stack\n    const stack: number[] = [];\n    const clashCopy = clashGraph.map(({local, clash}) => ({local, clash: new Set(clash)}));\n    while (clashCopy.length) {\n        clashCopy.sort((a, b) => a.clash.size - b.clash.size);\n        const {local} = clashCopy.shift() as ClashNode;\n        stack.push(local);\n\n        for (const node of clashCopy) node.clash.delete(local);\n    }\n\n    // pop and allocate\n    expr.builder.wipeLocals();\n    const locals: WLocal[] = [];\n    const mapping: WLocal[] = Array(clashGraph.length);\n    while (stack.length) {\n        const oldLocal = stack.pop() as number;\n        const {type} = clashGraph[oldLocal];\n\n        const clashesWith = new Set<WLocal>();\n        for (const c of clashGraph[oldLocal].clash) {\n            if (mapping[c]) clashesWith.add(mapping[c]);\n        }\n\n        let newLocal = undefined;\n        for (const local of locals) {\n            if (local.type !== type) continue;\n            if (clashesWith.has(local)) continue;\n            newLocal = local;\n            break;\n        }\n        if (!newLocal) locals.push(newLocal = expr.builder.addLocal(type));\n\n        mapping[oldLocal] = newLocal;\n    }\n    mapping.unshift(...expr.builder.args); // add arguments back into mapping\n\n    // transform according to the mapping\n    remapLocals(expr, mapping);\n}\n\nexport function remapLocals(expr: WExpression, mapping: WLocal[]): void {\n    peephole(expr, ([instr]) => {\n        if (instr.type !== \"index\" || !instr.name.startsWith(\"local.\")) return;\n        const local = mapping[Number(instr.immediate.value)];\n        if (instr.name === \"local.get\") {\n            return [Instructions.local.get(local)];\n        } else if (instr.name === \"local.set\") {\n            return [Instructions.local.set(local)];\n        } else if (instr.name === \"local.tee\") {\n            return [Instructions.local.tee(local)];\n        }\n    }, 1);\n}\n","import {byte, globalidx} from \"./base_types\";\nimport {encodeConstantInstr} from \"./encoding\";\nimport {ModuleBuilder} from \"./module\";\nimport {ValueType, encodeGlobal} from \"./wtypes\";\n\nexport class WGlobal {\n\n    constructor(readonly module: ModuleBuilder,\n                readonly type: ValueType,\n                readonly mutable: boolean,\n                public initialValue: number | bigint,\n                readonly exportName?: string) {\n    }\n\n    getIndex(): globalidx {\n        return this.module._globalIndex(this);\n    }\n\n    toBytes(): byte[] {\n        return [\n            ...encodeGlobal([this.type, this.mutable]),\n            ...encodeConstantInstr(this.initialValue, this.type),\n            0x0B as byte\n        ];\n    }\n}\n","import {WExpression} from \"../wasm\";\nimport {PartialInstr, InstrInstance} from \"../wasm/instr_helpers\";\n\n// subset of InstrFlow, also used by fn inlining\ninterface InstrLoc {\n    expr: WExpression;\n    instrIndex: number;\n}\n\n// keeps track of edits and offsets the precomputed indices on instr flows accordingly\nexport class InstrSplicer {\n    private offsetsMap = new Map<WExpression, { index: number, offset: number }[]>();\n\n    splice(loc: InstrLoc, deleteCount: number, replacements: (PartialInstr | InstrInstance)[], beginOffset?: number): void {\n        let offsets = this.offsetsMap.get(loc.expr);\n        if (!offsets) this.offsetsMap.set(loc.expr, offsets = []);\n\n        let instrIndex = loc.instrIndex + (beginOffset ?? 0);\n        for (const {index, offset} of offsets) {\n            if (instrIndex > index) instrIndex += offset;\n        }\n\n        loc.expr.replace(instrIndex, instrIndex + deleteCount, ...replacements);\n\n        const offset = replacements.length - deleteCount;\n        if (offset) offsets.push({index: instrIndex, offset});\n    }\n\n    realIndex(flow: InstrLoc): number {\n        const offsets = this.offsetsMap.get(flow.expr);\n        if (!offsets) return flow.instrIndex;\n\n        let instrIndex = flow.instrIndex;\n        for (const {index, offset} of offsets) {\n            if (instrIndex > index) instrIndex += offset;\n        }\n        return instrIndex;\n    }\n}\n","import {WExpression, ValueType, Instructions} from \"../../wasm\";\nimport {WLocal} from \"../../wasm/functions\";\nimport {WGlobal} from \"../../wasm/global\";\nimport {InstrInstance, ReadResource, PartialInstr} from \"../../wasm/instr_helpers\";\nimport {InstrSplicer} from \"../splicer\";\nimport {InstrFlow, controlFlow, ControlFlowGraph, Flow} from \"./control_flow\";\nimport {framework} from \"./framework\";\n\n// partial redundancy elimination\n// https://dl.acm.org/doi/pdf/10.1145/307824.307851\n\n// Local properties\n// TRANSP - Transparent - expression operands are not modified by execution of statement\n// ANTLOC - Locally anticipable - expression computed in basic block b and doesn't previous define operands\n// COMP - Locally available - expression computed in basic block b and b doesn't later redefine operands\n\n// Global properties\n// AV[IN/OUT] - Availability\n// ANT[IN/OUT] - Anticipability\n// SPAV[IN/OUT] - Safe partial availability\n// SPANT[IN/OUT] - Safe partial anticipability\n// SAFE[IN,OUT] - Safe to insert a computation\n\ninterface SubExpr {\n    positions: {start: number, end: number, expr: WExpression}[];\n    instructions: InstrInstance[];\n    resources: Set<ReadResource>;\n    type: ValueType;\n    bit: bigint;\n}\n\ninterface ExprResult {\n    expression: SubExpr;\n\n    insertBefore: InstrFlow[]; // INSERT_i\n    insertBetween: [InstrFlow, InstrFlow][]; // INSERT_{i,j}\n    insertAfter: InstrFlow[]; // from edge insertion minimization\n    insertInstructions: (InstrInstance | PartialInstr)[];\n\n    replacementFlows: InstrFlow[]; // REPLACE\n    replacementInstructions: (InstrInstance | PartialInstr)[];\n\n    fnLengthChange: number;\n}\n\nfunction subExprMatches(s1: SubExpr, s2: SubExpr): boolean {\n    if (s1.type !== s2.type || s1.instructions.length !== s2.instructions.length) return false;\n    return s1.instructions.every((v, i) => {\n        const arr1 = v.encoded, arr2 = s2.instructions[i].encoded;\n        return arr1.length === arr2.length && arr1.every((v, i) => v === arr2[i]);\n    });\n}\n\nfunction expressions(top: WExpression): SubExpr[] {\n    const expressions: SubExpr[] = [];\n    const exprQueue = [top];\n\n    let expr;\n    while ((expr = exprQueue.shift()) !== undefined) {\n        const {instructions} = expr;\n\n        instrLoop:\n        for (const [i, startInstr] of instructions.entries()) {\n            if (startInstr.type === \"structured\") {\n                exprQueue.push(startInstr.immediate.expression);\n                if (startInstr.immediate.expression2) exprQueue.push(startInstr.immediate.expression2);\n                continue;\n            }\n            if (startInstr.parameters.length || startInstr.writes.length || !startInstr.result) {\n                continue;\n            }\n\n            const stack = [startInstr.result];\n            const resources = new Set(startInstr.reads);\n            for (let j = i + 1; j < instructions.length; j++) {\n                const instr = instructions[j];\n                if (instr.parameters.length > stack.length || instr.writes.length) continue instrLoop;\n\n                stack.splice(0, instr.parameters.length);\n                if (instr.result) stack.unshift(instr.result);\n                for (const resource of instr.reads) resources.add(resource);\n\n                if (stack.length === 1 && (j - i) >= 2) {\n                    const position = {start: i, end: j, expr};\n                    const subExpr: SubExpr = {\n                        positions: [position],\n                        resources,\n                        type: stack[0],\n                        instructions: instructions.slice(i, j + 1),\n                        bit: 1n << BigInt(expressions.length)\n                    };\n\n                    // see if there is an existing subexpr which matches\n                    const matching = expressions.find(x => subExprMatches(x, subExpr));\n                    if (matching) {\n                        matching.positions.push(position);\n                    } else {\n                        expressions.push(subExpr);\n                    }\n                }\n            }\n        }\n    }\n\n    return expressions;\n}\n\nfunction transparent(cfg: ControlFlowGraph, expressions: SubExpr[]): (f: Flow) => bigint {\n    const fullyTransparent = (1n << BigInt(expressions.length)) - 1n;\n    const transpMap = new Map<InstrFlow, bigint>();\n    for (const f of cfg.all) {\n        let flags = fullyTransparent;\n        if (f.instr.type !== \"structured\") {\n            for (const resource of f.instr.writes) {\n                if (resource === \"memory\" || resource instanceof WGlobal || resource instanceof WLocal) {\n                    for (const [i, expression] of expressions.entries()) {\n                        if (expression.resources.has(resource)) flags &= ~(1n << BigInt(i));\n                    }\n                }\n            }\n        } // structured instructions are themselves transparent\n        transpMap.set(f, flags);\n    }\n    return (f) => transpMap.get(f as InstrFlow) ?? fullyTransparent;\n}\n\nfunction computed(cfg: ControlFlowGraph, expressions: SubExpr[]): (f: Flow) => bigint {\n    const computedMap = new Map<InstrFlow, bigint>();\n    for (const f of cfg.all) {\n        let flags = 0n;\n\n        for (const [expIdx, expression] of expressions.entries()) {\n            if (expression.positions.find(({expr, end}) => expr === f.expr && end === f.instrIndex)) {\n                flags |= 1n << BigInt(expIdx);\n            }\n        }\n\n        computedMap.set(f, flags);\n    }\n    return (f) => computedMap.get(f as InstrFlow) ?? 0n;\n}\n\nfunction analysis(cfg: ControlFlowGraph, exprs: SubExpr[]) {\n    const TRANSP = transparent(cfg, exprs);\n    const COMP = computed(cfg, exprs);\n    const ANTLOC = COMP; // since this implementation has no basic blocks, ANTLOC = COMP ?\n\n    // Step 1: Compute AVIN/AVOUT and ANTIN/ANTOUT for all nodes.\n    const AVIN = new Map<Flow, bigint>(), AVOUT = new Map<Flow, bigint>();\n    framework(cfg,\n        AVIN,\n        AVOUT,\n        \"forwards\",\n        \"intersection\",\n        (f, x) => COMP(f) | (x & TRANSP(f))\n    );\n\n    const ANTOUT = new Map<Flow, bigint>(), ANTIN = new Map<Flow, bigint>();\n    framework(cfg,\n        ANTOUT,\n        ANTIN,\n        \"backwards\",\n        \"intersection\",\n        (f, x) => ANTLOC(f) | (x & TRANSP(f))\n    );\n\n    // Step 2: Compute SAFEIN/SAFEOUT for all nodes.\n    const SAFEIN = new Map<Flow, bigint>(), SAFEOUT = new Map<Flow, bigint>();\n    for (const f of cfg.all) {\n        SAFEIN.set(f, (AVIN.get(f) ?? 0n) | (ANTIN.get(f) ?? 0n));\n        SAFEOUT.set(f, (AVOUT.get(f) ?? 0n) | (ANTOUT.get(f) ?? 0n));\n    }\n\n    // Step 3: Compute SPAVIN/SPAVOUT and SPANTIN/SPANTOUT for all nodes.\n    const SPAVIN = new Map<Flow, bigint>(), SPAVOUT = new Map<Flow, bigint>();\n    framework(cfg,\n        SPAVIN,\n        SPAVOUT,\n        \"forwards\",\n        \"union\",\n        (f, x) => (COMP(f) | (x & TRANSP(f))) & (SAFEOUT.get(f) ?? 0n),\n        (f, x) => x & (SAFEIN.get(f) ?? 0n)\n    );\n\n    const SPANTOUT = new Map<Flow, bigint>(), SPANTIN = new Map<Flow, bigint>();\n    framework(cfg,\n        SPANTOUT,\n        SPANTIN,\n        \"backwards\",\n        \"union\",\n        (f, x) => (ANTLOC(f) | (x & TRANSP(f))) & (SAFEIN.get(f) ?? 0n),\n        (f, x) => x & (SAFEOUT.get(f) ?? 0n)\n    );\n\n    // Step 4: Compute points of insertions and replacements INSERT, INSERT(i,j), and REPLACE.\n    const INSERT = new Map<Flow, bigint>(), REPLACE = new Map<Flow, bigint>();\n    const INSERT_EDGE = new Map<Flow, [Flow, bigint][]>();\n    for (const i of [cfg.entry, ...cfg.all]) {\n        const comp = COMP(i), spavin = (SPAVIN.get(i) ?? 0n), spantout = (SPANTOUT.get(i) ?? 0n);\n        const insert = comp & (~spavin) & spantout;\n        if (insert !== 0n) INSERT.set(i, insert);\n\n        const antloc = ANTLOC(i);\n        const replace = (antloc & spavin) | (comp & spantout);\n        if (replace !== 0n) REPLACE.set(i, replace);\n\n        const spavout = SPAVOUT.get(i) ?? 0n, edgeList = [];\n        for (const j of i.flowNext) {\n            if (!j.instr) continue;\n            const insert_edge = (~spavout) & (SPAVIN.get(j) ?? 0n) & (SPANTIN.get(j) ?? 0n);\n            if (insert_edge !== 0n) edgeList.push([j, insert_edge] as [InstrFlow, bigint]);\n        }\n        if (edgeList.length) INSERT_EDGE.set(i, edgeList);\n    }\n    return {INSERT, INSERT_EDGE, REPLACE};\n}\n\nfunction processResults(exprs: SubExpr[], {INSERT, INSERT_EDGE, REPLACE}: ReturnType<typeof analysis>): ExprResult[] {\n    // convert the results from bits\n    const results: ExprResult[] = [];\n    for (const exp of exprs) {\n        const insertBefore: InstrFlow[] = [];\n        for (const [i, bits] of INSERT.entries()) {\n            if (bits & exp.bit) {\n                if (i.instr) {\n                    insertBefore.push(i);\n                } else { // i must be entry\n                    insertBefore.push(...i.flowNext as InstrFlow[]);\n                }\n            }\n        }\n\n        const insertBetween: [InstrFlow, InstrFlow][] = [];\n        for (const [i, list] of INSERT_EDGE.entries()) {\n            for (const [j, bits] of list) {\n                if (bits & exp.bit) {\n                    if (i.instr && j.instr) {\n                        insertBetween.push([i, j]);\n                    } else { // i must be entry\n                        insertBefore.push(j as InstrFlow);\n                    }\n                }\n            }\n        }\n\n        const replacementFlows: InstrFlow[] = [];\n        for (const [i, bits] of REPLACE.entries()) {\n            if (bits & exp.bit) replacementFlows.push(i as InstrFlow);\n        }\n\n        if (insertBefore.length + insertBetween.length && replacementFlows.length) {\n            const local = replacementFlows[0].expr.builder.addLocal(exp.type);\n            const insertInstructions = [...exp.instructions, Instructions.local.set(local)];\n            const replacementInstructions = [Instructions.local.get(local)];\n\n            results.push({\n                expression: exp,\n                insertBefore, insertBetween, insertAfter: [],\n                insertInstructions,\n                replacementFlows,\n                replacementInstructions,\n                fnLengthChange: 0\n            });\n        }\n    }\n\n    for (const result of results) {\n        // minimizing edge insertions\n        for (const i of new Set(result.insertBetween.map(([i]) => i))) {\n            const check = [...i.flowNext].every(j =>\n                j.instr && (result.insertBetween.find(([i2, j2]) => i === i2 && j === j2) || result.insertBefore.includes(j))\n            );\n            if (check) {\n                // remove [i, *j] from edges and [*j] from nodes\n                result.insertBetween = result.insertBetween.filter(([i2]) => i !== i2);\n                result.insertBefore = result.insertBefore.filter(j2 => i.flowNext.indexOf(j2) === -1);\n\n                if (i.instr.type === \"structured\") {\n                    // the structured nodes appear in the flow graph at the start of their blocks, and the algorithm\n                    // wants to insert after that flow graph, NOT after the whole structured instruction.\n                    result.insertBefore.push(i);\n                    // so instead insert before, which is safe as structured instructions only side effects are jumping\n                } else {\n                    result.insertAfter.push(i);\n                }\n            }\n        }\n\n        // calculate how this result would change the length of the function\n        const inserted = result.insertInstructions.length * ((result.insertBefore.length) + (result.insertBetween.length) + (result.insertAfter.length));\n        const removed = (result.expression.instructions.length - result.replacementInstructions.length) * result.replacementFlows.length;\n        result.fnLengthChange = inserted - removed;\n    }\n    return results;\n}\n\nfunction eliminateOverlapping(results: ExprResult[]): void {\n    // as expressions(...) returns all subexpressions in functions, need to chose which results to action\n\n    results.sort((a, b) => {\n        // prioritize expression replacements which would make the function shorter as these probably replace\n        // longer subexpressions which appear more often\n        const diff = a.fnLengthChange - b.fnLengthChange;\n        if (diff !== 0) return diff;\n        // after that prioritize longer subexpressions\n        return b.expression.instructions.length - a.expression.instructions.length;\n    });\n\n    // filter out expressions we can't do because they overlap with other expressions\n    // (hopefully due to the above sorting we will keep the longer expressions and discard their subexpressions)\n    const modificationRegions: [expr: WExpression, start: number, end: number][] = [];\n    for (let i = 0; i < results.length; i++) {\n        const result = results[i];\n        const expressionLen = result.expression.instructions.length;\n\n        const regions = result.replacementFlows.map(f =>\n            [f.expr, f.instrIndex - expressionLen, f.instrIndex] as [WExpression, number, number]);\n\n        const overlaps = regions.some(([expr1, min1, max1]) =>\n            modificationRegions.some(([expr2, min2, max2]) =>\n                expr1 === expr2 && max1 >= min2 && max2 >= min1\n            ));\n\n        if (overlaps) { // can't process this result as it overlaps with another with higher score\n            results.splice(i, 1);\n            i--;\n        } else {\n            modificationRegions.push(...regions);\n        }\n    }\n}\n\nexport function pre(expr: WExpression): void {\n    const cfg = controlFlow(expr);\n    if (!cfg.all.length) return;\n    const exprs = expressions(expr);\n    if (!exprs.length) return;\n\n    const {INSERT, INSERT_EDGE, REPLACE} = analysis(cfg, exprs);\n    if (INSERT.size === 0 && INSERT_EDGE.size === 0 && REPLACE.size === 0) return;\n\n    const results = processResults(exprs, {INSERT, INSERT_EDGE, REPLACE});\n    eliminateOverlapping(results);\n\n    const ifs = new InstrSplicer(); // keeps tracks of edits and adjust indices\n    for (const result of results) {\n        const exprLength = result.expression.instructions.length;\n        for (const i of result.replacementFlows) { // i is the last node of the expression\n            ifs.splice(i, exprLength, result.replacementInstructions, 1 - exprLength);\n        }\n\n        for (const i of result.insertBefore) {\n            ifs.splice(i, 0, result.insertInstructions, 0);\n        }\n        for (const i of result.insertAfter) {\n            if (i.instr.name.startsWith(\"br\")) {\n                // just insert before instead\n                ifs.splice(i, 0, result.insertInstructions, 0);\n            } else {\n                ifs.splice(i, 0, result.insertInstructions, 1);\n            }\n        }\n\n        for (const [i, j] of result.insertBetween) {\n            if (i.expr === j.expr && i.instrIndex + 1 === j.instrIndex) {\n                // instructions one after each other\n                ifs.splice(j, 0, result.insertInstructions);\n            } else if (ifs.realIndex(i) + 1 === i.expr.instructions.length) {\n                // i at the end of a block\n                ifs.splice(i, 0, result.insertInstructions, i.instr.name.startsWith(\"br\") ? 0 : 1);\n            } else if (i.instr.name.startsWith(\"br\")) {\n                // at a branch\n                ifs.splice(i, 0, result.insertInstructions);\n            } else if (j.expr.parent === i.instr && j.instrIndex === 0) {\n                // j is first instruction inside i\n                ifs.splice(j, 0, result.insertInstructions);\n            } else if (i.expr.depth > j.expr.depth) {\n                // i nested deeper inside expr containing j\n                ifs.splice(i, 0, result.insertInstructions, i.instr.name.startsWith(\"br\") ? 0 : 1);\n            } else {\n                throw new Error(\"Unknown PRE insertion\");\n            }\n        }\n    }\n}\n","import {WExpression, ValueType, Instructions} from \"../../wasm\";\nimport {WLocal} from \"../../wasm/functions\";\nimport {simplifiedControlFlow, Flow} from \"./control_flow\";\n\nexport function rangeSplitting(expr: WExpression): void {\n    const cfg = simplifiedControlFlow(expr, x => x.name.startsWith(\"local.\"));\n    const localsMap = new Map<Flow, LocalRange[]>();\n    const definitionMap = new Map<Flow, LocalRange>();\n\n    const queue = cfg.entry.flowNext.slice();\n\n    let flow: Flow | undefined;\n    while ((flow = queue.shift()) !== undefined) {\n        const ranges: LocalRange[] = [];\n        for (const prev of flow.flowPrevious) {\n            for (const [i, local] of (localsMap.get(prev) ?? []).entries()) {\n                if (!local) continue;\n                if (ranges[i] !== undefined) {\n                    ranges[i] = ranges[i].merge(local);\n                } else {\n                    ranges[i] = local.get();\n                }\n            }\n        }\n\n        if (flow.instr && flow.instr.type === \"index\" && (flow.instr.name === \"local.set\" || flow.instr.name === \"local.tee\")) {\n            const i = Number(flow.instr.immediate.value) - expr.builder.args.length;\n            if (i >= 0) {\n                let local = definitionMap.get(flow);\n                if (!local) definitionMap.set(flow, local = new LocalRange(flow.instr.parameters[0]));\n                ranges[i] = local;\n            }\n        }\n\n        const existing = localsMap.get(flow);\n        if (!existing || existing.length !== ranges.length || existing.some((x, i) => ranges[i] !== x)) {\n            localsMap.set(flow, ranges);\n            for (const next of flow.flowNext) queue.push(next);\n        }\n    }\n\n    const allLocals = [...new Set([...definitionMap.values()].map(x => x.get()))];\n    if (allLocals.length <= expr.builder.locals.length) return;\n\n    expr.builder.wipeLocals();\n    for (const l of allLocals) l.newLocal = expr.builder.addLocal(l.type);\n\n    for (const [flow, ranges] of localsMap.entries()) {\n        if (!flow.instr || flow.instr.type !== \"index\") continue;\n        const index = Number(flow.instr.immediate.value) - expr.builder.args.length;\n        if (index < 0) continue;\n\n        if (flow.instr.name === \"local.get\") {\n            flow.expr.replace(flow.instrIndex, flow.instrIndex + 1, Instructions.local.get(ranges[index].getNewLocal()));\n        } else if (flow.instr.name === \"local.set\") {\n            flow.expr.replace(flow.instrIndex, flow.instrIndex + 1, Instructions.local.set(ranges[index].getNewLocal()));\n        } else if (flow.instr.name === \"local.tee\") {\n            flow.expr.replace(flow.instrIndex, flow.instrIndex + 1, Instructions.local.tee(ranges[index].getNewLocal()));\n        }\n    }\n}\n\nlet localId = 0;\nclass LocalRange {\n    readonly id = localId++;\n    private target?: LocalRange;\n    newLocal?: WLocal;\n\n    constructor(readonly type: ValueType) {\n    }\n\n    merge(other: LocalRange): LocalRange {\n        if (this === other) return this.get();\n\n        if (this.target) {\n            return this.target.merge(other);\n        } else if (other.id < this.id) {\n            other.merge(this);\n            return this.get();\n        } else {\n            this.target = other;\n            return other.get();\n        }\n    }\n\n    get(): LocalRange {\n        if (this.target) return this.target.get();\n        return this;\n    }\n\n    getNewLocal(): WLocal {\n        if (this.target) return this.target.getNewLocal();\n        if (!this.newLocal) throw new Error(\"No new local assigned?\");\n        return this.newLocal;\n    }\n}\n","import type {Location, ParseNode} from \"./parsing\";\n\nexport class CError extends Error {\n    name = \"CError\";\n\n    constructor(message: string, readonly node?: ParseNode, readonly node2?: ParseNode) {\n        super(message);\n\n        if (node?.loc) {\n            this.message += \"\\n\\n\" + locationString(node.loc);\n            if (node2?.loc) this.message += \"\\n\\n\" + locationString(node2.loc, \"Secondary location\");\n        }\n    }\n}\n\nexport function locationString(loc: Location, label: string = \"Location\"): string {\n    const lines = loc.source.split(\"\\n\");\n    if (loc.first_line >= lines.length) return `${label}: [UNKNOWN]`;\n\n    let output = `${label}:\\n`;\n\n    const lnumDigits = Math.ceil(Math.log10(loc.last_line + 4));\n    function outputLine(lnum: number) {\n        output += `L${(lnum + 1).toString().padStart(lnumDigits, '0')}: ${lines[lnum]}\\n`;\n    }\n\n    if (loc.first_line > 1) outputLine(loc.first_line - 2);\n    if (loc.first_line > 0) outputLine(loc.first_line - 1);\n    outputLine(loc.first_line);\n\n    // output ^^^ arrows\n    output += new Array(3 + lnumDigits + loc.first_column).join(\" \");\n    if (loc.first_line === loc.last_line) {\n        output += new Array(1 + loc.last_column - loc.first_column).join(\"^\");\n    } else {\n        output += \"^\";\n    }\n    output += \"\\n\";\n\n    if (loc.first_line + 1 < lines.length) outputLine(loc.first_line + 1);\n    if (loc.first_line + 2 < lines.length) outputLine(loc.first_line + 2);\n    return output;\n}\n","import {CError} from \"../c_error\";\nimport type {TypeSpecifier, TypeQualifier, ParseNode} from \"../parsing/parsetree\";\n\n// types for expressions and declarations in the IR\nexport type CType = CNotFuncType | CFuncType;\nexport type CNotFuncType = CArithmetic | CPointer | CArray | CStruct | CUnion | CVoid;\nexport type CQualifiedType<T extends CType> = T & {qualifier?: TypeQualifier, _base?: T};\n\nexport class CFuncType {\n    readonly typeName = \"function\";\n    readonly bytes = 0;\n    readonly alignment = 1;\n    readonly incomplete = false;\n\n    constructor(readonly node: ParseNode | undefined,\n                readonly returnType: CQualifiedType<CNotFuncType>,\n                readonly parameterTypes: CQualifiedType<CNotFuncType>[],\n                public parameterNames?: string[],\n                readonly variadic: boolean = false) {\n        // return type and parameter types must be complete\n        if (!(returnType instanceof CVoid)) checkTypeComplete(returnType);\n        parameterTypes.forEach(x => checkTypeComplete(x));\n    }\n\n    equals(t: Object): boolean {\n        return t instanceof CFuncType\n            && t.returnType.equals(this.returnType)\n            && t.parameterTypes.length === this.parameterTypes.length\n            && t.parameterTypes.every((other, i) => this.parameterTypes[i].equals(other))\n            && t.variadic === this.variadic;\n    }\n\n    get pointerGeneration(): CPointer {\n        return addQualifier(new CPointer(this.node, this, false, this), getQualifier(this));\n    }\n}\n\nexport class CPointer {\n    readonly bytes = 4;\n    readonly alignment = 4;\n    readonly incomplete = false;\n    readonly qualifier?: TypeQualifier;\n\n    constructor(readonly node: ParseNode | undefined,\n                readonly type: CType,\n                constant: boolean = false,\n                readonly original?: CFuncType | CArray /* used in pointer generation */) {\n        // allow pointers to incomplete types\n        if (constant) this.qualifier = \"const\";\n    }\n\n    equals(t: object): boolean {\n        return t instanceof CPointer && t.qualifier === this.qualifier && this.type.equals(t.type);\n    }\n\n    get pointerGeneration(): this {\n        return this; // no pointer generation (already a pointer!)\n    }\n\n    get typeName(): string {\n        return this.type.typeName + \"*\" + (this.qualifier ? \" \" + this.qualifier : \"\");\n    }\n}\n\nexport class CArray {\n    readonly alignment: number;\n\n    constructor(readonly node: ParseNode | undefined, readonly type: CType, public length?: number) {\n        checkTypeComplete(type);\n        this.alignment = type.alignment;\n    }\n\n    get bytes(): number {\n        if (this.length === undefined) throw new Error(\"Tried to get size of incomplete type\");\n        return this.type.bytes * this.length;\n    }\n\n    get incomplete(): boolean {\n        return this.length === undefined;\n    }\n\n    equals(t: object): boolean {\n        return t instanceof CArray && t.length === this.length && this.type.equals(t.type);\n    }\n\n    get pointerGeneration(): CPointer {\n        return addQualifier(new CPointer(this.node, this.type, false, this), getQualifier(this));\n    }\n\n    get typeName(): string {\n        if (this.length) {\n            return this.type.typeName + \"[\" + this.length + \"]\";\n        } else {\n            return this.type.typeName + \"[]\";\n        }\n    }\n}\n\nexport type CCompound = CStruct | CUnion | CEnum;\n\nexport class CCompoundMember {\n    constructor(readonly node: ParseNode, readonly name: string, readonly type: CQualifiedType<CNotFuncType>) {}\n}\n\nexport class CStruct {\n    private _members: ReadonlyArray<CCompoundMember> | undefined;\n\n    constructor(public node: ParseNode | undefined, readonly name: string | undefined) {\n    }\n\n    get members(): ReadonlyArray<CCompoundMember> {\n        if (this._members === undefined) throw new Error(\"Can't get members of an incomplete struct\");\n        return this._members;\n    }\n\n    set members(children: ReadonlyArray<CCompoundMember>) {\n        if (this._members !== undefined) throw new Error(\"Can't redefine a struct's members\");\n        if (children.length === 0) throw new Error(\"Struct must have one or more member\");\n        this._members = children;\n    }\n\n    get bytes(): number {\n        if (this.incomplete) throw new Error(\"Tried to get size of incomplete type\");\n        return this.members.reduce((total, x) => {\n            // align member type\n            total = Math.ceil(total / x.type.alignment) * x.type.alignment;\n            return total + x.type.bytes;\n        }, 0);\n    }\n\n    get alignment(): number {\n        return Math.max(...this.members.map(x => x.type.alignment));\n    }\n\n    get incomplete(): boolean {\n        return this._members === undefined;\n    }\n\n    equals(t: object): boolean {\n        if (!(t instanceof CStruct)) return false;\n        if (this.name === undefined && t.name === undefined) {\n            /** TODO breaks spec but works around anonymous structure being included in multiple files from a header file\n             *\n             * \"Structures, unions and enumerations with different tags are distinct,\n             * and a tagless union, structure, or enumeration specifies a unique type\" */\n            if (this.members.length !== t.members.length) return false;\n            return this.members.every((x, i) => t.members[i].name === x.name && t.members[i].type.equals(x.type));\n        }\n        return t.name === this.name;\n    }\n\n    memberType(m: string): CType {\n        const member = this.members.find(x => x.name === m);\n        if (member) return member.type;\n        throw new Error(`Struct does not contain member \"${m}\"`);\n    }\n\n    hasConstMember(): boolean { // if the struct contains one or more const members\n        return this.members.find(m =>\n            getQualifier(m.type) || ((m.type instanceof CUnion || m.type instanceof CStruct) && m.type.hasConstMember())\n        ) !== undefined;\n    }\n\n    get pointerGeneration(): this {\n        return this; // no pointer generation\n    }\n\n    get typeName(): string {\n        if (this.name) {\n            return \"struct \" + this.name;\n        } else {\n            return \"struct {\" + this.members.map(x => x.type.typeName + \" \" + x.name + \";\").join(\" \") + \"}\";\n        }\n    }\n}\n\nexport class CUnion {\n    private _members: ReadonlyArray<CCompoundMember> | undefined;\n\n    constructor(public node: ParseNode | undefined, readonly name: string | undefined) {\n    }\n\n    get members(): ReadonlyArray<CCompoundMember> {\n        if (this._members === undefined) throw new Error(\"Can't get members of an incomplete union\");\n        return this._members;\n    }\n\n    set members(children: ReadonlyArray<CCompoundMember>) {\n        if (this._members !== undefined) throw new Error(\"Can't redefine a union's members\");\n        if (children.length === 0) throw new Error(\"Struct must have one or more member\");\n        this._members = children;\n    }\n\n    get bytes(): number {\n        if (this.incomplete) throw new Error(\"Tried to get size of incomplete type\");\n        return this.members.reduce((total, x) => Math.max(total, x.type.bytes), 0);\n    }\n\n    get alignment(): number {\n        return Math.max(...this.members.map(x => x.type.alignment));\n    }\n\n    get incomplete(): boolean {\n        return this._members === undefined;\n    }\n\n    equals(t: object): boolean {\n        if (!(t instanceof CUnion)) return false;\n        if (this.name === undefined && t.name === undefined) {\n            if (this.members.length !== t.members.length) return false;\n            return this.members.every((x, i) => t.members[i].name === x.name && t.members[i].type.equals(x.type));\n        }\n        return t.name === this.name;\n    }\n\n    memberType(m: string): CType {\n        const member = this.members.find(x => x.name === m);\n        if (member) return member.type;\n        throw new Error(`Union does not contain member \"${m}\"`);\n    }\n\n    hasConstMember(): boolean { // if the union has one or more const members\n        return this.members.find(m =>\n            getQualifier(m.type) || ((m.type instanceof CUnion || m.type instanceof CStruct) && m.type.hasConstMember())\n        ) !== undefined;\n    }\n\n    get pointerGeneration(): this {\n        return this; // no pointer generation\n    }\n\n    get typeName(): string {\n        if (this.name) {\n            return \"union \" + this.name;\n        } else {\n            return \"union {\" + this.members.map(x => x.type.typeName + \" \" + x.name + \";\").join(\" \") + \"}\";\n        }\n    }\n}\n\nexport type CEnumValue = {name: string, value: bigint};\nexport class CEnum {\n    readonly typeName = \"enum\";\n    private _values: ReadonlyArray<CEnumValue> | undefined;\n\n    constructor(public node: ParseNode | undefined, readonly name: string | undefined) {\n    }\n\n    get values(): ReadonlyArray<CEnumValue> {\n        if (this._values === undefined) throw new Error(\"Can't get values of an incomplete enum\");\n        return this._values;\n    }\n\n    set values(children: ReadonlyArray<CEnumValue>) {\n        if (this._values !== undefined) throw new Error(\"Can't redefine an enum's values\");\n        if (children.length === 0) throw new Error(\"Enum must have one or more value\");\n        this._values = children;\n    }\n\n    get incomplete(): boolean {\n        return this._values === undefined;\n    }\n\n    equals(t: object): boolean {\n        if (this.name === undefined) return this === t;\n        return t instanceof CEnum && t.name === this.name;\n    }\n}\n\nexport class CVoid {\n    readonly typeName = \"void\";\n    readonly bytes = 0;\n    readonly alignment = 1;\n    readonly incomplete = true;\n    readonly node = undefined;\n\n    equals(t: object): boolean {\n        return t instanceof CVoid;\n    }\n\n    get pointerGeneration(): this {\n        return this; // no pointer generation\n    }\n}\n\nexport class CArithmetic {\n    readonly incomplete = false;\n    readonly node = undefined;\n    readonly alignment: number;\n\n    private constructor(readonly typeName: string, readonly bytes: number, readonly type: \"float\" | \"signed\" | \"unsigned\") {\n        this.alignment = bytes;\n    }\n\n    equals(t: object): boolean {\n        return t instanceof CArithmetic && t.typeName === this.typeName && t.type === this.type && t.bytes === this.bytes;\n    }\n\n    get minValue(): bigint | number {\n        if (CArithmetic.BOOL.equals(this)) return 0;\n\n        switch (this.type) {\n        case \"float\":\n            return -Infinity;\n        case \"unsigned\":\n            return 0;\n        case \"signed\":\n            return -(2n ** (BigInt(this.bytes * 8) - 1n));\n        }\n    }\n\n    get maxValue(): bigint | number {\n        if (CArithmetic.BOOL.equals(this)) return 1;\n\n        switch (this.type) {\n        case \"float\":\n            return Infinity;\n        case \"unsigned\":\n            return 2n ** BigInt(this.bytes * 8) - 1n;\n        case \"signed\":\n            return 2n ** (BigInt(this.bytes * 8) - 1n) - 1n;\n        }\n    }\n\n    get pointerGeneration(): this {\n        return this; // no pointer generation\n    }\n\n    static readonly Fp32 = new CArithmetic(\"float\", 4, \"float\");\n    static readonly Fp64 = new CArithmetic(\"double\", 8, \"float\");\n\n    static readonly U8 = new CArithmetic(\"char\", 1, \"unsigned\");\n    static readonly S8 = new CArithmetic(\"signed char\", 1, \"signed\");\n    static readonly U16 = new CArithmetic(\"unsigned short\", 2, \"unsigned\");\n    static readonly S16 = new CArithmetic(\"short\", 2, \"signed\");\n    static readonly U32 = new CArithmetic(\"unsigned int\", 4, \"unsigned\");\n    static readonly S32 = new CArithmetic(\"int\", 4, \"signed\");\n    static readonly U64 = new CArithmetic(\"unsigned long\", 8, \"unsigned\");\n    static readonly S64 = new CArithmetic(\"long\", 8, \"signed\");\n\n    static readonly BOOL = new CArithmetic(\"bool\", 4, \"signed\");\n}\n\nexport const CSizeT = CArithmetic.U32;\n\n\nconst constType = Symbol(\"const\"); // hidden property key\n\n/**\n * Add a qualifier to a type.\n *\n * This creates a new object with the qualifier attached, using the existing type as its prototype, allowing it to be\n * treated as the existing type. This new object is also cached on the existing type using a field referenced by a\n * symbol, so it can't be accessed when enumerating the fields and doesn't affect existing code.\n */\nexport function addQualifier<T extends CType>(t: T, qualifier?: TypeQualifier): CQualifiedType<T> {\n    if (qualifier === undefined) return t;\n    if (Object.prototype.hasOwnProperty.call(t, \"qualifier\")) {\n        throw new Error(\"Type already has a qualifier\");\n    }\n\n    const baseType = t as Record<typeof constType, any>;\n    if (baseType[constType]) {\n        // const type already exists\n        return baseType[constType];\n    }\n\n    const type = Object.setPrototypeOf({qualifier, _base: t}, t);\n    baseType[constType] = type;\n    return type;\n}\n\nexport function getQualifier(t: CQualifiedType<CType>): TypeQualifier | undefined {\n    return t?.qualifier;\n}\n\n/** integer promotion from the C standard */\nexport function integerPromotion(t: CArithmetic): CArithmetic {\n    if (t.type === \"float\") return t;\n    if (t.bytes < CArithmetic.S32.bytes || t === CArithmetic.BOOL) return CArithmetic.S32;\n    return t;\n}\n\n/** \"The usual arithmetic conversions\" from the C standard */\nexport function usualArithmeticConversion(t1: CArithmetic, t2: CArithmetic): CArithmetic {\n    if (t1 === CArithmetic.Fp64 || t2 === CArithmetic.Fp64) return CArithmetic.Fp64;\n    if (t1 === CArithmetic.Fp32 || t2 === CArithmetic.Fp32) return CArithmetic.Fp32;\n\n    // integer promotion\n    t1 = integerPromotion(t1);\n    t2 = integerPromotion(t2);\n\n    if (t1 === CArithmetic.U64 || t2 === CArithmetic.U64) return CArithmetic.U64;\n    if (t1 === CArithmetic.S64 || t2 === CArithmetic.S64) return CArithmetic.S64;\n    if (t1 === CArithmetic.U32 || t2 === CArithmetic.U32) return CArithmetic.U32;\n    return CArithmetic.S32;\n}\n\n/** Convert a list of specifier strings (e.g. \"signed\", \"int\") into a CType instance. */\nexport function getArithmeticType(specifierList: ReadonlyArray<TypeSpecifier & string>): CArithmetic | CVoid | undefined {\n    const copy = specifierList.slice();\n\n    function remove(s: TypeSpecifier & string) { // remove an item from a list if present, and return whether it was\n        const idx = copy.indexOf(s);\n        if (idx > -1) {\n            copy.splice(idx, 1);\n            return true;\n        }\n        return false;\n    }\n\n    function check<T>(x: T): T | undefined { // check that there are no specifiers left to be processed\n        if (copy.length > 0) return undefined; // extra specifiers so this type is invalid (e.g. \"unsigned signed int\")\n        return x;\n    }\n\n    if (remove(\"void\")) { // if \"void\" in list\n        return check(new CVoid()); // then the type must be void, check no extra specifiers were provided\n    } else if (remove(\"double\")) {\n        remove(\"long\"); // remove \"long\" if present, as treating \"long double\" as normal doubles\n        return check(CArithmetic.Fp64);\n    } else if (remove(\"float\")) {\n        return check(CArithmetic.Fp32);\n    } else if (remove(\"char\")) {\n        if (remove(\"signed\")) return check(CArithmetic.S8);\n        remove(\"unsigned\");\n        return check(CArithmetic.U8);\n    } else if (remove(\"short\")) {\n        remove(\"int\"); // remove optional \"int\" (\"short int\" === \"int\")\n        if (remove(\"unsigned\")) return check(CArithmetic.U16);\n        remove(\"signed\");\n        return check(CArithmetic.S16);\n    } else if (remove(\"long\")) {\n        remove(\"long\"); // remove an 2nd \"long\" if present, as treating \"long long\" as \"long\"\n        remove(\"int\");\n        if (remove(\"unsigned\")) return check(CArithmetic.U64);\n        remove(\"signed\");\n        return check(CArithmetic.S64);\n    } else if (remove(\"int\")) {\n        if (remove(\"unsigned\")) return check(CArithmetic.U32);\n        remove(\"signed\");\n        return check(CArithmetic.S32);\n    } else if (remove(\"unsigned\")) { // support just `unsigned` and `signed`\n        return check(CArithmetic.U32);\n    } else if (remove(\"signed\")) {\n        return check(CArithmetic.S32);\n    } else if (remove(\"bool\")) {\n        return check(CArithmetic.BOOL);\n    }\n    return undefined;\n}\n\n/** Assert that type is complete */\nexport function checkTypeComplete<T extends CType>(type: T, node: ParseNode | undefined = type.node): T {\n    if (type.incomplete) {\n        throw new class extends CError {\n            name = \"IncompleteTypeError\";\n        }(\"Invalid use of an incomplete type\", node);\n    }\n    return type;\n}\n","import {CError} from \"../c_error\";\nimport type {ParseNode} from \"../parsing\";\nimport type {CExpression} from \"./expressions\";\nimport {CArithmetic, CPointer, CStruct, CUnion, CType, CFuncType, checkTypeComplete} from \"./types\";\n\nexport class ExpressionTypeError extends CError {\n    name = \"ExpressionTypeError\";\n\n    constructor(node: ParseNode, readonly wantedType: string, readonly actualType?: string) {\n        super(actualType ? `Expected ${wantedType} but got ${actualType} instead!` : `Expected ${wantedType}`, node);\n    }\n}\n\n// Basic type checking for expressions, throws an exception if the expression's type is not the expected type\n\nexport function asArithmetic(node: ParseNode, t: CType): CArithmetic {\n    if (t instanceof CArithmetic) return t;\n    throw new ExpressionTypeError(node, \"arithmetic\", t.typeName);\n}\n\nexport function asInteger(node: ParseNode, t: CType): CArithmetic {\n    const arithmetic = asArithmetic(node, t);\n    switch (arithmetic.type) {\n    case \"signed\":\n    case \"unsigned\":\n        return arithmetic;\n    default:\n        throw new ExpressionTypeError(node, \"integer\", t.typeName);\n    }\n}\n\nexport function asPointer(node: ParseNode, t: CType): CPointer {\n    if (t instanceof CPointer) return t;\n    throw new ExpressionTypeError(node, \"pointer\", t.typeName);\n}\n\nexport function asArithmeticOrPointer(node: ParseNode, t: CType): CArithmetic | CPointer {\n    if (t instanceof CArithmetic) return t;\n    if (t instanceof CPointer) return t;\n    throw new ExpressionTypeError(node, \"arithmetic or pointer\", t.typeName);\n}\n\nexport function asNonFunctionPointer<T extends CType>(node: ParseNode, t: T): T {\n    if (t instanceof CPointer && t.type instanceof CFuncType) {\n        throw new ExpressionTypeError(node, \"non-function pointer\", \"function pointer\");\n    }\n    return t;\n}\n\nexport function asFunction(node: ParseNode, t: CType): CFuncType {\n    if (t instanceof CFuncType) return t;\n    if (t instanceof CPointer && t.type instanceof CFuncType) return t.type;\n    throw new ExpressionTypeError(node, \"function\", t.typeName);\n}\n\nexport function asStructOrUnion(node: ParseNode, t: CType): CStruct | CUnion {\n    checkTypeComplete(t);\n    if (t instanceof CStruct) return t;\n    if (t instanceof CUnion) return t;\n    throw new ExpressionTypeError(node, \"struct or union\", t.typeName);\n}\n\nexport function checkLvalue(expression: CExpression, lvalue: boolean): CExpression {\n    if (expression.lvalue === lvalue) return expression;\n    throw new ExpressionTypeError(expression.node, `lvalue=${lvalue}`, `lvalue=${expression.lvalue}`);\n}\n","import type {ParseNode, pt} from \"../parsing\";\nimport type {CDeclaration, CVariable, CArgument} from \"./declarations\";\nimport * as checks from \"./type_checking\";\nimport {\n    CArithmetic, CType, CArray, CPointer, CUnion, CStruct,\n    CSizeT, usualArithmeticConversion, integerPromotion, CFuncType, CVoid, checkTypeComplete, getQualifier\n} from \"./types\";\n\n// Classes to represent all the possible expression types in the IR\n\nexport type CExpression =\n    CConstant | CIdentifier | CStringLiteral |\n    CFunctionCall | CMemberAccess | CIncrDecr | // postfix\n    CAddressOf | CDereference | CUnaryPlusMinus | CBitwiseNot | CLogicalNot | CSizeof | // unary\n    CCast |\n    CMulDiv | CMod | CAddSub | CShift |\n    CRelational | CEquality |\n    CBitwiseAndOr | CLogicalAndOr |\n    CConditional | CAssignment | CComma;\n\n// evaluated expression, value and type pair\nexport type CValue = {readonly value: number | bigint, readonly type: CArithmetic | CPointer};\n\nexport class CConstant {\n    readonly lvalue = false;\n\n    constructor(readonly node: ParseNode, readonly type: CArithmetic, readonly value: bigint | number) {\n    }\n\n    changeType(type: CArithmetic): CConstant {\n        if (this.type.equals(type)) return this;\n\n        let newValue: bigint | number;\n        if (type.equals(CArithmetic.BOOL)) {\n            // eslint-disable-next-line eqeqeq\n            newValue = this.value == 0 ? 0 : 1;\n        } else if (type.type === \"float\") {\n            newValue = Number(this.value);\n        } else {\n            if (this.value > type.maxValue || this.value < type.minValue) {\n                throw new checks.ExpressionTypeError(this.node, `value which fits in ${type.typeName}`, this.value.toString());\n            }\n            newValue = BigInt(this.value);\n        }\n        return new CConstant(this.node, type, newValue);\n    }\n\n    // for analyzing expression dependencies\n    *identifiers(): IterableIterator<CIdentifier> {\n        // no identifier children\n    }\n}\n\nexport class CIdentifier {\n    readonly lvalue: boolean;\n\n    constructor(readonly node: ParseNode, readonly value: CDeclaration) {\n        this.lvalue = !(value.type instanceof CFuncType);\n    }\n\n    get type(): CType {\n        return this.value.type.pointerGeneration;\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield this;\n    }\n}\n\nexport class CStringLiteral {\n    readonly lvalue = false;\n    readonly type: CPointer;\n\n    constructor(readonly node: ParseNode, readonly value: bigint[]) {\n        // currently only supports UTF8\n        if (value.length === 0 || value[value.length - 1] !== 0n) {\n            throw new checks.ExpressionTypeError(node, \"null terminated char[]\", \"char[]\");\n        }\n        this.type = new CArray(node, CArithmetic.U8, value.length).pointerGeneration;\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        // no identifier children\n    }\n}\n\nexport class CFunctionCall {\n    readonly lvalue = false;\n    readonly fnType: CFuncType;\n    readonly type: CType;\n\n    constructor(readonly node: ParseNode, readonly body: CExpression, readonly args: CExpression[]) {\n        this.fnType = checks.asFunction(body.node, body.type);\n        this.type = this.fnType.returnType.pointerGeneration;\n\n        // check arguments correct for the function type\n        if (this.fnType.variadic && this.fnType.parameterTypes.length > args.length) {\n            throw new checks.ExpressionTypeError(node, `at least ${this.fnType.parameterTypes.length} argument(s) to variadic function`);\n        } else if (!this.fnType.variadic && this.fnType.parameterTypes.length !== args.length) {\n            throw new checks.ExpressionTypeError(node, `${this.fnType.parameterTypes.length} argument(s)`, `${args.length}`);\n        }\n        for (let i = 0; i < this.fnType.parameterTypes.length; i++) {\n            CAssignment.checkAssignmentValid(args[i].node, this.fnType.parameterTypes[i], args[i]);\n        }\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.body.identifiers();\n        for (const a of this.args) yield* a.identifiers();\n    }\n}\n\nexport class CMemberAccess {\n    readonly lvalue: boolean;\n    readonly structUnion: CStruct | CUnion;\n    readonly type: CType;\n\n    /** transform `e.member` to `(&e)->member` before calling */\n    constructor(readonly node: ParseNode, readonly body: CExpression, readonly member: string) {\n        const bodyType = body.type instanceof CPointer ? (body.type.original ?? body.type) : body.type; // no pointer gen\n        const pointerType = checks.asPointer(body.node, bodyType);\n        this.structUnion = checks.asStructOrUnion(body.node, pointerType.type);\n\n        const type = this.structUnion.memberType(member);\n        this.type = type.pointerGeneration;\n        this.lvalue = !(this.type instanceof CArray);\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.body.identifiers();\n    }\n}\n\nexport class CIncrDecr {\n    readonly lvalue = false;\n    readonly type: CArithmetic | CPointer;\n\n    constructor(readonly node: ParseNode, readonly body: CExpression,\n                readonly op: \"++\" | \"--\", readonly pos: \"pre\" | \"post\") {\n        checks.checkLvalue(body, true);\n\n        const bodyType = body.type instanceof CPointer ? (body.type.original ?? body.type) : body.type; // no pointer gen\n        this.type = checks.asNonFunctionPointer(body.node, checks.asArithmeticOrPointer(body.node, bodyType));\n        if (this.type instanceof CPointer) checkTypeComplete(this.type.type);\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.body.identifiers();\n    }\n}\n\nexport class CSizeof {\n    readonly lvalue = false;\n    readonly type = CSizeT;\n    readonly body: CType;\n\n    constructor(readonly node: ParseNode, body: CType) {\n        this.body = body instanceof CPointer ? (body.original ?? body) : body; // no pointer gen\n        if (this.body.incomplete || this.body.bytes === 0 || this.body instanceof CFuncType) {\n            throw new checks.ExpressionTypeError(node, \"Complete non-function type\", body.typeName);\n        }\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        // no identifier children\n    }\n}\n\nexport class CAddressOf { // &\n    readonly lvalue = false;\n    readonly type: CPointer;\n    readonly body: CExpression;\n\n    constructor(readonly node: ParseNode, body: CExpression) {\n        const bodyType = body.type instanceof CPointer ? (body.type.original ?? body.type) : body.type; // no pointer gen\n        if (!(body instanceof CIdentifier && bodyType instanceof CFuncType)) checks.checkLvalue(body, true);\n        this.type = new CPointer(node, bodyType);\n\n        if (body instanceof CIdentifier) {\n            // when translating to wasm all variables which have their address taken have to be stored on the shadow stack\n            (body.value as CVariable | CArgument).addressUsed = true;\n        }\n        this.body = body;\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.body.identifiers();\n    }\n}\n\nexport class CDereference { // * or 'indirection'\n    readonly lvalue = true;\n    readonly type: CType;\n\n    constructor(readonly node: ParseNode, readonly body: CExpression) {\n        this.type = checks.asPointer(node, body.type).type.pointerGeneration;\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.body.identifiers();\n    }\n}\n\nexport class CUnaryPlusMinus {\n    readonly lvalue = false;\n    readonly type: CArithmetic;\n    readonly bodyType: CArithmetic;\n\n    constructor(readonly node: ParseNode, readonly body: CExpression, readonly op: \"+\" | \"-\") {\n        this.bodyType = checks.asArithmetic(body.node, body.type);\n        this.type = integerPromotion(this.bodyType);\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.body.identifiers();\n    }\n}\n\nexport class CBitwiseNot {\n    readonly lvalue = false;\n    readonly type: CArithmetic;\n    readonly bodyType: CArithmetic;\n\n    constructor(readonly node: ParseNode, readonly body: CExpression) {\n        this.bodyType = checks.asInteger(body.node, body.type);\n        this.type = this.bodyType.bytes < CArithmetic.S32.bytes ? CArithmetic.S32 : this.bodyType;\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.body.identifiers();\n    }\n}\n\nexport class CLogicalNot {\n    readonly lvalue = false;\n    readonly type = CArithmetic.S32;\n\n    constructor(readonly node: ParseNode, readonly body: CExpression) {\n        checks.asArithmeticOrPointer(body.node, body.type);\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.body.identifiers();\n    }\n}\n\nexport class CCast {\n    readonly lvalue = false;\n    readonly type: CType;\n\n    constructor(readonly node: ParseNode, type: CType, readonly body: CExpression) {\n        this.type = type.pointerGeneration;\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.body.identifiers();\n    }\n}\n\nexport class CMulDiv {\n    readonly lvalue = false;\n    readonly type: CArithmetic;\n\n    constructor(readonly node: ParseNode, readonly lhs: CExpression, readonly rhs: CExpression, readonly op: \"*\" | \"/\") {\n        this.type = usualArithmeticConversion(\n            checks.asArithmetic(lhs.node, lhs.type),\n            checks.asArithmetic(rhs.node, rhs.type));\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.lhs.identifiers();\n        yield* this.rhs.identifiers();\n    }\n}\n\nexport class CMod {\n    readonly lvalue = false;\n    readonly type: CArithmetic;\n\n    constructor(readonly node: ParseNode, readonly lhs: CExpression, readonly rhs: CExpression) {\n        this.type = usualArithmeticConversion(\n            checks.asInteger(lhs.node, lhs.type),\n            checks.asInteger(rhs.node, rhs.type));\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.lhs.identifiers();\n        yield* this.rhs.identifiers();\n    }\n}\n\n// Array subscript a[b] becomes *(a + b)\nexport class CAddSub {\n    readonly lvalue = false;\n    readonly type: CArithmetic | CPointer;\n\n    constructor(readonly node: ParseNode, readonly lhs: CExpression, readonly rhs: CExpression, readonly op: \"+\" | \"-\") {\n        if (lhs.type instanceof CPointer && rhs.type instanceof CPointer) { // both pointers\n            if (!lhs.type.equals(rhs.type)) throw new checks.ExpressionTypeError(node, \"both pointers to have the same type\");\n            checkTypeComplete(lhs.type.type);\n            this.type = checks.asNonFunctionPointer(lhs.node, lhs.type);\n            checks.asNonFunctionPointer(rhs.node, rhs.type);\n\n        } else if (lhs.type instanceof CPointer) { // one pointer, one integral\n            checks.asInteger(rhs.node, rhs.type);\n            checkTypeComplete(lhs.type.type);\n            this.type = checks.asNonFunctionPointer(lhs.node, lhs.type);\n\n        } else if (rhs.type instanceof CPointer) { // one pointer, one integral\n            checks.asInteger(lhs.node, lhs.type);\n            checkTypeComplete(rhs.type.type);\n            this.type = checks.asNonFunctionPointer(rhs.node, rhs.type);\n\n        } else {\n            this.type = usualArithmeticConversion(checks.asArithmetic(lhs.node, lhs.type), checks.asArithmetic(rhs.node, rhs.type));\n        }\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.lhs.identifiers();\n        yield* this.rhs.identifiers();\n    }\n}\n\nexport class CShift {\n    readonly lvalue = false;\n    readonly type: CArithmetic;\n\n    constructor(readonly node: ParseNode, readonly lhs: CExpression, readonly rhs: CExpression, readonly dir: \"left\" | \"right\") {\n        this.type = integerPromotion(checks.asInteger(lhs.node, lhs.type));\n        checks.asInteger(rhs.node, rhs.type);\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.lhs.identifiers();\n        yield* this.rhs.identifiers();\n    }\n}\n\nexport class CRelational {\n    readonly lvalue = false;\n    readonly type = CArithmetic.BOOL;\n    readonly commonType: CArithmetic;\n\n    constructor(readonly node: ParseNode, readonly lhs: CExpression, readonly rhs: CExpression, readonly op: \"LT\" | \"GT\" | \"LEq\" | \"GEq\") {\n        checks.asArithmeticOrPointer(lhs.node, lhs.type);\n        checks.asArithmeticOrPointer(rhs.node, rhs.type);\n\n        this.commonType = usualArithmeticConversion(\n            lhs.type instanceof CArithmetic ? lhs.type : CSizeT,\n            rhs.type instanceof CArithmetic ? rhs.type : CSizeT);\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.lhs.identifiers();\n        yield* this.rhs.identifiers();\n    }\n}\n\nexport class CEquality {\n    readonly lvalue = false;\n    readonly type = CArithmetic.BOOL;\n    readonly commonType: CArithmetic;\n\n    constructor(readonly node: ParseNode, readonly lhs: CExpression, readonly rhs: CExpression, readonly op: \"==\" | \"!=\") {\n        checks.asArithmeticOrPointer(lhs.node, lhs.type);\n        checks.asArithmeticOrPointer(rhs.node, rhs.type);\n\n        this.commonType = usualArithmeticConversion(\n            lhs.type instanceof CArithmetic ? lhs.type : CSizeT,\n            rhs.type instanceof CArithmetic ? rhs.type : CSizeT);\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.lhs.identifiers();\n        yield* this.rhs.identifiers();\n    }\n}\n\nexport class CBitwiseAndOr {\n    readonly lvalue = false;\n    readonly type: CArithmetic;\n\n    constructor(readonly node: ParseNode, readonly lhs: CExpression, readonly rhs: CExpression, readonly op: \"and\" | \"or\" | \"xor\") {\n        this.type = usualArithmeticConversion(\n            checks.asInteger(lhs.node, lhs.type),\n            checks.asInteger(rhs.node, rhs.type));\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.lhs.identifiers();\n        yield* this.rhs.identifiers();\n    }\n}\n\nexport class CLogicalAndOr {\n    readonly lvalue = false;\n    readonly type = CArithmetic.BOOL;\n\n    constructor(readonly node: ParseNode, readonly lhs: CExpression, readonly rhs: CExpression, readonly op: \"and\" | \"or\") {\n        checks.asArithmeticOrPointer(lhs.node, lhs.type);\n        checks.asArithmeticOrPointer(rhs.node, rhs.type);\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.lhs.identifiers();\n        yield* this.rhs.identifiers();\n    }\n}\n\nexport class CConditional { // [test] ? [trueValue] : [falseValue]\n    readonly lvalue = false;\n    readonly type: CType;\n\n    constructor(readonly node: ParseNode, readonly test: CExpression, readonly trueValue: CExpression, readonly falseValue: CExpression) {\n        checks.asArithmeticOrPointer(test.node, test.type);\n\n        if (trueValue.type instanceof CArithmetic && falseValue.type instanceof CArithmetic) {\n            this.type = usualArithmeticConversion(trueValue.type, falseValue.type);\n            return;\n        } else if (trueValue.type.equals(falseValue.type)) {\n            this.type = trueValue.type;\n            return;\n        } else if (trueValue.type instanceof CPointer && falseValue.type instanceof CPointer) {\n            // both pointers - check if either is void* pointer\n            if (trueValue.type.type instanceof CVoid) {\n                this.type = falseValue.type;\n                return;\n            } else if (falseValue.type.type instanceof CVoid) {\n                this.type = trueValue.type;\n                return;\n            }\n        } else if (trueValue.type instanceof CPointer || falseValue.type instanceof CPointer) {\n            // one pointer - check if other null constant\n            const otherValue = trueValue.type instanceof CPointer ? falseValue : trueValue;\n            // eslint-disable-next-line eqeqeq\n            if (otherValue instanceof CConstant && otherValue.value == 0) {\n                this.type = trueValue.type instanceof CPointer ? trueValue.type : falseValue.type;\n                return;\n            }\n        }\n        throw new checks.ExpressionTypeError(node, \"both conditional branches to have the same type\", \"different types\");\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.test.identifiers();\n        yield* this.trueValue.identifiers();\n        yield* this.falseValue.identifiers();\n    }\n}\n\nexport class CAssignment {\n    readonly lvalue = false;\n    readonly type: CType;\n\n    // rhs may require casting\n    constructor(readonly node: ParseNode, readonly lhs: CExpression, readonly rhs: CExpression | CInitializer,\n                readonly assignmentType: pt.AssignmentType, readonly initialAssignment: boolean = false) {\n        // check lvalue\n        const lhsType = lhs.type instanceof CPointer ? (lhs.type.original ?? lhs.type) : lhs.type; // no pointer gen\n        checks.checkLvalue(lhs, true);\n        if ((lhsType instanceof CArray && !initialAssignment) || lhsType instanceof CFuncType || lhs.type.incomplete) {\n            throw new checks.ExpressionTypeError(lhs.node, \"assignable type\");\n        } else if (getQualifier(lhsType) === \"const\" && !initialAssignment) {\n            throw new checks.ExpressionTypeError(lhs.node, \"non-const location\");\n        } else if ((lhsType instanceof CStruct || lhsType instanceof CUnion) && lhsType.hasConstMember() && !initialAssignment) {\n            throw new checks.ExpressionTypeError(lhs.node, \"structure without a const member\");\n        }\n        this.type = lhsType.pointerGeneration;\n\n        // check assignment types are valid\n        if (assignmentType) {\n            if (rhs instanceof CInitializer) {\n                throw new checks.ExpressionTypeError(node,\"simple assignments with structure initializers\");\n            }\n            let rhsType = rhs.type;\n\n            // typecheck `lhs op= rhs` as `lhs = lhs op rhs`\n            // LHS only evaluated once so can't just be transformed: see `a[i++] += 1;`\n            switch (assignmentType) {\n            case \"mul\": rhsType = new CMulDiv(node, lhs, rhs, \"*\").type; break;\n            case \"div\": rhsType = new CMulDiv(node, lhs, rhs, \"/\").type; break;\n            case \"mod\": rhsType = new CMod(node, lhs, rhs).type; break;\n            case \"add\": rhsType = new CAddSub(node, lhs, rhs, \"+\").type; break;\n            case \"sub\": rhsType = new CAddSub(node, lhs, rhs, \"-\").type; break;\n            case \"leftShift\": rhsType = new CShift(node, lhs, rhs, \"left\").type; break;\n            case \"rightShift\": rhsType = new CShift(node, lhs, rhs, \"right\").type; break;\n            case \"bitwiseAnd\": rhsType = new CBitwiseAndOr(node, lhs, rhs, \"and\").type; break;\n            case \"bitwiseOr\": rhsType = new CBitwiseAndOr(node, lhs, rhs, \"or\").type; break;\n            case \"bitwiseXor\": rhsType = new CBitwiseAndOr(node, lhs, rhs, \"xor\").type; break;\n            default: throw new checks.ExpressionTypeError(node, \"valid assignment type\");\n            }\n            CAssignment._checkAssignmentTypeValid(node, lhsType, rhsType);\n        } else {\n            CAssignment.checkAssignmentValid(node, lhsType, rhs);\n        }\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.lhs.identifiers();\n        yield* this.rhs.identifiers();\n    }\n\n    static checkAssignmentValid(node: ParseNode, varType: CType, value: CExpression | CInitializer): void {\n        // also allow constant 0 to be assigned to a pointer\n        if (varType instanceof CPointer && value instanceof CConstant) {\n            if (value.value === 0n) return;\n        }\n        this._checkAssignmentTypeValid(node, varType, value.type);\n    }\n\n    private static _checkAssignmentTypeValid(node: ParseNode, varType: CType, valueType: CType): void {\n        if (varType.equals(valueType)) return;\n        if (varType instanceof CArithmetic && valueType instanceof CArithmetic) {\n            return; // arithmetic types always assignable\n        }\n        if (varType instanceof CPointer && valueType instanceof CPointer) {\n            // void pointers can be assigned to any pointer and any pointer can be assigned to a void pointer\n            if (varType.type instanceof CVoid || valueType.type instanceof CVoid) return;\n            // allow non-constant pointers to be assigned to constant pointers\n            if (varType.type.equals(valueType.type)) return;\n        }\n        if (varType instanceof CPointer && valueType instanceof CFuncType) {\n            // implicit function pointer conversion\n            if (varType.type.equals(valueType)) return;\n        }\n        if (valueType instanceof CPointer && valueType.original) {\n            // pointer generation\n            if (varType.equals(valueType.original)) return;\n\n            if (varType instanceof CArray && valueType.original instanceof CArray && varType.type.equals(valueType.type)) {\n                // allow assigning smaller arrays to larger ones\n                if ((valueType.original.length ?? 0) < (varType.length ?? 0)) return;\n            }\n        }\n\n        throw new checks.ExpressionTypeError(node, varType.typeName, valueType.typeName);\n    }\n}\n\nexport class CComma {\n    readonly lvalue = false;\n    readonly type: CType;\n\n    constructor(readonly node: ParseNode, readonly lhs: CExpression, readonly rhs: CExpression) {\n        this.type = rhs.type;\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.lhs.identifiers();\n        yield* this.rhs.identifiers();\n    }\n}\n\n/** Special type of expression permitted only in declarations */\nexport class CInitializer {\n    private _type: CType;\n    private _memberTypes: CType[] = [];\n\n    constructor(readonly node: ParseNode, readonly body: (CExpression | CInitializer)[], type?: CType) {\n        // default to a void* array which isn't the true type but lets the array size be used when declaring arrays\n        this._type = type ?? new CArray(undefined, new CPointer(undefined, new CVoid()), body.length);\n    }\n\n    get memberTypes(): ReadonlyArray<CType> {\n        return this._memberTypes;\n    }\n\n    get type(): CType {\n        return this._type;\n    }\n\n    /** Once the initializer is recursively constructed and the declaration's type is known, set the type of the\n     * initializer to the type of the declaration, checking that this initializer is valid for the provided type */\n    set type(value: CType) {\n        this._memberTypes = [];\n\n        if (value instanceof CArray) {\n            if (this.body.length > (value.length ?? Infinity)) {\n                throw new checks.ExpressionTypeError(this.node, `at most ${value.length} elements`, `${this.body.length} elements`);\n            }\n            for (let i = 0; i < this.body.length; i++) {\n                this.body[i] = CInitializer.typeCheck(value.type, this.body[i]);\n                this._memberTypes.push(value.type);\n            }\n\n        } else if (value instanceof CStruct) {\n            if (this.body.length > value.members.length) {\n                throw new checks.ExpressionTypeError(this.node, `at most ${value.members.length} elements`, `${this.body.length} elements`);\n            }\n            for (let i = 0; i < this.body.length; i++) {\n                this.body[i] = CInitializer.typeCheck(value.members[i].type, this.body[i]);\n                this._memberTypes.push(value.members[i].type);\n            }\n\n        } else if (value instanceof CUnion) {\n            if (this.body.length > 1) {\n                throw new checks.ExpressionTypeError(this.node, `one element matching first member in union`, `${this.body.length} elements`);\n            } else if (this.body.length === 1) {\n                this.body[0] = CInitializer.typeCheck(value.members[0].type, this.body[0]);\n                this._memberTypes.push(value.members[0].type);\n            }\n\n        } else {\n            throw new checks.ExpressionTypeError(this.node, \"Invalid type for initializer\");\n        }\n        this._type = value;\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        for (const c of this.body) yield* c.identifiers();\n    }\n\n    private static typeCheck(desiredType: CType, expr: CExpression | CInitializer): CExpression | CInitializer {\n        if (expr instanceof CInitializer) {\n            expr.type = desiredType;\n        } else {\n            CAssignment.checkAssignmentValid(expr.node, desiredType, expr);\n\n            if (expr instanceof CConstant && desiredType instanceof CArithmetic && expr.type !== desiredType) {\n                expr = expr.changeType(desiredType);\n            }\n        }\n        return expr;\n    }\n}\n","import {CError} from \"../c_error\";\nimport type {ParseNode} from \"../parsing\";\nimport type {CDeclaration} from \"./declarations\";\nimport {CFuncDeclaration, CFuncDefinition, CVarDeclaration, CVarDefinition} from \"./declarations\";\nimport type {CLabelledStatement} from \"./statements\";\nimport type {CCompound, CType} from \"./types\";\n\n/**\n * Represents a scope storing identifiers (variables & functions) and tags (struct, union & enum names) in the IR.\n * Each one has a parent scope excluding the base scope for the translation unit.\n *\n * e.g. base scope (function declarations) <- function scope (contains parameters) <- compound statement scope (fn locals).\n *\n * If a tag or identifier isn't found in the current scope, parents are checked.\n */\nexport class Scope {\n    private tags = new Map<string, CCompound>(); // names of structs, unions & enums\n    private identifiers = new Map<string, CDeclaration>(); // names of variables and functions\n    private typedefs = new Map<string, CType>();\n    labelledStatement?: CLabelledStatement;\n\n    constructor(readonly node?: ParseNode,\n                readonly parent?: Scope,\n                readonly func: CFuncDefinition | undefined = parent?.func) {\n    }\n\n    private _getTag(tag: string): CCompound | undefined {\n        // perform recursive lookup in parents if not found\n        return this.tags.get(tag) ?? this.parent?._getTag(tag);\n    }\n\n    lookupTag<T extends CCompound>(tag: string, wantedType?: { new(...args: any[]): T }, node?: ParseNode): T | undefined {\n        const result = this._getTag(tag);\n        if (wantedType && result && wantedType.prototype !== Object.getPrototypeOf(result)) {\n            throw new ScopeError(\"`\" + tag + \"` was already declared as a \" + result.typeName, result.node, node);\n        }\n        return result as T | undefined;\n    }\n\n    addTag(value: CCompound): void {\n        if (!value.name) throw new Error(\"Cannot add nameless compound type to scope\"); // shouldn't happen\n        if (this._getTag(value.name)) throw new ScopeError(\"Compound type `\" + value.name + \"` is already defined!\", value.node);\n        this.tags.set(value.name, value);\n    }\n\n    private _getId(name: string): CDeclaration | undefined {\n        return this.identifiers.get(name) ?? this.parent?._getId(name);\n    }\n\n    lookupIdentifier(name: string, node?: ParseNode): CDeclaration {\n        const result = this._getId(name);\n        if (!result) {\n            throw new ScopeError(\"Failed to find `\" + name + \"`\", node);\n        }\n        return result;\n    }\n\n    addIdentifier(value: CDeclaration): void {\n        const existing = this.identifiers.get(value.name); // allowing redefining identifiers defined in parent scopes\n        if (existing) {\n            if (existing.type.equals(value.type) && existing instanceof CFuncDeclaration && value instanceof CFuncDefinition) {\n                // allow replacement of function declaration with definition\n                if (existing.linkage !== \"external\" && value.linkage === \"external\") {\n                    // linkage inherited from first declaration\n                    value.linkage = existing.linkage;\n                }\n                existing.definition = value;\n            } else if (existing.type.equals(value.type) && value instanceof CFuncDeclaration) {\n                // allow functions to be redeclared (but don't override instance in scope)\n                if (existing instanceof CFuncDeclaration) existing.fnImport ||= value.fnImport;\n                return;\n            } else if (existing.type.equals(value.type) && existing instanceof CVarDeclaration && value instanceof CVarDefinition) {\n                // allow replacement of variable declaration with definition\n                if (existing.linkage !== \"external\" && existing.linkage !== value.linkage) {\n                    // check linkage is the same\n                    throw new ScopeError(\"Variable `\" + value.name + \"` is already defined with \" + existing.linkage + \" linkage\", existing.node, value.node);\n                }\n                existing.definition = value;\n            } else if (existing.type.equals(value.type) && value instanceof CVarDeclaration) {\n                // allow variables to be redeclared (but don't override instance in scope)\n                if (existing.linkage !== \"external\" && existing.linkage !== value.linkage) {\n                    // check linkage is the same\n                    throw new ScopeError(\"Variable `\" + value.name + \"` is already defined with \" + existing.linkage + \" linkage\", existing.node, value.node);\n                }\n                return;\n            } else {\n                throw new ScopeError(\"Identifier `\" + value.name + \"` is already defined in this scope!\", existing.node, value.node);\n            }\n        }\n        this.identifiers.set(value.name, value);\n    }\n\n    get declarations(): ReadonlyArray<CDeclaration> {\n        return [...this.identifiers.values()];\n    }\n\n    private _getTypedef(id: string): CType | undefined {\n        // perform recursive lookup in parents if not found\n        return this.typedefs.get(id) ?? this.parent?._getTypedef(id);\n    }\n\n    lookupTypedef(id: string, node?: ParseNode): CType {\n        const result = this._getTypedef(id);\n        if (result === undefined) {\n            throw new ScopeError(\"typedef `\" + id + \"` not found in scope\", node);\n        }\n        return result;\n    }\n\n    addTypedef(id: string, type: CType, node?: ParseNode): void {\n        const existing = this._getTypedef(id);\n        if (existing) {\n            if (existing.equals(type)) return;\n            throw new ScopeError(\"typedef already defined with a different type\", node);\n        }\n        this.typedefs.set(id, type);\n    }\n}\n\nclass ScopeError extends CError {\n    name = \"ScopeError\";\n}\n","import type * as pt from \"../parsing/parsetree\";\nimport {CFuncDefinition} from \"./declarations\";\nimport {CExpression, CAssignment, CValue} from \"./expressions\";\nimport {Scope} from \"./scope\";\nimport {ExpressionTypeError, asArithmeticOrPointer} from \"./type_checking\";\n\n// classes to represent the various C statements in the IR\nexport type CStatement =\n    CCompoundStatement | CExpressionStatement | CNop |\n    CIf | CForLoop | CWhileLoop | CDoLoop | CSwitch |\n    CGoto | CContinue | CBreak | CReturn;\n\nexport class CCompoundStatement {\n    readonly scope: Scope;\n    readonly statements: CStatement[] = [];\n\n    constructor(readonly node: pt.ParseNode, readonly parent: CStatement | CFuncDefinition) {\n        this.scope = new Scope(node, parent.scope, parent instanceof CFuncDefinition ? parent : undefined);\n    }\n}\n\nexport class CExpressionStatement {\n    constructor(readonly node: pt.ParseNode, readonly expression: CExpression, readonly parent: CStatement) {\n    }\n\n    get scope(): Scope {\n        return this.parent.scope;\n    }\n}\n\nexport class CNop {\n    constructor(readonly node: pt.NoOp, readonly parent: CStatement) {\n    }\n\n    get scope(): Scope {\n        return this.parent.scope;\n    }\n}\n\nexport class CIf {\n    ifBody?: CStatement;\n    elseBody?: CStatement;\n\n    constructor(readonly node: pt.IfStatement, readonly test: CExpression, readonly parent: CStatement) {\n        asArithmeticOrPointer(test.node, test.type);\n    }\n\n    get scope(): Scope {\n        return this.parent.scope;\n    }\n}\n\nexport class CForLoop {\n    init?: CExpressionStatement | CExpressionStatement[] | CNop;\n    test?: CExpressionStatement | CNop;\n    update?: CExpression;\n    body?: CStatement;\n\n    readonly scope: Scope; // own scope for init variable\n\n    constructor(readonly node: pt.ForLoop, readonly parent: CStatement) {\n        this.scope = new Scope(node, parent.scope);\n    }\n}\n\nexport class CWhileLoop {\n    body?: CStatement;\n\n    constructor(readonly node: pt.WhileLoop, readonly test: CExpression, readonly parent: CStatement) {\n        asArithmeticOrPointer(test.node, test.type);\n    }\n\n    get scope(): Scope {\n        return this.parent.scope;\n    }\n}\n\nexport class CDoLoop {\n    body?: CStatement;\n\n    constructor(readonly node: pt.DoWhileLoop, readonly test: CExpression, readonly parent: CStatement) {\n        asArithmeticOrPointer(test.node, test.type);\n    }\n\n    get scope(): Scope {\n        return this.parent.scope;\n    }\n}\n\nexport class CGoto {\n    constructor(readonly node: pt.GotoStatement, readonly target: CLabelledStatement, readonly parent: CStatement) {\n    }\n\n    get scope(): Scope {\n        return this.parent.scope;\n    }\n}\n\nexport class CSwitch {\n    children: {cases: CValue[], body: CCompoundStatement, default: boolean}[] = [];\n\n    constructor(readonly node: pt.SwitchStatement, readonly expression: CExpression, readonly parent: CStatement) {\n    }\n\n    get scope(): Scope {\n        return this.parent.scope;\n    }\n}\n\nexport class CContinue {\n    constructor(readonly node: pt.ContinueStatement,\n                readonly loop: CForLoop | CWhileLoop | CDoLoop,\n                readonly parent: CStatement) {\n    }\n\n    get scope(): Scope {\n        return this.parent.scope;\n    }\n}\n\nexport class CBreak {\n    constructor(readonly node: pt.BreakStatement,\n                readonly target: CForLoop | CWhileLoop | CDoLoop | CSwitch,\n                readonly parent: CStatement) {\n    }\n\n    get scope(): Scope {\n        return this.parent.scope;\n    }\n}\n\nexport class CReturn {\n    constructor(readonly node: pt.ReturnStatement,\n                readonly func: CFuncDefinition,\n                public value: CExpression | undefined,\n                readonly parent: CStatement) {\n\n        if (value === undefined) {\n            if (func.type.returnType.bytes > 0) {\n                // function return type is not void but a value was not provided\n                throw new ExpressionTypeError(node, \"`return [expression]`\", \"`return;`\");\n            }\n        } else {\n            if (!func.type.returnType.equals(value.type)) {\n                // check provided return value matches the function's return type\n                CAssignment.checkAssignmentValid(node, func.type.returnType, value);\n            }\n        }\n    }\n\n    get scope(): Scope {\n        return this.parent.scope;\n    }\n}\n\n// not a CStatement, used to store labelled statements in Scopes\nexport class CLabelledStatement {\n    body?: CStatement;\n\n    constructor(readonly node: pt.Statement, readonly label: string) {\n    }\n}\n","import type {FunctionDefinition, ParseNode} from \"../parsing/parsetree\";\nimport type {CInitializer, CExpression} from \"./expressions\";\nimport type {Scope} from \"./scope\";\nimport {CCompoundStatement} from \"./statements\";\nimport type {CFuncType, CNotFuncType, CQualifiedType} from \"./types\";\n\n// classes to represent all the different types of declarations in the IR\nexport type CDeclaration = CVariable | CFunction;\nexport type CVariable = CVarDeclaration | CVarDefinition | CArgument;\nexport type CFunction = CFuncDefinition | CFuncDeclaration;\n\nexport class CVarDeclaration {\n    readonly declType = \"variable\";\n    _addressUsed: boolean = false;\n    _definition?: CVarDefinition;\n\n    constructor(readonly node: ParseNode,\n                readonly name: string,\n                readonly type: CQualifiedType<CNotFuncType>,\n                readonly storage: \"static\" | \"local\",\n                readonly linkage: \"none\" | \"internal\" | \"external\") {\n    }\n\n    set addressUsed(b: boolean) {\n        if (this._definition) this._definition.addressUsed ||= b;\n        else this._addressUsed ||= b;\n    }\n\n    get addressUsed(): boolean {\n        return this._definition ? this._definition.addressUsed : this._addressUsed;\n    }\n\n    set definition(v: CVarDefinition | undefined) {\n        if (v === undefined) throw new Error(\"Cannot set definition to undefined\");\n        v.addressUsed ||= this._addressUsed;\n        this._definition = v;\n    }\n\n    get definition(): CVarDefinition | undefined {\n        return this._definition;\n    }\n}\n\nexport class CVarDefinition {\n    readonly declType = \"variable\";\n    staticValue?: CExpression | CInitializer;\n    addressUsed: boolean = false;\n    readonly dependencies = new Map<CDeclaration, boolean>(); // direct dependencies of initializer only\n\n    constructor(readonly node: ParseNode,\n                readonly name: string,\n                readonly type: CQualifiedType<CNotFuncType>,\n                readonly storage: \"static\" | \"local\",\n                public linkage: \"none\" | \"internal\" | \"external\") {\n    }\n}\n\nexport class CArgument {\n    readonly declType = \"variable\";\n    readonly storage = \"argument\";\n    readonly linkage = \"none\";\n    addressUsed: boolean = false;\n\n    constructor(readonly node: ParseNode,\n                readonly name: string,\n                readonly type: CQualifiedType<CNotFuncType>,\n                readonly index: number) {\n    }\n}\n\nexport class CFuncDeclaration {\n    readonly declType = \"function\";\n    definition?: CFuncDefinition | CFuncImport;\n\n    constructor(readonly node: ParseNode,\n                readonly name: string,\n                readonly type: CQualifiedType<CFuncType>,\n                readonly linkage: \"none\" | \"internal\" | \"external\",\n                public fnImport: boolean = false) {\n    }\n}\n\nexport class CFuncImport {\n    readonly declType = \"import\";\n    readonly node: ParseNode;\n\n    constructor(readonly declaration: CFuncDeclaration) {\n        this.node = declaration.node;\n    }\n\n    getFunction(): CFuncDeclaration {\n        return this.declaration;\n    }\n}\n\nexport class CFuncDefinition {\n    readonly declType = \"function\";\n    readonly body: CCompoundStatement;\n    readonly dependencies = new Map<CDeclaration, boolean>(); // direct dependencies only\n    readonly hints: {inline: boolean} = {inline: false};\n\n    constructor(readonly node: FunctionDefinition,\n                readonly name: string,\n                readonly type: CQualifiedType<CFuncType>,\n                public linkage: \"none\" | \"internal\" | \"external\",\n                readonly translationUnit: Scope) {\n        this.body = new CCompoundStatement(node.body, this);\n    }\n\n    get scope(): Scope {\n        return this.translationUnit;\n    }\n\n    equals(t: object): boolean {\n        return t === this;\n    }\n\n    getFunction(): CFuncDefinition {\n        return this;\n    }\n}\n","import {CVarDefinition} from \"../declarations\";\nimport {CExpression, CConstant, CIdentifier, CSizeof, CBitwiseNot, CLogicalNot, CCast, CMulDiv, CMod, CAddSub, CShift, CRelational, CEquality, CBitwiseAndOr, CLogicalAndOr, CConditional, CUnaryPlusMinus, CValue, CInitializer} from \"../expressions\";\nimport {ExpressionTypeError} from \"../type_checking\";\nimport {CArithmetic, CSizeT, CPointer} from \"../types\";\n\ntype ExtraFn = (e: CExpression, evalExpr: (e: CExpression) => CValue | undefined, fail: (e: CExpression) => undefined) => CValue | undefined;\n\nconst CONSTANT = Symbol(\"constant\");\n\nexport function constExpression(e: CExpression, extra?: ExtraFn): CValue {\n    const v = evalExpression(e, extra);\n    if (v) return v;\n    throw new ExpressionTypeError(e.node, \"constant expression\");\n}\n\nexport function constInteger(e: CExpression, extra?: ExtraFn): CValue & {readonly value: bigint} {\n    const v = evalInteger(e, extra);\n    if (v) return v;\n    throw new ExpressionTypeError(e.node, \"constant integer expression\");\n}\n\nfunction fail(e: CExpression): undefined {\n    (e as object as {[CONSTANT]: boolean})[CONSTANT] = false;\n    return undefined;\n}\n\nexport function evalExpression(e: CExpression, extra?: ExtraFn): CValue | undefined {\n    if (!((e as object as { [CONSTANT]: boolean })[CONSTANT] ?? true)) {\n        return undefined; // cache on expr if failed previously to speed up flags.generation_try_constant_expr\n    } else if (e instanceof CConstant) {\n        return {value: e.value, type: e.type};\n    } else if (e instanceof CIdentifier && e.value instanceof CVarDefinition && e.value.type.qualifier === \"const\" && e.value.staticValue instanceof CConstant) {\n        return evalExpression(e.value.staticValue, extra);\n\n    } else if (e instanceof CSizeof) {\n        return normalizeType({value: e.body.bytes, type: CSizeT});\n\n    } else if (e instanceof CUnaryPlusMinus) {\n        const v = evalExpression(e.body, extra);\n        if (!v) return fail(e);\n        return e.op === \"+\" ? v : {value: -v.value, type: e.type};\n\n    } else if (e instanceof CBitwiseNot) {\n        const v = evalInteger(e.body, extra);\n        if (!v) return fail(e);\n        return normalizeType({value: ~v.value, type: v.type});\n\n    } else if (e instanceof CLogicalNot) {\n        const v = evalExpression(e.body, extra);\n        if (!v) return fail(e);\n        // eslint-disable-next-line eqeqeq\n        return {value: v.value == 0 ? 1n : 0n, type: CArithmetic.S32};\n\n    } else if (e instanceof CCast && (e.type instanceof CArithmetic || e.type instanceof CPointer)) {\n        const v = evalExpression(e.body, extra);\n        if (!v) return fail(e);\n        return normalizeType({value: v.value, type: e.type});\n\n    } else if (e instanceof CMulDiv) {\n        const lhs = evalExpression(e.lhs, extra), rhs = evalExpression(e.rhs, extra);\n        if (!lhs || !rhs) return fail(e);\n        if (e.op === \"*\") {\n            if (e.type.type === \"float\") {\n                return {value: Number(lhs.value) * Number(rhs.value), type: e.type};\n            }\n            return normalizeType({value: BigInt(lhs.value) * BigInt(rhs.value), type: e.type});\n\n            // eslint-disable-next-line eqeqeq\n        } else if (rhs.value != 0) {\n            if (e.type.type === \"float\") {\n                return {value: Number(lhs.value) / Number(rhs.value), type: e.type};\n            }\n            return normalizeType({value: BigInt(lhs.value) / BigInt(rhs.value), type: e.type});\n        }\n\n    } else if (e instanceof CMod) {\n        const lhs = evalInteger(e.lhs, extra), rhs = evalInteger(e.rhs, extra);\n        if (!lhs || !rhs || rhs.value === 0n) return fail(e);\n        return normalizeType({value: lhs.value % rhs.value, type: e.type});\n\n    } else if (e instanceof CAddSub && e.type instanceof CArithmetic) {\n        const lhs = evalExpression(e.lhs, extra), rhs = evalExpression(e.rhs, extra);\n        if (!lhs || !rhs) return fail(e);\n        if (e.op === \"+\") {\n            if (e.type.type === \"float\") {\n                return {value: Number(lhs.value) + Number(rhs.value), type: e.type};\n            }\n            return normalizeType({value: BigInt(lhs.value) + BigInt(rhs.value), type: e.type});\n        } else {\n            if (e.type.type === \"float\") {\n                return {value: Number(lhs.value) - Number(rhs.value), type: e.type};\n            }\n            return normalizeType({value: BigInt(lhs.value) - BigInt(rhs.value), type: e.type});\n        }\n\n    } else if (e instanceof CShift) {\n        const lhs = evalInteger(e.lhs, extra), rhs = evalInteger(e.rhs, extra);\n        if (!lhs || !rhs) return fail(e);\n        if (e.dir === \"left\") {\n            return normalizeType({value: lhs.value << rhs.value, type: e.type});\n        }\n        return normalizeType({value: lhs.value >> rhs.value, type: e.type});\n\n    } else if (e instanceof CRelational) {\n        const lhs = evalExpression(e.lhs, extra), rhs = evalExpression(e.rhs, extra);\n        if (!lhs || !rhs) return fail(e);\n        if (e.op === \"LT\") {\n            return {value: lhs.value < rhs.value ? 1n : 0n, type: CArithmetic.S32};\n        } else if (e.op === \"GT\") {\n            return {value: lhs.value > rhs.value ? 1n : 0n, type: CArithmetic.S32};\n        } else if (e.op === \"LEq\") {\n            return {value: lhs.value <= rhs.value ? 1n : 0n, type: CArithmetic.S32};\n        } else {\n            return {value: lhs.value >= rhs.value ? 1n : 0n, type: CArithmetic.S32};\n        }\n\n    } else if (e instanceof CEquality) {\n        const lhs = evalExpression(e.lhs, extra), rhs = evalExpression(e.rhs, extra);\n        if (!lhs || !rhs) return fail(e);\n        if (e.op === \"==\") {\n            // eslint-disable-next-line eqeqeq\n            return {value: lhs.value == rhs.value ? 1n : 0n, type: CArithmetic.S32};\n        } else {\n            // eslint-disable-next-line eqeqeq\n            return {value: lhs.value != rhs.value ? 1n : 0n, type: CArithmetic.S32};\n        }\n\n    } else if (e instanceof CBitwiseAndOr) {\n        const lhs = evalInteger(e.lhs, extra), rhs = evalInteger(e.rhs, extra);\n        if (!lhs || !rhs) return fail(e);\n        if (e.op === \"and\") {\n            return normalizeType({value: lhs.value & rhs.value, type: e.type});\n        } else if (e.op === \"or\") {\n            return normalizeType({value: lhs.value | rhs.value, type: e.type});\n        } else {\n            return normalizeType({value: lhs.value ^ rhs.value, type: e.type});\n        }\n\n    } else if (e instanceof CLogicalAndOr) {\n        const lhs = evalExpression(e.lhs, extra);\n        if (!lhs) return fail(e);\n        if (e.op === \"and\") {\n            // eslint-disable-next-line eqeqeq\n            if (lhs.value != 0) {\n                const rhs = evalExpression(e.rhs, extra);\n                if (!rhs) return fail(e);\n                // eslint-disable-next-line eqeqeq\n                if (rhs.value != 0) return {value: 1n, type: CArithmetic.S32};\n            }\n            return {value: 0n, type: CArithmetic.S32};\n        } else {\n            // eslint-disable-next-line eqeqeq\n            if (lhs.value != 0) return {value: 1n, type: CArithmetic.S32};\n            const rhs = evalExpression(e.rhs, extra);\n            if (!rhs) return fail(e);\n            // eslint-disable-next-line eqeqeq\n            if (rhs.value != 0) return {value: 1n, type: CArithmetic.S32};\n            return {value: 0n, type: CArithmetic.S32};\n        }\n\n    } else if (e instanceof CConditional && (e.type instanceof CArithmetic || e.type instanceof CPointer)) {\n        const test = evalExpression(e.test, extra);\n        if (!test) return fail(e);\n        let value: CValue | undefined;\n        // eslint-disable-next-line eqeqeq\n        if (test.value != 0) {\n            value = evalExpression(e.trueValue, extra);\n        } else {\n            value = evalExpression(e.falseValue, extra);\n        }\n        if (!value) return fail(e);\n        return normalizeType({value: value.value, type: e.type});\n\n    }\n\n    // for adding addressof support etc for static initializers\n    if (extra !== undefined) {\n        const v = extra(e, (e2) => evalExpression(e2, extra), fail);\n        if (v) return v;\n    }\n\n    fail(e);\n}\n\nexport function evalInteger(e: CExpression, extra?: ExtraFn): undefined | CValue & {readonly value: bigint} {\n    const v = evalExpression(e, extra);\n    if (v?.type instanceof CArithmetic && v.type.type !== \"float\") return {value: BigInt(v.value), type: v.type};\n    return undefined;\n}\n\nfunction normalizeType(v: CValue): CValue {\n    if (v.type instanceof CArithmetic) {\n        if (CArithmetic.BOOL.equals(v.type)) {\n            // eslint-disable-next-line eqeqeq\n            return {value: v.value == 0 ? 0n : 1n, type: CArithmetic.BOOL};\n        } else if (v.type.type === \"float\") {\n            return {value: typeof v.value === \"number\" ? v.value : Number(v.value), type: v.type};\n        } else {\n            let value: bigint;\n            if (typeof v.value === \"number\") {\n                // need to emulate runtime behaviour - i.e. the use of the trunc_sat instructions\n                if (isNaN(v.value)) {\n                    value = 0n;\n                } else if (v.value > v.type.maxValue) {\n                    value = BigInt(v.type.maxValue);\n                } else if (v.value < v.type.minValue) {\n                    value = BigInt(v.type.minValue);\n                } else {\n                    value = BigInt(Math.trunc(v.value));\n                }\n            } else {\n                value = v.value;\n            }\n\n            const bitmask = 2n ** BigInt(8 * v.type.bytes) - 1n;\n            if (v.type.type === \"unsigned\") {\n                value &= bitmask;\n            } else { // signed\n                const minValue = BigInt(v.type.minValue);\n                value = ((value - minValue) & bitmask) + minValue;\n            }\n\n            return {value, type: v.type};\n        }\n    } else { // instanceof CPointer\n        // normalize as if U32\n        const value = normalizeType({value: v.value, type: CArithmetic.U32}).value;\n        return {value: value, type: v.type};\n    }\n}\n\nexport const normalizeValueType = normalizeType;\n","import {CError} from \"../c_error\";\nimport type {ParseNode} from \"../parsing\";\nimport type {WFnGenerator} from \"./generator\";\n\nexport class GenError extends CError {\n    name = \"GenerationError\";\n\n    constructor(message: string, ctx?: WFnGenerator, node?: ParseNode) {\n        super(ctx !== undefined ? `In function '${ctx.fnName}': ${message}` : message, node);\n    }\n}\n","import {ParseNode} from \"../parsing\";\nimport {CConstant, CInitializer, CStringLiteral, CExpression, CValue, CCast, CAddressOf, CIdentifier, CAddSub, CDereference} from \"../ir/expressions\";\nimport {constExpression, normalizeValueType} from \"../ir/transform/constant_expressions\";\nimport {CArithmetic, CArray, CUnion, CStruct, CSizeT, CPointer, CType} from \"../ir/types\";\nimport {byte} from \"../wasm/base_types\";\nimport {GenError} from \"./gen_error\";\nimport {WGenerator} from \"./generator\";\nimport {getStaticAddress} from \"./storage\";\n\nexport function staticInitializer(ctx: WGenerator, init: CExpression | CInitializer, targetType?: CType): byte[] {\n    if (init instanceof CInitializer) {\n        if (targetType && !init.type.equals(targetType)) throw new GenError(\"Static initializer type mismatch\", undefined, init.node);\n        return initializer(ctx, init);\n    } else if (init instanceof CStringLiteral && targetType instanceof CPointer) {\n        // string literal being used as pointer\n        return stringLiteralPtr(ctx, init);\n    } else if (init instanceof CStringLiteral) {\n        // string literal being used as array\n        return stringLiteral(init);\n    } else {\n        if (targetType && !init.type.equals(targetType)) init = new CCast(init.node, targetType, init);\n        const value = constExpression(init, (e: CExpression, evalExpr, fail) => {\n            if (e instanceof CAddressOf && e.body instanceof CIdentifier) {\n                let addr: number | bigint | undefined;\n                if (e.body.value.declType === \"variable\") {\n                    addr = getStaticAddress(e.body.value);\n                } else {\n                    addr = ctx.indirectIndex(e.body.value);\n                }\n                if (addr !== undefined) return normalizeValueType({value: addr, type: e.type});\n\n            } else if (e instanceof CAddressOf && e.body instanceof CDereference) { // &x[3] turns into &*(x + 3)\n                const v = evalExpr(e.body.body);\n                if (!v) return fail(e);\n                return normalizeValueType({value: v.value, type: e.type});\n\n            } else if (e instanceof CIdentifier && e.value.declType === \"function\") { // implicit function to pointer conversion\n                const addr = ctx.indirectIndex(e.value);\n                return normalizeValueType({value: addr, type: new CPointer(e.node, e.type)});\n\n            } else if (e instanceof CIdentifier) { // implicit array to pointer conversion\n                const addr = getStaticAddress(e.value);\n                if (addr !== undefined) return normalizeValueType({value: addr, type: new CPointer(e.node, e.type)});\n\n            } else if (e instanceof CStringLiteral) {\n                // allocate a new string literal and return pointer\n                const addr = ctx.nextStaticAddr; // chars 1 byte aligned\n                const stringBytes = stringLiteral(e);\n                ctx.nextStaticAddr += stringBytes.length;\n                ctx.module.dataSegment(addr, stringBytes);\n                return normalizeValueType({value: addr, type: e.type});\n\n            } else if (e instanceof CAddSub && e.type instanceof CPointer) { // pointer arithmetic\n                const lhs = evalExpr(e.lhs), rhs = evalExpr(e.rhs);\n                if (!lhs || !rhs) return fail(e);\n                const lhsValue = lhs.type instanceof CPointer ? BigInt(lhs.value) : BigInt(e.type.type.bytes) * BigInt(lhs.value);\n                const rhsValue = rhs.type instanceof CPointer ? BigInt(rhs.value) : BigInt(e.type.type.bytes) * BigInt(rhs.value);\n                return normalizeValueType({value: lhsValue + rhsValue, type: e.type});\n            }\n        });\n        return constant(value, init.node);\n    }\n}\n\nfunction encode(bytes: number, method: (d: DataView) => void): byte[] {\n    const buffer = new ArrayBuffer(bytes);\n    method(new DataView(buffer));\n    return [...new Uint8Array(buffer)] as byte[];\n}\n\nfunction constant(c: CValue, node?: ParseNode): byte[] {\n    if (CArithmetic.S64.equals(c.type)) {\n        return encode(8, d => d.setBigInt64(0, BigInt(c.value), true));\n    } else if (CArithmetic.U64.equals(c.type)) {\n        return encode(8, d => d.setBigUint64(0, BigInt(c.value), true));\n    } else if (CArithmetic.S32.equals(c.type)) {\n        return encode(4, d => d.setInt32(0, Number(c.value), true));\n    } else if (CArithmetic.U32.equals(c.type) || c.type instanceof CPointer) {\n        return encode(4, d => d.setUint32(0, Number(c.value), true));\n    } else if (CArithmetic.S16.equals(c.type)) {\n        return encode(2, d => d.setInt16(0, Number(c.value), true));\n    } else if (CArithmetic.U16.equals(c.type)) {\n        return encode(2, d => d.setUint16(0, Number(c.value), true));\n    } else if (CArithmetic.S8.equals(c.type)) {\n        return encode(1, d => d.setInt8(0, Number(c.value)));\n    } else if (CArithmetic.U8.equals(c.type)) {\n        return encode(1, d => d.setUint8(0, Number(c.value)));\n    } else if (CArithmetic.Fp64.equals(c.type)) {\n        return encode(8, d => d.setFloat64(0, Number(c.value), true));\n    } else if (CArithmetic.Fp32.equals(c.type)) {\n        return encode(4, d => d.setFloat32(0, Number(c.value), true));\n    } else if (CArithmetic.BOOL.equals(c.type)) {\n        // eslint-disable-next-line eqeqeq\n        return encode(4, d => d.setInt32(0, c.value == 0 ? 0 : 1, true));\n    }\n    throw new GenError(\"Unknown value type?\", undefined, node);\n}\n\nfunction stringLiteralPtr(ctx: WGenerator, init: CStringLiteral): byte[] {\n    const addr = ctx.nextStaticAddr; // char is any byte aligned\n    const stringBytes = stringLiteral(init);\n    ctx.nextStaticAddr += stringBytes.length;\n    ctx.module.dataSegment(addr, stringBytes);\n\n    return constant(new CConstant(init.node, CSizeT, BigInt(addr)));\n}\n\nfunction stringLiteral(s: CStringLiteral): byte[] {\n    return s.value.map(Number) as byte[];\n}\n\nfunction initializer(ctx: WGenerator, init: CInitializer): byte[] {\n    let bytes: byte[];\n\n    if (init.type instanceof CArray) {\n        if (init.type.length === undefined) throw new GenError(\"Array length still unknown?\", undefined, init.node);\n        bytes = init.body.flatMap((x, i) => {\n            const element = staticInitializer(ctx, x, init.memberTypes[i]);\n            return pad(element, init.memberTypes[i].bytes);\n        });\n\n    } else if (init.type instanceof CUnion) {\n        bytes = staticInitializer(ctx, init.body[0], init.memberTypes[0]);\n\n    } else if (init.type instanceof CStruct) {\n        bytes = [];\n        for (let i = 0; i < init.body.length; i++) {\n            alignPad(bytes, init.memberTypes[i].alignment);\n            const member = staticInitializer(ctx, init.body[i], init.memberTypes[i]);\n            pad(member, init.memberTypes[i].bytes);\n            bytes.push(...member);\n        }\n\n    } else {\n        throw new GenError(\"Invalid initializer\", undefined, init.node);\n    }\n    return bytes;\n}\n\nfunction pad(bytes: byte[], n: number) {\n    while (bytes.length < n) bytes.push(0 as byte);\n    return bytes;\n}\n\nfunction alignPad(bytes: byte[], n: number) {\n    while (bytes.length % n !== 0) bytes.push(0 as byte);\n    return bytes;\n}\n","import {CType, CArithmetic, CPointer, CArray, CVoid, CFuncType, CStruct, CUnion} from \"../ir/types\";\nimport {Instructions, ValueType, f32Type, f64Type, i64Type, i32Type} from \"../wasm\";\nimport {WInstruction} from \"../wasm/instructions\";\nimport {ResultType} from \"../wasm/wtypes\";\n\n// CType - CArithmetic + wasm.ValueType\nexport type ImplementationType = CPointer | CArray | CStruct | CUnion | CVoid | CFuncType | ValueType;\n\n/**\n * Types used when computing the type of WebAssembly expressions.\n * CArithmetic is mapped to corresponding WebAssembly ValueTypes.\n * Otherwise the same C types are used.\n */\nexport function implType(type: CType): ImplementationType {\n    if (type instanceof CArithmetic) return valueType(type);\n    return type;\n}\n\n/**\n * WebAssembly Types used for passing values as a parameter into a function, or storing on the stack.\n */\nexport function realType(type: CType): ValueType {\n    if (type instanceof CArithmetic) return valueType(type);\n    if (type instanceof CPointer) return i32Type;\n    if (type instanceof CStruct || type instanceof CUnion) {\n        // passed around as pointer\n        return i32Type;\n    }\n    if (type instanceof CVoid) throw new Error(\"Void cannot be stored\");\n    throw new Error(type.typeName + \" doesn't have a real type\");\n}\n\nexport function conversion(inType: CType, outType: CType): WInstruction[] {\n    if (inType.equals(outType)) return [];\n\n    if (inType instanceof CArithmetic && outType instanceof CArithmetic) {\n        return arithmeticConversion(inType, outType);\n    } else if (inType instanceof CArithmetic && inType.type !== \"float\" && outType instanceof CPointer) {\n        // convert int to pointer\n        if (inType.bytes > 4) return [Instructions.i32.wrap_i64()]; // check for converting 8 byte int\n        return [];\n    } else if (outType instanceof CArithmetic && outType.type !== \"float\" && inType instanceof CPointer) {\n        // convert pointer to int\n        return [];\n    } else if (outType instanceof CPointer && inType instanceof CPointer) {\n        // pointer.type change\n        return [];\n    } else if (inType instanceof CFuncType && outType instanceof CPointer && inType.equals(outType.type)) {\n        // fn to pointer (function should already a pointer)\n        return [];\n    }\n\n    throw new Error(`Cannot convert ${inType.typeName} to ${outType.typeName}`);\n}\n\n/**\n * Follows the standard. For float -> int conversion it uses saturating truncation instructions to avoid runtime traps.\n *\n * > 3.2.1.3 Floating and integral\n * >\n * > When a value of floating type is converted to integral type, the fractional part is discarded.\n * > If the value of the integral part cannot be represented by the integral type, the behavior is undefined.\n */\nfunction arithmeticConversion(inType: CArithmetic, outType: CArithmetic): WInstruction[] {\n    if (CArithmetic.BOOL.equals(outType)) {\n        if (CArithmetic.Fp64.equals(inType)) return [Instructions.f64.const(0), Instructions.f64.ne()];\n        if (CArithmetic.Fp32.equals(inType)) return [Instructions.f32.const(0), Instructions.f32.ne()];\n        if (inType.bytes === 8) return [Instructions.i64.const(0n), Instructions.i64.ne()];\n        return [Instructions.i32.const(0), Instructions.i32.ne()];\n\n    } else if (CArithmetic.Fp64.equals(outType)) {\n        if (CArithmetic.Fp32.equals(inType)) return [Instructions.f64.promote_f32()];\n        if (inType.type === \"signed\" && inType.bytes === 8) return [Instructions.f64.convert_i64_s()];\n        if (inType.type === \"unsigned\" && inType.bytes === 8) return [Instructions.f64.convert_i64_u()];\n        if (inType.type === \"signed\" && inType.bytes <= 4) return [Instructions.f64.convert_i32_s()];\n        if (inType.type === \"unsigned\" && inType.bytes <= 4) return [Instructions.f64.convert_i32_u()];\n\n    } else if (CArithmetic.Fp32.equals(outType)) {\n        if (CArithmetic.Fp64.equals(inType)) return [Instructions.f32.demote_f64()];\n        if (inType.type === \"signed\" && inType.bytes === 8) return [Instructions.f32.convert_i64_s()];\n        if (inType.type === \"unsigned\" && inType.bytes === 8) return [Instructions.f32.convert_i64_u()];\n        if (inType.type === \"signed\" && inType.bytes <= 4) return [Instructions.f32.convert_i32_s()];\n        if (inType.type === \"unsigned\" && inType.bytes <= 4) return [Instructions.f32.convert_i32_u()];\n\n    } else if (CArithmetic.U64.equals(outType)) {\n        if (CArithmetic.Fp64.equals(inType)) return [Instructions.i64.trunc_sat_f64_u()];\n        if (CArithmetic.Fp32.equals(inType)) return [Instructions.i64.trunc_sat_f32_u()];\n        if (CArithmetic.S64.equals(inType)) return [];\n        if (inType.type === \"signed\") return [Instructions.i64.extend_i32_u()];\n        if (inType.type === \"unsigned\") return [Instructions.i64.extend_i32_u()];\n\n    } else if (CArithmetic.S64.equals(outType)) {\n        if (CArithmetic.Fp64.equals(inType)) return [Instructions.i64.trunc_f64_s()];\n        if (CArithmetic.Fp32.equals(inType)) return [Instructions.i64.trunc_f32_s()];\n        if (CArithmetic.U64.equals(inType)) return [];\n        if (inType.type === \"signed\") return [Instructions.i64.extend_i32_s()];\n        if (inType.type === \"unsigned\") return [Instructions.i64.extend_i32_u()];\n\n    } else if (CArithmetic.U32.equals(outType)) {\n        if (CArithmetic.Fp64.equals(inType)) return [Instructions.i32.trunc_sat_f64_u()];\n        if (CArithmetic.Fp32.equals(inType)) return [Instructions.i32.trunc_sat_f32_u()];\n        if (inType.bytes === 8) return [Instructions.i32.wrap_i64()];\n        return [];\n\n    } else if (CArithmetic.S32.equals(outType)) {\n        if (CArithmetic.Fp64.equals(inType)) return [Instructions.i32.trunc_sat_f64_s()];\n        if (CArithmetic.Fp32.equals(inType)) return [Instructions.i32.trunc_sat_f32_s()];\n        if (inType.bytes === 8) return [Instructions.i32.wrap_i64()];\n        return [];\n\n    } else if (outType.type === \"signed\" && outType.bytes < 4) {\n        if (inType.type !== \"float\" && inType.bytes < outType.bytes) return []; // e.g. (un)signed char -> signed short\n        if (CArithmetic.BOOL.equals(inType)) return [];\n\n        const conversion = [\n            Instructions.i32.const(32 - (8 * outType.bytes)),\n            Instructions.i32.shl(),\n            Instructions.i32.const(32 - (8 * outType.bytes)),\n            Instructions.i32.shr_s(),\n        ];\n\n        if (CArithmetic.Fp64.equals(inType)) conversion.unshift(Instructions.i32.trunc_f64_s());\n        if (CArithmetic.Fp32.equals(inType)) conversion.unshift(Instructions.i32.trunc_f32_s());\n        if (inType.type !== \"float\" && inType.bytes === 8) conversion.unshift(Instructions.i32.wrap_i64());\n        return conversion;\n\n    } else if (outType.type === \"unsigned\" && outType.bytes < 4) {\n        if (CArithmetic.BOOL.equals(inType)) return [];\n\n        const conversion = [\n            Instructions.i32.const((2 ** (8 * outType.bytes)) - 1),\n            Instructions.i32.and()\n        ];\n\n        if (CArithmetic.Fp64.equals(inType)) conversion.unshift(Instructions.i32.trunc_sat_f64_u());\n        if (CArithmetic.Fp32.equals(inType)) conversion.unshift(Instructions.i32.trunc_sat_f32_u());\n        if (inType.type !== \"float\" && inType.bytes === 8) conversion.unshift(Instructions.i32.wrap_i64());\n        return conversion;\n    }\n\n    throw new Error(\"Invalid arithmetic type\");\n}\n\nexport function valueType(type: CArithmetic): ValueType {\n    if (type.type === \"float\") {\n        return type.bytes === 4 ? f32Type : f64Type;\n    } else if (type.bytes === 8) {\n        return i64Type;\n    } else if (type.bytes <= 4) {\n        return i32Type;\n    }\n\n    throw new Error(\"Unknown type\");\n}\n\nexport function returnType(type: CType): ResultType {\n    if (type instanceof CVoid || largeReturn(type)) return [];\n    return [realType(type)];\n}\n\nexport function largeReturn(type: CType): boolean {\n    // functions that return structs/unions as they cannot be returned as a single Wasm value\n    return type instanceof CStruct || type instanceof CUnion;\n}\n","import {CArgument, CDeclaration, CVarDefinition, CVarDeclaration} from \"../ir/declarations\";\nimport {CExpression} from \"../ir/expressions\";\nimport * as e from \"../ir/expressions\";\nimport {Scope} from \"../ir/scope\";\nimport {CType, CArithmetic, CPointer, CStruct, CUnion, CArray, CVoid, CFuncType} from \"../ir/types\";\nimport {Instructions, i32Type} from \"../wasm\";\nimport {localidx} from \"../wasm/base_types\";\nimport {WLocal} from \"../wasm/functions\";\nimport {WInstruction} from \"../wasm/instructions\";\nimport {GenError} from \"./gen_error\";\nimport {WFnGenerator, WGenerator} from \"./generator\";\nimport {staticInitializer} from \"./static_initializer\";\nimport {realType, conversion} from \"./type_conversion\";\n\nexport type StorageLocation =\n    {type: \"local\", \"index\": {getIndex(d: number): localidx}} |\n    {type: \"static\", \"address\": number} |\n    {type: \"shadow\", \"shadowOffset\": number} | // offset from shadow pointer\n    {type: \"pointer\"}; // address on stack\n\n/** Setup the static storage location for a variable and if it has a static initializer return a function to set the\n * value AFTER all the functions have been created. This allows static initializer values to refer to each other\n * and to functions. Whilst creating functions only the location of the static variable is needed, not it's value. */\nexport function storageSetupStaticVar(ctx: WGenerator, d: CVarDefinition): (() => void) | undefined {\n    const addr = Math.ceil(ctx.nextStaticAddr / d.type.alignment) * d.type.alignment;\n    ctx.nextStaticAddr = addr + d.type.bytes;\n\n    setStorageLocation(d, {\n        type: \"static\",\n        address: addr\n    });\n\n    if (d.staticValue) {\n        const value = d.staticValue;\n        return () => ctx.module.dataSegment(addr, staticInitializer(ctx, value, d.type));\n    }\n}\n\nexport function storageSetupScope(ctx: WFnGenerator, s: Scope): [setup: WInstruction[], finishedCallback: () => void] {\n    const instr: WInstruction[] = [];\n    const temporaries: WLocal[] = [];\n\n    for (const declaration of s.declarations) {\n        if (declaration instanceof CArgument) {\n            if (declaration.type instanceof CStruct || declaration.type instanceof CUnion) {\n                // argument is effectively a pointer to a struct/union to copy\n\n                // align\n                ctx.shadowStackUsage = Math.ceil(ctx.shadowStackUsage / declaration.type.alignment) * declaration.type.alignment;\n\n                setStorageLocation(declaration, {\n                    type: \"shadow\",\n                    shadowOffset: ctx.shadowStackUsage\n                });\n                // copy from given pointer\n                instr.push(...memcpy(\n                    [Instructions.local.get(ctx.builder.args[declaration.index])],\n                    [Instructions.global.get(ctx.gen.shadowStackPtr), Instructions.i32.const(ctx.shadowStackUsage), Instructions.i32.add()],\n                    declaration.type.bytes\n                ));\n                ctx.shadowStackUsage += declaration.type.bytes;\n\n            } else if (declaration.addressUsed) {\n                ctx.shadowStackUsage = Math.ceil(ctx.shadowStackUsage / declaration.type.alignment) * declaration.type.alignment;\n                setStorageLocation(declaration, {\n                    type: \"shadow\",\n                    shadowOffset: ctx.shadowStackUsage\n                });\n                // copy value onto shadow stack\n                instr.push(Instructions.global.get(ctx.gen.shadowStackPtr));\n                instr.push(Instructions.local.get(ctx.builder.args[declaration.index]));\n                instr.push(store(declaration.type, ctx.shadowStackUsage));\n\n                ctx.shadowStackUsage += declaration.type.bytes; // 4 byte align\n            } else {\n                setStorageLocation(declaration, {\n                    type: \"local\",\n                    index: ctx.builder.args[declaration.index]\n                });\n            }\n        }\n\n        if (declaration instanceof CVarDefinition) {\n            if (declaration.storage === \"local\") {\n                if (declaration.addressUsed || !(declaration.type instanceof CArithmetic || declaration.type instanceof CPointer)) {\n                    // have to place on shadow stack\n                    ctx.shadowStackUsage = Math.ceil(ctx.shadowStackUsage / declaration.type.alignment) * declaration.type.alignment;\n                    setStorageLocation(declaration, {\n                        type: \"shadow\",\n                        shadowOffset: ctx.shadowStackUsage\n                    });\n                    ctx.shadowStackUsage += declaration.type.bytes;\n                } else {\n                    const local = ctx.builder.getTempLocal(realType(declaration.type));\n                    temporaries.push(local);\n                    setStorageLocation(declaration, {\n                        type: \"local\",\n                        index: local\n                    });\n                }\n            } else if (declaration.storage === \"static\" && getStorageLocation(declaration) === undefined) { // storage should have already been setup\n                throw new GenError(\"In function static variable is not setup\");\n            }\n        }\n    }\n\n    return [instr, () => temporaries.forEach(x => ctx.builder.freeTempLocal(x))];\n}\n\n// the storage operations\n\n/** Pushes the stored value from location 'e' onto the stack  */\nexport function storageGet(ctx: WFnGenerator, ctype: CType, locationExpr: CExpression): WInstruction[] {\n    const [instr, location] = fromExpression(ctx, locationExpr);\n\n    if (ctype instanceof CStruct || ctype instanceof CUnion || (ctype instanceof CPointer && ctype.original instanceof CArray)) {\n        // loading a structure just returns a pointer\n        return getAddress(ctx, locationExpr);\n    }\n\n    if (location.type === \"local\") {\n        instr.push(Instructions.local.get(location.index));\n    } else if (location.type === \"static\") {\n        instr.push(Instructions.i32.const(0), load(ctype, location.address));\n    } else if (location.type === \"shadow\") {\n        instr.push(Instructions.global.get(ctx.gen.shadowStackPtr), load(ctype, location.shadowOffset));\n    } else if (location.type === \"pointer\") {\n        instr.push(load(ctype, 0));\n    }\n    return instr;\n}\n\n/** Stores the value on the top of the stack when 'valueExpr' is run into location 'locationExpr'.\n * If keepValue is true then the stored value is kept on the top of the stack after being stored */\nexport function storageSet(ctx: WFnGenerator, ctype: CType, locationExpr: CExpression, valueExpr: CExpression, keepValue: boolean): WInstruction[] {\n    const [instr, location] = fromExpression(ctx, locationExpr);\n    const valueInstr = ctx.expression(valueExpr, false);\n    valueInstr.push(...conversion(valueExpr.type, locationExpr.type));\n\n    if (ctype instanceof CStruct || ctype instanceof CUnion || ctype instanceof CArray) {\n        // storing a structure copies memory, presumes pointer to the same type is on top of stack\n        return memcpy(valueInstr, getAddress(ctx, locationExpr), ctype.bytes);\n    }\n\n    if (location.type === \"local\") {\n        instr.push(...valueInstr, keepValue ? Instructions.local.tee(location.index) : Instructions.local.set(location.index));\n    } else if (location.type === \"static\") {\n        instr.push(Instructions.i32.const(0), ...valueInstr);\n        if (keepValue) {\n            instr.push(...ctx.withTemporaryLocal(realType(ctype), (tmp) => [\n                Instructions.local.tee(tmp), // store copy of value\n                store(ctype, location.address),\n                Instructions.local.get(tmp)\n            ]));\n        } else {\n            instr.push(store(ctype, location.address));\n        }\n    } else if (location.type === \"shadow\") {\n        instr.push(Instructions.global.get(ctx.gen.shadowStackPtr), ...valueInstr);\n        if (keepValue) {\n            instr.push(...ctx.withTemporaryLocal(realType(ctype), (tmp) => [\n                Instructions.local.tee(tmp), // store copy of value\n                store(ctype, location.shadowOffset),\n                Instructions.local.get(tmp)\n            ]));\n        } else {\n            instr.push(store(ctype, location.shadowOffset));\n        }\n    } else if (location.type === \"pointer\") {\n        // address should already be on top of the stack\n        instr.push(...valueInstr);\n        if (keepValue) {\n            instr.push(...ctx.withTemporaryLocal(realType(ctype), (tmp) => [\n                Instructions.local.tee(tmp), // store copy of value\n                store(ctype, 0),\n                Instructions.local.get(tmp)\n            ]));\n        } else {\n            instr.push(store(ctype, 0));\n        }\n    }\n    return instr;\n}\n\n/** Updates the location 'locationExpr' by running 'instr' which should transform its value on the stack.\n * If keepValue is true then the stored value is kept on the top of the stack after being stored */\nexport function storageUpdate(ctx: WFnGenerator, ctype: CType, locationExpr: CExpression, transform: WInstruction[], keepValue: boolean): WInstruction[] {\n    if (ctype instanceof CArray || ctype instanceof CStruct || ctype instanceof CUnion) {\n        throw new GenError(\"Cannot storageUpdate \" + ctype.typeName, ctx, locationExpr.node);\n    }\n    const [instr, location] = fromExpression(ctx, locationExpr);\n\n    if (location.type === \"local\") {\n        instr.push(Instructions.local.get(location.index), ...transform);\n        if (keepValue) instr.push(Instructions.local.tee(location.index));\n        else instr.push(Instructions.local.set(location.index));\n\n        return instr;\n    } else if (location.type === \"static\") {\n        instr.push(Instructions.i32.const(0), Instructions.i32.const(0), load(ctype, location.address), ...transform);\n\n        if (keepValue) {\n            instr.push(...ctx.withTemporaryLocal(realType(ctype), (tmp) => [\n                Instructions.local.tee(tmp), // store copy of value\n                store(ctype, location.address),\n                Instructions.local.get(tmp)\n            ]));\n        } else {\n            instr.push(store(ctype, location.address));\n        }\n    } else if (location.type === \"shadow\") {\n        instr.push(Instructions.global.get(ctx.gen.shadowStackPtr), Instructions.global.get(ctx.gen.shadowStackPtr));\n        instr.push(load(ctype, location.shadowOffset), ...transform);\n\n        if (keepValue) {\n            instr.push(...ctx.withTemporaryLocal(realType(ctype), (tmp) => [\n                Instructions.local.tee(tmp), // store copy of value\n                store(ctype, location.shadowOffset),\n                Instructions.local.get(tmp)\n            ]));\n        } else {\n            instr.push(store(ctype, location.shadowOffset));\n        }\n    } else if (location.type === \"pointer\") {\n        instr.push(...ctx.withTemporaryLocal(i32Type, (addrTmp) => [\n            Instructions.local.tee(addrTmp), // duplicate pointer on top of stack\n            Instructions.local.get(addrTmp)\n        ]));\n        instr.push(load(ctype, 0), ...transform);\n\n        if (keepValue) {\n            instr.push(...ctx.withTemporaryLocal(realType(ctype), (tmp) => [\n                Instructions.local.tee(tmp), // store copy of value\n                store(ctype, 0),\n                Instructions.local.get(tmp)\n            ]));\n        } else {\n            instr.push(store(ctype, 0));\n        }\n    }\n    return instr;\n}\n\n/** Updates the location 'locationExpr' by running 'instr' which should transform its value on the stack.\n * Value before transform is left on the stack */\nexport function storageGetThenUpdate(ctx: WFnGenerator, ctype: CType, locationExpr: CExpression, transform: WInstruction[]): WInstruction[] {\n    if (ctype instanceof CArray || ctype instanceof CStruct || ctype instanceof CUnion) {\n        throw new GenError(\"Cannot storageGetThenUpdate \" + ctype.typeName, ctx, locationExpr.node);\n    }\n    const [instr, location] = fromExpression(ctx, locationExpr);\n\n    if (location.type === \"local\") {\n        instr.push(Instructions.local.get(location.index));\n        instr.push(Instructions.local.get(location.index), ...transform, Instructions.local.set(location.index));\n    } else if (location.type === \"static\") {\n        instr.push(Instructions.i32.const(0), Instructions.i32.const(0), load(ctype, location.address));\n        instr.push(...ctx.withTemporaryLocal(realType(ctype), (tmp) => [\n            Instructions.local.tee(tmp), // store copy of old value\n            ...transform,\n            store(ctype, location.address),\n            Instructions.local.get(tmp)\n        ]));\n    } else if (location.type === \"shadow\") {\n        instr.push(Instructions.global.get(ctx.gen.shadowStackPtr), Instructions.global.get(ctx.gen.shadowStackPtr));\n        instr.push(load(ctype, location.shadowOffset));\n\n        instr.push(...ctx.withTemporaryLocal(realType(ctype), (tmp) => [\n            Instructions.local.tee(tmp), // store copy of old value\n            ...transform,\n            store(ctype, location.shadowOffset),\n            Instructions.local.get(tmp)\n        ]));\n    } else if (location.type === \"pointer\") {\n        instr.push(...ctx.withTemporaryLocal(i32Type, (addrTmp) => [\n            Instructions.local.tee(addrTmp), // duplicate pointer on top of stack\n            Instructions.local.get(addrTmp)\n        ]));\n        instr.push(load(ctype, 0));\n        instr.push(...ctx.withTemporaryLocal(realType(ctype), (tmp) => [\n            Instructions.local.tee(tmp), // store copy of old value\n            ...transform,\n            store(ctype, 0),\n            Instructions.local.get(tmp)\n        ]));\n    }\n    return instr;\n}\n\n// helper to get address of a storage location\nexport function getAddress(ctx: WFnGenerator, s: e.CExpression): WInstruction[] {\n    const [instr, loc] = fromExpression(ctx, s);\n    if (loc.type === \"local\") {\n        throw new GenError(\"Local with addressed access stored in local. This shouldn't happen!\", ctx, s.node);\n    } else if (loc.type === \"static\") {\n        instr.push(Instructions.i32.const(loc.address));\n    } else if (loc.type === \"shadow\") {\n        instr.push(Instructions.global.get(ctx.gen.shadowStackPtr),\n            Instructions.i32.const(loc.shadowOffset),\n            Instructions.i32.add());\n    }\n    return instr;\n}\n\n// helper to get the storage location from an expression\n\n/**\n * Helper function which finds the storage location from a CExpression.\n *\n * The first return value are instructions to be executed before accessing the storage and\n * the second return value is the storage location itself.\n */\nfunction fromExpression(ctx: WFnGenerator, s: e.CExpression): [WInstruction[], StorageLocation] {\n    if (!s.lvalue) throw new GenError(\"Only lvalue expressions can have storage locations\", ctx, s.node);\n\n    if (s instanceof e.CIdentifier) {\n        let location = getStorageLocation(s.value);\n        if (location) return [[], location];\n\n        if (s.value instanceof CVarDeclaration) {\n            if (s.value.definition === undefined) throw new GenError(\"No variable definition found\", ctx, s.node);\n            location = getStorageLocation(s.value.definition);\n            if (location) return [[], location];\n        }\n\n    } else if (s instanceof e.CMemberAccess) {\n        const address = ctx.expression(s.body, false);\n        if (s.structUnion instanceof CStruct) {\n            let offset = 0;\n            for (const member of s.structUnion.members) {\n                offset = Math.ceil(offset / member.type.alignment) * member.type.alignment;\n                if (member.name === s.member) break;\n                offset += member.type.bytes;\n            }\n            return [[...address, Instructions.i32.const(offset), Instructions.i32.add()], {type: \"pointer\"}];\n        }\n        return [address, {type: \"pointer\"}]; // for unions\n    } else if (s instanceof e.CDereference) {\n        return [ctx.expression(s.body, false), {type: \"pointer\"}];\n    }\n\n    throw new GenError(\"Invalid location expression\", ctx, s.node);\n}\n\nexport function getStaticAddress(s: CDeclaration): number | undefined {\n    if (s instanceof CVarDeclaration && s.definition) s = s.definition;\n    const loc = getStorageLocation(s);\n    return loc?.type === \"static\" ? loc.address : undefined;\n}\n\n// helpers for storing storage location on variables using a Symbol\n\nconst locationSymbol = Symbol(\"storage location\");\nfunction setStorageLocation(s: CDeclaration, loc: StorageLocation) {\n    (s as any as Record<typeof locationSymbol, StorageLocation>)[locationSymbol] = loc;\n}\n\nfunction getStorageLocation(s: CDeclaration): StorageLocation | undefined {\n    return (s as any as Record<typeof locationSymbol, StorageLocation | undefined>)[locationSymbol];\n}\n\n// helpers returning the instructions to read/write a type from memory\n\nfunction load(type: CType, offset: number): WInstruction {\n    if (type instanceof CPointer) {\n        return Instructions.i32.load(2, offset);\n    }\n    if (type instanceof CStruct || type instanceof CUnion || type instanceof CArray) {\n        throw new Error(\"Invalid \" + type.typeName + \" load\");\n    }\n    if (type instanceof CVoid || type instanceof CFuncType) {\n        throw new Error(\"Cannot load \" + type.typeName);\n    }\n\n    // must be arithmetic\n    if (type.type === \"float\") {\n        if (type.bytes === 8) {\n            return Instructions.f64.load(3, offset);\n        } else {\n            return Instructions.f32.load(2, offset);\n        }\n\n    } else if (type.bytes === 8) {\n        return Instructions.i64.load(3, offset);\n\n    } else if (type.bytes === 4) {\n        return Instructions.i32.load(2, offset);\n\n    } else if (type.type === \"signed\") {\n        if (type.bytes === 2) {\n            return Instructions.i32.load16_s(1, offset);\n        } else {\n            return Instructions.i32.load8_s(0, offset);\n        }\n\n    } else {\n        if (type.bytes === 2) {\n            return Instructions.i32.load16_u(1, offset);\n        } else {\n            return Instructions.i32.load8_u(0, offset);\n        }\n    }\n}\n\nfunction store(type: CType, offset: number): WInstruction {\n    if (type instanceof CPointer) {\n        return Instructions.i32.store(2, offset);\n    }\n    if (type instanceof CStruct || type instanceof CUnion || type instanceof CArray) {\n        throw new Error(\"Invalid \" + type.typeName + \" store\");\n    }\n    if (type instanceof CVoid || type instanceof CFuncType) {\n        throw new Error(\"Cannot store \" + type.typeName);\n    }\n\n    if (type.type === \"float\") {\n        if (type.bytes === 8) {\n            return Instructions.f64.store(3, offset);\n        } else {\n            return Instructions.f32.store(2, offset);\n        }\n\n    } else if (type.bytes === 8) {\n        return Instructions.i64.store(3, offset);\n    } else if (type.bytes === 4) {\n        return Instructions.i32.store(2, offset);\n    } else if (type.bytes === 2) {\n        return Instructions.i32.store16(1, offset);\n    } else {\n        return Instructions.i32.store8(0, offset);\n    }\n}\n\nexport function memcpy(sourceAddr: WInstruction[], destAddr: WInstruction[], bytes: number): WInstruction[] {\n    return [\n        ...destAddr,\n        ...sourceAddr,\n        Instructions.i32.const(bytes),\n        Instructions.memory.copy()\n    ];\n}\n","import {CError} from \"../c_error\";\nimport {getArithmeticType} from \"../ir/types\";\nimport * as pt from \"./parsetree\";\nimport {ParseNode, TypeSpecifier} from \"./parsetree\";\n\nconst validatorMap = new Map<typeof ParseNode, ((node: ParseNode, parents: ParseNode[]) => void)[]>();\n\nexport function validate<T extends Iterable<ParseNode>>(nodeList: T, parents: ParseNode[] = []): T {\n    for (const node of nodeList) {\n        parents.push(node);\n        validate(node.children(), parents);\n        parents.pop();\n\n        for (const validator of validatorMap.get(Object.getPrototypeOf(node).constructor) ?? []) {\n            validator(node, parents);\n        }\n    }\n    return nodeList;\n}\n\nexport class ParseTreeValidationError extends CError {\n    readonly name = \"TreeValidationError\";\n\n    constructor(node: ParseNode | undefined, message: string, node2?: ParseNode) {\n        super(node && node.loc ? `Line ${node.loc.first_line + 1}: ${message}` : message, node, node2);\n    }\n}\n\nfunction validator<T extends ParseNode>(type: { new(...args: any[]): T}, fn: (node: T, parents: ParseNode[]) => void) {\n    const validators = validatorMap.get(type);\n    if (validators) {\n        validators.push(fn as any);\n    } else {\n        validatorMap.set(type, [fn as any]);\n    }\n}\n\n// DeclarationSpecifiers/SpecifierQualifiers validation\nfunction typeLookup(specifierList: ReadonlyArray<pt.TypeSpecifier>, node?: ParseNode) {\n    if (specifierList.every(v => typeof v === 'string')) {\n        if (!getArithmeticType(specifierList as ReadonlyArray<TypeSpecifier & string>)) {\n            throw new ParseTreeValidationError(node, \"Invalid specifiers - \" + specifierList.join(\", \"));\n        }\n    }\n}\n\nconst typeValidation = (d: pt.SpecifierQualifiers | pt.DeclarationSpecifiers) => {\n    if (d.qualifierList.length > 1) throw new ParseTreeValidationError(d, \"Invalid qualifiers.\");\n    typeLookup(d.specifierList, d);\n};\n\nvalidator(pt.SpecifierQualifiers, typeValidation);\nvalidator(pt.DeclarationSpecifiers, typeValidation);\nvalidator(pt.DeclarationSpecifiers, (d, parents) => {\n    if (d.storageList.length > 1) throw new ParseTreeValidationError(d, \"Invalid storage class list.\");\n    if (d.fnSpecifierList.length > 1) throw new ParseTreeValidationError(d, \"Invalid fn specifier list.\");\n\n    if (d.storageList[0] === \"typedef\" && parents.length !== 1) {\n        throw new ParseTreeValidationError(d, \"Nested typedefs are not allowed\");\n    }\n});\n\n// Constant expr validation\nfunction constExprValidation(n: ParseNode, parents: ParseNode[]) {\n    for (let i = parents.length - 1; i >= 0; i--) {\n        if (!(parents[i] instanceof pt.Expression) || parents[i].type === \"sizeof\") return;\n        if (parents[i].type === \"constantExpr\") throw new ParseTreeValidationError(n, \"Invalid constant expr.\");\n    }\n}\n\nvalidator(pt.UnaryExpression, (node, parent) => {\n    switch (node.type) {\n    case \"postfixIncrement\":\n    case \"postfixDecrement\":\n    case \"prefixIncrement\":\n    case \"prefixDecrement\":\n    case \"addressOf\": // If integers are required (believe this is always the case?)\n    case \"dereference\":\n        constExprValidation(node, parent);\n    }\n});\nvalidator(pt.BinaryExpression, (node, parent) => {\n    switch (node.type) {\n    case \"comma\":\n    case \"arraySubscript\": // If int\n        constExprValidation(node, parent);\n    }\n});\nvalidator(pt.FunctionCallExpression, constExprValidation);\n\n// If int\nvalidator(pt.MemberAccessExpression, constExprValidation);\n","import {CError} from \"../c_error\";\nimport {ParseNode} from \"./parsetree\";\n\nexport type Location = {\n    first_line: number,\n    last_line: number,\n    first_column: number,\n    last_column: number,\n    source: string,\n};\n\nconst keywords = Object.fromEntries([\n    \"if\", \"break\", \"case\", \"char\", \"const\", \"continue\", \"default\", \"do\", \"double\", \"else\", \"enum\", \"extern\", \"float\",\n    \"for\", \"inline\", \"int\", \"long\", \"return\", \"short\", \"signed\", \"sizeof\", \"static\", \"struct\", \"switch\", \"typedef\",\n    \"union\", \"unsigned\", \"void\", \"while\", \"_Bool\", \"goto\",\n\n    // currently unsupported (but still lex so parser throws error)\n    \"auto\", \"register\", \"volatile\",\n\n    // special for c2wasm, not on spec\n    \"import\"\n].map(x => [x, x.toUpperCase()]));\n\nconst symbols = [\n    \"...\",\"<<=\",\">>=\",\n    \"!=\",\"%=\",\"&&\",\"&=\",\"*=\",\"++\",\"+=\",\"--\",\"-=\",\"->\",\"/=\",\"<<\",\"<=\",\"==\",\">=\",\">>\",\"^=\",\"|=\",\"||\",\n    \"!\",\"%\",\"&\",\"(\",\")\",\"*\",\"+\",\",\",\"-\",\".\",\"/\",\":\",\";\",\"<\",\"=\",\">\",\"?\",\"[\",\"]\",\"^\",\"{\",\"|\",\"}\",\"~\"\n];\n\nconst rules: {regex: RegExp, type: string | ((s: string) => string), value?: (s: string) => string}[] = [\n    {\n        type: (s) => keywords[s] ?? 'IDENTIFIER',\n        regex: /[a-zA-Z_][a-zA-Z0-9_]*/,\n    },\n    {\n        type: x => x,\n        regex: new RegExp(symbols.map(s => s.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')).join('|')),\n    },\n    {\n        type: 'CONSTANT_FLOAT',\n        regex: /(?:[0-9]+[Ee][+-]?[0-9]+|(?:[0-9]*\\.[0-9]+|[0-9]+\\.[0-9]*)(?:[Ee][+-]?[0-9]+)?)[fFlL]?|(?:[1-9][0-9]*|0)[fF]/,\n    },\n    {\n        type: 'CONSTANT_HEX',\n        regex: /0[xX][a-fA-F0-9]+(?:[uU][lL]{0,2}|[lL]{1,2}[uU]?|)/,\n    },\n    {\n        type: 'CONSTANT_OCTAL',\n        regex: /0[0-7]+(?:[uU][lL]{0,2}|[lL]{1,2}[uU]?|)/,\n    },\n    {\n        type: 'CONSTANT_INT',\n        regex: /(?:[1-9][0-9]*|0)(?:[uU][lL]{0,2}|[lL]{1,2}[uU]?|)/,\n    },\n    {\n        type: 'CONSTANT_CHAR',\n        regex: /'(?:[^\\\\\\n']|\\\\(?:.|x[0-9a-fA-F]{1,2}|[0-7]{1,3}))'/,\n        value: x => x.slice(1, -1),\n    },\n    {\n        type: 'STRING_LITERAL',\n        regex: /\"(?:[^\\\\\\n\"]|\\\\(?:[^x0-7\\n]|x[0-9a-fA-F]{1,2}|[0-7]{1,3}))*\"/,\n        value: x => x.slice(1, -1),\n    },\n];\n\nexport class Lexer {\n    static regex = new RegExp(rules.map(x => '(' + x.regex.source + ')').join('|'), 'ym');\n\n    private source = '';\n    private index = 0;\n    private line = 0;\n    private col = 0;\n\n    next(): {type: string, value: string, text: string, loc: Location} {\n        // Skip whitespace\n        while (this.index < this.source.length && (this.source[this.index] === ' '\n            || this.source[this.index] === '\\t' || this.source[this.index] === '\\v'\n            || this.source[this.index] === '\\f' || this.source[this.index] === '\\n')) {\n\n            if (this.source[this.index] === '\\n') {\n                this.line++;\n                this.col = 1;\n            } else {\n                this.col++;\n            }\n            this.index++;\n        }\n\n        const loc: Location = {\n            first_line: this.line,\n            first_column: this.col,\n            last_line: this.line,\n            last_column: this.col + 1,\n            source: this.source,\n        };\n\n        // Reached end of source\n        if (this.index === this.source.length) {\n            return {type: 'EOF', value: '', text: '', loc};\n        }\n\n        // Match sticky regex from current index\n        Lexer.regex.lastIndex = this.index;\n        const match = Lexer.regex.exec(this.source);\n        if (!match) throw new LexerError(loc);\n\n        // Update location information\n        const text = match[0];\n        this.index += text.length;\n        this.col += text.length;\n        loc.last_column = this.col;\n\n        // group[n+1] !== undefined means that rule[n] matched\n        let groupIdx = 0;\n        while (match[groupIdx + 1] === undefined) groupIdx++;\n        const group = rules[groupIdx];\n\n        return {\n            type: typeof group.type === 'function' ? group.type(text) : group.type,\n            value: group.value?.(text) ?? text,\n            text, loc,\n        };\n    }\n\n    reset(s: string) {\n        this.source = s;\n        this.index = 0;\n        this.line = 0;\n        this.col = 1;\n    }\n}\n\nclass LexerError extends CError {\n    name = \"LexerError\";\n\n    constructor(loc: Location) {\n        super(\"Unknown token\", new class extends ParseNode {\n            type = \"Unknown\";\n        }(loc));\n    }\n}\n\nexport const lexer = new Lexer();\n","import {locationString} from \"../c_error\";\nimport gen from \"./gen/c_grammar\";\nimport {lexer, Location} from \"./lexer\";\nimport * as parsetree from \"./parsetree\";\nimport {validate} from \"./validation\";\n\n// adapt lexer to work with Jison\nclass WrappedLexer {\n    yytext?: string;\n    yylloc?: Location;\n    yylineno?: number;\n\n    private types = new Map<string, boolean>();\n\n    /** return the token type and update yytext, yylloc, yylineno */\n    lex(): string {\n        const token = lexer.next();\n        this.yytext = token.value;\n        this.yylloc = token.loc;\n        this.yylineno = token.loc.first_line;\n\n        if (token.type === \"IDENTIFIER\" && this.types.get(token.text)) {\n            return \"TYPE_NAME\";\n        }\n        return token.type;\n    }\n\n    setInput(input: string): void {\n        this.yytext = undefined;\n        this.yylloc = undefined;\n        this.yylineno = undefined;\n        this.types.clear();\n\n        lexer.reset(input);\n    }\n\n    externalDeclaration(d: parsetree.Declaration) {\n        if (d.typeInfo.storageList[0] !== \"typedef\") return;\n\n        for (let declarator of d.list) {\n            while (!(declarator instanceof parsetree.IdentifierDeclarator)) declarator = declarator.body;\n            this.types.set(declarator.id, true);\n        }\n    }\n}\n\n// provide the generated parser with our custom lexer\nconst generatedParser = gen as any;\ngeneratedParser.parser.lexer = new WrappedLexer();\n\n/**\n * Parse the input string into a parse tree and perform some basic validation\n */\nexport function parse(input: string): parsetree.TranslationUnit {\n    try {\n        const tree = generatedParser.parse(input);\n        return validate(tree);\n    } catch (e) {\n        if (e?.hash?.loc) { // Jison parse errors\n            e.message += \"\\n\\n\" + locationString(e.hash?.loc);\n        }\n        throw e;\n    }\n}\n","import {ParseNode} from \"../parsing\";\nimport {CFuncDeclaration} from \"./declarations\";\nimport {Scope} from \"./scope\";\nimport {CFuncType, CVoid, CArithmetic, CPointer} from \"./types\";\n\nconst fakeParseNode: ParseNode = new class extends ParseNode {\n    readonly type: string = \"__internal__\";\n\n    constructor() {\n        super({first_line: 0, first_column: 0, last_line: 0, last_column: 0, source: \"\"});\n    }\n}();\n\nexport const INTERNAL_FNS = {\n    /** For executing arbitrary Wasm. Should NOT contain control flow as the code will not be processed\n     * by optimisations. Similarly, locals should only be accessed as parameters as they map be remapped.\n     *\n     * __wasm_push__([#parameters], [parameter1], [parameter2], ..., [byte1], [byte2]...);\n     */\n    wasm: new CFuncDeclaration(\n        fakeParseNode,\n        \"__wasm__\",\n        new CFuncType(fakeParseNode, new CVoid(), [CArithmetic.U32], undefined, true),\n        \"internal\"\n    ),\n    /** For executing arbitrary Wasm* returning i32 */\n    wasm_i32: new CFuncDeclaration(\n        fakeParseNode,\n        \"__wasm_i32__\",\n        new CFuncType(fakeParseNode, CArithmetic.U32, [CArithmetic.U32], undefined, true),\n        \"internal\"\n    ),\n    /** For executing arbitrary Wasm* returning i64 */\n    wasm_i64: new CFuncDeclaration(\n        fakeParseNode,\n        \"__wasm_i64__\",\n        new CFuncType(fakeParseNode, CArithmetic.U64, [CArithmetic.U32], undefined, true),\n        \"internal\"\n    ),\n    /** For executing arbitrary Wasm* returning f32 */\n    wasm_f32: new CFuncDeclaration(\n        fakeParseNode,\n        \"__wasm_f32__\",\n        new CFuncType(fakeParseNode, CArithmetic.Fp32, [CArithmetic.U32], undefined, true),\n        \"internal\"\n    ),\n    /** For executing arbitrary Wasm* returning f64 */\n    wasm_f64: new CFuncDeclaration(\n        fakeParseNode,\n        \"__wasm_f64__\",\n        new CFuncType(fakeParseNode, CArithmetic.Fp64, [CArithmetic.U32], undefined, true),\n        \"internal\"\n    ),\n    /** For getting the value of the shadow stack pointer\n     *\n     * __wasm_ssp__();\n     */\n    wasm_ssp: new CFuncDeclaration(\n        fakeParseNode,\n        \"__wasm_ssp__\",\n        new CFuncType(fakeParseNode, new CPointer(fakeParseNode, new CVoid(), true), []),\n        \"internal\"\n    ),\n    /**\n     * Wasm real type load - compensates for conversation/type_conversion.ts realType()\n     * Most C values are directly stored as Wasm values, but CStruct and CUnions have to be stored as pointers.\n     * This isn't directly expressed in the type information, and so this function is needed for any C directly manipulating memory.\n     *\n     * __wasm_rload__([ptr]);\n     */\n    wasm_rload: new CFuncDeclaration(\n        fakeParseNode,\n        \"__wasm_rload__\",\n        new CFuncType(fakeParseNode, new CPointer(fakeParseNode, new CVoid(), true), [new CPointer(fakeParseNode, new CVoid(), true)]),\n        \"internal\"\n    )\n};\n\nexport const INTERNAL_SCOPE = new Scope();\nObject.values(INTERNAL_FNS).forEach(x => INTERNAL_SCOPE.addIdentifier(x));\n","import {CFunctionCall, CIdentifier, CConstant} from \"../ir/expressions\";\nimport {INTERNAL_FNS} from \"../ir/internal_scope\";\nimport {CArithmetic, CStruct, CUnion, CPointer} from \"../ir/types\";\nimport {ValueType, i32Type, i64Type, f32Type, f64Type} from \"../wasm\";\nimport {byte} from \"../wasm/base_types\";\nimport {WInstruction, Instructions} from \"../wasm/instructions\";\nimport {GenError} from \"./gen_error\";\nimport {WFnGenerator} from \"./generator\";\nimport {realType} from \"./type_conversion\";\n\n\nfunction arbitrary(ctx: WFnGenerator, e: CFunctionCall, result: ValueType | null): WInstruction[] {\n    if (!(e.args[0] instanceof CConstant)) {\n        throw new GenError(\"__wasm__ first argument should be integer constant specifying the number of parameters\", ctx, e.args[0].node);\n    }\n    const parameters = Number(e.args[0].value);\n\n    const parameterArgs = e.args.slice(1, parameters + 1);\n    const parameterInstructions = parameterArgs.flatMap(x => ctx.expression(x, false));\n\n    const instructionArgs = e.args.slice(parameters + 1);\n    const instructionBytes = instructionArgs.map(x => {\n        if (x instanceof CConstant) return Number(x.changeType(CArithmetic.U8).value);\n        throw new GenError(\"__wasm__ instructions must be constants\", ctx, x.node);\n    });\n\n    return [\n        ...parameterInstructions,\n        () => ({\n            name: \"arbitrary\",\n            type: \"zeroArg\",\n            immediate: {},\n\n            encoded: instructionBytes as byte[],\n            parameters: parameterArgs.map(parm => realType(parm.type)),\n            result,\n            reads: [],\n            writes: [\"arbitraryCode\", \"memory\"], // the arbitrary code may write to memory\n\n            copy() {\n                return () => this;\n            }\n        })];\n}\n\nexport function internalFunctions(ctx: WFnGenerator, e: CFunctionCall, discard: boolean): WInstruction[] | undefined {\n    if (!(e.body instanceof CIdentifier)) return undefined; // indirect call\n\n    switch (e.body.value) {\n\n    case INTERNAL_FNS.wasm:\n        return arbitrary(ctx, e, null);\n    case INTERNAL_FNS.wasm_i32:\n        return arbitrary(ctx, e, i32Type);\n    case INTERNAL_FNS.wasm_i64:\n        return arbitrary(ctx, e, i64Type);\n    case INTERNAL_FNS.wasm_f32:\n        return arbitrary(ctx, e, f32Type);\n    case INTERNAL_FNS.wasm_f64:\n        return arbitrary(ctx, e, f64Type);\n\n    case INTERNAL_FNS.wasm_ssp:\n        return discard ? [] : [Instructions.global.get(ctx.gen.shadowStackPtr)];\n\n    case INTERNAL_FNS.wasm_rload:\n        if (e.args[0].type instanceof CPointer) {\n            const instr = ctx.expression(e.args[0], false);\n            const type = e.args[0].type.type;\n            if (type instanceof CStruct || type instanceof CUnion) {\n                instr.push(Instructions.i32.load(2, 0));\n            }\n            return instr;\n        }\n        throw new GenError(\"__wasm_rload__ argument should be pointer\");\n\n    default:\n        return undefined;\n\n    }\n}\n","import {getFlags} from \"../optimisation/flags\";\nimport {CFuncDefinition, CFuncDeclaration} from \"../ir/declarations\";\nimport {CIdentifier} from \"../ir/expressions\";\nimport * as c from \"../ir/expressions\";\nimport {evalExpression} from \"../ir/transform/constant_expressions\";\nimport {CType, CArithmetic, CPointer, CArray, CSizeT, CUnion, CStruct, CFuncType, integerPromotion} from \"../ir/types\";\nimport {i32Type, Instructions, i64Type, f32Type, f64Type, ValueType} from \"../wasm\";\nimport {WInstruction} from \"../wasm/instructions\";\nimport {GenError} from \"./gen_error\";\nimport {WFnGenerator} from \"./generator\";\nimport {storageGet, storageSet, storageUpdate, storageGetThenUpdate, getAddress} from \"./storage\";\nimport {ImplementationType, implType, conversion, valueType, realType, largeReturn, returnType} from \"./type_conversion\";\nimport {internalFunctions} from \"./wasm_functions\";\n\nfunction constant(ctx: WFnGenerator, e: c.CConstant, discard: boolean): WInstruction[] {\n    if (discard) return []; // no possible side effects\n\n    return [gInstr(valueType(e.type), \"const\", e.value)];\n}\n\nfunction identifier(ctx: WFnGenerator, e: c.CIdentifier, discard: boolean): WInstruction[] {\n    if (discard) return []; // no possible side effects\n\n    if (e.value instanceof CFuncDefinition || e.value instanceof CFuncDeclaration) {\n        // get function pointer\n        return [Instructions.i32.const(ctx.gen.indirectIndex(e.value))];\n    }\n    return storageGet(ctx, e.type, e);\n}\n\nfunction stringLiteral(ctx: WFnGenerator, e: c.CStringLiteral, discard: boolean): WInstruction[] {\n    if (discard) return []; // no possible side effects\n    const stringAddress = ctx.gen.nextStaticAddr; // chars allowed to be 1-byte aligned\n    ctx.gen.nextStaticAddr += e.value.length;\n\n    ctx.gen.module.dataSegment(stringAddress, e.value.map(Number));\n    return [Instructions.i32.const(stringAddress)];\n}\n\n/**\n * Stack has to contain function arguments.\n * If any argument (or function pointer) is varadic then it will try to manipulate the same region so need to call all\n * child expressions before storing. This means pushing everything onto the stack in the right order.\n * - evaluate normal function arguments\n * - (allocate space for large return struct/union, push as hidden extra argument)\n * - (evaluate indirect function id)\n * - (evaluate variadic arguments)\n * - (store variadic arguments)\n * - increment shadow stack pointer\n * - call function (and cleanup)\n * - decrement shadow stack pointer\n * - (push large return ptr)\n */\nfunction functionCall(ctx: WFnGenerator, e: c.CFunctionCall, discard: boolean): WInstruction[] {\n    const indirectValue: WInstruction[] = [];\n    if (e.body instanceof c.CIdentifier && (e.body.value instanceof CFuncDefinition || e.body.value instanceof CFuncDeclaration)) {\n        // normal function call\n    } else if (e.body.type instanceof CFuncType || (e.body.type instanceof CPointer && e.body.type.type instanceof CFuncType)) {\n        // indirect function call\n        indirectValue.push(...subExpr(ctx, e.body, e.body.type));\n    } else {\n        throw new GenError(\"Invalid fn call identifier\", ctx, e.body.node);\n    }\n\n    const internalExpression = internalFunctions(ctx, e, discard); // __wasm__ etc\n    if (internalExpression !== undefined) {\n        if (e.fnType.returnType.bytes > 0 && discard) internalExpression.push(Instructions.drop());\n        return internalExpression;\n    }\n\n    const instr = e.fnType.parameterTypes.flatMap((t, i) => subExpr(ctx, e.args[i], t));\n\n    let largeReturnPtr: WInstruction[] | undefined;\n    if (largeReturn(e.fnType.returnType)) {\n        largeReturnPtr = [ // address allocated for storing return value\n            Instructions.global.get(ctx.gen.shadowStackPtr),\n            Instructions.i32.const(ctx.shadowStackUsage),\n            Instructions.i32.add()\n        ];\n        // allocate space for return value\n        ctx.shadowStackUsage += 4 * Math.ceil(e.fnType.returnType.bytes / 4);\n        // push pointer onto stack as hidden argument\n        instr.push(...largeReturnPtr);\n    }\n\n    if (indirectValue.length > 0) {\n        // indirect call index\n        instr.push(...indirectValue);\n    }\n\n    let shadowUsage = ctx.shadowStackUsage;\n    if (e.fnType.variadic) {\n        // push variadic variables onto stack\n        const types: ValueType[] = [];\n        for (let i = e.fnType.parameterTypes.length; i < e.args.length; i++) {\n            // default argument promotions\n            let type = e.args[i].type;\n            if (type instanceof CArithmetic) {\n                if (type.type === \"float\") type = CArithmetic.Fp64;\n                else type = integerPromotion(type);\n            }\n\n            // storing realType so C code needs to do __wasm_rload__ to account for structs being pointers etc\n            types.unshift(realType(type));\n            instr.push(Instructions.global.get(ctx.gen.shadowStackPtr), ...subExpr(ctx, e.args[i], type));\n        }\n\n        shadowUsage += 16; // empty region to help prevent overruns\n        for (const type of types) {\n            instr.push(gInstr(type, \"store\", type === i64Type || type === f64Type ? 3 : 2, shadowUsage));\n            shadowUsage += 8;\n        }\n    }\n    if (shadowUsage > 0) {\n        // increment shadow stack pointer for callee\n        instr.push(Instructions.global.get(ctx.gen.shadowStackPtr),\n            Instructions.i32.const(shadowUsage),\n            Instructions.i32.add(),\n            Instructions.global.set(ctx.gen.shadowStackPtr));\n    }\n\n    // do actual call\n    if (indirectValue.length > 0) {\n        instr.push(Instructions.call_indirect(ctx.gen.typeIndex(e.fnType)));\n    } else {\n        // direct call\n        const fn = (e.body as CIdentifier).value as CFuncDeclaration | CFuncDefinition;\n        instr.push(Instructions.call(ctx.gen.functionIndex(fn)));\n    }\n\n    if (discard && returnType(e.fnType.returnType).length) {\n        // cleanup return value if needed\n        instr.push(Instructions.drop());\n    }\n    if (shadowUsage > 0) {\n        // restore shadow stack pointer\n        instr.push(Instructions.global.get(ctx.gen.shadowStackPtr),\n            Instructions.i32.const(shadowUsage),\n            Instructions.i32.sub(),\n            Instructions.global.set(ctx.gen.shadowStackPtr));\n    }\n    if (!discard && largeReturnPtr) {\n        // return value is the struct/union returned via the largeReturnPtr\n        instr.push(...largeReturnPtr);\n    }\n    return instr;\n}\n\nfunction memberAccess(ctx: WFnGenerator, e: c.CMemberAccess, discard: boolean): WInstruction[] {\n    if (discard) return expressionGeneration(ctx, e.body, true);\n\n    return storageGet(ctx, e.type, e);\n}\n\nfunction incrDecr(ctx: WFnGenerator, e: c.CIncrDecr, discard: boolean): WInstruction[] {\n    const amount = e.type instanceof CPointer ? e.type.type.bytes : 1;\n    const type = realType(e.type);\n\n    if (e.pos === \"post\" && !discard) {\n        return storageGetThenUpdate(ctx, e.body.type, e.body, [\n            gConst(type, amount),\n            gInstr(type, e.op === \"++\" ? \"add\" : \"sub\"),\n        ]);\n    } else {\n        // can convert post and discard => pre with discard\n\n        return storageUpdate(ctx, e.body.type, e.body, [\n            gConst(type, amount),\n            gInstr(type, e.op === \"++\" ? \"add\" : \"sub\"),\n        ], !discard && e.pos === \"pre\");\n    }\n}\n\nfunction addressOf(ctx: WFnGenerator, e: c.CAddressOf, discard: boolean): WInstruction[] {\n    if (discard) return expressionGeneration(ctx, e.body, true); // get any side effects\n\n    if (e.body instanceof CIdentifier && (e.body.value instanceof CFuncDefinition || e.body.value instanceof CFuncDeclaration)) {\n        // get function pointer\n        return [Instructions.i32.const(ctx.gen.indirectIndex(e.body.value))];\n    }\n    return getAddress(ctx, e.body);\n}\n\nfunction dereference(ctx: WFnGenerator, e: c.CDereference, discard: boolean): WInstruction[] {\n    if (discard) return expressionGeneration(ctx, e.body, true); // get any side effects\n\n    if (e.type instanceof CPointer && e.type.original instanceof CFuncType) { // pointer generation\n        // don't do final deref of function pointers\n        return expressionGeneration(ctx, e.body, false);\n    }\n    return storageGet(ctx, e.type, e);\n}\n\nfunction unaryPlusMinus(ctx: WFnGenerator, e: c.CUnaryPlusMinus, discard: boolean): WInstruction[] {\n    if (discard) return expressionGeneration(ctx, e.body, true); // get any side effects\n\n    const instr = expressionGeneration(ctx, e.body, false);\n    if (e.op === \"-\") {\n        const type = implType(e.body.type);\n        if (type === f32Type || type === f64Type) {\n            instr.push(fInstr(type, \"neg\"));\n        } else {\n            instr.unshift(gConst(type, 0));\n            instr.push(gInstr(type, \"sub\"));\n        }\n    }\n    return instr;\n}\n\nfunction bitwiseNot(ctx: WFnGenerator, e: c.CBitwiseNot, discard: boolean): WInstruction[] {\n    if (discard) return expressionGeneration(ctx, e.body, true); // get any side effects\n\n    const wType = valueType(e.type);\n    return [...subExpr(ctx, e.body, e.type), iInstr(wType, \"const\", -1n), iInstr(wType, \"xor\")];\n}\n\nfunction logicalNot(ctx: WFnGenerator, e: c.CLogicalNot, discard: boolean): WInstruction[] {\n    if (discard) return expressionGeneration(ctx, e.body, true); // get any side effects\n\n    const instr = expressionGeneration(ctx, e.body, false);\n    const wType = realType(e.body.type);\n\n    if (isIValueType(wType)) {\n        return [...instr, iInstr(wType, \"eqz\")];\n    } else {\n        return [...instr, fInstr(wType, \"const\", 0), fInstr(wType, \"eq\")];\n    }\n}\n\nfunction sizeof(ctx: WFnGenerator, e: c.CSizeof, discard: boolean): WInstruction[] {\n    if (discard) return []; // no possible side effects\n\n    return [Instructions.i32.const(e.body.bytes)];\n}\n\nfunction cast(ctx: WFnGenerator, e: c.CCast, discard: boolean): WInstruction[] {\n    if (discard) return expressionGeneration(ctx, e.body, true); // get any side effects\n\n    return [...expressionGeneration(ctx, e.body, false), ...conversion(e.body.type, e.type)];\n}\n\nfunction mulDiv(ctx: WFnGenerator, e: c.CMulDiv, discard: boolean): WInstruction[] {\n    if (discard) return [...expressionGeneration(ctx, e.lhs, true), ...expressionGeneration(ctx, e.rhs, true)];\n\n    const instr = [...subExpr(ctx, e.lhs, e.type), ...subExpr(ctx, e.rhs, e.type)];\n    const wType = valueType(e.type);\n    if (isIValueType(wType)){\n        if (e.op === \"*\") instr.push(iInstr(wType, \"mul\"));\n        else instr.push(e.type.type === \"signed\" ? iInstr(wType, \"div_s\") : iInstr(wType, \"div_u\"));\n    } else {\n        instr.push(e.op === \"*\" ? fInstr(wType, \"mul\") : fInstr(wType, \"div\"));\n    }\n\n    return instr;\n}\n\nfunction mod(ctx: WFnGenerator, e: c.CMod, discard: boolean): WInstruction[] {\n    if (discard) return [...expressionGeneration(ctx, e.lhs, true), ...expressionGeneration(ctx, e.rhs, true)];\n\n    const wType = valueType(e.type);\n    if (e.type.type === \"signed\") {\n        return [...subExpr(ctx, e.lhs, e.type), ...subExpr(ctx, e.rhs, e.type), iInstr(wType, \"rem_s\")];\n    } else {\n        return [...subExpr(ctx, e.lhs, e.type), ...subExpr(ctx, e.rhs, e.type), iInstr(wType, \"rem_u\")];\n    }\n}\n\nfunction addSub(ctx: WFnGenerator, e: c.CAddSub, discard: boolean): WInstruction[] {\n    if (discard) return [...expressionGeneration(ctx, e.lhs, true), ...expressionGeneration(ctx, e.rhs, true)];\n\n    if (e.type instanceof CArithmetic) {\n        const lhs = subExpr(ctx, e.lhs, e.type);\n        const rhs = subExpr(ctx, e.rhs, e.type);\n        const wType = valueType(e.type);\n        return [...lhs, ...rhs, e.op === \"+\" ? gInstr(wType, \"add\") : gInstr(wType, \"sub\")];\n    } else {\n        // eslint-disable-next-line no-inner-declarations\n        function toExpr(side: c.CExpression) {\n            if (side.type instanceof CPointer) {\n                return ctx.expression(side, false);\n            } else { // if side.type === integer\n                const instr = subExpr(ctx, side, CArithmetic.U32);\n                const size = (e.type as CPointer).type.bytes;\n                if (size > 1) instr.push(Instructions.i32.const(size), Instructions.i32.mul());\n                return instr;\n            }\n        }\n\n        return [...toExpr(e.lhs), ...toExpr(e.rhs), e.op === \"+\" ? Instructions.i32.add() : Instructions.i32.sub()];\n    }\n}\n\nfunction shift(ctx: WFnGenerator, e: c.CShift, discard: boolean): WInstruction[] {\n    if (discard) return [...expressionGeneration(ctx, e.lhs, true), ...expressionGeneration(ctx, e.rhs, true)];\n\n    const wType = valueType(e.type);\n    if (e.dir === \"left\") {\n        return [...subExpr(ctx, e.lhs, e.type), ...subExpr(ctx, e.rhs, e.type), iInstr(wType, \"shl\")];\n    } else if (e.type.type === \"signed\") {\n        return [...subExpr(ctx, e.lhs, e.type), ...subExpr(ctx, e.rhs, e.type), iInstr(wType, \"shr_s\")];\n    } else {\n        return [...subExpr(ctx, e.lhs, e.type), ...subExpr(ctx, e.rhs, e.type), iInstr(wType, \"shr_u\")];\n    }\n}\n\nfunction relational(ctx: WFnGenerator, e: c.CRelational, discard: boolean): WInstruction[] {\n    if (discard) return [...expressionGeneration(ctx, e.lhs, true), ...expressionGeneration(ctx, e.rhs, true)];\n\n    const wType = valueType(e.commonType);\n    if (!isIValueType(wType)) {\n        return [...subExpr(ctx, e.lhs, e.commonType), ...subExpr(ctx, e.rhs, e.commonType),\n            e.op === \"LT\" ? fInstr(wType, \"lt\") :\n                e.op === \"GT\" ? fInstr(wType, \"gt\") :\n                    e.op === \"LEq\" ? fInstr(wType, \"le\") : fInstr(wType, \"ge\")];\n    } else if (e.commonType.type === \"signed\") {\n        return [...subExpr(ctx, e.lhs, e.commonType), ...subExpr(ctx, e.rhs, e.commonType),\n            e.op === \"LT\" ? iInstr(wType, \"lt_s\") :\n                e.op === \"GT\" ? iInstr(wType, \"gt_s\") :\n                    e.op === \"LEq\" ? iInstr(wType, \"le_s\") : iInstr(wType, \"ge_s\")];\n    } else {\n        return [...subExpr(ctx, e.lhs, e.commonType), ...subExpr(ctx, e.rhs, e.commonType),\n            e.op === \"LT\" ? iInstr(wType, \"lt_u\") :\n                e.op === \"GT\" ? iInstr(wType, \"gt_u\") :\n                    e.op === \"LEq\" ? iInstr(wType, \"le_u\") : iInstr(wType, \"ge_u\")];\n    }\n}\n\nfunction equality(ctx: WFnGenerator, e: c.CEquality, discard: boolean): WInstruction[] {\n    if (discard) return [...expressionGeneration(ctx, e.lhs, true), ...expressionGeneration(ctx, e.rhs, true)];\n\n    return [\n        ...subExpr(ctx, e.lhs, e.commonType),\n        ...subExpr(ctx, e.rhs, e.commonType),\n        gInstr(valueType(e.commonType), e.op === \"==\" ? \"eq\" : \"ne\")];\n}\n\nfunction bitwiseAndOr(ctx: WFnGenerator, e: c.CBitwiseAndOr, discard: boolean): WInstruction[] {\n    if (discard) return [...expressionGeneration(ctx, e.lhs, true), ...expressionGeneration(ctx, e.rhs, true)];\n\n    return [...subExpr(ctx, e.lhs, e.type), ...subExpr(ctx, e.rhs, e.type), iInstr(valueType(e.type), e.op)];\n}\n\nfunction logicalAndOr(ctx: WFnGenerator, e: c.CLogicalAndOr, discard: boolean): WInstruction[] {\n    if (discard) return [...expressionGeneration(ctx, e.lhs, true), ...expressionGeneration(ctx, e.rhs, true)];\n\n    if (e.op === \"and\") {\n        return [...condition(ctx, e.lhs), Instructions.if(i32Type, condition(ctx, e.rhs, false), [\n            Instructions.i32.const(0n)\n        ])];\n    } else { // op === \"or\"\n        return [...condition(ctx, e.lhs), Instructions.if(i32Type, [\n            Instructions.i32.const(1n)\n        ], condition(ctx, e.rhs, false))];\n    }\n}\n\nfunction conditional(ctx: WFnGenerator, e: c.CConditional, discard: boolean): WInstruction[] {\n    const test = condition(ctx, e.test);\n    if (discard) {\n        const trueSideEffects = expressionGeneration(ctx, e.trueValue, true);\n        const falseSideEffects = expressionGeneration(ctx, e.falseValue,true);\n        if (trueSideEffects.length === 0 && falseSideEffects.length === 0) return [];\n\n        return [...test, Instructions.if(null, trueSideEffects, falseSideEffects)];\n    } else {\n        return [...test, Instructions.if(realType(e.type),\n            subExpr(ctx, e.trueValue, e.type),\n            subExpr(ctx, e.falseValue, e.type))];\n    }\n}\n\nfunction assignment(ctx: WFnGenerator, e: c.CAssignment, discard: boolean): WInstruction[] {\n    if (e.assignmentType !== undefined && !(e.rhs instanceof c.CInitializer)) {\n        let body: c.CExpression;\n        if (e.assignmentType === \"mul\") {\n            body = new c.CMulDiv(e.node, e.lhs, e.rhs, \"*\");\n        } else if (e.assignmentType === \"div\") {\n            body = new c.CMulDiv(e.node, e.lhs, e.rhs, \"/\");\n        } else if (e.assignmentType === \"mod\") {\n            body = new c.CMod(e.node, e.lhs, e.rhs);\n        } else if (e.assignmentType === \"add\") {\n            body = new c.CAddSub(e.node, e.lhs, e.rhs, \"+\");\n        } else if (e.assignmentType === \"sub\") {\n            body = new c.CAddSub(e.node, e.lhs, e.rhs, \"-\");\n        } else if (e.assignmentType === \"leftShift\") {\n            body = new c.CShift(e.node, e.lhs, e.rhs, \"left\");\n        } else if (e.assignmentType === \"rightShift\") {\n            body = new c.CShift(e.node, e.lhs, e.rhs, \"right\");\n        } else if (e.assignmentType === \"bitwiseAnd\") {\n            body = new c.CBitwiseAndOr(e.node, e.lhs, e.rhs, \"and\");\n        } else if (e.assignmentType === \"bitwiseXor\") {\n            body = new c.CBitwiseAndOr(e.node, e.lhs, e.rhs, \"xor\");\n        } else {\n            body = new c.CBitwiseAndOr(e.node, e.lhs, e.rhs, \"or\");\n        }\n\n        // try to convert \"body\" into instructions, then remove the instructions which load the lhs to create transformation\n        const exprBody = expressionGeneration(ctx, body, false);\n        const lhs = expressionGeneration(ctx, e.lhs, false);\n\n        const transform = exprBody.slice(lhs.length);\n        // conversion must be added to wrap result correctly as integer promotion etc may have taken place in the body.\n        transform.push(...conversion(body.type, e.lhs.type));\n\n        return storageUpdate(ctx, e.lhs.type, e.lhs, transform, !discard);\n    } else if (e.rhs instanceof c.CInitializer) {\n        const instr: WInstruction[] = [];\n\n        if (e.rhs.type instanceof CArray) {\n            for (let i = 0; i < e.rhs.body.length; i++) {\n                const value = e.rhs.body[i];\n\n                const entryPointer = new c.CAddSub(e.lhs.node, e.lhs, new c.CConstant(e.lhs.node, CSizeT, BigInt(i)), \"+\");\n                const entryDeref = new c.CDereference(e.lhs.node, entryPointer);\n                const entryAssignment = new c.CAssignment(value.node, entryDeref, value, undefined, e.initialAssignment);\n                instr.push(...expressionGeneration(ctx, entryAssignment, true));\n            }\n        } else if (e.rhs.type instanceof CUnion) {\n            const addr = new c.CAddressOf(e.lhs.node, e.lhs);\n            const access = new c.CMemberAccess(e.rhs.node, addr, e.rhs.type.members[0].name);\n            const assignment = new c.CAssignment(e.rhs.body[0].node, access, e.rhs.body[0], undefined, true);\n            instr.push(...expressionGeneration(ctx, assignment, true));\n        } else if (e.rhs.type instanceof CStruct) {\n            const addr = new c.CAddressOf(e.lhs.node, e.lhs);\n\n            for (let i = 0; i < e.rhs.body.length; i++) {\n                const access = new c.CMemberAccess(e.rhs.node, addr, e.rhs.type.members[i].name);\n                const assignment = new c.CAssignment(e.rhs.body[i].node, access, e.rhs.body[i], undefined, true);\n                instr.push(...expressionGeneration(ctx, assignment, true));\n            }\n        } else {\n            throw new GenError(\"Unknown initializer\", ctx, e.node);\n        }\n\n        if (!discard) instr.push(...expressionGeneration(ctx, e.lhs, false));\n        return instr;\n    } else {\n        return storageSet(ctx, e.lhs.type, e.lhs, e.rhs, !discard);\n    }\n}\n\nfunction comma(ctx: WFnGenerator, e: c.CComma, discard: boolean): WInstruction[] {\n    return [...expressionGeneration(ctx, e.lhs, true), ...expressionGeneration(ctx, e.rhs, discard)];\n}\n\nexport function expressionGeneration(ctx: WFnGenerator, e: c.CExpression, discard: boolean): WInstruction[] {\n    if (!discard && e.type instanceof CArithmetic && !(e instanceof c.CConstant) && getFlags().generation_try_constant_expr) {\n        // try to evaluate as constant expression\n        const value = evalExpression(e);\n        if (value) return constant(ctx, new c.CConstant(e.node, e.type, value.value), false);\n    }\n\n    if (e instanceof c.CConstant) return constant(ctx, e, discard);\n    else if (e instanceof c.CIdentifier) return identifier(ctx, e, discard);\n    else if (e instanceof c.CStringLiteral) return stringLiteral(ctx, e, discard);\n    else if (e instanceof c.CFunctionCall) return functionCall(ctx, e, discard);\n    else if (e instanceof c.CMemberAccess) return memberAccess(ctx, e, discard);\n    else if (e instanceof c.CIncrDecr) return incrDecr(ctx, e, discard);\n    else if (e instanceof c.CAddressOf) return addressOf(ctx, e, discard);\n    else if (e instanceof c.CDereference) return dereference(ctx, e, discard);\n    else if (e instanceof c.CUnaryPlusMinus) return unaryPlusMinus(ctx, e, discard);\n    else if (e instanceof c.CBitwiseNot) return bitwiseNot(ctx, e, discard);\n    else if (e instanceof c.CLogicalNot) return logicalNot(ctx, e, discard);\n    else if (e instanceof c.CSizeof) return sizeof(ctx, e, discard);\n    else if (e instanceof c.CCast) return cast(ctx, e, discard);\n    else if (e instanceof c.CMulDiv) return mulDiv(ctx, e, discard);\n    else if (e instanceof c.CMod) return mod(ctx, e, discard);\n    else if (e instanceof c.CAddSub) return addSub(ctx, e, discard);\n    else if (e instanceof c.CShift) return shift(ctx, e, discard);\n    else if (e instanceof c.CRelational) return relational(ctx, e, discard);\n    else if (e instanceof c.CEquality) return equality(ctx, e, discard);\n    else if (e instanceof c.CBitwiseAndOr) return bitwiseAndOr(ctx, e, discard);\n    else if (e instanceof c.CLogicalAndOr) return logicalAndOr(ctx, e, discard);\n    else if (e instanceof c.CConditional) return conditional(ctx, e, discard);\n    else if (e instanceof c.CAssignment) return assignment(ctx, e, discard);\n    else return comma(ctx, e, discard);\n}\n\n// helpers\n/** expressionGeneration + casting */\nexport function subExpr(ctx: WFnGenerator, e: c.CExpression, desiredType: CType, discard: boolean = false): WInstruction[] {\n    const fakeCast = new c.CCast(e.node, desiredType, e);\n    return expressionGeneration(ctx, fakeCast, discard);\n}\n\nexport function condition(ctx: WFnGenerator, e: c.CExpression, anyNonZeroI32 = true): WInstruction[] {\n    const wType = implType(e.type);\n    if (wType === i32Type || wType instanceof CPointer) {\n        if (anyNonZeroI32 || CArithmetic.BOOL.equals(e.type)) {\n            return expressionGeneration(ctx, e, false);\n        } else {\n            return [...expressionGeneration(ctx, e, false), Instructions.i32.const(0n), Instructions.i32.ne()];\n        }\n    } else if (typeof wType !== \"number\") {\n        throw new GenError(\"Invalid condition\", ctx, e.node);\n    }\n    return [...expressionGeneration(ctx, e, false), gConst(wType, 0), gInstr(wType, \"ne\")];\n}\n\nfunction isIValueType(w: ImplementationType) {\n    return w === i32Type || w === i64Type;\n}\n\n/** f32 or f64 instruction */\nfunction fInstr(t: ImplementationType, op: (keyof typeof Instructions.f32 & keyof typeof Instructions.f64), ...args: any[]) {\n    if (typeof t !== \"number\") throw new Error(\"Instructions can only operate on value types\");\n\n    if (t === f32Type) {\n        // @ts-ignore\n        return Instructions.f32[op](...args);\n    } else if (t === f64Type) {\n        // @ts-ignore\n        return Instructions.f64[op](...args);\n    }\n    throw new Error(\"Invalid value type for floating point instruction\");\n}\n\n/** i32 or i64 instruction */\nfunction iInstr(t: ImplementationType, op: (keyof typeof Instructions.i32 & keyof typeof Instructions.i64), ...args: any[]) {\n    if (typeof t !== \"number\") throw new Error(\"Instructions can only operate on value types\");\n\n    if (t === i32Type) {\n        // @ts-ignore\n        return Instructions.i32[op](...args);\n    } else if (t === i64Type) {\n        // @ts-ignore\n        return Instructions.i64[op](...args);\n    }\n    throw new Error(\"Invalid value type for integer instruction\");\n}\n\n/** generic instruction - i32, i64, f32 or f64 */\nexport function gInstr(t: ImplementationType, op: (keyof typeof Instructions.i32 & keyof typeof Instructions.i64 & keyof typeof Instructions.f32 & keyof typeof Instructions.f64), ...args: any[]): WInstruction {\n    if (typeof t !== \"number\") throw new Error(\"Instructions can only operate on value types\");\n\n    if (t === i32Type) {\n        // @ts-ignore\n        return Instructions.i32[op](...args);\n    } else if (t === i64Type) {\n        // @ts-ignore\n        return Instructions.i64[op](...args);\n    } else if (t === f32Type) {\n        // @ts-ignore\n        return Instructions.f32[op](...args);\n    } else if (t === f64Type) {\n        // @ts-ignore\n        return Instructions.f64[op](...args);\n    }\n    throw new Error(\"Invalid value type?\");\n}\n\n/** generic constant */\nfunction gConst(t: ImplementationType, n: number) {\n    if (typeof t !== \"number\") throw new Error(\"Constants can only take value types\");\n    if (t !== (t | 0)) throw new Error(\"Invalid generic constant - not integer\");\n\n    if (t === i32Type) {\n        return Instructions.i32.const(BigInt(n));\n    } else if (t === i64Type) {\n        return Instructions.i64.const(BigInt(n));\n    } else if (t === f32Type) {\n        return Instructions.f32.const(n);\n    } else if (t === f64Type) {\n        return Instructions.f64.const(n);\n    }\n    throw new Error(\"Invalid value type?\");\n}\n","import {gInstr} from \"../../generation/expressions\";\nimport {WExpression, Instructions} from \"../../wasm\";\nimport {InstrInstance} from \"../../wasm/instr_helpers\";\nimport {InstrFlow, simplifiedControlFlow, Flow} from \"./control_flow\";\nimport {framework} from \"./framework\";\n\ntype DUChain = { // def-use chain\n    readonly local: bigint,\n    possibleUses: InstrFlow[], // instructions which reference this definition\n    definiteUses: InstrFlow[], // instructions which reference this definition and no other possible definition\n    bit: bigint,\n} & ({type: \"arg\"} | {type: \"local.set\" | \"local.tee\", flow: InstrFlow});\n\nfunction reachingDefinitions(expr: WExpression): { definitions: DUChain[], reaching: Map<Flow, bigint>, localMasks: bigint[] } {\n    const cfg = simplifiedControlFlow(expr, instr => instr.name.startsWith(\"local.\"));\n\n    const reaching = new Map<Flow, bigint>();\n    const flowDefMap = new Map<InstrFlow, DUChain>();\n    const duChains: DUChain[] = [];\n\n    // masks containing the bits for each local allowing quick killing of all a locals definitions\n    const localMasks: bigint[] = Array(expr.builder.args.length + expr.builder.locals.length).fill(0n);\n\n    // entry definitions are the function parameters\n    let entryDefinitions = 0n;\n    for (let i = 0n; i < expr.builder.args.length; i++) {\n        const d: DUChain = {\n            local: i, type: \"arg\",\n            possibleUses: [], definiteUses: [],\n            bit: 1n << BigInt(duChains.length)\n        };\n        entryDefinitions |= d.bit;\n        localMasks[Number(i)] |= d.bit;\n        duChains.push(d);\n    }\n    reaching.set(cfg.entry, entryDefinitions);\n\n    // definition objects for each of local.set/tee instructions\n    for (const f of cfg.all) {\n        if (f.instr.type === \"index\" && (f.instr.name === \"local.set\" || f.instr.name === \"local.tee\")) {\n            const d: DUChain = {\n                local: f.instr.immediate.value, type: f.instr.name,\n                possibleUses: [], definiteUses: [],\n                flow: f, bit: 1n << BigInt(duChains.length)\n            };\n            localMasks[Number(d.local)] |= d.bit;\n            flowDefMap.set(f, d);\n            duChains.push(d);\n        }\n    }\n\n    framework(cfg, null, reaching,\"forwards\", \"union\", (f, x) => {\n        const flowDef = flowDefMap.get(f as InstrFlow);\n        if (flowDef) {\n            x &= ~localMasks[Number(flowDef.local)];\n            x |= flowDef.bit;\n        }\n        return x;\n    });\n\n    // fill in usage info\n    for (const [flow, defs] of reaching.entries()) {\n        if (!flow.instr || flow.instr.type !== \"index\" || flow.instr.name !== \"local.get\") continue;\n        const local = flow.instr.immediate.value;\n\n        const localDefs = [];\n        for (let i = 0, bits = defs & localMasks[Number(local)]; bits; i++) {\n            if (bits & 1n) localDefs.push(duChains[i]);\n            bits >>= 1n;\n        }\n\n        if (localDefs.length === 1) {\n            localDefs[0].definiteUses.push(flow);\n        }\n        localDefs.forEach(d => d.possibleUses.push(flow));\n    }\n\n    return {definitions: duChains, reaching, localMasks};\n}\n\n// find the instruction which created the result consumed by this instruction\nfunction findValueInstr(f: InstrFlow): InstrInstance | undefined {\n    let len = f.instr.parameters.length;\n    for (let i = f.instrIndex - 1; i >= 0; i--) {\n        const instr = f.expr.instructions[i];\n        if (instr.result) len--;\n        if (len === 0) return instr;\n        len += instr.parameters.length;\n    }\n    return undefined;\n}\n\nexport function copyPropagation(expr: WExpression): void {\n    const {definitions, reaching, localMasks} = reachingDefinitions(expr);\n    if (!definitions.length) return; // couldn't analyze\n\n    for (const def of definitions) {\n        if (def.type === \"arg\") continue;\n\n        if (def.possibleUses.length === 0) {\n            // never used so drop the assignment\n            dropAssignment(def.flow);\n            continue;\n        }\n\n        // check if there are definite uses which we would be able to inline / propagate\n        if (def.definiteUses.length === 0) continue;\n\n        const valueInstr = findValueInstr(def.flow);\n        if (valueInstr?.type === \"constant\") {\n            // constant propagation\n            const replacement = gInstr(def.flow.instr.parameters[0], \"const\", valueInstr.immediate.value);\n\n            for (const use of def.definiteUses) {\n                use.expr.replace(use.instrIndex, use.instrIndex + 1, replacement);\n            }\n        } else if (valueInstr?.type === \"index\" && (valueInstr.name === \"local.get\" || valueInstr.name === \"local.tee\")) {\n            // copy propagation\n            const getFlow = [...def.flow.flowPrevious].find(f => f.instr && f.instrIndex === def.flow.instrIndex - 1 && f.expr === def.flow.expr);\n            if (!getFlow) continue; // needed to look up the valid definitions\n            const getLocal = Number(valueInstr.immediate.value);\n            const getDefs = (reaching.get(getFlow) ?? 0n) & localMasks[getLocal];\n\n            const replacement = Instructions.local.get(getLocal);\n            let replacedAll = true;\n            for (const use of def.definiteUses) {\n                if (getDefs === ((reaching.get(use) ?? 0n) & localMasks[getLocal])) {\n                    // have to be careful to only replace where the same definition of getLocal is validate\n                    use.expr.replace(use.instrIndex, use.instrIndex + 1, replacement);\n                } else {\n                    replacedAll = false; // getLocal has been redefined so can't replace\n                }\n            }\n            if (!replacedAll) continue;\n        } else {\n            continue;\n        }\n\n        if (def.definiteUses.length === def.possibleUses.length) {\n            // can remove the assignment if no extra possible uses\n            dropAssignment(def.flow);\n        }\n    }\n}\n\nfunction dropAssignment(f: InstrFlow) {\n    if (f.instr.name === \"local.tee\") {\n        f.expr.replace(f.instrIndex, f.instrIndex + 1, Instructions.nop()); // use nop to avoid changing indices\n    } else if (f.instr.name === \"local.set\") {\n        f.expr.replace(f.instrIndex, f.instrIndex + 1, Instructions.drop());\n    }\n}\n","import {WExpression, Instructions, WFunction} from \"../wasm\";\nimport {WLocal} from \"../wasm/functions\";\nimport {deadCodeElimination} from \"./dead_code\";\nimport {getFlags} from \"./flags\";\nimport {realloc_locals, remapLocals} from \"./flow/local_allocation\";\nimport {pre} from \"./flow/pre\";\nimport {rangeSplitting} from \"./flow/range_splitting\";\nimport {copyPropagation} from \"./flow/reaching_defs\";\nimport {Optimiser} from \"./optimiser\";\nimport {peepholeMulti, peepholeOptimisers} from \"./peephole\";\n\nconst optimisers: Optimiser[] = [];\n\nexport function optimise(fn: WFunction): void {\n    const flags = getFlags(), expr = fn.body;\n\n    fn.instrCounts.push({name: \"before opt\", count: countInstructions(expr)});\n    for (const optimiser of optimisers) {\n        if (optimiser.enabled(flags)) {\n            optimiser.run(expr);\n            fn.instrCounts.push({name: optimiser.name, count: countInstructions(expr)});\n        }\n    }\n}\n\nfunction countInstructions(expr: WExpression): number {\n    let num = expr.instructions.length;\n    for (const instr of expr.instructions) {\n        if (instr.type === \"structured\") {\n            num += countInstructions(instr.immediate.expression);\n            if (instr.immediate.expression2) num += countInstructions(instr.immediate.expression2);\n        }\n    }\n    return num;\n}\n\nfunction peepholeOptimisations(expr: WExpression) {\n    const flags = getFlags();\n    peepholeMulti(expr, peepholeOptimisers.filter(x => x.enabled(flags)).map(x => [x.run, x.peepholeSize]));\n}\n\noptimisers.push({\n    name: \"Peephole optimisations\",\n    enabled: () => true,\n    run: peepholeOptimisations\n});\n\noptimisers.push({\n    name: \"Partial redundancy elimination\",\n    enabled: (flags) => flags.partial_redundancy_elimination,\n    run: pre\n});\n\noptimisers.push({\n    name: \"Dead code elimination\",\n    enabled: (flags) => flags.dead_code_elimination,\n    run: deadCodeElimination\n});\n\noptimisers.push({\n    name: \"Copy propagation\",\n    enabled: (flags) => flags.copy_propagation,\n    run: copyPropagation\n});\n\noptimisers.push({\n    name: \"Local live range splitting\",\n    enabled: (flags) => flags.live_range_splitting,\n    run: rangeSplitting\n});\n\noptimisers.push({\n    name: \"Reallocate locals\",\n    enabled: (flags) => flags.reallocate_locals,\n    run: realloc_locals // must be ran when there are no redundant variables, i.e. immediate after copy propagation\n});\n\noptimisers.push({\n    name: \"Dead code elimination 2nd pass\",\n    enabled: (flags) => flags.dead_code_elimination,\n    run: deadCodeElimination\n});\n\noptimisers.push({\n    name: \"Remove unused locals\",\n    enabled: (flags) => flags.unused_locals,\n    run: (expr) => {\n        const usedLocals = new Set<WLocal>();\n        for (const resource of [...expr.writes, ...expr.reads]) {\n            if (resource instanceof WLocal && !resource.isArgument) usedLocals.add(resource);\n        }\n        if (usedLocals.size === expr.builder.locals.length) return;\n\n        // store current list of locals to enable lookup when re-encoding\n        const oldLocals = expr.builder.args.slice();\n        oldLocals.push(...expr.builder.locals);\n\n        // remove any unused locals from builder\n        for (const local of expr.builder.locals.slice()) { // slice needed to avoid modifying whilst iterating\n            if (!usedLocals.has(local)) {\n                expr.builder.deleteLocal(local);\n            }\n        }\n\n        // now have to re-encode any local instructions\n        remapLocals(expr, oldLocals);\n    }\n});\n\noptimisers.push({\n    name: \"Peephole optimisations 2nd pass\",\n    enabled: (flags) => flags.peephole_2nd_pass,\n    run: peepholeOptimisations\n});\n","import {optimise} from \"../optimisation\";\nimport {getFlags} from \"../optimisation/flags\";\nimport {funcidx, localidx, byte, tableidx} from \"./base_types\";\nimport {encodeU32} from \"./encoding\";\nimport {WExpression, WInstruction, Instructions} from \"./instructions\";\nimport {ModuleBuilder} from \"./module\";\nimport {ValueType, FunctionType, encodeVec} from \"./wtypes\";\n\n\nexport class WImportedFunction {\n    constructor(readonly parent: ModuleBuilder, readonly type: FunctionType, readonly module: string, readonly name: string) {\n    }\n\n    getIndex(): funcidx {\n        return this.parent._funcIndex(this);\n    }\n\n    getTableIndex(): tableidx {\n        return this.parent._tableIndex(this);\n    }\n}\n\nexport class WFunction {\n    private _builder?: WFunctionBuilder;\n    readonly hints: {inline: boolean} = {inline: false};\n    readonly instrCounts: {name: string, count: number}[] = [];\n\n    constructor(readonly parent: ModuleBuilder, readonly type: FunctionType, readonly exportName?: string) {\n    }\n\n    getIndex(): funcidx {\n        return this.parent._funcIndex(this);\n    }\n\n    getTableIndex(): tableidx {\n        return this.parent._tableIndex(this);\n    }\n\n    define(bodyFn: (b: WFunctionBuilder) => WInstruction[]): void {\n        if (this._builder !== undefined) throw new Error(`Wasm function already defined`);\n        this._builder = new WFunctionBuilder(this, bodyFn);\n        optimise(this);\n\n        const expr = this._builder.expr; // clean up function returns\n        if (this.type[1].length > 0) {\n            // if function returns something\n            const finalInstr = expr.get(-1);\n            if (finalInstr.name === \"return\") {\n                // final return can be implicit\n                expr.pop();\n            } else if (expr.stack.length === 0 && finalInstr.name !== \"unreachable\") {\n                // no return at end of function or value left on stack, must return elsewhere\n                expr.push(Instructions.unreachable());\n            }\n        }\n    }\n\n    toBytes(): byte[] {\n        if (this._builder === undefined) throw new Error(`Wasm function body not defined`);\n\n        // RLE is used to compress locals\n        const locals: [count: bigint, type: ValueType][] = [];\n        let lastType: ValueType | null = null;\n        let count = 0n;\n        for (const localType of this.locals) {\n            if (localType === lastType) {\n                count++;\n            } else {\n                if (lastType) locals.push([count, lastType]);\n                lastType = localType;\n                count = 1n;\n            }\n        }\n        if (lastType) locals.push([count, lastType]);\n\n        // encode function body\n        const code: byte[] = encodeVec(locals.map(x => [...encodeU32(x[0]), x[1]])); // locals\n        code.push(...this._builder.expr.encoded); // expression\n        code.unshift(...encodeU32(BigInt(code.length)));\n        return code;\n    }\n\n    get locals(): ReadonlyArray<ValueType> {\n        return this._builder?.locals?.map(x => x.type) ?? [];\n    }\n\n    get body(): WExpression {\n        if (!this._builder) throw new Error(\"Wasm function body is not yet defined\");\n        return this._builder.expr;\n    }\n}\n\nexport class WFunctionBuilder {\n    private readonly _arguments: WLocal[];\n    private readonly _locals: WLocal[] = [];\n    private readonly _freeTempLocals: WLocal[] = [];\n    readonly expr: WExpression;\n\n    constructor(readonly fn: WFunction, bodyFn: (b: WFunctionBuilder) => WInstruction[]) {\n        this._arguments = fn.type[0].map(t => new WLocal(this._localidx.bind(this), t, true));\n\n        this.expr = new WExpression(null, 0, this);\n        this.expr.push(...bodyFn(this));\n    }\n\n    get locals(): ReadonlyArray<WLocal> {\n        return this._locals;\n    }\n\n    addLocal(t: ValueType): WLocal {\n        const local = new WLocal(this._localidx.bind(this), t, false);\n        this._locals.push(local);\n        return local;\n    }\n\n    getTempLocal(type: ValueType): WLocal {\n        const index = this._freeTempLocals.findIndex(x => x.type === type);\n        if (index < 0) {\n            // no previous temporary local can be used, allocate a new one\n            return this.addLocal(type);\n        } else {\n            // reuse temporary local\n            return this._freeTempLocals.splice(index, 1)[0];\n        }\n    }\n\n    freeTempLocal(local: WLocal): void {\n        if (getFlags().reallocate_locals) {\n            // don't actually reuse variables - we will reallocate locals later\n            return;\n        }\n        this._freeTempLocals.push(local);\n    }\n\n    deleteLocal(local: WLocal): void {\n        // WARNING! this will invalidate any instructions already encoded\n        const index = this._locals.indexOf(local);\n        if (index >= 0) this._locals.splice(index, 1);\n    }\n\n    wipeLocals(): void {\n        // WARNING! this will invalidate any instructions already encoded\n        this._locals.splice(0, this._locals.length);\n    }\n\n    get args(): ReadonlyArray<WLocal> {\n        return this._arguments;\n    }\n\n    get self(): {getIndex(): funcidx} {\n        return {getIndex: this.fn.getIndex.bind(this.fn)};\n    }\n\n    get type(): FunctionType {\n        return this.fn.type;\n    }\n\n    getLocal(index: localidx): WLocal {\n        const i = Number(index);\n        if (index < this._arguments.length) return this._arguments[i];\n        return this._locals[i - this._arguments.length];\n    }\n\n    private _localidx(l: WLocal) {\n        let idx = this._arguments.indexOf(l);\n        if (idx >= 0) return BigInt(idx) as localidx;\n        idx = this._locals.indexOf(l);\n        if (idx >= 0) return BigInt(this._arguments.length + idx) as localidx;\n        throw \"Local not found?\";\n    }\n}\n\nexport class WLocal {\n    constructor(private readonly lookup: (l: WLocal) => localidx, readonly type: ValueType, readonly isArgument: boolean) {\n    }\n\n    getIndex(): localidx {\n        return this.lookup(this);\n    }\n}\n","import {byte, typeidx, funcidx, globalidx, tableidx} from \"./base_types\";\nimport {encodeU32, encodeUtf8, encodeConstantInstr} from \"./encoding\";\nimport {WFunctionBuilder, WFunction, WImportedFunction} from \"./functions\";\nimport {WGlobal} from \"./global\";\nimport {WInstruction} from \"./instructions\";\nimport {encodeVec, ResultType, encodeFunctionType, FunctionType, MemoryType, encodeLimits, ValueType, i32Type} from \"./wtypes\";\n\nexport class ModuleBuilder {\n    private _functions: WFunction[] = [];\n    private _importedFunctions: WImportedFunction[] = [];\n    private _functionTable: (WFunction | WImportedFunction)[] = [];\n    private _functionTypes: FunctionType[] = [];\n    private _globals: WGlobal[] = [];\n    private _memory?: MemoryType;\n    private _dataSegments: [offset: number, contents: byte[]][] = [];\n    startFunction?: WFunction;\n    emitCallback?: () => void;\n\n    function(params: ResultType, returnValue: ResultType, bodyFn?: (b: WFunctionBuilder) => WInstruction[], exportName?: string): WFunction {\n        const type: FunctionType = [params, returnValue];\n        const fn = new WFunction(this, type, exportName);\n        this._functions.push(fn);\n        if (bodyFn) fn.define(bodyFn); // have to add to list before defining to enable recursive calls\n        return fn;\n    }\n\n    importFunction(param: ResultType, returnValue: ResultType, module: string, name: string): WImportedFunction {\n        if (this._functions.length > 0) throw new Error(\"Cannot define an imported functions after defining normal functions\");\n\n        const fn = new WImportedFunction(this, [param, returnValue], module, name);\n        this._importedFunctions.push(fn);\n        return fn;\n    }\n\n    global(type: ValueType, mutable: boolean, initialValue: number | bigint, exportName?: string): WGlobal {\n        const g = new WGlobal(this, type, mutable, initialValue, exportName);\n        this._globals.push(g);\n        return g;\n    }\n\n    setupMemory(initial64kPages: number, maximum64kPages?: number): void {\n        if (initial64kPages < 1 || (maximum64kPages !== undefined && maximum64kPages < initial64kPages)) {\n            throw new Error(\"Invalid memory size\");\n        }\n\n        if (maximum64kPages === undefined) {\n            this._memory = [BigInt(initial64kPages)];\n        } else {\n            this._memory = [BigInt(initial64kPages), BigInt(maximum64kPages)];\n        }\n    }\n\n    dataSegment(offset: number, contents: byte[] | number[]): void {\n        // remove 0s from the start\n        let startIdx = 0;\n        while (startIdx < contents.length && contents[startIdx] === 0) startIdx++;\n        // always slice to ensure we take a copy\n        contents = contents.slice(startIdx);\n        offset += startIdx;\n\n        // remove 0s from the end\n        while (contents.length && contents[contents.length - 1] === 0) contents.pop();\n\n        if (contents.length) this._dataSegments.push([offset, contents as byte[]]);\n    }\n\n    private byteList(): byte[] {\n        const imports = this._encodeImports();\n        const funcTypes = this._functions.map(x => encodeU32(this._typeIndex(x.type)));\n        const code = this._functions.map(x => x.toBytes());\n        if (this.emitCallback) this.emitCallback();\n\n        const startSection: byte[] = [];\n        if (this.startFunction) {\n            startSection.push(...encodeU32(this.startFunction.getIndex()));\n            // do section encoding manually as this is the only non-vector section\n            startSection.unshift(8 as byte, ...encodeU32(BigInt(startSection.length)));\n        }\n\n        // TODO name custom section for local names (+ fn names?)\n        return [\n            0x00, 0x61, 0x73, 0x6D, // magic\n            0x01, 0x00, 0x00, 0x00, // version\n            ...encodeSection(1, this._functionTypes.map(encodeFunctionType)), // type section\n            ...encodeSection(2, imports), // import section\n            ...encodeSection(3, funcTypes), // function section,\n            ...encodeSection(4, this._encodeTable()), // table section\n            ...encodeSection(5, this._memory ? [encodeLimits(this._memory)] : []), // memory section\n            ...encodeSection(6, this._globals.map(x => x.toBytes())), // globals section\n            ...encodeSection(7, this._encodeExports()), // export section\n            ...startSection, // 8, start function section\n            ...encodeSection(9, this._encodeElements()),\n            ...encodeSection(10, code), // code section\n            ...encodeSection(11, this._encodeDataSegments()) // data segments section\n        ] as byte[];\n    }\n\n    toBytes(): Uint8Array {\n        return new Uint8Array(this.byteList());\n    }\n\n    async execute(imports: WebAssembly.Imports): Promise<WebAssembly.Exports> {\n        const module = await WebAssembly.instantiate(this.toBytes(), imports);\n        return module.instance.exports;\n    }\n\n    private _encodeImports(): byte[][] {\n        const imports: byte[][] = [];\n\n        for (const i of this._importedFunctions) {\n            imports.push([...encodeUtf8(i.module), ...encodeUtf8(i.name), 0x00 as byte, ...encodeU32(this._typeIndex(i.type))]);\n        }\n\n        return imports;\n    }\n\n    private _encodeTable(): byte[][] {\n        if (this._functionTable.length === 0) return [];\n\n        const tableSize = BigInt(this._functionTable.length);\n        const table: byte[] = [0x70 as byte, ...encodeLimits([tableSize, tableSize])];\n        return [table];\n    }\n\n    private _encodeExports(): byte[][] {\n        const exports: byte[][] = [];\n\n        for (const i of this._functions) {\n            if (i.exportName) exports.push([...encodeUtf8(i.exportName), 0x00 as byte, ...encodeU32(i.getIndex())]);\n        }\n        for (const i of this._globals) {\n            if (i.exportName) exports.push([...encodeUtf8(i.exportName), 0x03 as byte, ...encodeU32(i.getIndex())]);\n        }\n        if (this._memory) exports.push([...encodeUtf8(\"__mem\"), 0x02 as byte, 0x00 as byte]);\n\n        return exports;\n    }\n\n    private _encodeElements(): byte[][] {\n        if (this._functionTable.length === 0) return [];\n\n        return [[0x00 as byte,\n            ...encodeConstantInstr(0, i32Type), 0x0B as byte, // i32.const expression\n            ...encodeVec(this._functionTable.map(x => encodeU32(x.getIndex())))]];\n    }\n\n    private _encodeDataSegments(): byte[][] {\n        if (this._dataSegments.length > 0 && this._memory === undefined) {\n            throw new Error(\"Cannot use data segments with memory disabled\");\n        }\n\n        // sort into offset order\n        this._dataSegments.sort((a,b) => a[0] - b[0]);\n\n        // merge segments\n        let lastEnd = -Infinity;\n        for (let i = 0; i < this._dataSegments.length; i++) {\n            const [offset, contents] = this._dataSegments[i];\n            if (lastEnd + 5 >= offset) { // between each segment min 5 byte overhead (0x00, 0x41, [offset], 0x0B, [size])\n                const previousContents = this._dataSegments[i - 1][1];\n                for (let i = lastEnd; i < offset; i++) previousContents.push(0 as byte);\n                previousContents.push(...contents);\n\n                this._dataSegments.splice(i, 1); // remove this segment now we have merged\n                i--;\n            }\n            lastEnd = offset + contents.length;\n        }\n\n        // convert each offset into `expression(i32.const offset)`\n        return this._dataSegments.map(([offset, contents]) => [0x00 as byte,\n            ...encodeConstantInstr(offset, i32Type), 0x0B as byte, // i32.const expression\n            ...encodeU32(BigInt(contents.length)), ...contents]); // byte vector\n    }\n\n    _funcIndex(fn: WFunction | WImportedFunction): funcidx {\n        let idx: number;\n        if (fn instanceof WImportedFunction) {\n            idx = this._importedFunctions.indexOf(fn);\n        } else {\n            idx = this._functions.indexOf(fn);\n        }\n        if (idx < 0) throw new Error(\"Function not found?\");\n        if (fn instanceof WFunction) idx += this._importedFunctions.length;\n        return BigInt(idx) as funcidx;\n    }\n\n    _tableIndex(fn: WFunction | WImportedFunction): tableidx {\n        let idx = this._functionTable.indexOf(fn);\n        if (idx < 0) {\n            idx = this._functionTable.push(fn) - 1;\n        }\n        return BigInt(idx) as tableidx;\n    }\n\n    _typeIndex(x: FunctionType): typeidx {\n        for (let i = 0; i < this._functionTypes.length; i++) {\n            const f = this._functionTypes[i];\n            if (f[0].length === x[0].length && f[0].every((v, i) => v === x[0][i]) &&\n                f[1].length === x[1].length && f[1].every((v, i) => v === x[1][i])) {\n                return BigInt(i) as typeidx;\n            }\n        }\n        return BigInt(this._functionTypes.push(x) - 1) as typeidx;\n    }\n\n    _globalIndex(g: WGlobal): globalidx {\n        const idx = this._globals.indexOf(g);\n        if (idx < 0) throw new Error(\"Global not found?\");\n        return BigInt(idx) as globalidx;\n    }\n\n    get functions(): ReadonlyArray<WFunction> {\n        return this._functions;\n    }\n\n    get functionImports(): ReadonlyArray<WImportedFunction> {\n        return this._importedFunctions;\n    }\n\n    _functionLookup(f: funcidx): WFunction | WImportedFunction {\n        if (f < this._importedFunctions.length) return this._importedFunctions[Number(f)];\n        return this._functions[Number(f) - this._importedFunctions.length];\n    }\n\n    _typeLookup(t: typeidx): FunctionType {\n        return this._functionTypes[Number(t)];\n    }\n\n    _globalLookup(g: globalidx): WGlobal {\n        return this._globals[Number(g)];\n    }\n\n    _inFunctionTable(f: WFunction | WImportedFunction): boolean {\n        return this._functionTable.indexOf(f) >= 0;\n    }\n\n    _removeFunction(f: WFunction): void {\n        const idx = this._functions.indexOf(f);\n        if (idx >= 0) this._functions.splice(idx, 1);\n    }\n}\n\nfunction encodeSection(id: number, vec: byte[][]): byte[] {\n    if (vec.length === 0) return [];\n\n    const contents = encodeVec(vec);\n    return [id as byte, ...encodeU32(BigInt(contents.length)), ...contents];\n}\n","import {ModuleBuilder, WFunction, WExpression, Instructions} from \"../../wasm\";\nimport type {funcidx} from \"../../wasm/base_types\";\nimport {remapLocals} from \"../flow/local_allocation\";\nimport {optimise} from \"../index\";\nimport {peephole} from \"../peephole\";\nimport {InstrSplicer} from \"../splicer\";\n\nexport function inlineFunctions(module: ModuleBuilder): void {\n    const map = FnInfo.infoMap(module);\n    const modifiedFns = new Set<WFunction>();\n\n    const splicer = new InstrSplicer();\n    for (const info of map.values()) {\n        for (const usage of info.inliningCandidates()) {\n            const argTypes = info.fn.type[0];\n            const newLocals = [...argTypes, ...info.fn.locals].map(x => usage.expr.builder.addLocal(x));\n            const returnType = info.fn.type[1][0] ?? null;\n\n            // create the structure for the inlining\n            const replacement = [];\n            for (let i = argTypes.length - 1; i >= 0; i--) {\n                replacement.push(Instructions.local.set(newLocals[i]));\n            }\n            replacement.push(Instructions.block(returnType, []));\n            splicer.splice(usage, 1, replacement);\n\n            const blockIndex = splicer.realIndex(usage) + argTypes.length;\n            const block = usage.expr.instructions[blockIndex];\n            if (!block || block.type !== \"structured\" || block.immediate.expression.instructions.length !== 0) {\n                throw new Error(\"Failed to inline function\");\n            }\n\n            // actually copy the function and modify as needed\n            info.fn.body.copyInto(block.immediate.expression);\n            remapLocals(block.immediate.expression, newLocals);\n            peephole(block.immediate.expression, ([instr], depth) => {\n                if (instr.name === \"return\") {\n                    // replace returns with br to the encapsulating block\n                    return [returnType ? Instructions.br(depth, returnType) : Instructions.br(depth)];\n                }\n            }, 1);\n\n            modifiedFns.add(usage.fn);\n        }\n    }\n\n    for (const fn of modifiedFns) { // clean up any modified functions\n        optimise(fn);\n    }\n    if (modifiedFns.size) removeUnusedFns(module);\n\n    // FIXME nested inlining?\n}\n\nexport function removeUnusedFns(module: ModuleBuilder): void {\n    const map = FnInfo.infoMap(module);\n    const functions = [...module.functions, ...module.functionImports].map(x => {\n        const info = map.get(x as WFunction);\n        if (info?.usages.length === 0 && !info.inTable && !info.exported) {\n            module._removeFunction(x as WFunction);\n            return undefined;\n        }\n        return x;\n    });\n\n    const startingIndex = functions.indexOf(undefined);\n    if (startingIndex === -1) return; // no functions to remove\n\n    for (let i = startingIndex + 1; i < functions.length; i++) {\n        const fn = functions[i];\n        const info = map.get(fn as WFunction);\n        if (!fn || !info) continue;\n\n        for (const usage of info.usages) {\n            usage.expr.replace(usage.instrIndex, usage.instrIndex + 1, Instructions.call(fn));\n        }\n    }\n}\n\ntype Usage = {fn: WFunction, fnInfo: FnInfo, expr: WExpression, instrIndex: number};\n\nclass FnInfo {\n    usages: Usage[] = [];\n    size: number = 0;\n    inTable: boolean;\n    exported: boolean;\n\n    constructor(readonly fn: WFunction, private readonly fnMap: Map<WFunction, FnInfo>) {\n        this.inTable = fn.parent._inFunctionTable(fn);\n        this.exported = fn.exportName !== undefined;\n    }\n\n    analyze() {\n        if (this.size > 0) return;\n\n        const exprQueue = [this.fn.body];\n        let expr;\n        while ((expr = exprQueue.shift()) !== undefined) {\n            this.size += expr.instructions.length;\n            for (const [i, instr] of expr.instructions.entries()) {\n                if (instr.type === \"structured\") {\n                    exprQueue.push(instr.immediate.expression);\n                    if (instr.immediate.expression2) exprQueue.push(instr.immediate.expression2);\n                } else if (instr.type === \"index\" && instr.name === \"call\") {\n                    const target = this.fn.parent._functionLookup(instr.immediate.value as funcidx);\n                    const fnInfo = this.fnMap.get(target as WFunction);\n                    if (fnInfo) fnInfo.usages.push({fn: this.fn, fnInfo, expr, instrIndex: i});\n                }\n            }\n        }\n    }\n\n    inliningCandidates(): Usage[] {\n        if (this.size > 50 || this.usages.length === 0) return []; // never inline\n\n        let score = this.size;\n        score += Math.min(this.fn.body.builder.args.length - 1, 0) * 5; // one argument is okay\n        score += this.fn.locals.length * 5;\n        if (this.fn.hints.inline) score -= 20;\n\n        if (score <= 8 || (score <= 16 && this.usages.length <= 3 && !this.inTable && !this.exported)) {\n            // inline all (non-recursive) cases\n            return this.usages.filter(({fn}) => fn !== this.fn);\n        }\n        return [];\n    }\n\n    static infoMap(module: ModuleBuilder) {\n        const map = new Map<WFunction, FnInfo>();\n        for (const fn of module.functions) map.set(fn, new FnInfo(fn, map));\n        for (const info of map.values()) info.analyze();\n        return map;\n    }\n}\n","import {getFlags} from \"../optimisation/flags\";\nimport {CConstant} from \"../ir/expressions\";\nimport * as c from \"../ir/statements\";\nimport {CArithmetic, CPointer} from \"../ir/types\";\nimport {Instructions, i32Type, i64Type} from \"../wasm\";\nimport {labelidx} from \"../wasm/base_types\";\nimport {WInstruction} from \"../wasm/instructions\";\nimport {subExpr, condition, expressionGeneration, gInstr} from \"./expressions\";\nimport {GenError} from \"./gen_error\";\nimport {WFnGenerator} from \"./generator\";\nimport {storageSetupScope, memcpy} from \"./storage\";\nimport {valueType, largeReturn} from \"./type_conversion\";\n\nfunction _compoundStatement(ctx: WFnGenerator, s: c.CCompoundStatement): WInstruction[] {\n    const [instr, finishCallback] = storageSetupScope(ctx, s.scope);\n    if (s.scope.labelledStatement === undefined) {\n        instr.push(...s.statements.flatMap(s2 => statementGeneration(ctx, s2)));\n    } else {\n        // place all the instructions before the labelled statement in a block to enable jumping forward\n        const blockStatements: c.CStatement[] = [];\n        // place all the instructions after and including the labelled statement in a loop to enable jumping back\n        const loopStatements: c.CStatement[] = [];\n        for (const statement of s.statements) {\n            if (loopStatements.length > 0 || s.scope.labelledStatement.body === statement) {\n                loopStatements.push(statement);\n            } else {\n                blockStatements.push(statement);\n            }\n        }\n\n        // only need to store the break depth once as they are at the same depth\n        instr.push(\n            Instructions.block(null, blockStatements.flatMap(s2 => statementGeneration(ctx, s2)), storeBreakDepth(s.scope.labelledStatement)),\n            Instructions.loop(null, loopStatements.flatMap(s2 => statementGeneration(ctx, s2)))\n        );\n    }\n    finishCallback();\n    return instr;\n}\n\nfunction _expressionStatement(ctx: WFnGenerator, s: c.CExpressionStatement): WInstruction[] {\n    return ctx.expression(s.expression, true);\n}\n\nfunction _nop(ctx: WFnGenerator, s: c.CNop): WInstruction[] {\n    return []; // [Instructions.nop()]\n}\n\nfunction _if(ctx: WFnGenerator, s: c.CIf): WInstruction[] {\n    const ifBody = s.ifBody === undefined ? [Instructions.nop()] : statementGeneration(ctx, s.ifBody);\n    const elseBody = s.elseBody === undefined ? undefined : statementGeneration(ctx, s.elseBody);\n\n    return [...condition(ctx, s.test), Instructions.if(null, ifBody, elseBody)];\n}\n\nfunction _forLoop(ctx: WFnGenerator, s: c.CForLoop): WInstruction[] {\n    if (s.body === undefined) throw new GenError(\"Invalid for loop body\", ctx, s.node);\n    const [instr, storageFinishCallback] = storageSetupScope(ctx, s.scope);\n\n    let init: WInstruction[] = [];\n    if (Array.isArray(s.init)) {\n        init = s.init.flatMap(e => ctx.expression(e.expression, true));\n    } else if (s.init !== undefined && !(s.init instanceof c.CNop)) {\n        init = ctx.expression(s.init.expression, true);\n    }\n\n    let test: WInstruction[] = [Instructions.i32.const(1n)];\n    if (s.test !== undefined && !(s.test instanceof c.CNop)) {\n        test = condition(ctx, s.test.expression);\n    }\n\n    let update: WInstruction[] = [];\n    if (s.update !== undefined) update = ctx.expression(s.update, true);\n\n    instr.push(...init,\n        Instructions.loop(null, [\n            ...test,\n            Instructions.if(null, [\n                Instructions.block(null, [\n                    ...statementGeneration(ctx, s.body),\n                ], storeContinueDepth(s)),\n                ...update,\n                Instructions.br(1) // jump back to start of loop\n            ], undefined, storeBreakDepth(s))\n        ])\n    );\n\n    storageFinishCallback();\n    return instr;\n}\n\nfunction _whileLoop(ctx: WFnGenerator, s: c.CWhileLoop): WInstruction[] {\n    if (s.body === undefined) throw new GenError(\"Invalid while loop body\", ctx, s.node);\n\n    return [Instructions.loop(null, [\n        ...condition(ctx, s.test),\n        Instructions.if(null, [\n            ...statementGeneration(ctx, s.body),\n            Instructions.br(1) // jump back to start of loop\n        ], undefined, storeBreakDepth(s))\n    ], storeContinueDepth(s))];\n}\n\nfunction _doLoop(ctx: WFnGenerator, s: c.CDoLoop): WInstruction[] {\n    if (s.body === undefined) throw new GenError(\"Invalid while loop body\", ctx, s.node);\n\n    return [Instructions.block(null, [\n        Instructions.loop(null, [\n            ...statementGeneration(ctx, s.body),\n            ...condition(ctx, s.test),\n            Instructions.br_if(0)\n        ], storeContinueDepth(s))\n    ], storeBreakDepth(s))];\n}\n\nfunction _switch(ctx: WFnGenerator, s: c.CSwitch): WInstruction[] {\n    const type = valueType(s.expression.type as CArithmetic);\n    return ctx.withTemporaryLocal(type, value => {\n        const initInstr: WInstruction[] = [\n            ...expressionGeneration(ctx, s.expression, false),\n            Instructions.local.set(value)\n        ];\n\n        let defaultIndex = s.children.findIndex(x => x.default);\n        if (defaultIndex === -1) defaultIndex = s.children.length;\n\n        const checks: WInstruction[] = [];\n        // check if we can use br_table\n        let minValue = 2n ** 65n, maxValue = -minValue, numCases = 0;\n        for (const child of s.children) {\n            for (const sCase of child.cases) {\n                if (sCase.value > maxValue) maxValue = BigInt(sCase.value);\n                if (sCase.value < minValue) minValue = BigInt(sCase.value);\n                numCases++;\n            }\n        }\n        if (maxValue - minValue <= Math.min(2 ** 16, numCases * 8) && getFlags().generation_switch_br_table) { // basic heuristic\n            // use br_table\n            checks.push(Instructions.local.get(value));\n            if (minValue < 0 || minValue > 16) { // adjust to start at zero\n                const typeInstrs = type === i32Type ? Instructions.i32 : Instructions.i64;\n                checks.push(typeInstrs.const(minValue), typeInstrs.sub());\n            } else {\n                minValue = 0n;\n            }\n            if (type === i64Type) checks.push(Instructions.i32.wrap_i64());\n\n            // build actual jump table\n            const table: number[] = Array(Number(maxValue - minValue) + 1).fill(defaultIndex);\n            for (const [depth, child] of s.children.entries()) {\n                for (const sCase of child.cases) {\n                    table[Number(sCase.value) - Number(minValue)] = depth;\n                }\n            }\n\n            checks.push(Instructions.br_table(defaultIndex, table));\n\n        } else {\n            // use manual jump table\n            for (const [depth, child] of s.children.entries()) {\n                for (const sCase of child.cases) {\n                    if (sCase.type instanceof CPointer) throw new GenError(\"Invalid switch case\", ctx, s.node);\n                    const constant = new CConstant(s.node, sCase.type, sCase.value);\n                    checks.push(Instructions.local.get(value), ...subExpr(ctx, constant, s.expression.type), gInstr(type, \"eq\"));\n                    checks.push(Instructions.br_if(depth));\n                }\n            }\n            // add default\n            checks.push(Instructions.br(defaultIndex));\n        }\n\n        // case bodies\n        let block = Instructions.block(null, checks);\n        for (let i = 0; i < s.children.length; i++) {\n            block = Instructions.block(null, [\n                block,\n                ...ctx.statement(s.children[i].body)\n            ], i === s.children.length - 1 ? storeBreakDepth(s) : undefined); // final case body is also break target\n        }\n\n        return [...initInstr, block];\n    });\n}\n\nfunction _goto(ctx: WFnGenerator, s: c.CGoto): WInstruction[] {\n    return [Instructions.br({\n        getIndex(depth: number): labelidx {\n            const statement = s.target as any as Record<typeof breakDepthSymbol, number | undefined>;\n            const targetDepth = statement[breakDepthSymbol];\n            if (targetDepth === undefined) throw new GenError(\"Failed to find target depth\", ctx, s.node);\n\n            return BigInt(depth - targetDepth) as labelidx;\n        }\n    })];\n}\n\nfunction _continue(ctx: WFnGenerator, s: c.CContinue): WInstruction[] {\n    return [Instructions.br({\n        getIndex(depth: number): labelidx {\n            const statement = s.loop as any as Record<typeof continueDepthSymbol, number | undefined>;\n            const targetDepth = statement[continueDepthSymbol];\n            if (targetDepth === undefined) throw new GenError(\"Failed to find continue depth\", ctx, s.node);\n\n            return BigInt(depth - targetDepth) as labelidx;\n        }\n    })];\n}\n\nfunction _break(ctx: WFnGenerator, s: c.CBreak): WInstruction[] {\n    return [Instructions.br({\n        getIndex(depth: number): labelidx {\n            const statement = s.target as any as Record<typeof breakDepthSymbol, number | undefined>;\n            const targetDepth = statement[breakDepthSymbol];\n            if (targetDepth === undefined) throw new GenError(\"Failed to find break depth\", ctx, s.node);\n\n            return BigInt(depth - targetDepth) as labelidx;\n        }\n    })];\n}\n\nfunction _return(ctx: WFnGenerator, s: c.CReturn): WInstruction[] {\n    if (s.value === undefined) {\n        return [Instructions.return()];\n    } else if (largeReturn(s.func.type.returnType)) {\n        // copy return value to large return parameter (the last parameter)\n        return [...memcpy(\n            subExpr(ctx, s.value, s.func.type.returnType),\n            [Instructions.local.get(s.func.type.parameterTypes.length)],\n            s.value.type.bytes),\n        Instructions.return()];\n    } else {\n        return [...subExpr(ctx, s.value, s.func.type.returnType), Instructions.return()];\n    }\n}\n\nexport function statementGeneration(ctx: WFnGenerator, s: c.CStatement): WInstruction[] {\n    if (s instanceof c.CCompoundStatement) return _compoundStatement(ctx, s);\n    else if (s instanceof c.CExpressionStatement) return _expressionStatement(ctx, s);\n    else if (s instanceof c.CNop) return _nop(ctx, s);\n    else if (s instanceof c.CIf) return _if(ctx, s);\n    else if (s instanceof c.CForLoop) return _forLoop(ctx, s);\n    else if (s instanceof c.CWhileLoop) return _whileLoop(ctx, s);\n    else if (s instanceof c.CDoLoop) return _doLoop(ctx, s);\n    else if (s instanceof c.CSwitch) return _switch(ctx, s);\n    else if (s instanceof c.CGoto) return _goto(ctx, s);\n    else if (s instanceof c.CContinue) return _continue(ctx, s);\n    else if (s instanceof c.CBreak) return _break(ctx, s);\n    else return _return(ctx, s);\n}\n\n// break and continue depth helpers\nconst breakDepthSymbol = Symbol(\"break depth\");\nconst continueDepthSymbol = Symbol(\"continue depth\");\n\nfunction storeBreakDepth<T extends c.CForLoop | c.CWhileLoop | c.CDoLoop | c.CSwitch | c.CLabelledStatement>(s: T): (c: {depth: number}) => void {\n    const statement = s as Record<typeof breakDepthSymbol, any>;\n    return ({depth}) => {\n        // passed the instruction's context, so the depth of the structured instruction is depth + 1\n        statement[breakDepthSymbol] = depth + 1;\n    };\n}\n\nfunction storeContinueDepth<T extends c.CForLoop | c.CWhileLoop | c.CDoLoop>(s: T): (c: {depth: number}) => void {\n    const statement = s as Record<typeof continueDepthSymbol, any>;\n    return ({depth}) => {\n        statement[continueDepthSymbol] = depth + 1;\n    };\n}\n","import type {Linker} from \"../linker\";\nimport {interproceduralOptimise} from \"../optimisation/interprocedural\";\nimport {getFlags} from \"../optimisation/flags\";\nimport {CFuncDefinition, CFuncDeclaration} from \"../ir/declarations\";\nimport type {CExpression} from \"../ir/expressions\";\nimport type {CStatement} from \"../ir/statements\";\nimport {CArithmetic, CFuncType, CPointer} from \"../ir/types\";\nimport {ModuleBuilder, WFunctionBuilder, WFunction, Instructions, WImportedFunction, ValueType, i32Type} from \"../wasm\";\nimport type {funcidx, tableidx, typeidx} from \"../wasm/base_types\";\nimport type {WLocal} from \"../wasm/functions\";\nimport type {WGlobal} from \"../wasm/global\";\nimport type {WInstruction} from \"../wasm/instructions\";\nimport {FunctionType} from \"../wasm/wtypes\";\nimport {expressionGeneration} from \"./expressions\";\nimport {GenError} from \"./gen_error\";\nimport {statementGeneration} from \"./statements\";\nimport {storageSetupStaticVar} from \"./storage\";\nimport {realType, returnType, largeReturn} from \"./type_conversion\";\n\nexport const SHADOW_STACK_SIZE = 2 ** 20;\nexport const FIRST_STATIC_ADDR = 32; // reserve first 32 bytes as 0\n\nexport class WGenerator {\n    readonly module: ModuleBuilder;\n    readonly functions = new Map<CFuncDefinition | CFuncDeclaration, WFunction | WImportedFunction>();\n\n    // current memory pointers\n    nextStaticAddr = FIRST_STATIC_ADDR;\n    _shadowStackPtr?: WGlobal;\n\n    constructor(linker: Linker) {\n        this.module = new ModuleBuilder();\n\n        const staticInitializers = [];\n        for (const variable of linker.emitVariables) {\n            const initializer = storageSetupStaticVar(this, variable);\n            if (initializer) staticInitializers.push(initializer);\n        }\n\n        // add all functions\n        for (const funcImport of linker.emitImports) this.importFunction(funcImport);\n        for (const func of linker.emitExportedFunctions) this.function(func, func.name);\n        for (const func of linker.emitFunctions) this.function(func);\n\n        // define non-imported functions\n        for (const [cfunc, wfunc] of this.functions.entries()) {\n            if (cfunc instanceof CFuncDefinition && wfunc instanceof WFunction) {\n                wfunc.define(b => this.functionBody(cfunc, b));\n            }\n        }\n\n        for (const initializer of staticInitializers) initializer();\n\n        interproceduralOptimise(this.module);\n\n        this.module.emitCallback = () => {\n            const staticSize = Math.ceil(this.nextStaticAddr / 1024) * 1024;\n            if (this._shadowStackPtr) {\n                const shadowStackStart = staticSize + 1024; // between 1024-2047 byte buffer\n                this._shadowStackPtr.initialValue = BigInt(shadowStackStart);\n                this.module.setupMemory(Math.ceil((shadowStackStart + SHADOW_STACK_SIZE) / 65536));\n            } else if (this.isMemoryUsed()) {\n                this.module.setupMemory(Math.ceil(staticSize / 65536));\n            }\n        };\n    }\n\n    get shadowStackPtr(): WGlobal {\n        if (!this._shadowStackPtr) {\n            this._shadowStackPtr = this.module.global(i32Type, true, 0n, \"__sp\");\n        }\n        return this._shadowStackPtr;\n    }\n\n    private isMemoryUsed(): boolean {\n        if (this._shadowStackPtr || this.nextStaticAddr > FIRST_STATIC_ADDR) return true;\n\n        for (const f of this.module.functions) {\n            for (const instr of f.body.instructionsRecursive()) {\n                if (instr.type === \"structured\") {\n                    // structured instructions include the resources used by child instructions\n                    // and can't directly read/write memory\n                    continue;\n                }\n                if (instr.name === \"call\" || instr.name === \"call_indirect\") {\n                    // call instructions include \"memory\" to ensure flow analysis is safe\n                    continue;\n                }\n                if (instr.reads.includes(\"memory\") || instr.writes.includes(\"memory\")) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    private function(func: CFuncDefinition, name?: string) {\n        if (largeReturn(func.type.returnType)) {\n            // would be hard to correctly call, so don't export\n            name = undefined;\n        }\n        if (name && !func.type.parameterTypes.every(t => t instanceof CArithmetic)) {\n            // ensure ssp is included for argument passing when exported unless arguments are all numbers\n            this.shadowStackPtr;\n        }\n\n        const wasmFunc = this.module.function(...WGenerator.funcType(func.type), undefined, name);\n        wasmFunc.hints.inline = func.hints.inline;\n        this.functions.set(func, wasmFunc);\n    }\n\n    private functionBody(s: CFuncDefinition, b: WFunctionBuilder): WInstruction[] {\n        const fnGenerator = new WFnGenerator(this, b, s.name);\n        const body = fnGenerator.statement(s.body);\n\n        if (fnGenerator.shadowStackUsage > 0 && getFlags().generation_zero_shadow_stack) {\n            // use memory.fill to ensure shadow stack space is 0 before fn runs\n            // not technically needed as automatic variables do not have default initializers\n            body.unshift(\n                Instructions.global.get(this.shadowStackPtr),\n                Instructions.i32.const(0),\n                Instructions.i32.const(fnGenerator.shadowStackUsage),\n                Instructions.memory.fill()\n            );\n        }\n        return body;\n    }\n\n    private importFunction(func: CFuncDeclaration) {\n        const wasmFunc = this.module.importFunction(\n            func.type.parameterTypes.map(realType),\n            returnType(func.type.returnType),\n            \"c2wasm\",\n            func.name);\n        this.functions.set(func, wasmFunc);\n    }\n\n    functionIndex(fn: CFuncDeclaration | CFuncDefinition): {getIndex(): funcidx} {\n        if (fn instanceof CFuncDeclaration && fn.definition !== undefined) fn = fn.definition.getFunction();\n\n        return {\n            getIndex: () => {\n                const wasmFunc = this.functions.get(fn);\n                if (wasmFunc === undefined) throw new GenError(`Function '${fn.name}' not emitted`, undefined, fn.node);\n                return wasmFunc.getIndex();\n            }\n        };\n    }\n\n    private static funcType(fnType: CFuncType): FunctionType {\n        const paramTypes = fnType.parameterTypes.map(realType);\n        if (largeReturn(fnType.returnType)) {\n            paramTypes.push(i32Type); // add additional argument for large return pointer\n        }\n\n        return [paramTypes, returnType(fnType.returnType)];\n    }\n\n    typeIndex(fnType: CFuncType): typeidx {\n        return this.module._typeIndex(WGenerator.funcType(fnType));\n    }\n\n    indirectIndex(fn: CFuncDeclaration | CFuncDefinition): tableidx {\n        if (fn instanceof CFuncDeclaration && fn.definition !== undefined) fn = fn.definition.getFunction();\n\n        const wasmFunc = this.functions.get(fn);\n        if (wasmFunc === undefined) throw new GenError(`Function '${fn.name}' not emitted`, undefined, fn.node);\n        return wasmFunc.getTableIndex();\n    }\n}\n\nexport class WFnGenerator {\n    shadowStackUsage: number = 0;\n\n    constructor(readonly gen: WGenerator, readonly builder: WFunctionBuilder, readonly fnName: string) {\n    }\n\n    statement(s: CStatement): WInstruction[] {\n        return statementGeneration(this, s);\n    }\n\n    expression(e: CExpression, discardResult: boolean): WInstruction[] {\n        return expressionGeneration(this, e, discardResult);\n    }\n\n    withTemporaryLocal<T>(type: ValueType, expressionFn: (local: WLocal) => T): T {\n        const local = this.builder.getTempLocal(type);\n        const expression = expressionFn(local);\n        this.builder.freeTempLocal(local);\n        return expression;\n    }\n}\n","import {ModuleBuilder} from \"../../wasm\";\nimport {getFlags} from \"../flags\";\nimport {inlineFunctions} from \"./functions\";\n\nexport function interproceduralOptimise(module: ModuleBuilder): void {\n    const flags = getFlags();\n    if (flags.inlining) inlineFunctions(module);\n}\n","import {CVarDefinition} from \"../declarations\";\nimport {CConstant} from \"../expressions\";\nimport {Scope} from \"../scope\";\nimport {CType, getArithmeticType, CPointer, addQualifier, CFuncType, CNotFuncType, CArray, CEnum, CStruct, CUnion, CCompoundMember, CVoid, CArithmetic} from \"../types\";\nimport {ParseTreeValidationError, pt} from \"../../parsing/\";\nimport {evalIntegerConstant} from \"./expr_transform\";\n\ntype GeneralTypeDecl = {\n    typeInfo: pt.SpecifierQualifiers | pt.DeclarationSpecifiers,\n    declarator?: pt.Declarator | pt.AbstractDeclarator\n};\n\n/** helper function for specifier & declarator type */\nexport function getType(o: GeneralTypeDecl, scope: Scope): CType {\n    let type = getSpecifierType(o.typeInfo, scope);\n    if (o.typeInfo.qualifierList.length) type = addQualifier(type, o.typeInfo.qualifierList[0]);\n    if (o.declarator) type = getDeclaratorType(type, o.declarator, scope);\n    return type;\n}\n\n/** transform the CType from a type specifier into the declarator type */\nexport function getDeclaratorType(type: CType, declarator: pt.Declarator | pt.AbstractDeclarator, scope: Scope): CType {\n    let d: pt.Declarator | pt.AbstractDeclarator | undefined = declarator;\n\n    while (d && !(d instanceof pt.IdentifierDeclarator)) {\n        if (d instanceof pt.PointerDeclarator || d instanceof pt.AbstractPointerDeclarator) {\n            let ptr: pt.Pointer | undefined = d.pointer;\n            while (ptr) {\n                type = new CPointer(ptr, type, ptr.qualifierList?.includes(\"const\"));\n                ptr = ptr.body;\n            }\n            d = d.body;\n\n        } else if (d instanceof pt.ArrayDeclarator || d instanceof pt.AbstractArrayDeclarator) {\n            type = new CArray(d, type);\n            if (d.length) {\n                type.length = Number(evalIntegerConstant(d.length, scope).value);\n                if (type.length <= 0) throw new ParseTreeValidationError(d.length, \"Invalid array length\");\n            }\n            d = d.body;\n\n        } else { // d instanceof pt.(Abstract)FunctionDeclarator\n            const parameterTypes = [];\n            let parameterNames = undefined;\n\n            for (const param of d.args ?? []) {\n                let type = getType(param, scope);\n                if (type instanceof CArray) {\n                    // in function parameters arrays are equivalent to pointers\n                    type = new CPointer(type.node, type.type);\n                } else if (type instanceof CFuncType) {\n                    throw new ParseTreeValidationError(param, \"Functions cannot be parameters\");\n                }\n                parameterTypes.push(type);\n\n                if (param.declarator && !param.declarator.abstractDeclarator) {\n                    parameterNames ??= [];\n                    parameterNames.push(getDeclaratorName(param.declarator));\n                }\n\n                if (parameterNames && parameterNames.length !== parameterTypes.length) {\n                    throw new ParseTreeValidationError(param, \"Unexpected mix of abstract & non-abstract declarators\");\n                }\n            }\n\n            if (parameterTypes.length === 1 && parameterTypes[0] instanceof CVoid) parameterTypes.shift();\n\n            if (parameterTypes.length === 0) {\n                // ensure parameterNames are always non-null in function definitions\n                parameterNames = [];\n            }\n\n            type = new CFuncType(d, type as CNotFuncType, parameterTypes, parameterNames, d.variadic);\n            d = d.body;\n        }\n    }\n    return type;\n}\n\nexport function getDeclaratorName(declarator: pt.Declarator | pt.InitDeclarator): string {\n    while (!(declarator instanceof pt.IdentifierDeclarator)) {\n        declarator = declarator.body;\n    }\n    return declarator.id;\n}\n\n/** Get the base type from the list of specifiers */\nfunction getSpecifierType(d: pt.SpecifierQualifiers | pt.DeclarationSpecifiers, scope: Scope): CType {\n    const specifiers = d.specifierList;\n    const singleSpecifier = specifiers.length === 1 ? specifiers[0] : undefined;\n\n    if (singleSpecifier instanceof pt.StructUnionSpecifier) {\n        const type = singleSpecifier.structure === \"struct\" ? CStruct : CUnion;\n        let structure = new type(singleSpecifier, singleSpecifier.id);\n        if (singleSpecifier.id) {\n            // lookup tag and if it already exists use the existing instance\n            const existing: CStruct | CUnion = scope.lookupTag(singleSpecifier.id, type as any, singleSpecifier) as any;\n            if (existing) {\n                structure = existing;\n            } else {\n                scope.addTag(structure);\n            }\n        }\n        if (!singleSpecifier.declarations) return structure;\n\n        const values: CCompoundMember[] = []; // populate struct/union members if provided\n        for (const declaration of singleSpecifier.declarations) {\n            const baseType = getType(declaration, scope);\n\n            for (const declarator of declaration.list) {\n                const type = getDeclaratorType(baseType, declarator, scope);\n                const name = getDeclaratorName(declarator);\n                if (type.incomplete || type.bytes === 0 || type instanceof CFuncType) {\n                    throw new ParseTreeValidationError(declarator, \"Type must be complete\");\n                }\n\n                values.push(new CCompoundMember(declaration, name, type));\n            }\n        }\n        structure.members = values;\n        structure.node = singleSpecifier; // set the parse node to point to the node which actually defined the members\n        return structure;\n\n    } else if (singleSpecifier instanceof pt.EnumSpecifier) {\n        let cEnum = new CEnum(singleSpecifier, singleSpecifier.id);\n        if (singleSpecifier.id) {\n            // lookup tag and if it already exists use its instance\n            const existing = scope.lookupTag(singleSpecifier.id, CEnum, singleSpecifier);\n            if (existing) {\n                cEnum = existing;\n            } else {\n                scope.addTag(cEnum);\n            }\n        }\n        if (!singleSpecifier.body) return CArithmetic.S32;\n\n        // enum members either provide their own value or use the last value + 1, starting at 0\n        let nextValue = 0n;\n        const values = [];\n        for (const e of singleSpecifier.body) { // populate enum\n            if (e.value) nextValue = evalIntegerConstant(e.value, scope).value;\n\n            // enum constants are `int`s!!!\n            const enumConstant = new CVarDefinition(e, e.id, addQualifier(CArithmetic.S32, \"const\"), \"static\", \"internal\");\n            enumConstant.staticValue = new CConstant(e, CArithmetic.S32, nextValue);\n\n            scope.addIdentifier(enumConstant); // add the enum member as a constant to the scope\n            values.push({name: e.id, value: nextValue++});\n        }\n        cEnum.values = values;\n        cEnum.node = singleSpecifier;\n        return CArithmetic.S32;\n\n    } else if (specifiers.every(x => typeof x === 'string')) {\n        // arithmetic or void\n        const type = getArithmeticType(specifiers as ReadonlyArray<pt.TypeSpecifier & string>);\n        if (type) return type;\n\n    } else if (specifiers.length === 1 && specifiers[0] instanceof pt.CustomTypeSpecifier) {\n        // typedef\n        return scope.lookupTypedef(specifiers[0].name);\n    }\n\n    throw new ParseTreeValidationError(d, \"Invalid specifier\");\n}\n","import {ParseNode, ParseTreeValidationError, pt} from \"../../parsing\";\nimport {\n    CExpression, CConstant, CIdentifier, CFunctionCall, CMemberAccess, CDereference, CConditional,\n    CAssignment, CStringLiteral, CIncrDecr, CAddressOf, CUnaryPlusMinus, CBitwiseNot, CLogicalNot, CSizeof, CAddSub,\n    CCast, CComma, CMulDiv, CMod, CShift, CRelational, CEquality, CBitwiseAndOr, CLogicalAndOr, CValue\n} from \"../expressions\";\nimport {Scope} from \"../scope\";\nimport {CArithmetic, CArray} from \"../types\";\nimport {constInteger} from \"./constant_expressions\";\nimport {getType} from \"./type_transform\";\n\n/** Transform expressions from the parse tree */\nexport function ptExpression(e: pt.Expression, scope: Scope): CExpression {\n    if (e instanceof pt.ConstantExpression) {\n        // pt.ConstantExpression is a wrapped class in the parse tree denoting where constant expressions are expected.\n        return ptExpression(e.expr, scope);\n\n    } else if (e instanceof pt.Constant) {\n        return ptConstant(e);\n\n    } else if (e instanceof pt.Identifier) {\n        const id = new CIdentifier(e, scope.lookupIdentifier(e.name, e));\n        if (scope.func) scope.func.dependencies.set(id.value, true);\n        return id;\n\n    } else if (e instanceof pt.StringLiteral) {\n        const arr: bigint[] = []; // split the literal into characters taking into account escape sequences\n        const charRegex = /[^\\\\\\n\"]|\\\\(?:[^x0-7\\n]|x[0-9a-fA-F]{1,2}|[0-7]{1,3})/y;\n        while (charRegex.lastIndex < e.value.length) {\n            const match = charRegex.exec(e.value);\n            if (match && charRegex.lastIndex !== 0) {\n                arr.push(BigInt(unescapeChar(match[0], e).codePointAt(0) ?? 0)); // unescape the char if needed\n            } else {\n                // regex didn't match the body for some reason, this shouldn't happen\n                throw new ParseTreeValidationError(e, \"Invalid string literal\");\n            }\n        }\n        arr.push(0n); // null terminator\n        return new CStringLiteral(e, arr);\n\n    } else if (e instanceof pt.UnaryExpression) {\n        return ptUnary(e, scope);\n\n    } else if (e instanceof pt.BinaryExpression) {\n        return ptBinary(e, scope);\n\n    } else if (e instanceof pt.SizeofExpression) {\n        if (e.body instanceof pt.Expression) { // sizeof [expression]\n            return new CSizeof(e, ptExpression(e.body, scope).type);\n        } else { // sizeof [type]\n            return new CSizeof(e, getType(e.body, scope));\n        }\n\n    } else if (e instanceof pt.CastExpression) {\n        return new CCast(e, getType(e.targetType, scope), ptExpression(e.body, scope));\n\n    } else if (e instanceof pt.FunctionCallExpression) {\n        return new CFunctionCall(e, ptExpression(e.fn, scope), (e.args ?? []).map(e => ptExpression(e, scope)));\n\n    } else if (e instanceof pt.MemberAccessExpression) {\n        let body = ptExpression(e.lhs, scope);\n        if (!e.pointer) { // transform into pointer access\n            body = new CAddressOf(e, body);\n        }\n        return new CMemberAccess(e, body, e.rhs);\n\n    } else if (e instanceof pt.ConditionalExpression) {\n        return new CConditional(e, ptExpression(e.condition, scope), ptExpression(e.trueValue, scope), ptExpression(e.falseValue, scope));\n\n    } else if (e instanceof pt.AssignmentExpression) {\n        return new CAssignment(e, ptExpression(e.lhs, scope), ptExpression(e.rhs, scope), e.assignType);\n\n    }\n\n    throw new ParseTreeValidationError(e, \"Invalid expression\");\n}\n\n/** Evaluate an expression at compile time to an integer constant */\nexport function evalIntegerConstant(c: pt.ConstantExpression, scope: Scope): CValue & {value: bigint} {\n    const expr = ptExpression(c.expr, scope);\n    return constInteger(expr);\n}\n\nfunction ptUnary(e: pt.UnaryExpression, scope: Scope): CExpression {\n    // transform unary expressions\n    const body = ptExpression(e.body, scope);\n    if (e.type === \"prefixIncrement\") return new CIncrDecr(e, body, \"++\", \"pre\");\n    if (e.type === \"prefixDecrement\") return new CIncrDecr(e, body, \"--\", \"pre\");\n    if (e.type === \"postfixIncrement\") return new CIncrDecr(e, body, \"++\", \"post\");\n    if (e.type === \"postfixDecrement\") return new CIncrDecr(e, body, \"--\", \"post\");\n    if (e.type === \"addressOf\") return new CAddressOf(e, body);\n    if (e.type === \"dereference\") return new CDereference(e, body);\n    if (e.type === \"unaryPlus\") return new CUnaryPlusMinus(e, body, \"+\");\n    if (e.type === \"unaryMinus\") return new CUnaryPlusMinus(e, body, \"-\");\n    if (e.type === \"bitwiseNot\") return new CBitwiseNot(e, body);\n    if (e.type === \"logicalNot\") return new CLogicalNot(e, body);\n\n    throw new ParseTreeValidationError(e, \"Invalid unary expression\");\n}\n\nfunction ptBinary(e: pt.BinaryExpression, scope: Scope): CExpression {\n    // transform binary expressions\n    const lhs = ptExpression(e.lhs, scope), rhs = ptExpression(e.rhs, scope);\n\n    if (e.type === \"mul\") return new CMulDiv(e, lhs, rhs, \"*\");\n    if (e.type === \"div\") return new CMulDiv(e, lhs, rhs, \"/\");\n    if (e.type === \"mod\") return new CMod(e, lhs, rhs);\n    if (e.type === \"add\") return new CAddSub(e, lhs, rhs, \"+\");\n    if (e.type === \"sub\") return new CAddSub(e, lhs, rhs, \"-\");\n    if (e.type === \"bitwiseShiftLeft\") return new CShift(e, lhs, rhs, \"left\");\n    if (e.type === \"bitwiseShiftRight\") return new CShift(e, lhs, rhs, \"right\");\n\n    if (e.type === \"relationalLT\") return new CRelational(e, lhs, rhs, \"LT\");\n    if (e.type === \"relationalGT\") return new CRelational(e, lhs, rhs, \"GT\");\n    if (e.type === \"relationalLEq\") return new CRelational(e, lhs, rhs, \"LEq\");\n    if (e.type === \"relationalGEq\") return new CRelational(e, lhs, rhs, \"GEq\");\n    if (e.type === \"relationalEq\") return new CEquality(e, lhs, rhs, \"==\");\n    if (e.type === \"relationalNEq\") return new CEquality(e, lhs, rhs, \"!=\");\n\n    if (e.type === \"bitwiseAnd\") return new CBitwiseAndOr(e, lhs, rhs, \"and\");\n    if (e.type === \"bitwiseXor\") return new CBitwiseAndOr(e, lhs, rhs, \"xor\");\n    if (e.type === \"bitwiseOr\") return new CBitwiseAndOr(e, lhs, rhs, \"or\");\n    if (e.type === \"logicalAnd\") return new CLogicalAndOr(e, lhs, rhs, \"and\");\n    if (e.type === \"logicalOr\") return new CLogicalAndOr(e, lhs, rhs, \"or\");\n\n    if (e.type === \"comma\") return new CComma(e, lhs, rhs);\n    if (e.type === \"arraySubscript\") {\n        // transform `a[b]` into `*(a+b)`\n        return new CDereference(e, new CAddSub(e, ptExpression(e.lhs, scope), ptExpression(e.rhs, scope), \"+\"));\n    }\n\n    throw new ParseTreeValidationError(e, \"Invalid binary expression\");\n}\n\n/** Transform a constant\n *\n * This is quite complicated because we have to work out what type to give the constant, following the rules set out in\n * the standard\n */\nexport function ptConstant(e: pt.Constant): CConstant {\n    let value = e.value;\n    let type: CArithmetic;\n\n    if (e.valueType === \"int\" || e.valueType === \"oct\" || e.valueType === \"hex\") {\n        let unsigned = false, long = false;\n        value = value.toLowerCase();\n        if (value.endsWith(\"u\")) {\n            value = value.slice(0, -1);\n            unsigned = true;\n        }\n        if (value.endsWith(\"l\")) {\n            value = value.slice(0, -1);\n            long = true;\n            // may be a second l for long long\n            if (value.endsWith(\"l\")) value = value.slice(0, -1);\n        }\n        if (!unsigned && value.endsWith(\"u\")) {\n            // check u again as u and l can appear in either order\n            value = value.slice(0, -1);\n            unsigned = true;\n        }\n\n        let num: bigint; // all integer constants are stored as BigInt\n        if (e.valueType !== \"oct\") {\n            // BigInt constructor natively handles decimal values and hexadecimal values prefixed with 0x\n            num = BigInt(value);\n        } else {\n            // Have to manually construct octal constants\n            num = 0n;\n            for (let i = 0; i < value.length - 1; i++) { // ignore the leading 0\n                num += BigInt(value[value.length - 1 - i]) * (8n ** BigInt(i));\n            }\n        }\n\n        // Choose the list of possible types from the suffixes and the constant type used (decimal, hex, octal)\n        let possibleTypes;\n        if (e.valueType === \"int\" && !unsigned && !long) {\n            possibleTypes = [CArithmetic.S32, CArithmetic.S64, CArithmetic.U64];\n        } else if (e.valueType !== \"int\" && !unsigned && !long) {\n            possibleTypes = [CArithmetic.S32, CArithmetic.U32, CArithmetic.S64, CArithmetic.U64];\n        } else if (unsigned && long) {\n            possibleTypes = [CArithmetic.U64];\n        } else if (long) {\n            possibleTypes = [CArithmetic.S64, CArithmetic.U64];\n        } else { // if (unsigned)\n            possibleTypes = [CArithmetic.U32, CArithmetic.U64];\n        }\n\n        // find smallest acceptable type which fits the value\n        for (const type of possibleTypes) {\n            if (num >= type.minValue && num <= type.maxValue) {\n                return new CConstant(e, type, num);\n            }\n        }\n        throw new ParseTreeValidationError(e, \"Integer constant too large for its type\");\n\n    } else if (e.valueType === \"float\") {\n        // floats default to double unless suffixed with \"f\"\n        if (value.endsWith(\"f\")) {\n            value = value.slice(0, -1);\n            type = CArithmetic.Fp32;\n        } else {\n            type = CArithmetic.Fp64;\n        }\n        return new CConstant(e, type, parseFloat(value));\n\n    } else if (e.valueType === \"char\") {\n        value = unescapeChar(value, e);\n        return new CConstant(e, CArithmetic.U8, BigInt(value.codePointAt(0)));\n    }\n\n    throw new ParseTreeValidationError(e, \"Invalid constant type?\");\n}\n\n/** Unescape strings as defined in the C standard */\nfunction unescapeChar(s: string, node?: ParseNode): string {\n    if (s.startsWith(\"\\\\\")) {\n        if (s === \"\\\\n\") return \"\\n\";\n        if (s === \"\\\\t\") return \"\\t\";\n        if (s === \"\\\\v\") return \"\\v\";\n        if (s === \"\\\\b\") return \"\\b\";\n        if (s === \"\\\\r\") return \"\\r\";\n        if (s === \"\\\\f\") return \"\\f\";\n        if (s === \"\\\\a\") return \"\\x07\";\n        if (s === \"\\\\\\\\\") return \"\\\\\";\n        if (s === \"\\\\?\") return \"?\";\n        if (s === \"\\\\'\") return \"'\";\n        if (s === '\\\\\"') return '\"';\n\n        let value: number;\n        if (s.startsWith(\"\\\\x\")) {\n            // hex constant\n            value = parseInt(s.slice(2), 16);\n        } else {\n            // octal constant\n            value = parseInt(s.slice(1), 8);\n        }\n\n        if (!isNaN(value) && value >= 0 && value <= 255) {\n            return String.fromCharCode(value);\n        }\n        throw new ParseTreeValidationError(node, \"Invalid character escape\");\n    }\n\n    const codePoint = s.codePointAt(0);\n    if (s.length !== 1 || codePoint === undefined || codePoint > 255) {\n        throw new ParseTreeValidationError(node, \"Invalid character\");\n    }\n    return s;\n}\n","import {parse} from \"../parsing\";\nimport {Expression, Constant, BinaryExpression, UnaryExpression, Identifier} from \"../parsing/parsetree\";\nimport {ptConstant} from \"../ir/transform/expr_transform\";\nimport {Preprocessor} from \"./preprocessor\";\n\nexport function ppEvaluate(x: string, preprocessor: Preprocessor): bigint {\n    const parseTree = parse(`int x = ${x};`);\n    if (parseTree.length !== 1 || parseTree[0].type !== \"declaration\" || parseTree[0].list.length !== 1 || parseTree[0].list[0].type !== \"initDeclarator\" || Array.isArray(parseTree[0].list[0].initializer)) {\n        throw preprocessor.error(\"Invalid #if conditional: `\" + x + \"`\");\n    }\n    const expression = parseTree[0].list[0].initializer as Expression;\n    return _eval(expression, preprocessor);\n}\n\nfunction _eval(n: Expression, preprocessor: Preprocessor): bigint {\n    if (n instanceof Constant && n.valueType !== \"float\") {\n        return BigInt(ptConstant(n).value);\n    } else if (n instanceof BinaryExpression) {\n        switch (n.type) {\n        case \"add\":\n            return _eval(n.lhs, preprocessor) + _eval(n.rhs, preprocessor);\n        case \"sub\":\n            return _eval(n.lhs, preprocessor) - _eval(n.rhs, preprocessor);\n        case \"mul\":\n            return _eval(n.lhs, preprocessor) * _eval(n.rhs, preprocessor);\n        case \"div\":\n            return _eval(n.lhs, preprocessor) / _eval(n.rhs, preprocessor);\n        case \"bitwiseAnd\":\n            return _eval(n.lhs, preprocessor) & _eval(n.rhs, preprocessor);\n        case \"bitwiseOr\":\n            return _eval(n.lhs, preprocessor) | _eval(n.rhs, preprocessor);\n        case \"bitwiseXor\":\n            return _eval(n.lhs, preprocessor) ^ _eval(n.rhs, preprocessor);\n        case \"bitwiseShiftLeft\":\n            return _eval(n.lhs, preprocessor) << _eval(n.rhs, preprocessor);\n        case \"bitwiseShiftRight\":\n            return _eval(n.lhs, preprocessor) >> _eval(n.rhs, preprocessor);\n        case \"relationalEq\":\n            return _eval(n.lhs, preprocessor) === _eval(n.rhs, preprocessor) ? 1n : 0n;\n        case \"relationalNEq\":\n            return _eval(n.lhs, preprocessor) !== _eval(n.rhs, preprocessor) ? 1n : 0n;\n        case \"relationalLT\":\n            return _eval(n.lhs, preprocessor) < _eval(n.rhs, preprocessor) ? 1n : 0n;\n        case \"relationalLEq\":\n            return _eval(n.lhs, preprocessor) <= _eval(n.rhs, preprocessor) ? 1n : 0n;\n        case \"relationalGT\":\n            return _eval(n.lhs, preprocessor) > _eval(n.rhs, preprocessor) ? 1n : 0n;\n        case \"relationalGEq\":\n            return _eval(n.lhs, preprocessor) >= _eval(n.rhs, preprocessor) ? 1n : 0n;\n        case \"logicalAnd\":\n            return (_eval(n.lhs, preprocessor) !== 0n && _eval(n.rhs, preprocessor) !== 0n) ? 1n : 0n;\n        case \"logicalOr\":\n            return (_eval(n.lhs, preprocessor) !== 0n || _eval(n.rhs, preprocessor) !== 0n) ? 1n : 0n;\n        }\n    } else if (n instanceof UnaryExpression) {\n        switch (n.type) {\n        case \"unaryPlus\":\n            return _eval(n.body, preprocessor);\n        case \"unaryMinus\":\n            return -(_eval(n.body, preprocessor));\n        case \"logicalNot\":\n            return _eval(n.body, preprocessor) === 0n ? 1n : 0n;\n        }\n    } else if (n instanceof Identifier) {\n        return 0n;\n    }\n\n    throw preprocessor.error(\"Invalid preprocessor expression\");\n}\n","// preprocessor tokens\nexport type Token = {\n    type?: \"identifier\", // with optional type\n    value: string\n};\n\n// various regexes used\nexport const PreProRegex = {\n    identifier: /^[a-zA-Z_][a-zA-Z0-9_]*/,\n    token: /^(?:\"(?:\\\\\"|[^\\n\"])*\"|[^ \\t\\v\\f\\na-zA-Z_]+)/,\n    whitespace: /^[ \\t\\v\\f]+/,\n    // used in first pass so is global and multiline\n    comments: /\\/\\*[^]*?\\*\\/|\\/\\/.*?$/gm,\n    // used to process conditions\n    condition: /defined(?:[ \\t]*\\([ \\t]*([a-zA-Z_][a-zA-Z0-9_]*)[ \\t]*\\)|[ \\t]+([a-zA-Z_][a-zA-Z0-9_]*))|(d?[^d]*)/gm\n};\n\n// functions to 'consume' text from an input line\ntype ConsumeFailed = { success: false, remainingLine: string };\ntype ConsumeSucceeded = { success: true, remainingLine: string } & Token;\n\n\nexport abstract class PreprocessorBase {\n\n    abstract error(message: string): Error;\n\n    /** Consume identifier, token or whitespace */\n    consumeAny(line: string): ConsumeSucceeded {\n        let match: ConsumeFailed | ConsumeSucceeded;\n        if ((match = this.consume(line, PreProRegex.identifier)).success) {\n            match.type = \"identifier\";\n            return match;\n        } else if ((match = this.consume(line, PreProRegex.token)).success) {\n            return match;\n        } else if ((match = this.consume(line, PreProRegex.whitespace)).success) {\n            return match;\n        }\n        throw this.error(\"Malformed input? Line does not match defined regular expressions.\\n`\" + line + \"`\");\n    }\n\n    /** Consume or throw error */\n    mustConsume(line: string, t: RegExp | string, errorName: string = t.toString()): ConsumeSucceeded {\n        const match = this.consume(line, t);\n        if (match.success) return match;\n\n        throw this.error(`Expected to find ${errorName} but found \\`${line}\\` instead`);\n    }\n\n    consume(line: string, t: RegExp | string): ConsumeFailed | ConsumeSucceeded {\n        if (typeof t === \"string\") {\n            if (line.startsWith(t)) {\n                return {success: true, value: t, remainingLine: line.substring(t.length)};\n            } else {\n                return {success: false, remainingLine: line};\n            }\n        }\n\n        const match = line.match(t);\n        if (match === null) {\n            return {success: false, remainingLine: line};\n        }\n        return {success: true, value: match[0], remainingLine: line.substring(match[0].length)};\n    }\n\n}\n","import {Token, PreProRegex} from \"./helpers\";\nimport type {Preprocessor} from \"./preprocessor\";\n\nexport class Definition {\n\n    constructor(readonly preprocessor: Preprocessor,\n                readonly identifier: string,\n                readonly replacement: Token[],\n                readonly parameters: string[]) {\n    }\n\n    expand(line: string): { output: string, line: string } {\n        if (this.parameters.length > 0) return this.expandWithParameters(line);\n\n        const output = this.replacement.map(x => x.value).join(\"\");\n        return {output, line};\n    }\n\n    private expandWithParameters(line: string) {\n        // check if macro call\n        const originalLine = line;\n        line = this.preprocessor.consume(line, PreProRegex.whitespace).remainingLine;\n        if (line.length === 0 || line[0] !== \"(\") {\n            // not referencing the definition\n            return {output: this.identifier, line: originalLine};\n        }\n        line = this.preprocessor.mustConsume(line, \"(\").remainingLine;\n\n        // consume args\n        const args: string[] = [];\n        for (let i = 0; i < this.parameters.length; i++) {\n            const match = this.consumeArgument(line);\n            args.push(match.value.trim());\n            if (i !== this.parameters.length - 1) {\n                line = this.preprocessor.mustConsume(match.remainingLine, \",\").remainingLine;\n            } else {\n                line = this.preprocessor.mustConsume(match.remainingLine, \")\").remainingLine;\n            }\n        }\n\n        // assemble output\n        let output = \"\";\n        for (const token of this.replacement) {\n            if (token.type === \"identifier\") {\n                const index = this.parameters.indexOf(token.value);\n                if (index >= 0) {\n                    output += this.preprocessor.expandDefinitions(args[index]);\n                    continue; // TODO repeat as needed\n                }\n            }\n            output += token.value;\n        }\n        return {output, line};\n    }\n\n    private consumeArgument(line: string): {value: string, remainingLine: string} {\n        const out = {value: \"\", remainingLine: line};\n        let inQuote = false, bracketDepth = 0;\n\n        while (out.remainingLine.length > 0 && (inQuote || bracketDepth !== 0 || (out.remainingLine[0] !== \",\" && out.remainingLine[0] !== \")\"))) {\n            const char = out.remainingLine[0];\n            let consumed = 1;\n\n            if (inQuote && char === `\\\\` && out.remainingLine[1] === `\"`) {\n                // escaped quote\n                consumed = 2;\n            } else if (!inQuote && char === `'`) {\n                consumed += Math.max(out.remainingLine.indexOf(`'`, 1), 0);\n            } else if (char === `\"`) {\n                inQuote = !inQuote;\n            } else if (char === `(` && !inQuote) {\n                bracketDepth++;\n            } else if (char === `)` && !inQuote) {\n                bracketDepth--;\n            }\n\n            out.value += out.remainingLine.substring(0, consumed);\n            out.remainingLine = out.remainingLine.substring(consumed);\n        }\n        return out;\n    }\n\n    equals(t: this): boolean {\n        return t.identifier === this.identifier &&\n            t.replacement.length === this.replacement.length &&\n            t.replacement.every((v, i) => v.value === this.replacement[i].value) &&\n            t.parameters.length === this.parameters.length &&\n            t.parameters.every((v, i) => v === this.parameters[i]);\n    }\n}\n","import {LIBRARY_HEADERS} from \"../c_library/standard_library\";\nimport {ppEvaluate} from \"./conditionals\";\nimport {Definition} from \"./definition\";\nimport {PreProRegex, PreprocessorBase} from \"./helpers\";\n\nexport class Preprocessor extends PreprocessorBase {\n    definitions = new Map<string, Definition>();\n\n    libraryFiles: Map<string, string>; // #include <...>\n    userFiles = new Map<string, string>(); // #include \"...\"\n\n    constructor(readonly filename: string, standardHeaders: boolean = true, customDefinitions?: {[key: string]: string}) {\n        super();\n        if (standardHeaders) {\n            this.libraryFiles = new Map<string, string>(LIBRARY_HEADERS);\n        } else {\n            this.libraryFiles = new Map<string, string>();\n        }\n\n        this.definitions.set(\"__FILE__\", new Definition(this, \"__FILE__\", [{value: `\"${filename}\"`}], []));\n        this.definitions.set(\"__c2wasm__\", new Definition(this, \"__c2wasm__\", [{value: \"1\"}], []));\n\n        if (customDefinitions) {\n            for (const [key, value] of Object.entries(customDefinitions)) {\n                this.definitions.set(key, new Definition(this, key, [{value}], []));\n            }\n        }\n    }\n\n    process(text: string, filename: string = this.filename): string {\n        // replace crlf with lf\n        text = text.replace(/\\r\\n/g, \"\\n\");\n        // remove comments\n        text = text.replace(PreProRegex.comments, \" \");\n        // remove line continuations\n        const lines = text.replace(/\\\\\\n/g, \"\").split(\"\\n\");\n\n        let output = \"\";\n        while (lines.length > 0) {\n            let line = lines.shift() as string;\n\n            if (line.startsWith(\"#\")) {\n                line = line.substring(1).trimStart();\n\n                let match: ReturnType<typeof Preprocessor.prototype[\"consume\"]>;\n                if ((match = this.consume(line, \"define\")).success) {\n                    this._define(match.remainingLine);\n                } else if ((match = this.consume(line, \"undef\")).success) {\n                    this._undef(match.remainingLine);\n                } else if ((match = this.consume(line, \"include\")).success) {\n                    output += this._include(match.remainingLine) + \"\\n\";\n                } else if ((match = this.consume(line, \"ifdef\")).success) {\n                    this._ifdef(match.remainingLine, true, lines);\n                } else if ((match = this.consume(line, \"ifndef\")).success) {\n                    this._ifdef(match.remainingLine, false, lines);\n                } else if ((match = this.consume(line, \"if\")).success) {\n                    output += this._if(match.remainingLine, lines);\n                } else if ((match = this.consume(line, \"pragma\")).success) {\n                    const l = this.mustConsume(match.remainingLine, PreProRegex.whitespace, \"whitespace\").remainingLine;\n                    if (l.trim() === \"once\") {\n                        // only include source file once\n                        const defName = `__pragma_once_${filename}__`;\n                        if (this.definitions.has(defName)) return output;\n                        this.definitions.set(defName, new Definition(this, defName, [], []));\n                    }\n                    // unknown pragmas must be ignored\n                } else if ((match = this.consume(line, \"error\")).success) {\n                    throw this.error(\"#\" + line);\n                } else if (line.trim().length > 1) {\n                    throw this.error(`Unknown preprocessor directive \"#${line}\"`);\n                }\n\n            } else {\n                output += this.expandDefinitions(line) + \"\\n\";\n            }\n        }\n        return output;\n    }\n\n    expandDefinitions(line: string, definitions = this.definitions): string {\n        let output = \"\";\n        while (line.length > 0) {\n            const token = this.consumeAny(line);\n            if (token?.type === \"identifier\") {\n                const def = definitions.get(token.value);\n                if (def !== undefined) {\n                    const e = def.expand(token.remainingLine);\n\n                    // \"once a given identifier has been replaced in a given expansion,\n                    // it is not replaced if it turns up again during rescanning\"\n                    const newDefinitions = new Map(definitions);\n                    newDefinitions.delete(token.value);\n\n                    let output1 = e.output, output2 = \"\";\n                    while (output1 !== output2) {\n                        output2 = output1;\n                        output1 = this.expandDefinitions(output1, newDefinitions);\n                    }\n\n                    output += output1;\n                    line = e.line;\n                    continue;\n                }\n            }\n            output += token?.value;\n            line = token.remainingLine;\n        }\n        return output;\n    }\n\n    error(message: string): Error {\n        return new class extends Error {\n            name = \"PreprocessorError\";\n        }(`In file '${this.filename}': ${message}`);\n    }\n\n    private _include(line: string): string {\n        line = this.mustConsume(line, PreProRegex.whitespace, \"whitespace\").remainingLine.trim();\n        if (line.startsWith('\"') && line.endsWith('\"')) {\n            return this._includeUser(line.substring(1, line.length - 1));\n        } else if (line.startsWith(\"<\") && line.endsWith(\">\")) {\n            return this._includeLib(line.substring(1, line.length - 1));\n        }\n\n        // if failed try expand macros\n        line = this.expandDefinitions(line);\n        if (line.startsWith('\"') && line.endsWith('\"')) {\n            return this._includeUser(line.substring(1, line.length - 1));\n        } else if (line.startsWith(\"<\") && line.endsWith(\">\")) {\n            return this._includeLib(line.substring(1, line.length - 1));\n        }\n\n        throw this.error(\"Invalid #include\");\n    }\n\n    private _includeLib(path: string) {\n        const file = this.libraryFiles.get(path);\n        if (file === undefined) throw this.error(\"Unknown path `\" + path + \"`\");\n        return this.process(file, `<${path}>`);\n    }\n\n    private _includeUser(path: string) {\n        const localPath = this.filename.replace(/[^/\\\\]*$/, path);\n        let file = this.userFiles.get(localPath);\n        if (file === undefined) {\n            file = this.userFiles.get(path);\n            if (file === undefined) return this._includeLib(path);\n        }\n        return this.process(file, path);\n    }\n    private _define(line: string) {\n        line = this.mustConsume(line, PreProRegex.whitespace, \"whitespace\").remainingLine;\n        const identifier = this.mustConsume(line, PreProRegex.identifier, \"identifier\");\n        const tokens = [];\n        const parameters: string[] = [];\n\n        if (identifier.remainingLine.trim().length > 0) {\n            if (identifier.remainingLine[0] === \"(\") {\n                // definition with parameters\n                line = this.mustConsume(identifier.remainingLine, \"(\").remainingLine;\n                while (line.length > 0) {\n                    line = this.consume(line, PreProRegex.whitespace).remainingLine;\n                    const parameter = this.mustConsume(line, PreProRegex.identifier, \"identifier\");\n                    parameters.push(parameter.value);\n                    line = this.consume(parameter.remainingLine, PreProRegex.whitespace).remainingLine;\n\n                    if (line.length === 0) {\n                        throw this.error(\"Unexpected end of line\");\n                    } else if (line[0] === \",\") {\n                        line = this.mustConsume(line, \",\").remainingLine;\n                    } else if (line[0] === \")\") {\n                        break;\n                    } else {\n                        throw this.error(\"Unexpected\");\n                    }\n                }\n                line = this.mustConsume(line, \")\").remainingLine;\n                if (line.length > 0) {\n                    line = this.mustConsume(line, PreProRegex.whitespace, \"whitespace\").remainingLine;\n                }\n\n            } else {\n                // normal definition\n                line = this.mustConsume(identifier.remainingLine, PreProRegex.whitespace, \"whitespace\").remainingLine;\n            }\n\n            // body\n            while (line.length > 0) {\n                const token = this.consumeAny(line);\n                if (token.type !== \"identifier\" || !parameters.includes(token.value)) {\n                    token.value = this.expandDefinitions(token.value);\n                }\n\n                tokens.push(token);\n                line = token.remainingLine;\n            }\n        }\n\n        const def = new Definition(this, identifier.value, tokens, parameters);\n        const existing = this.definitions.get(identifier.value);\n        if (existing !== undefined && !def.equals(existing)) {\n            throw this.error(\"Duplicate defines must be the same\");\n        }\n        this.definitions.set(identifier.value, def);\n    }\n\n    private _undef(line: string) {\n        line = this.mustConsume(line, PreProRegex.whitespace, \"whitespace\").remainingLine;\n        const identifier = this.mustConsume(line, PreProRegex.identifier, \"identifier\");\n        if (identifier.remainingLine.trim().length !== 0) throw this.error(\"Unexpected extra characters in undef\");\n        this.definitions.delete(identifier.value);\n    }\n\n    private _ifdef(line: string, ifdef: boolean, lines: string[]) {\n        line = this.mustConsume(line, PreProRegex.whitespace, \"whitespace\").remainingLine;\n        const identifier = this.mustConsume(line, PreProRegex.identifier, \"identifier\");\n        lines.unshift(`#if ${ifdef ? \"\" : \"!\"} defined ${identifier.value}`);\n    }\n\n    private _if(line: string, lines: string[]): string {\n        const expression = this.mustConsume(line, PreProRegex.whitespace, \"whitespace\").remainingLine;\n        let condition = this._condition(expression), anyCondition = condition, depth = 1, hadElse = false;\n\n        const body: string[] = [];\n        for (let i = 0; i < lines.length; i++) {\n            const line = lines[i].trimEnd();\n\n            if (line.startsWith(\"#if\")) {\n                depth++;\n\n            } else if (line === \"#endif\") {\n                depth--;\n                if (depth === 0) {\n                    // well formed ifdef\n                    lines.splice(0, i + 1);\n                    return this.process(body.join(\"\\n\"));\n                }\n\n            } else if (line === \"#else\" && depth === 1) {\n                if (hadElse) throw this.error(\"more than one #else statement\");\n                hadElse = true;\n\n                condition = !anyCondition;\n                anyCondition = true;\n                continue;\n            } else if (line.startsWith(\"#elif\") && depth === 1) {\n                if (anyCondition) {\n                    condition = false;\n                } else {\n                    const expression = this.mustConsume(lines[i].substring(5), PreProRegex.whitespace, \"whitespace\").remainingLine;\n                    condition = this._condition(expression);\n                    anyCondition ||= condition;\n                }\n                continue;\n            }\n\n            if (condition) body.push(lines[i]);\n        }\n\n        throw this.error(\"no matching #endif found\");\n    }\n\n    private _condition(s: string): boolean {\n        // deal with \"defined ...\"\n        let processed = \"\";\n        for (const match of s.matchAll(PreProRegex.condition)) {\n            if (match.length !== 4) throw this.error(\"invalid regex result when processing #if condition\");\n            const definitionName = match[1] ?? match[2];\n            if (definitionName) {\n                processed += this.definitions.has(definitionName) ? \" 1L \" : \" 0L \";\n            } else {\n                processed += match[3];\n            }\n        }\n        // expand remaining macros\n        processed = this.expandDefinitions(processed);\n        // try evaluate\n        try {\n            return ppEvaluate(processed, this) !== 0n;\n        } catch (e) {\n            throw this.error(\"Invalid condition `\" + s + \"`\");\n        }\n    }\n}\n","import {ParseTreeValidationError, pt} from \"../../parsing\";\nimport {CFuncDefinition, CArgument, CFuncDeclaration, CVarDefinition, CVarDeclaration} from \"../declarations\";\nimport {CAssignment, CIdentifier, CExpression, CInitializer, CStringLiteral, CConstant} from \"../expressions\";\nimport {INTERNAL_SCOPE} from \"../internal_scope\";\nimport {Scope} from \"../scope\";\nimport {CStatement, CCompoundStatement, CExpressionStatement, CNop, CIf, CForLoop, CWhileLoop, CDoLoop, CSwitch, CBreak, CContinue, CReturn, CGoto, CLabelledStatement} from \"../statements\";\nimport {ExpressionTypeError} from \"../type_checking\";\nimport {CFuncType, CVoid, CArray, CArithmetic, CPointer} from \"../types\";\nimport {ptExpression, evalIntegerConstant} from \"./expr_transform\";\nimport {getDeclaratorName, getDeclaratorType, getType} from \"./type_transform\";\n\n/** Main function, transform a parse tree translation unit into a root scope */\nexport function ptTransform(translationUnit: pt.TranslationUnit): Scope {\n    const fileScope = new Scope(undefined, INTERNAL_SCOPE);\n    for (const decl of translationUnit) {\n        if (decl instanceof pt.FunctionDefinition) {\n            ptFunction(decl, fileScope);\n        } else {\n            ptDeclaration(decl, fileScope, false);\n        }\n    }\n    return fileScope;\n}\n\n/** Add the pt declarations to the scope, and either store their static initializer on the variables or return a\n * list of assignments to add to the body of the current function to set their initial values */\nfunction ptDeclaration(declaration: pt.Declaration, scope: Scope, inFunction: boolean): CAssignment[] {\n    if (declaration.typeInfo.storageList[0] === \"typedef\") {\n        ptTypedef(declaration, scope);\n        return [];\n    }\n\n    const declType = getType(declaration, scope);\n    const assignments = [];\n    for (let entry of declaration.list) {\n        const name = getDeclaratorName(entry);\n\n        let initialValue: CExpression | CInitializer | undefined;\n        if (entry instanceof pt.InitDeclarator) {\n            initialValue = ptInitializer(entry, entry.initializer, scope);\n            entry = entry.body;\n        }\n\n        const type = getDeclaratorType(declType, entry, scope);\n        const initialType = initialValue?.type instanceof CPointer ? initialValue.type.original ?? initialValue.type : initialValue?.type;\n        if (initialType instanceof CArray && type instanceof CArray && type.incomplete) {\n            // initialize array length from initializer if incomplete\n            type.length = initialType.length;\n        }\n\n        if (type.incomplete) {\n            throw new ExpressionTypeError(type.node ?? entry, \"complete type\", \"incomplete type\");\n        } else if (type instanceof CFuncType) {\n            // function declarations\n            const linkage = declaration.typeInfo.storageList[0] === \"static\" ? \"internal\" : \"external\";\n            const fnImport = declaration.typeInfo.fnSpecifierList[0] === \"import\";\n            scope.addIdentifier(new CFuncDeclaration(entry, name, type, linkage, fnImport));\n        } else {\n            if (declaration.typeInfo.fnSpecifierList.length > 0) {\n                throw new ExpressionTypeError(entry, \"variable declaration with function specifier\");\n            }\n\n            // work out storage, linkage and if definition or declaration\n            let storage: \"static\" | \"local\";\n            let linkage: \"none\" | \"internal\" | \"external\";\n            let declType: typeof CVarDefinition | typeof CVarDeclaration;\n            if (declaration.typeInfo.storageList[0] === \"static\") {\n                storage = \"static\";\n                linkage = inFunction ? \"none\" : \"internal\";\n                declType = inFunction ? CVarDefinition : (initialValue !== undefined ? CVarDefinition : CVarDeclaration);\n            } else if (declaration.typeInfo.storageList[0] === \"extern\") {\n                storage = \"static\";\n                linkage = \"external\";\n                declType = CVarDeclaration;\n            } else {\n                storage = inFunction ? \"local\" : \"static\";\n                linkage = inFunction ? \"none\" : \"external\";\n                declType = inFunction ? CVarDefinition : (initialValue !== undefined ? CVarDefinition : CVarDeclaration);\n            }\n            const cvar = new declType(entry, name, type, storage, linkage);\n            scope.addIdentifier(cvar);\n\n            // if definition with initializer\n            if (initialValue) {\n                if (cvar instanceof CVarDeclaration) {\n                    throw new ExpressionTypeError(entry, \"declaration\", \"declaration with initializer\");\n                }\n                if (initialValue instanceof CInitializer) {\n                    initialValue.type = type;\n                }\n                if (initialValue instanceof CConstant && type instanceof CArithmetic && type !== initialValue.type) {\n                    // force constants to take the correct type\n                    initialValue = initialValue.changeType(type);\n                }\n\n                if (inFunction && cvar.storage !== \"static\") {\n                    const id: CExpression = new CIdentifier(entry, cvar);\n                    assignments.push(new CAssignment(entry, id, initialValue, undefined, true));\n                } else {\n                    // static initialization, must be constant and evaluated at compile time\n                    cvar.staticValue = initialValue;\n                    CAssignment.checkAssignmentValid(entry, type, cvar.staticValue);\n\n                    // setup variable dependencies\n                    for (const identifier of initialValue.identifiers()) {\n                        cvar.dependencies.set(identifier.value, true);\n                    }\n                }\n            }\n        }\n    }\n    return assignments;\n}\n\nfunction ptTypedef(node: pt.Declaration, scope: Scope) {\n    if (node.list.length === 0) throw new ParseTreeValidationError(node, \"typedef must define at least one identifier\");\n    const baseType = getType(node, scope);\n\n    for (const decl of node.list) {\n        if (decl instanceof pt.InitDeclarator) throw new ParseTreeValidationError(node, \"cannot initialize a typedef\");\n        const type = getDeclaratorType(baseType, decl, scope);\n        const name = getDeclaratorName(decl);\n        scope.addTypedef(name, type, decl);\n    }\n}\n\n/** Transform an initializer to either a CInitializer (for arrays, structs & unions) or a CExpression */\nfunction ptInitializer(node: pt.ParseNode, initializer: pt.Initializer, scope: Scope): CExpression | CInitializer {\n    if (Array.isArray(initializer)) {\n        return new CInitializer(node, initializer.map(x => ptInitializer(node, x, scope)));\n    } else {\n        return ptExpression(initializer as pt.Expression, scope);\n    }\n}\n\n/** Transform a function */\nfunction ptFunction(fn: pt.FunctionDefinition, scope: Scope): void {\n    if (fn.typeInfo.fnSpecifierList[0] === \"import\") {\n        throw new ExpressionTypeError(fn, \"function definition to not be marked `import`\");\n    }\n\n    // get and check the function's type\n    const type = getType(fn, scope);\n    if (!(type instanceof CFuncType)) throw new ParseTreeValidationError(fn, \"Unexpected declarator\");\n    // get the function name\n    const name = getDeclaratorName(fn.declarator);\n\n    let linkage: \"internal\" | \"external\";\n    if (fn.typeInfo.storageList[0] === \"static\") linkage = \"internal\";\n    else if (fn.typeInfo.storageList[0] === \"typedef\") throw new ParseTreeValidationError(fn, \"Invalid typedef\");\n    else linkage = \"external\";\n\n    const cfn = new CFuncDefinition(fn, name, type, linkage, scope);\n    cfn.hints.inline = fn.typeInfo.fnSpecifierList[0] === \"inline\";\n    scope.addIdentifier(cfn);\n\n    // add arguments as parameters to function's scope\n    if (!type.parameterNames) throw new ParseTreeValidationError(fn, \"Expected parameter names\");\n    for (let i = 0; i < type.parameterTypes.length; i++) {\n        cfn.body.scope.addIdentifier(new CArgument(fn, type.parameterNames[i], type.parameterTypes[i], i));\n    }\n\n    // parse function body body\n    ptCompound(fn.body, cfn);\n\n    // check function always returns\n    if (!(type.returnType instanceof CVoid) && !checkReturns(cfn.body)) {\n        throw new ParseTreeValidationError(fn.body, \"Non-void function may not return\");\n    }\n}\n\n/** Checks every branch through a function will definitely return */\nfunction checkReturns(statement: CStatement | undefined): boolean {\n    if (statement instanceof CReturn) {\n        return true;\n    } else if (statement instanceof CCompoundStatement) {\n        for (let i = 0; i < statement.statements.length; i++) {\n            if (checkReturns(statement.statements[i])) {\n                if (i + 1 < statement.statements.length) {\n                    // statements after return\n\n                    if (statement.statements[i + 1] === statement.scope.labelledStatement?.body) {\n                        // this is okay as the following statement is labelled, so can jump there\n                        continue; // check code after jumping to the label returns\n                    }\n\n                    // not okay - no way to reach statements after return\n                    throw new ParseTreeValidationError(statement.statements[i + 1].node, \"Statement after return\");\n                }\n                return true;\n            }\n        }\n    } else if (statement instanceof CIf) {\n        return checkReturns(statement.ifBody) && checkReturns(statement.elseBody);\n    } else if (statement instanceof CDoLoop) {\n        return checkReturns(statement.body);\n    } else if (statement instanceof CSwitch) {\n        // if every child returns and there's a default statement then switch is safe\n        return statement.children.every(x => checkReturns(x.body)) &&\n            statement.children.find(x => x.default) !== undefined;\n    }\n    return false;\n}\n\n/** Transform statements from the parse tree */\nfunction ptStatement(node: pt.Statement, parent: CStatement): CStatement {\n    if (node instanceof pt.CompoundStatement) {\n        return ptCompound(node, parent);\n\n    } else if (node instanceof pt.ExpressionStatement) {\n        return new CExpressionStatement(node, ptExpression(node.expression, parent.scope), parent);\n\n    } else if (node instanceof pt.IfStatement) {\n        const s = new CIf(node, ptExpression(node.expression, parent.scope), parent);\n        s.ifBody = ptStatement(node.ifBody, s);\n        if (node.elseBody) s.elseBody = ptStatement(node.elseBody, s);\n        return s;\n\n    } else if (node instanceof pt.ForLoop) {\n        const s = new CForLoop(node, parent);\n        if (node.init instanceof pt.ExpressionStatement || node.init instanceof pt.NoOp) {\n            s.init = ptStatement(node.init, s) as CExpressionStatement | CNop;\n        } else {\n            s.init = ptDeclaration(node.init, s.scope, true)\n                .map(e => new CExpressionStatement(e.node, e, s));\n        }\n        s.test = ptStatement(node.test, s) as CExpressionStatement | CNop;\n        if (node.update) s.update = ptExpression(node.update, s.scope);\n        s.body = ptStatement(node.body, s);\n        return s;\n\n    } else if (node instanceof pt.WhileLoop) {\n        const s = new CWhileLoop(node, ptExpression(node.test, parent.scope), parent);\n        s.body = ptStatement(node.body, s);\n        return s;\n\n    } else if (node instanceof pt.DoWhileLoop) {\n        const s = new CDoLoop(node, ptExpression(node.test, parent.scope), parent);\n        s.body = ptStatement(node.body, s);\n        return s;\n\n    } else if (node instanceof pt.GotoStatement) {\n        let p: CStatement | CFuncDefinition = parent; // find which statement this goto is targeting\n        while (p.scope.labelledStatement?.label !== node.target) {\n            if (p.parent instanceof CFuncDefinition) {\n                throw new ParseTreeValidationError(node, \"No properly structured control flow target for goto statement\");\n            }\n            p = p.parent;\n        }\n        return new CGoto(node, p.scope.labelledStatement, parent);\n\n    } else if (node instanceof pt.ContinueStatement) {\n        let p: CStatement = parent; // find which statement this node is continuing\n        while (!(p instanceof CForLoop || p instanceof CWhileLoop || p instanceof CDoLoop)) {\n            if (p.parent instanceof CFuncDefinition) {\n                throw new ParseTreeValidationError(node, \"No target for continue statement\");\n            }\n            p = p.parent;\n        }\n        return new CContinue(node, p, parent);\n\n    } else if (node instanceof pt.BreakStatement) {\n        let p: CStatement = parent;\n        while (!(p instanceof CForLoop || p instanceof CWhileLoop || p instanceof CDoLoop || p instanceof CSwitch)) {\n            if (p.parent instanceof CFuncDefinition) {\n                throw new ParseTreeValidationError(node, \"No target for break statement\");\n            }\n            p = p.parent;\n        }\n        return new CBreak(node, p, parent);\n\n    } else if (node instanceof pt.SwitchStatement) {\n        const s = new CSwitch(node, ptExpression(node.expression, parent.scope), parent);\n        ptSwitchBody(s, node, parent.scope);\n        return s;\n\n    } else if (node instanceof pt.ReturnStatement) {\n        let p: CStatement | CFuncDefinition = parent;\n        while (!(p instanceof CFuncDefinition)) p = p.parent;\n\n        const value = node.value ? ptExpression(node.value, parent.scope) : undefined;\n        return new CReturn(node, p, value, parent);\n\n    } else if (node instanceof pt.NoOp) {\n        return new CNop(node, parent);\n\n    } else if (node instanceof pt.CaseStatement) {\n        // allowed case/default statements handled in ptSwitchBody\n        throw new ParseTreeValidationError(node, \"Unexpected case statement\");\n    } else if (node instanceof pt.DefaultStatement) {\n        throw new ParseTreeValidationError(node, \"Unexpected default statement\");\n    }\n\n    throw new ParseTreeValidationError(node, \"Unknown statement type\");\n}\n\n/** Transform compound statements */\nfunction ptCompound(node: pt.CompoundStatement, parent: CStatement | CFuncDefinition): CCompoundStatement {\n    const c = parent instanceof CFuncDefinition ? parent.body : new CCompoundStatement(node, parent);\n\n    // need to check for labelled statements first to allow jumping forward\n    const labelled = node.body.filter(x => x instanceof pt.Statement && x.label !== undefined) as pt.Statement[];\n    if (labelled.length > 1) {\n        throw new ParseTreeValidationError(labelled[0], \"Only one labelled statement is supported per block\", labelled[1]);\n    } else if (labelled.length === 1) {\n        c.scope.labelledStatement = new CLabelledStatement(labelled[0], labelled[0].label as string);\n    }\n\n    for (const child of node.body) {\n        _compoundBody(child, c);\n    }\n    return c;\n}\n\n/** Transform a declaration or statement inside a compound statement */\nfunction _compoundBody(child: pt.Declaration | pt.Statement, c: CCompoundStatement) {\n    if (child instanceof pt.Declaration) {\n        for (const assignment of ptDeclaration(child, c.scope, true)) {\n            // add initializers to body of the statement to ensure they happen in the correct order\n            c.statements.push(new CExpressionStatement(assignment.node, assignment, c));\n        }\n    } else {\n        const statement = ptStatement(child, c);\n        c.statements.push(statement);\n\n        if (child.label !== undefined && c.scope.labelledStatement?.node === child) {\n            // now store the statement\n            c.scope.labelledStatement.body = statement;\n        }\n    }\n}\n\n/** Transform the body of a switch statement.\n *\n * This is quite complicated as case & default statements both absorb the following statement.\n * Furthermore, these statements are limited to being used at the top level inside the switch statement, whereas in C\n * you can place them inside other statements inside the switch block, creating arbitrary goto which is out of scope.\n */\nfunction ptSwitchBody(s: CSwitch, node: pt.SwitchStatement, scope: Scope) {\n    if (!(node.body instanceof pt.CompoundStatement)) {\n        throw new ParseTreeValidationError(node, \"Expected switch statement to have a compound statement body\");\n    }\n    const children = node.body.body.slice();\n    while (children.length > 0) { // iterate over the body of the switch statement\n        const child = children.shift();\n        if (child instanceof pt.CaseStatement || child instanceof pt.DefaultStatement) {\n            let block;\n            if (s.children.length > 0 && s.children[s.children.length - 1].body.statements.length === 0) {\n                // multiple cases in a row, use the last defined block\n                block = s.children[s.children.length - 1];\n            } else {\n                // last block already has children, make a new block\n                block = {cases: [], default: false, body: new CCompoundStatement(node, s)};\n                s.children.push(block);\n            }\n\n            if (child instanceof pt.CaseStatement) { // add the case or mark this block as accepting default\n                block.cases.push(evalIntegerConstant(child.value, scope));\n            } else {\n                block.default = true;\n            }\n\n            // case and default statements eat a statement\n            children.unshift(child.body);\n        } else if (child) {\n            // handle other statements as if this was a compound statement\n            if (s.children.length === 0) {\n                throw new ParseTreeValidationError(child, \"Unexpected first statement inside a switch statement\");\n            }\n            const compound = s.children[s.children.length - 1].body;\n            _compoundBody(child, compound);\n        }\n    }\n}\n","import {parse} from \"../parsing\";\nimport {Scope} from \"./scope\";\nimport {ptTransform} from \"./transform/transform\";\n\nexport function toIR(source: string): Scope {\n    const translationUnit = parse(source);\n    return ptTransform(translationUnit);\n}\n","import {CError} from \"./c_error\";\nimport {ParseNode} from \"./parsing\";\nimport {Preprocessor} from \"./preprocessor\";\nimport {toIR} from \"./ir\";\nimport {CFuncDefinition, CFuncDeclaration, CVarDeclaration, CVarDefinition, CFuncImport, CDeclaration, CArgument} from \"./ir/declarations\";\nimport {Scope} from \"./ir/scope\";\nimport {CStatement, CCompoundStatement, CForLoop, CIf, CWhileLoop, CDoLoop, CSwitch} from \"./ir/statements\";\n\ntype Emitable = CFuncDefinition | CFuncImport | CVarDefinition;\n\nexport class Linker {\n    private _emitExportedFunctions: CFuncDefinition[] = [];\n    private _emitFunctions: CFuncDefinition[] = [];\n    private _emitImports: CFuncDeclaration[] = [];\n    private _emitVariables: CVarDefinition[] = [];\n\n    private _linkables = new Map<string, ExternalFunction | ExternalVariable>();\n    private _linked = false;\n\n    constructor(readonly files: ReadonlyMap<string, string>, standardHeaders: boolean = true, customDefinitions?: {[key: string]: string}) {\n        for (const [path, code] of files.entries()) {\n            if (!path.endsWith(\".c\")) continue;\n\n            const preprocessor = new Preprocessor(path, standardHeaders, customDefinitions);\n            for (const [p2, c2] of files.entries()) preprocessor.userFiles.set(p2, c2);\n            const processed = preprocessor.process(code);\n            try {\n                this.process_scope(toIR(processed));\n            } catch (e) {\n                e.message = (e.message ?? \"\") + \"\\nIn file: \" + path;\n                throw e;\n            }\n        }\n    }\n\n    /** check complete or link with others */\n    public link(...linkers: Linker[]): void {\n        if (this._linked) throw new LinkingError(\"Already linked!\");\n        if (linkers && linkers.some(x => !x._linked)) throw new LinkingError(\"Cannot link against a not-linked Linker!\");\n\n        outerLoop: // link this with others\n        for (const linkable of this._linkables.values()) {\n            if (linkable.definition !== undefined) continue; // we've got a definition\n\n            for (const other of linkers) {\n                const linkable2 = other._linkables.get(linkable.id);\n                if (linkable2 !== undefined && linkable2.definition) {\n                    if (linkable instanceof ExternalFunction && linkable2 instanceof ExternalFunction) {\n                        // we've found a definition in the other linker we can use!\n                        linkable.setDefinition(linkable2.definition, other);\n                    } else if (linkable instanceof ExternalVariable && linkable2 instanceof ExternalVariable) {\n                        // have to be separate branches to please TS\n                        linkable.setDefinition(linkable2.definition, other);\n                    } else {\n                        throw new LinkingError(\"Tried to link incompatible types\", linkable.parseNode, linkable2.parseNode);\n                    }\n                    continue outerLoop;\n                }\n            }\n\n            if (linkable.externalType === \"variable\") {\n                // each external variable declaration is also a tentative definition, so initialize to zero\n                const cvar = new CVarDefinition(linkable.parseNode, linkable.id, linkable.type, \"static\", \"external\");\n                linkable.setDefinition(cvar, this);\n                continue;\n            } else if (linkable.externalType === \"function\" && linkable.declarationArray[0].fnImport) {\n                // define the function import if didn't already exist in other linker\n                linkable.setDefinition(new CFuncImport(linkable.declarationArray[0]), this);\n                continue;\n            }\n\n            throw new LinkingError(\"Failed to find definition\", linkable.parseNode);\n        }\n\n        // now work out which functions and imports to emit\n        const seen = new Map<Emitable, boolean>();\n        const toEmit: Emitable[] = [];\n        for (const linkable of this._linkables.values()) {\n            if (linkable.definition === undefined) {\n                throw new LinkingError(\"Invalid state - declaration has no definition in emit\", linkable.parseNode);\n            } else if (linkable.definitionLinker === this) {\n                seen.set(linkable.definition, true);\n                toEmit.unshift(linkable.definition);\n            }\n        }\n\n        while (toEmit.length) {\n            const dependency = toEmit.shift() as Emitable;\n            if (dependency instanceof CFuncImport) {\n                this._emitImports.push(dependency.declaration);\n            } else {\n                if (dependency.declType === \"variable\") {\n                    if (dependency.storage === \"static\") this._emitVariables.push(dependency);\n                } else if (dependency.linkage === \"external\" && this._linkables.get(dependency.name)?.definitionLinker === this) {\n                    this._emitExportedFunctions.push(dependency);\n                } else {\n                    this._emitFunctions.push(dependency);\n                }\n\n                for (const dep2 of dependency.dependencies.keys() as IterableIterator<CDeclaration>) {\n                    if (dep2 instanceof CFuncDeclaration || dep2 instanceof CVarDeclaration) {\n                        if (dep2.node.type === \"__internal__\") {\n                            // not a real function! __wasm__ etc\n                        } else if (dep2.definition === undefined) {\n                            throw new LinkingError(\"Invalid state - declaration doesn't have definition in emit\", dep2.node);\n                        } else if (!seen.has(dep2.definition)) {\n                            seen.set(dep2.definition, true);\n                            toEmit.push(dep2.definition);\n                        }\n                    } else if (!(dep2 instanceof CArgument) && !seen.has(dep2)) {\n                        seen.set(dep2, true);\n                        toEmit.push(dep2);\n                    }\n                }\n            }\n        }\n\n        this._linked = true;\n    }\n\n    get emitExportedFunctions(): ReadonlyArray<CFuncDefinition> {\n        return this._emitExportedFunctions;\n    }\n\n    get emitFunctions(): ReadonlyArray<CFuncDefinition> {\n        return this._emitFunctions;\n    }\n\n    get emitImports(): ReadonlyArray<CFuncDeclaration> {\n        return this._emitImports;\n    }\n\n    get emitVariables(): ReadonlyArray<CVarDefinition> {\n        return this._emitVariables;\n    }\n\n    private process_scope(scope: Scope) {\n        for (const decl of scope.declarations) {\n\n            if (decl instanceof CFuncDeclaration) {\n                if (decl.linkage === \"external\") {\n                    this.externalFn(decl).addDeclaration(decl);\n                } else if (decl.fnImport) {\n                    decl.definition = new CFuncImport(decl);\n                } else {\n                    throw new LinkingError(\"No definition of internally linked function\", decl.node);\n                }\n\n            } else if (decl instanceof CFuncDefinition) {\n                if (decl.linkage === \"external\") {\n                    this.externalFn(decl).setDefinition(decl, this);\n                }\n                this.process_fn_body(decl.body);\n\n            } else if (decl instanceof CVarDeclaration) { // \"tentative definition\" - if no def found initialize to 0\n                if (decl.linkage === \"external\") {\n                    this.externalVar(decl).addDeclaration(decl);\n                } else {\n                    // tentative definition with internal linkage\n                    decl.definition = new CVarDefinition(decl.node, decl.name, decl.type, decl.storage, decl.linkage);\n\n                    // don't emit now, will emit when linking if used\n                    // this._emitVariables.push(decl.definition);\n                }\n\n            } else if (decl instanceof CVarDefinition) {\n                if (decl.linkage === \"external\") {\n                    this.externalVar(decl).setDefinition(decl, this);\n                }\n                // if (decl.storage === \"static\") this._emitVariables.push(decl);\n\n            }\n        }\n    }\n\n    private process_fn_body(statement: CStatement) {\n        // find all scopes\n\n        if (statement instanceof CCompoundStatement) {\n            this.process_scope(statement.scope);\n            for (const child of statement.statements) this.process_fn_body(child);\n        } else if (statement instanceof CForLoop) {\n            this.process_scope(statement.scope);\n            if (statement.body) this.process_fn_body(statement.body);\n        } else if (statement instanceof CIf) {\n            if (statement.ifBody) this.process_fn_body(statement.ifBody);\n        } else if (statement instanceof CWhileLoop || statement instanceof CDoLoop) {\n            if (statement.body) this.process_fn_body(statement.body);\n        } else if (statement instanceof CSwitch) {\n            for (const child of statement.children) this.process_fn_body(child.body);\n        }\n    }\n\n    private externalFn(node: CFuncDeclaration | CFuncDefinition): ExternalFunction {\n        let result = this._linkables.get(node.name);\n        if (result === undefined) {\n            this._linkables.set(node.name, result = new ExternalFunction(node.name, node.type));\n        } else if (result instanceof ExternalVariable) {\n            throw new LinkingError(\"Tried to link function with variable\", node.node, result.parseNode);\n        } else if (!result.type.equals(node.type)) {\n            throw new LinkingError(\"Tried to link functions with incompatible types\", node.node, result.parseNode);\n        } else if ((node instanceof CFuncDefinition ? false : node.fnImport) !== (result.definition ? false : result.declarationArray[0].fnImport)) {\n            throw new LinkingError(\"Tried to link mix of functions marked import\", node.node, result.parseNode);\n        }\n        return result;\n    }\n\n    private externalVar(node: CVarDeclaration | CVarDefinition): ExternalVariable {\n        let result = this._linkables.get(node.name);\n        if (result === undefined) {\n            this._linkables.set(node.name, result = new ExternalVariable(node.name, node.type));\n        } else if (result instanceof ExternalFunction) {\n            throw new LinkingError(\"Tried to link variable with function\", node.node, result.parseNode);\n        } else if (!result.type.equals(node.type)) {\n            throw new LinkingError(\"Tried to link variables with incompatible types\", node.node, result.parseNode);\n        }\n        return result;\n    }\n}\n\nclass Linkable<Decl extends CVarDeclaration | CFuncDeclaration, Def extends Decl[\"definition\"]> {\n    protected readonly declarations: Decl[] = [];\n    protected _definition?: Def;\n    protected _defLinker?: Linker;\n\n    constructor(readonly id: string, readonly type: Decl[\"type\"]) {\n\n    }\n\n    addDeclaration(d: Decl) {\n        this.declarations.push(d);\n        if (this._definition) d.definition = this._definition;\n    }\n\n    setDefinition(d: NonNullable<Def>, defLinker: Linker) {\n        if (this._definition !== undefined) {\n            throw new LinkingError(\"Already defined!\", d.node, this.parseNode);\n        }\n        this._definition = d;\n        this._defLinker = defLinker;\n\n        this.declarations.forEach(x => {\n            x.definition = d;\n        });\n    }\n\n    get parseNode(): ParseNode {\n        if (this._definition) return this._definition.node;\n        if (this.declarations.length > 0) return this.declarations[0].node;\n        throw new LinkingError(\"Linkable without parse node? This shouldn't happen!\");\n    }\n\n    get definition(): Def | undefined {\n        return this._definition;\n    }\n\n    get definitionLinker(): Linker {\n        if (!this._defLinker) throw new Error(\"Definition not set\");\n        return this._defLinker;\n    }\n\n    get declarationArray(): ReadonlyArray<Decl> {\n        return this.declarations;\n    }\n}\n\nclass ExternalFunction extends Linkable<CFuncDeclaration, CFuncDefinition | CFuncImport> {\n    readonly externalType = \"function\";\n}\n\nclass ExternalVariable extends Linkable<CVarDeclaration, CVarDefinition> {\n    readonly externalType = \"variable\";\n}\n\nclass LinkingError extends CError {\n    name = \"LinkingError\";\n}\n","import {STANDARD_LIBRARY} from \"./c_library/standard_library\";\nimport {WGenerator} from \"./generation\";\nimport {Linker} from \"./linker\";\nimport {ModuleBuilder} from \"./wasm\";\n\nexport function compile(files: ReadonlyMap<string, string> | string,\n                        customDefinitions?: {[key: string]: string}): ModuleBuilder {\n    if (typeof files === \"string\") {\n        const f = new Map<string, string>();\n        f.set(\"main.c\", files);\n        files = f;\n    }\n\n    // \"linker\" also calls preprocessor, lexer, parser and pt transformation into IR\n    const linker = new Linker(files, true, customDefinitions);\n    linker.link(stdLibrary(customDefinitions));\n\n    const generator = new WGenerator(linker);\n    return generator.module;\n}\n\n/** No access to standard library! */\nexport function compileSnippet(source: string): ModuleBuilder {\n    const fileMap = new Map<string, string>();\n    fileMap.set(\"main.c\", source);\n\n    const linker = new Linker(fileMap, false);\n    linker.link();\n    return new WGenerator(linker).module;\n}\n\nconst _standardLibrary = new Map<string, Linker>();\nexport function stdLibrary(customDefinitions?: {[key: string]: string}): Linker {\n    const definitionsJson = JSON.stringify(customDefinitions);\n    let lib = _standardLibrary.get(definitionsJson);\n    if (!lib) {\n        lib = new Linker(STANDARD_LIBRARY, true, customDefinitions);\n        lib.link();\n        _standardLibrary.set(definitionsJson, lib);\n    }\n    return lib;\n}\n","import {compile, setFlags} from \"../src\";\n\nfunction writeRow(text: string = \"\", body: string = \"\") {\n    const div = document.createElement(\"div\");\n    if (text) div.innerText = text;\n    if (body) div.innerHTML += '\\n' + body;\n    document.body.appendChild(div);\n    document.body.appendChild(document.createElement(\"hr\"));\n    return div;\n}\n\ndocument.body.innerHTML = `\n    <a href=\"https://github.com/eembc/coremark\" target=\"_blank\" style=\"float: right\"><b>Sources</b></a>\n    <h1>CoreMark</h1>\n    <h4>Compiled in the browser to WebAssembly using <a href=\"https://github.com/ictrobot/c2wasm\">c2wasm</a>.</h4>\n    <hr>\n`;\n\nlet downloadTime = performance.now();\nwriteRow(\"Fetching sources\");\nfetch(`examples/CoreMark.json?v=${new Date().getTime()}`).then(async response => {\n    const text = await response.text();\n\n    downloadTime = performance.now() - downloadTime;\n    writeRow(\"Downloaded sources \", `- ${(text.length / 1024).toFixed(2)} KiB in ${downloadTime.toFixed(2)}ms (${(text.length * 8 / 1024 / 1024 / (downloadTime / 1000)).toFixed(2)} Mb/s)`);\n\n    const sources = new Map(Object.entries(JSON.parse(text) as {[s: string]: string}));\n\n    // fix source layout\n    for (const [filename, contents] of [...sources.entries()]) {\n        if (filename.startsWith(\"c2wasm/\")) {\n            sources.set(filename.replace(\"c2wasm/\", \"\"), contents);\n            sources.delete(filename);\n        } else if (filename.startsWith(\"simple/\")) {\n            sources.delete(filename);\n        }\n    }\n    writeRow(\"Source license:\", `<pre>${sources.get(\"coremark.h\")?.match(/\\/\\*([^\\\\*]*)\\*\\//)?.[1]}</pre>`);\n    console.log(\"Sources\", sources);\n\n    writeRow(\"Precompiling standard library\");\n    setTimeout(() => precompile(sources), 100);\n});\n\nasync function precompile(sources: Map<string, string>) {\n    let compileTime = performance.now();\n    try {\n        compile(\"\");\n    } catch (e) {\n        writeRow(\"Failed \", `<pre>${e.stack}</pre>`);\n        return;\n    }\n    compileTime = performance.now() - compileTime;\n    writeRow(\"Compiled in\", `${compileTime.toFixed(2)} ms`);\n\n    writeRow(\"Compiling module\");\n    setTimeout(() => compileModule(sources), 100);\n}\n\nasync function compileModule(sources: Map<string, string>) {\n    setFlags(\"default\");\n    setFlags({inlining: true});\n\n    let output = \"\", main: () => number;\n    let compileTime = performance.now();\n    try {\n        main = ((await compile(sources).execute({c2wasm: {\n            __put_char: (n: number) => output += String.fromCharCode(n),\n            __time: () => performance.now()\n        }})) as {main: () => number}).main;\n    } catch (e) {\n        writeRow(\"Failed \", `<pre>${e.stack}</pre>`);\n        return;\n    }\n    compileTime = performance.now() - compileTime;\n    writeRow(\"Compiled in\", `${compileTime.toFixed(2)} ms`);\n\n    const button = document.createElement(\"button\");\n    button.innerText = \"Run\";\n    button.addEventListener(\"click\", () => run(main, () => {\n        const out = output;\n        output = \"\";\n        return out;\n    }));\n    writeRow(\"\").appendChild(button);\n}\n\nasync function run(main: () => number, getOutput: () => string) {\n    writeRow(\"Running CoreMark (will take 10-20 seconds)\");\n    setTimeout(() => {\n        let returnValue: number;\n        try {\n            returnValue = main();\n        } catch (e) {\n            writeRow(\"Failed \", `<pre>${e.stack}</pre>`);\n            return;\n        }\n\n        writeRow(\"Output:\", `<pre>${getOutput()}</pre>`);\n        writeRow(\"Returned exit code\", `<code>${returnValue}</code>`);\n    }, 100);\n}\n"],"names":["ParseNode","constructor","loc","Expression","_expression","Identifier","name","super","type","Constant","value","valueType","StringLiteral","UnaryOperations","UnaryExpression","body","_unaryExpr","this","BinaryOperations","BinaryExpression","lhs","rhs","_binaryExpr","SizeofExpression","CastExpression","targetType","FunctionCallExpression","fn","args","MemberAccessExpression","pointer","ConditionalExpression","condition","trueValue","falseValue","AssignmentExpression","assignType","ConstantExpression","expr","CustomTypeSpecifier","SpecifierQualifiers","specifierList","qualifierList","specifier","DeclarationSpecifiers","storageList","fnSpecifierList","EnumSpecifier","id","Enumerator","Declaration","typeInfo","list","InitDeclarator","initializer","exploreInitializer","Array","isArray","x","StructUnionSpecifier","structure","declarations","StructDeclaration","PointerDeclarator","abstractDeclarator","IdentifierDeclarator","ArrayDeclarator","length","FunctionDeclarator","variadic","ParameterDeclaration","declarator","Pointer","TypeName","AbstractPointerDeclarator","AbstractArrayDeclarator","AbstractFunctionDeclarator","Statement","_statement","setLabel","label","IfStatement","expression","ifBody","elseBody","SwitchStatement","CaseStatement","DefaultStatement","CompoundStatement","ExpressionStatement","NoOp","ForLoop","init","test","update","WhileLoop","DoWhileLoop","GotoStatement","target","ContinueStatement","BreakStatement","ReturnStatement","FunctionDefinition","c_grammar","JisonParserError","msg","hash","stacktrace","Object","defineProperty","enumerable","writable","exception","Error","ex2","message","stack","hasOwnProperty","captureStackTrace","s","c","l","a","i","push","u","rv","e","apply","setPrototypeOf","prototype","create","parser","trace","yy","options","hasPartialLrUpgradeOnConflict","errorRecoveryTokenDiscardCount","symbols_","terminals_","TERROR","EOF","originalQuoteName","originalParseError","cleanupAfterParse","constructParseErrorInfo","yyMergeLocationInfo","__reentrant_call_depth","__error_infos","__error_recovery_infos","quoteName","id_str","getSymbolName","symbol","key","describeSymbol","terminal_descriptions_","collect_expected_token_set","state","do_not_describe","tokenset","check","state_descriptions_","p","table","d","productions_","pop","r","rule","bp","performAction","yytext","yyloc","yystate","yysp","yyvstack","yylstack","yyparser","yylexer","lexer","$","undefined","_$","t","externalDeclaration","len","y","m","mode","g","goto","n","q","j","z","shift","bt","defaultActions","idx","bda","parseError","str","ExceptionClass","recoverable","destroy","parse","input","self","sstack","vstack","lstack","sp","NO_ACTION","__lexer__","sharedState_yy","pre_parse","post_parse","pre_lex","post_lex","shallow_copy","src","dst","k","call","shallow_copy_noclobber","copy_yylloc","range","slice","fastLex","token","assert","yyGetSharedState","resultValue","invoke_post_methods","do_not_nuke_errorinfos","cleanupAfterLex","el","first_index","last_index","first_yylloc","last_yylloc","dont_look_back","i1","i2","l1","l2","first_line","last_line","first_column","last_column","ex","expected","pei","errStr","text","match","token_id","line","yylineno","yylloc","action","new_state","newState","symbol_stack","state_stack","value_stack","location_stack","stack_pointer","rec","yyrulelen","this_production","lex","yyval","retval","setInput","canIUse","errSymbolDescr","showPosition","join","ntsymbol","JisonLexerError","Parser","exports","arguments","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","module","__webpack_modules__","definition","o","get","obj","prop","Symbol","toStringTag","STANDARD_LIBRARY","Map","entries","LIBRARY_HEADERS","map","path","data","endsWith","set","DEFAULT","generation_try_constant_expr","generation_zero_shadow_stack","generation_switch_br_table","peephole_local_tee","peephole_i32_constants_ops","peephole_constants_add_mul","peephole_add_0","peephole_combine_adds","peephole_load_offset","peephole_constant_if","peephole_unused_blocks","partial_redundancy_elimination","copy_propagation","live_range_splitting","dead_code_elimination","reallocate_locals","unused_locals","peephole_2nd_pass","inlining","current","setFlags","flags","fromEntries","keys","getFlags","encodeF32","buffer","ArrayBuffer","DataView","setFloat32","Uint8Array","encodeF64","setFloat64","encodeU32","result","byte","Number","unsignedLeb128","encodeInt32Constant","BigInt","signedLeb128","encodeInt64Constant","encodeConstantInstr","i32Type","i64Type","f32Type","f64Type","toString","encodeUtf8","point","nextcode","charCodeAt","unshift","encodeResultType","encodeVec","encodeFunctionType","f","encodeLimits","values","flat","zeroArgs","opcode","parameters","reads","writes","instr","immediate","encoded","copy","zeroArgsSpecial","specialFn","context","constantArg","encodeFn","typeFn","memArg","align","offset","getIndex","depth","idxArg","suffix","stackOps","extra","encodeBlockType","blockLoopInstr","contextFn","expression2","ctx","copyInto","WExpression","builder","parent","_stack","_instructions","items","instrFn","createInstr","index","instructions","replace","start","end","forEach","stackManipulation","newInstr","some","v","instructionsRecursive","reverse","flatMap","Set","Instructions","unreachable","nop","block","loop","if","elseOpcode","ifInstr","br","br_if","br_table","defaultLbl","lblArray","defaultValue","valueTable","return","func","_functionLookup","call_indirect","_typeLookup","drop","local","getLocal","tee","global","_globalLookup","memory","size","grow","fill","i32","load","load8_s","load8_u","load16_s","load16_u","store","store8","store16","const","eqz","eq","ne","lt_s","lt_u","gt_s","gt_u","le_s","le_u","ge_s","ge_u","clz","ctz","popcnt","add","sub","mul","div_s","div_u","rem_s","rem_u","and","or","xor","shl","shr_s","shr_u","rotl","rotr","wrap_i64","trunc_f32_s","trunc_f32_u","trunc_f64_s","trunc_f64_u","reinterpret_f32","extend8_s","extend16_s","trunc_sat_f32_s","trunc_sat_f32_u","trunc_sat_f64_s","trunc_sat_f64_u","i64","load32_s","load32_u","store32","extend_i32_s","extend_i32_u","reinterpret_f64","extend32_s","f32","lt","gt","le","ge","abs","neg","ceil","floor","trunc","nearest","sqrt","div","min","max","copysign","convert_i32_s","convert_i32_u","convert_i64_s","convert_i64_u","demote_f64","reinterpret_i32","f64","promote_f32","reinterpret_i64","deadCodeElimination","usedLocals","stackItems","produces","consumes","currentStack","dfInstr","item","consumedBy","producedBy","remainingItem","needed","dataflow","instruction","resource","WLocal","markNeeded","markRecursively","write","has","read","replacement","changed","filter","peepholeOptimisers","peephole","peepholeMulti","fns","maxSize","reduce","b","Math","emulateInt","bits","branchedTo","startsWith","child","controlFlow","entryFlow","flowPrevious","flowNext","exitFlow","allFlows","brTargets","_expr2flow","previousFlow","followingFlow","flows","instrIndex","flow","nextFlow","child1","child2","targetIdx","initial","find","next","entry","exit","all","simplifiedControlFlow","newAll","previous","indexOf","framework","cfg","intermediateMap","bitMap","direction","meetOperation","transferFunction","intermediateOverride","queue","X","before","beforeBits","after","remapLocals","mapping","enabled","run","instr1","instr2","peepholeSize","instr3","s1","s2","u1","u2","instr4","includes","WGlobal","mutable","initialValue","exportName","_globalIndex","toBytes","InstrSplicer","offsetsMap","splice","deleteCount","replacements","beginOffset","offsets","realIndex","analysis","exprs","TRANSP","expressions","fullyTransparent","transpMap","resources","transparent","COMP","computedMap","expIdx","positions","computed","ANTLOC","AVIN","AVOUT","ANTOUT","ANTIN","SAFEIN","SAFEOUT","SPAVIN","SPAVOUT","SPANTOUT","SPANTIN","INSERT","REPLACE","INSERT_EDGE","comp","spavin","spantout","insert","spavout","edgeList","insert_edge","localId","LocalRange","merge","other","getNewLocal","newLocal","CError","node","node2","locationString","lines","source","split","output","lnumDigits","log10","outputLine","lnum","padStart","CFuncType","returnType","parameterTypes","parameterNames","typeName","bytes","alignment","incomplete","CVoid","checkTypeComplete","equals","every","pointerGeneration","addQualifier","CPointer","getQualifier","constant","original","qualifier","CArray","CCompoundMember","CStruct","members","_members","children","total","memberType","member","hasConstMember","CUnion","CEnum","_values","CArithmetic","minValue","BOOL","Infinity","maxValue","Fp32","Fp64","U8","S8","U16","S16","U32","S32","U64","S64","CSizeT","constType","baseType","_base","integerPromotion","usualArithmeticConversion","t1","t2","getArithmeticType","remove","ExpressionTypeError","wantedType","actualType","asArithmetic","asInteger","arithmetic","asPointer","asArithmeticOrPointer","asNonFunctionPointer","checkLvalue","lvalue","CConstant","changeType","newValue","CIdentifier","CStringLiteral","CFunctionCall","fnType","CAssignment","checkAssignmentValid","identifiers","CMemberAccess","bodyType","pointerType","structUnion","CIncrDecr","op","pos","CSizeof","CAddressOf","addressUsed","CDereference","CUnaryPlusMinus","CBitwiseNot","CLogicalNot","CCast","CMulDiv","CMod","CAddSub","CShift","dir","CRelational","commonType","CEquality","CBitwiseAndOr","CLogicalAndOr","CConditional","otherValue","assignmentType","initialAssignment","lhsType","CInitializer","rhsType","_checkAssignmentTypeValid","static","varType","CComma","_memberTypes","_type","memberTypes","typeCheck","desiredType","Scope","tags","typedefs","_getTag","tag","lookupTag","getPrototypeOf","ScopeError","addTag","_getId","lookupIdentifier","addIdentifier","existing","CFuncDeclaration","CFuncDefinition","linkage","fnImport","CVarDeclaration","CVarDefinition","_getTypedef","lookupTypedef","addTypedef","CCompoundStatement","statements","scope","CExpressionStatement","CNop","CIf","CForLoop","CWhileLoop","CDoLoop","CGoto","CSwitch","CContinue","CBreak","CReturn","CLabelledStatement","storage","declType","_addressUsed","_definition","dependencies","CArgument","CFuncImport","declaration","getFunction","translationUnit","hints","inline","CONSTANT","fail","evalExpression","staticValue","normalizeType","evalInteger","e2","isNaN","bitmask","normalizeValueType","GenError","fnName","staticInitializer","pad","alignPad","addr","nextStaticAddr","stringBytes","stringLiteral","dataSegment","stringLiteralPtr","constExpression","evalExpr","getStaticAddress","indirectIndex","lhsValue","rhsValue","encode","method","setBigInt64","setBigUint64","setInt32","setUint32","setInt16","setUint16","setInt8","setUint8","implType","realType","conversion","inType","outType","arithmeticConversion","largeReturn","storageSetupStaticVar","setStorageLocation","address","storageSetupScope","temporaries","shadowStackUsage","shadowOffset","memcpy","gen","shadowStackPtr","getTempLocal","getStorageLocation","freeTempLocal","storageGet","ctype","locationExpr","location","fromExpression","getAddress","storageUpdate","transform","keepValue","withTemporaryLocal","tmp","addrTmp","locationSymbol","sourceAddr","destAddr","validatorMap","validate","nodeList","parents","validator","ParseTreeValidationError","validators","typeValidation","typeLookup","constExprValidation","keywords","toUpperCase","rules","regex","RegExp","Lexer","col","lastIndex","exec","LexerError","groupIdx","group","reset","generatedParser","WrappedLexer","types","clear","parsetree","fakeParseNode","INTERNAL_FNS","wasm","wasm_i32","wasm_i64","wasm_f32","wasm_f64","wasm_ssp","wasm_rload","INTERNAL_SCOPE","arbitrary","parameterArgs","parameterInstructions","instructionBytes","parm","discard","gInstr","functionCall","indirectValue","subExpr","internalExpression","internalFunctions","largeReturnPtr","shadowUsage","typeIndex","functionIndex","incrDecr","amount","gConst","storageGetThenUpdate","assignment","entryPointer","entryDeref","entryAssignment","expressionGeneration","access","valueExpr","valueInstr","storageSet","exprBody","identifier","stringAddress","memberAccess","addressOf","dereference","fInstr","unaryPlusMinus","wType","iInstr","bitwiseNot","isIValueType","logicalNot","sizeof","cast","mulDiv","mod","toExpr","side","addSub","relational","equality","bitwiseAndOr","logicalAndOr","trueSideEffects","falseSideEffects","conditional","comma","anyNonZeroI32","w","findValueInstr","dropAssignment","optimisers","optimise","instrCounts","count","countInstructions","optimiser","num","peepholeOptimisations","top","exprQueue","instrLoop","startInstr","position","bit","matching","subExprMatches","arr1","arr2","results","exp","insertBefore","insertBetween","replacementFlows","addLocal","insertInstructions","replacementInstructions","insertAfter","fnLengthChange","j2","inserted","removed","processResults","sort","diff","modificationRegions","expressionLen","regions","expr1","min1","max1","expr2","min2","max2","eliminateOverlapping","ifs","exprLength","definitions","reaching","localMasks","flowDefMap","duChains","locals","entryDefinitions","possibleUses","definiteUses","flowDef","defs","localDefs","reachingDefinitions","def","use","getFlow","getDefs","replacedAll","localsMap","definitionMap","ranges","prev","allLocals","wipeLocals","liveMap","numArgs","flag","clashGraph","clash","live","clashCopy","delete","oldLocal","clashesWith","isArgument","oldLocals","deleteLocal","WImportedFunction","_funcIndex","getTableIndex","_tableIndex","WFunction","define","bodyFn","_builder","WFunctionBuilder","finalInstr","lastType","localType","code","_locals","_freeTempLocals","_arguments","_localidx","bind","findIndex","lookup","ModuleBuilder","_functions","_importedFunctions","_functionTable","_functionTypes","_globals","_dataSegments","function","params","returnValue","importFunction","param","setupMemory","initial64kPages","maximum64kPages","_memory","contents","startIdx","byteList","imports","_encodeImports","funcTypes","_typeIndex","emitCallback","startSection","startFunction","encodeSection","_encodeTable","_encodeExports","_encodeElements","_encodeDataSegments","async","WebAssembly","instantiate","instance","tableSize","lastEnd","previousContents","functions","functionImports","_inFunctionTable","_removeFunction","vec","inlineFunctions","FnInfo","infoMap","modifiedFns","splicer","info","usage","inliningCandidates","argTypes","newLocals","blockIndex","usages","inTable","exported","startingIndex","removeUnusedFns","fnMap","analyze","fnInfo","score","statementGeneration","finishCallback","labelledStatement","blockStatements","loopStatements","statement","storeBreakDepth","_compoundStatement","_expressionStatement","_if","storageFinishCallback","storeContinueDepth","_forLoop","_whileLoop","_doLoop","initInstr","defaultIndex","default","checks","numCases","sCase","cases","typeInstrs","_switch","targetDepth","breakDepthSymbol","_goto","continueDepthSymbol","_continue","_break","_return","linker","staticInitializers","variable","emitVariables","funcImport","emitImports","emitExportedFunctions","emitFunctions","cfunc","wfunc","functionBody","staticSize","_shadowStackPtr","shadowStackStart","isMemoryUsed","wasmFunc","funcType","fnGenerator","WFnGenerator","paramTypes","discardResult","expressionFn","getType","specifiers","singleSpecifier","getDeclaratorType","getDeclaratorName","cEnum","nextValue","evalIntegerConstant","enumConstant","getSpecifierType","ptr","ptExpression","ptConstant","arr","charRegex","unescapeChar","codePointAt","ptUnary","ptBinary","constInteger","possibleTypes","unsigned","long","toLowerCase","parseFloat","parseInt","String","fromCharCode","codePoint","ppEvaluate","preprocessor","parseTree","error","_eval","PreProRegex","Definition","expand","expandWithParameters","originalLine","consume","remainingLine","mustConsume","consumeArgument","trim","expandDefinitions","out","inQuote","bracketDepth","char","consumed","substring","Preprocessor","PreprocessorBase","consumeAny","success","errorName","filename","standardHeaders","customDefinitions","userFiles","libraryFiles","process","trimStart","_define","_undef","_include","_ifdef","defName","newDefinitions","output1","output2","_includeUser","_includeLib","file","localPath","tokens","parameter","ifdef","_condition","anyCondition","hadElse","trimEnd","processed","matchAll","definitionName","ptDeclaration","inFunction","decl","ptTypedef","assignments","ptInitializer","initialType","cvar","ptFunction","cfn","ptCompound","checkReturns","ptStatement","_compoundBody","ptSwitchBody","labelled","toIR","fileScope","ptTransform","files","_emitExportedFunctions","_emitFunctions","_emitImports","_emitVariables","_linkables","_linked","p2","c2","process_scope","link","linkers","LinkingError","outerLoop","linkable","linkable2","ExternalFunction","setDefinition","ExternalVariable","parseNode","externalType","declarationArray","seen","toEmit","definitionLinker","dependency","dep2","externalFn","addDeclaration","process_fn_body","externalVar","Linkable","defLinker","_defLinker","compile","definitionsJson","JSON","stringify","lib","_standardLibrary","stdLibrary","writeRow","document","createElement","innerText","innerHTML","appendChild","downloadTime","performance","now","fetch","Date","getTime","then","response","toFixed","sources","console","log","setTimeout","compileTime","main","execute","c2wasm","__put_char","__time","button","addEventListener","getOutput","compileModule","precompile"],"sourceRoot":""}