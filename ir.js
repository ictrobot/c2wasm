(()=>{var e={428:(e,t,i)=>{"use strict";i.r(t),i.d(t,{AbstractArrayDeclarator:()=>AbstractArrayDeclarator,AbstractFunctionDeclarator:()=>AbstractFunctionDeclarator,AbstractPointerDeclarator:()=>AbstractPointerDeclarator,ArrayDeclarator:()=>ArrayDeclarator,AssignmentExpression:()=>AssignmentExpression,BinaryExpression:()=>BinaryExpression,BinaryOperations:()=>s,BreakStatement:()=>BreakStatement,CaseStatement:()=>CaseStatement,CastExpression:()=>CastExpression,CompoundStatement:()=>CompoundStatement,ConditionalExpression:()=>ConditionalExpression,Constant:()=>Constant,ConstantExpression:()=>ConstantExpression,ContinueStatement:()=>ContinueStatement,CustomTypeSpecifier:()=>CustomTypeSpecifier,Declaration:()=>Declaration,DeclarationSpecifiers:()=>DeclarationSpecifiers,DefaultStatement:()=>DefaultStatement,DoWhileLoop:()=>DoWhileLoop,EnumSpecifier:()=>EnumSpecifier,Enumerator:()=>Enumerator,Expression:()=>Expression,ExpressionStatement:()=>ExpressionStatement,ForLoop:()=>ForLoop,FunctionCallExpression:()=>FunctionCallExpression,FunctionDeclarator:()=>FunctionDeclarator,FunctionDefinition:()=>FunctionDefinition,GotoStatement:()=>GotoStatement,Identifier:()=>Identifier,IdentifierDeclarator:()=>IdentifierDeclarator,IfStatement:()=>IfStatement,InitDeclarator:()=>InitDeclarator,MemberAccessExpression:()=>MemberAccessExpression,NoOp:()=>NoOp,ParameterDeclaration:()=>ParameterDeclaration,ParseNode:()=>ParseNode,Pointer:()=>Pointer,PointerDeclarator:()=>PointerDeclarator,ReturnStatement:()=>ReturnStatement,SizeofExpression:()=>SizeofExpression,SpecifierQualifiers:()=>SpecifierQualifiers,Statement:()=>Statement,StringLiteral:()=>StringLiteral,StructDeclaration:()=>StructDeclaration,StructUnionSpecifier:()=>StructUnionSpecifier,SwitchStatement:()=>SwitchStatement,TypeName:()=>TypeName,UnaryExpression:()=>UnaryExpression,UnaryOperations:()=>n,WhileLoop:()=>WhileLoop});class ParseNode{constructor(e){this.loc=e}*children(){}}class Expression extends ParseNode{constructor(){super(...arguments),this._expression=!0}}class Identifier extends Expression{constructor(e,t){super(e),this.name=t,this.type="identifier"}}class Constant extends Expression{constructor(e,t,i){super(e),this.value=t,this.valueType=i,this.type="constant"}}class StringLiteral extends Expression{constructor(e,t){super(e),this.value=t,this.type="stringLiteral"}}const n=["postfixIncrement","postfixDecrement","prefixIncrement","prefixDecrement","addressOf","dereference","unaryPlus","unaryMinus","bitwiseNot","logicalNot"];class UnaryExpression extends Expression{constructor(e,t,i){super(e),this.type=t,this.body=i,this._unaryExpr=!0}*children(){yield this.body}}const s=["arraySubscript","comma","mul","div","mod","add","sub","bitwiseShiftLeft","bitwiseShiftRight","relationalLT","relationalGT","relationalLEq","relationalGEq","relationalEq","relationalNEq","bitwiseAnd","bitwiseXor","bitwiseOr","logicalAnd","logicalOr"];class BinaryExpression extends Expression{constructor(e,t,i,n){super(e),this.type=t,this.lhs=i,this.rhs=n,this._binaryExpr=!0}*children(){yield this.lhs,yield this.rhs}}class SizeofExpression extends Expression{constructor(e,t){super(e),this.body=t,this.type="sizeof"}*children(){yield this.body}}class CastExpression extends Expression{constructor(e,t,i){super(e),this.targetType=t,this.body=i,this.type="cast"}*children(){yield this.targetType,yield this.body}}class FunctionCallExpression extends Expression{constructor(e,t,i=[]){super(e),this.fn=t,this.args=i,this.type="functionCall"}*children(){yield this.fn,yield*this.args}}class MemberAccessExpression extends Expression{constructor(e,t,i,n){super(e),this.pointer=t,this.lhs=i,this.rhs=n,this.type="access"}*children(){yield this.lhs}}class ConditionalExpression extends Expression{constructor(e,t,i,n){super(e),this.condition=t,this.trueValue=i,this.falseValue=n,this.type="conditional"}*children(){yield this.condition,yield this.trueValue,yield this.falseValue}}class AssignmentExpression extends Expression{constructor(e,t,i,n){super(e),this.assignType=t,this.lhs=i,this.rhs=n,this.type="assign"}*children(){yield this.lhs,yield this.rhs}}class ConstantExpression extends Expression{constructor(e,t){super(e),this.expr=t,this.type="constantExpr"}*children(){yield this.expr}}class CustomTypeSpecifier extends ParseNode{constructor(e,t){super(e),this.name=t,this.type="customType"}}class SpecifierQualifiers extends ParseNode{constructor(e,t,i){super(e),this.specifierList=t,this.qualifierList=i,this.type="specifiersAndQualifiers"}*children(){for(const e of this.specifierList)e instanceof ParseNode&&(yield e)}}class DeclarationSpecifiers extends ParseNode{constructor(e,t,i,n,s){super(e),this.specifierList=t,this.qualifierList=i,this.storageList=n,this.fnSpecifierList=s,this.type="declarationSpecifiers"}*children(){for(const e of this.specifierList)e instanceof ParseNode&&(yield e)}}class EnumSpecifier extends ParseNode{constructor(e,t,i){super(e),this.id=t,this.body=i,this.type="enum"}*children(){this.body&&(yield*this.body)}}class Enumerator extends ParseNode{constructor(e,t,i){super(e),this.id=t,this.value=i,this.type="enumerator"}*children(){this.value&&(yield this.value)}}class Declaration extends ParseNode{constructor(e,t,i=[]){super(e),this.typeInfo=t,this.list=i,this.type="declaration"}*children(){yield this.typeInfo,yield*this.list}}class InitDeclarator extends ParseNode{constructor(e,t,i){super(e),this.body=t,this.initializer=i,this.type="initDeclarator"}*children(){yield this.body,yield*this.exploreInitializer()}*exploreInitializer(e=this.initializer){if(e instanceof AssignmentExpression)yield e;else if(Array.isArray(e))for(const t of e)yield*this.exploreInitializer(t)}}class StructUnionSpecifier extends ParseNode{constructor(e,t,i,n){super(e),this.structure=t,this.id=i,this.declarations=n,this.type="structUnionSpecifier"}*children(){this.declarations&&(yield*this.declarations)}}class StructDeclaration extends ParseNode{constructor(e,t,i=[]){super(e),this.typeInfo=t,this.list=i,this.type="structDeclaration"}*children(){yield this.typeInfo,yield*this.list}}class PointerDeclarator extends ParseNode{constructor(e,t,i){super(e),this.pointer=t,this.body=i,this.type="pointerDeclarator",this.abstractDeclarator=!1}*children(){yield this.pointer,yield this.body}}class IdentifierDeclarator extends ParseNode{constructor(e,t){super(e),this.id=t,this.type="identifierDeclarator",this.abstractDeclarator=!1}}class ArrayDeclarator extends ParseNode{constructor(e,t,i){super(e),this.body=t,this.length=i,this.type="arrayDeclarator",this.abstractDeclarator=!1}*children(){yield this.body,this.length&&(yield this.length)}}class FunctionDeclarator extends ParseNode{constructor(e,t,i,n=!1){super(e),this.body=t,this.args=i,this.variadic=n,this.type="functionDeclarator",this.abstractDeclarator=!1}*children(){yield this.body;for(const e of this.args??[])e instanceof ParseNode&&(yield e)}}class ParameterDeclaration extends ParseNode{constructor(e,t,i){super(e),this.typeInfo=t,this.declarator=i,this.type="parameterDeclaration"}*children(){yield this.typeInfo,this.declarator&&(yield this.declarator)}}class Pointer extends ParseNode{constructor(e,t,i){super(e),this.qualifierList=t,this.body=i,this.type="pointer"}*children(){this.body&&(yield this.body)}}class TypeName extends ParseNode{constructor(e,t,i){super(e),this.typeInfo=t,this.declarator=i,this.type="typeName"}*children(){yield this.typeInfo,this.declarator&&(yield this.declarator)}}class AbstractPointerDeclarator extends ParseNode{constructor(e,t,i){super(e),this.pointer=t,this.body=i,this.type="abstractPointerDeclarator",this.abstractDeclarator=!0}*children(){yield this.pointer,this.body&&(yield this.body)}}class AbstractArrayDeclarator extends ParseNode{constructor(e,t,i){super(e),this.body=t,this.length=i,this.type="abstractArrayDeclarator",this.abstractDeclarator=!0}*children(){this.body&&(yield this.body),this.length&&(yield this.length)}}class AbstractFunctionDeclarator extends ParseNode{constructor(e,t,i,n=!1){super(e),this.body=t,this.args=i,this.variadic=n,this.type="abstractFunctionDeclarator",this.abstractDeclarator=!0}*children(){this.body&&(yield this.body),this.args&&(yield*this.args)}}class Statement extends ParseNode{constructor(){super(...arguments),this._statement=!0}setLabel(e){return this.label=e,this}}class IfStatement extends Statement{constructor(e,t,i,n){super(e),this.expression=t,this.ifBody=i,this.elseBody=n,this.type="ifStatement"}*children(){yield this.expression,yield this.ifBody,this.elseBody&&(yield this.elseBody)}}class SwitchStatement extends Statement{constructor(e,t,i){super(e),this.expression=t,this.body=i,this.type="switchStatement"}*children(){yield this.expression,yield this.body}}class CaseStatement extends Statement{constructor(e,t,i){super(e),this.value=t,this.body=i,this.type="caseStatement"}*children(){yield this.value,yield this.body}}class DefaultStatement extends Statement{constructor(e,t){super(e),this.body=t,this.type="defaultStatement"}*children(){yield this.body}}class CompoundStatement extends Statement{constructor(e,t){super(e),this.body=t,this.type="compoundStatement"}*children(){yield*this.body}}class ExpressionStatement extends Statement{constructor(e,t){super(e),this.expression=t,this.type="expressionStatement"}*children(){yield this.expression}}class NoOp extends Statement{constructor(e){super(e),this.type="nopStatement"}}class ForLoop extends Statement{constructor(e,t,i,n,s){super(e),this.init=t,this.test=i,this.update=n,this.body=s,this.type="forStatement"}*children(){yield this.init,yield this.test,this.update&&(yield this.update),yield this.body}}class WhileLoop extends Statement{constructor(e,t,i){super(e),this.test=t,this.body=i,this.type="whileStatement"}*children(){yield this.test,yield this.body}}class DoWhileLoop extends Statement{constructor(e,t,i){super(e),this.body=t,this.test=i,this.type="doWhileStatement"}*children(){yield this.body,yield this.test}}class GotoStatement extends Statement{constructor(e,t){super(e),this.target=t,this.type="gotoStatement"}}class ContinueStatement extends Statement{constructor(){super(...arguments),this.type="continueStatement"}}class BreakStatement extends Statement{constructor(){super(...arguments),this.type="breakStatement"}}class ReturnStatement extends Statement{constructor(e,t){super(e),this.value=t,this.type="returnStatement"}*children(){this.value&&(yield this.value)}}class FunctionDefinition extends ParseNode{constructor(e,t,i,n){super(e),this.typeInfo=t,this.declarator=i,this.body=n,this.type="functionDefinition"}*children(){yield this.typeInfo,yield this.declarator,yield this.body}}},347:(e,t,i)=>{var n=function(){function e(e,t){var i;if(Object.defineProperty(this,"name",{enumerable:!1,writable:!1,value:"JisonParserError"}),null==e&&(e="???"),Object.defineProperty(this,"message",{enumerable:!1,writable:!0,value:e}),this.hash=t,t&&t.exception instanceof Error){var n=t.exception;this.message=n.message||e,i=n.stack}i||(Error.hasOwnProperty("captureStackTrace")?Error.captureStackTrace(this,this.constructor):i=new Error(e).stack),i&&Object.defineProperty(this,"stack",{enumerable:!1,writable:!1,value:i})}function t(e,t,i){i=i||0;for(var n=0;n<t;n++)this.push(e),e+=i}function n(e,t){for(t+=e=this.length-e;e<t;e++)this.push(this[e])}function s(e){for(var t=[],i=0,n=e.length;i<n;i++){var s=e[i];"function"==typeof s?(i++,s.apply(t,e[i])):t.push(s)}return t}"function"==typeof Object.setPrototypeOf?Object.setPrototypeOf(e.prototype,Error.prototype):e.prototype=Object.create(Error.prototype),e.prototype.constructor=e,e.prototype.name="JisonParserError";var r={trace:function(){},JisonParserError:e,yy:{},options:{type:"lalr",hasPartialLrUpgradeOnConflict:!0,errorRecoveryTokenDiscardCount:3},symbols_:{"!":14,"!=":43,$accept:0,$end:1,"%":16,"%=":48,"&":9,"&&":44,"&=":53,"(":3,")":4,"*":10,"*=":46,"+":11,"++":35,"+=":49,",":8,"-":12,"--":36,"-=":50,"->":34,".":7,"...":76,"/":15,"/=":47,":":22,";":24,"<":17,"<<":38,"<<=":51,"<=":40,"=":23,"==":42,">":18,">=":41,">>":39,">>=":52,"?":21,BREAK:87,CASE:77,CHAR:60,CONST:73,CONSTANT_CHAR:32,CONSTANT_FLOAT:28,CONSTANT_HEX:29,CONSTANT_INT:31,CONSTANT_OCTAL:30,CONTINUE:86,DEFAULT:78,DO:83,DOUBLE:65,ELSE:80,ENUM:72,EOF:1,EXTERN:57,FLOAT:64,FOR:84,GOTO:85,IDENTIFIER:27,IF:79,IMPORT:75,INLINE:74,INT:62,LONG:63,RETURN:88,SHORT:61,SIGNED:66,SIZEOF:37,STATIC:58,STRING_LITERAL:33,STRUCT:70,SWITCH:81,TYPEDEF:56,TYPE_NAME:69,UNION:71,UNSIGNED:67,VOID:59,WHILE:82,"[":5,"]":6,"^":19,"^=":54,_BOOL:68,abstract_declarator:141,additive_expression:101,and_expression:105,argument_expression_list:96,assignment_expression:111,assignment_operator:112,ast_tree:89,block_item:149,block_item_list:148,cast_expression:99,compound_statement:147,concat_string_literals:93,conditional_expression:110,constant:91,constant_expression:114,declaration:115,declaration_specifiers:116,declarator:133,direct_abstract_declarator:142,direct_declarator:134,enum_specifier:128,enumerator:130,enumerator_list:129,equality_expression:104,error:2,exclusive_or_expression:106,expression:113,expression_statement:150,external_declaration:155,function_definition:156,function_specifier:132,identifier:90,inclusive_or_expression:107,init_declarator:118,init_declarator_list:117,initializer:143,initializer_list:144,iteration_statement:152,jump_statement:153,labeled_statement:146,logical_and_expression:108,logical_or_expression:109,multiplicative_expression:100,parameter_declaration:139,parameter_list:138,parameter_type_list:137,pointer:135,postfix_expression:95,primary_expression:94,relational_expression:103,selection_statement:151,shift_expression:102,specifier_qualifier_list:125,statement:145,storage_class_specifier:119,string_literal:92,struct_declaration:124,struct_declaration_list:123,struct_declarator:127,struct_declarator_list:126,struct_or_union:122,struct_or_union_specifier:121,translation_unit:154,type_name:140,type_qualifier:131,type_qualifier_list:136,type_specifier:120,unary_expression:97,unary_operator:98,"{":25,"|":20,"|=":55,"||":45,"}":26,"~":13},terminals_:{1:"EOF",2:"error",3:"(",4:")",5:"[",6:"]",7:".",8:",",9:"&",10:"*",11:"+",12:"-",13:"~",14:"!",15:"/",16:"%",17:"<",18:">",19:"^",20:"|",21:"?",22:":",23:"=",24:";",25:"{",26:"}",27:"IDENTIFIER",28:"CONSTANT_FLOAT",29:"CONSTANT_HEX",30:"CONSTANT_OCTAL",31:"CONSTANT_INT",32:"CONSTANT_CHAR",33:"STRING_LITERAL",34:"->",35:"++",36:"--",37:"SIZEOF",38:"<<",39:">>",40:"<=",41:">=",42:"==",43:"!=",44:"&&",45:"||",46:"*=",47:"/=",48:"%=",49:"+=",50:"-=",51:"<<=",52:">>=",53:"&=",54:"^=",55:"|=",56:"TYPEDEF",57:"EXTERN",58:"STATIC",59:"VOID",60:"CHAR",61:"SHORT",62:"INT",63:"LONG",64:"FLOAT",65:"DOUBLE",66:"SIGNED",67:"UNSIGNED",68:"_BOOL",69:"TYPE_NAME",70:"STRUCT",71:"UNION",72:"ENUM",73:"CONST",74:"INLINE",75:"IMPORT",76:"...",77:"CASE",78:"DEFAULT",79:"IF",80:"ELSE",81:"SWITCH",82:"WHILE",83:"DO",84:"FOR",85:"GOTO",86:"CONTINUE",87:"BREAK",88:"RETURN"},TERROR:2,EOF:1,originalQuoteName:null,originalParseError:null,cleanupAfterParse:null,constructParseErrorInfo:null,yyMergeLocationInfo:null,__reentrant_call_depth:0,__error_infos:[],__error_recovery_infos:[],quoteName:function(e){return'"'+e+'"'},getSymbolName:function(e){if(this.terminals_[e])return this.terminals_[e];var t=this.symbols_;for(var i in t)if(t[i]===e)return i;return null},describeSymbol:function(e){if(e!==this.EOF&&this.terminal_descriptions_&&this.terminal_descriptions_[e])return this.terminal_descriptions_[e];if(e===this.EOF)return"end of input";var t=this.getSymbolName(e);return t?this.quoteName(t):null},collect_expected_token_set:function(e,t){var i=this.TERROR,n=[],s={};if(!t&&this.state_descriptions_&&this.state_descriptions_[e])return[this.state_descriptions_[e]];for(var r in this.table[e])if((r=+r)!==i){var o=t?r:this.describeSymbol(r);o&&!s[o]&&(n.push(o),s[o]=!0)}return n},productions_:function(e){for(var t=[],i=e.pop,n=e.rule,s=0,r=i.length;s<r;s++)t.push([i[s],n[s]]);return t}({pop:s([89,89,90,t,[91,5],92,93,93,t,[94,4],t,[95,8],96,96,t,[97,6],t,[98,6],99,99,t,[100,4],t,[101,3],t,[102,3],t,[103,5],t,[104,3],105,105,106,106,107,107,108,108,109,109,110,110,111,111,t,[112,11],113,113,114,115,115,t,[116,8],117,117,118,118,t,[119,3],t,[120,13],t,[121,3],122,122,123,123,124,t,[125,4],126,126,127,t,[128,5],129,129,130,130,131,132,132,133,133,t,[134,6],t,[135,4],136,136,137,137,138,138,t,[139,3],140,140,t,[141,3],t,[142,9],t,[143,3],144,144,t,[145,6],t,[146,3],147,147,148,148,149,149,150,150,t,[151,3],t,[152,6],t,[153,5],154,154,155,155,156]),rule:s([2,t,[1,9],n,[10,4],3,1,4,3,4,3,3,2,2,n,[10,3],t,[2,4],4,t,[1,7],4,1,t,[3,3],n,[4,3],n,[3,6],n,[8,7],n,[36,3],n,[4,6],5,n,[4,3],t,[1,11],n,[59,3],n,[3,3],n,[80,3],n,[4,4],n,[32,4],t,[1,15],5,4,n,[107,4],2,3,n,[31,4],n,[114,4],5,5,6,n,[40,8],n,[17,4],n,[130,4],n,[125,3],n,[67,4],n,[21,3],n,[139,3],n,[22,4],n,[46,3],3,3,4,n,[4,4],n,[33,3],n,[83,8],n,[41,3],n,[39,5],n,[31,3],5,7,5,5,7,6,7,6,7,n,[49,3],n,[20,6],3])}),performAction:function(e,t,i,n,s,r){var a=this.yy,c=a.parser,h=a.lexer;switch(i){case 0:this.$=void 0,this._$=r[n-1];break;case 1:return this.$=void 0,this._$=c.yyMergeLocationInfo(n-1,n),s[n-1];case 2:return this.$=void 0,this._$=r[n],[];case 3:case 9:case 100:case 101:case 102:case 103:case 104:case 105:case 106:case 107:case 108:case 109:case 110:case 111:case 142:this._$=r[n],this.$=e;break;case 4:this._$=r[n],this.$=new o.Constant(this._$,e,"float");break;case 5:this._$=r[n],this.$=new o.Constant(this._$,e,"hex");break;case 6:this._$=r[n],this.$=new o.Constant(this._$,e,"oct");break;case 7:this._$=r[n],this.$=new o.Constant(this._$,e,"int");break;case 8:this._$=r[n],this.$=new o.Constant(this._$,e,"char");break;case 10:case 13:case 16:case 26:case 38:case 40:case 44:case 47:case 50:case 55:case 58:case 60:case 62:case 64:case 66:case 68:case 70:case 83:case 98:case 113:case 114:case 130:case 144:case 167:case 178:case 183:case 184:case 185:case 186:case 187:case 188:case 196:case 197:case 216:this._$=r[n],this.$=s[n];break;case 11:this._$=c.yyMergeLocationInfo(n-1,n),this.$=s[n-1]+s[n];break;case 12:this._$=r[n],this.$=new o.Identifier(this._$,e);break;case 14:this._$=r[n],this.$=new o.StringLiteral(this._$,s[n]);break;case 15:case 146:case 169:case 179:this._$=c.yyMergeLocationInfo(n-2,n),this.$=s[n-1];break;case 17:this._$=c.yyMergeLocationInfo(n-3,n),this.$=new o.BinaryExpression(this._$,"arraySubscript",s[n-3],s[n-1]);break;case 18:this._$=c.yyMergeLocationInfo(n-2,n),this.$=new o.FunctionCallExpression(this._$,s[n-2]);break;case 19:this._$=c.yyMergeLocationInfo(n-3,n),this.$=new o.FunctionCallExpression(this._$,s[n-3],s[n-1]);break;case 20:this._$=c.yyMergeLocationInfo(n-2,n),this.$=new o.MemberAccessExpression(this._$,!1,s[n-2],s[n]);break;case 21:this._$=c.yyMergeLocationInfo(n-2,n),this.$=new o.MemberAccessExpression(this._$,!0,s[n-2],s[n]);break;case 22:this._$=c.yyMergeLocationInfo(n-1,n),this.$=new o.UnaryExpression(this._$,"postfixIncrement",s[n-1]);break;case 23:this._$=c.yyMergeLocationInfo(n-1,n),this.$=new o.UnaryExpression(this._$,"postfixDecrement",s[n-1]);break;case 24:case 96:case 121:case 128:case 136:case 155:case 159:case 181:case 194:case 214:this._$=r[n],this.$=[s[n]];break;case 25:case 97:case 129:case 137:case 160:case 182:this._$=c.yyMergeLocationInfo(n-2,n),this.$=(s[n-2].push(s[n]),s[n-2]);break;case 27:this._$=c.yyMergeLocationInfo(n-1,n),this.$=new o.UnaryExpression(this._$,"prefixIncrement",s[n]);break;case 28:this._$=c.yyMergeLocationInfo(n-1,n),this.$=new o.UnaryExpression(this._$,"prefixDecrement",s[n]);break;case 29:this._$=c.yyMergeLocationInfo(n-1,n),this.$=new o.UnaryExpression(this._$,s[n-1],s[n]);break;case 30:this._$=c.yyMergeLocationInfo(n-1,n),this.$=new o.SizeofExpression(this._$,s[n]);break;case 31:this._$=c.yyMergeLocationInfo(n-3,n),this.$=new o.SizeofExpression(this._$,s[n-1]);break;case 32:this._$=r[n],this.$="addressOf";break;case 33:this._$=r[n],this.$="dereference";break;case 34:this._$=r[n],this.$="unaryPlus";break;case 35:this._$=r[n],this.$="unaryMinus";break;case 36:this._$=r[n],this.$="bitwiseNot";break;case 37:this._$=r[n],this.$="logicalNot";break;case 39:this._$=c.yyMergeLocationInfo(n-3,n),this.$=new o.CastExpression(this._$,s[n-2],s[n]);break;case 41:this._$=c.yyMergeLocationInfo(n-2,n),this.$=new o.BinaryExpression(this._$,"mul",s[n-2],s[n]);break;case 42:this._$=c.yyMergeLocationInfo(n-2,n),this.$=new o.BinaryExpression(this._$,"div",s[n-2],s[n]);break;case 43:this._$=c.yyMergeLocationInfo(n-2,n),this.$=new o.BinaryExpression(this._$,"mod",s[n-2],s[n]);break;case 45:this._$=c.yyMergeLocationInfo(n-2,n),this.$=new o.BinaryExpression(this._$,"add",s[n-2],s[n]);break;case 46:this._$=c.yyMergeLocationInfo(n-2,n),this.$=new o.BinaryExpression(this._$,"sub",s[n-2],s[n]);break;case 48:this._$=c.yyMergeLocationInfo(n-2,n),this.$=new o.BinaryExpression(this._$,"bitwiseShiftLeft",s[n-2],s[n]);break;case 49:this._$=c.yyMergeLocationInfo(n-2,n),this.$=new o.BinaryExpression(this._$,"bitwiseShiftRight",s[n-2],s[n]);break;case 51:this._$=c.yyMergeLocationInfo(n-2,n),this.$=new o.BinaryExpression(this._$,"relationalLT",s[n-2],s[n]);break;case 52:this._$=c.yyMergeLocationInfo(n-2,n),this.$=new o.BinaryExpression(this._$,"relationalGT",s[n-2],s[n]);break;case 53:this._$=c.yyMergeLocationInfo(n-2,n),this.$=new o.BinaryExpression(this._$,"relationalLEq",s[n-2],s[n]);break;case 54:this._$=c.yyMergeLocationInfo(n-2,n),this.$=new o.BinaryExpression(this._$,"relationalGEq",s[n-2],s[n]);break;case 56:this._$=c.yyMergeLocationInfo(n-2,n),this.$=new o.BinaryExpression(this._$,"relationalEq",s[n-2],s[n]);break;case 57:this._$=c.yyMergeLocationInfo(n-2,n),this.$=new o.BinaryExpression(this._$,"relationalNEq",s[n-2],s[n]);break;case 59:this._$=c.yyMergeLocationInfo(n-2,n),this.$=new o.BinaryExpression(this._$,"bitwiseAnd",s[n-2],s[n]);break;case 61:this._$=c.yyMergeLocationInfo(n-2,n),this.$=new o.BinaryExpression(this._$,"bitwiseXor",s[n-2],s[n]);break;case 63:this._$=c.yyMergeLocationInfo(n-2,n),this.$=new o.BinaryExpression(this._$,"bitwiseOr",s[n-2],s[n]);break;case 65:this._$=c.yyMergeLocationInfo(n-2,n),this.$=new o.BinaryExpression(this._$,"logicalAnd",s[n-2],s[n]);break;case 67:this._$=c.yyMergeLocationInfo(n-2,n),this.$=new o.BinaryExpression(this._$,"logicalOr",s[n-2],s[n]);break;case 69:this._$=c.yyMergeLocationInfo(n-4,n),this.$=new o.ConditionalExpression(this._$,s[n-4],s[n-2],s[n]);break;case 71:this._$=c.yyMergeLocationInfo(n-2,n),this.$=new o.AssignmentExpression(this._$,s[n-1],s[n-2],s[n]);break;case 72:this._$=r[n],this.$=void 0;break;case 73:this._$=r[n],this.$="mul";break;case 74:this._$=r[n],this.$="div";break;case 75:this._$=r[n],this.$="mod";break;case 76:this._$=r[n],this.$="add";break;case 77:this._$=r[n],this.$="sub";break;case 78:this._$=r[n],this.$="leftShift";break;case 79:this._$=r[n],this.$="rightShift";break;case 80:this._$=r[n],this.$="bitwiseAnd";break;case 81:this._$=r[n],this.$="bitwiseXor";break;case 82:this._$=r[n],this.$="bitwiseOr";break;case 84:this._$=c.yyMergeLocationInfo(n-2,n),this.$=new o.BinaryExpression(this._$,"comma",s[n-2],s[n]);break;case 85:this._$=r[n],this.$=new o.ConstantExpression(this._$,s[n]);break;case 86:this._$=c.yyMergeLocationInfo(n-1,n),this.$=new o.Declaration(this._$,s[n-1]);break;case 87:this._$=c.yyMergeLocationInfo(n-2,n),this.$=new o.Declaration(this._$,s[n-2],s[n-1]);break;case 88:this._$=r[n],this.$=new o.DeclarationSpecifiers(this._$,[],[],[s[n]],[]);break;case 89:this._$=c.yyMergeLocationInfo(n-1,n),this.$=new o.DeclarationSpecifiers(this._$,s[n].specifierList,s[n].qualifierList,[s[n-1],...s[n].storageList],s[n].fnSpecifierList);break;case 90:this._$=r[n],this.$=new o.DeclarationSpecifiers(this._$,[s[n]],[],[],[]);break;case 91:this._$=c.yyMergeLocationInfo(n-1,n),this.$=new o.DeclarationSpecifiers(this._$,[s[n-1],...s[n].specifierList],s[n].qualifierList,s[n].storageList,s[n].fnSpecifierList);break;case 92:this._$=r[n],this.$=new o.DeclarationSpecifiers(this._$,[],[s[n]],[],[]);break;case 93:this._$=c.yyMergeLocationInfo(n-1,n),this.$=new o.DeclarationSpecifiers(this._$,s[n].specifierList,[s[n-1],...s[n].qualifierList],s[n].storageList,s[n].fnSpecifierList);break;case 94:this._$=r[n],this.$=new o.DeclarationSpecifiers(this._$,[],[],[],[s[n]]);break;case 95:this._$=c.yyMergeLocationInfo(n-1,n),this.$=new o.DeclarationSpecifiers(this._$,s[n].specifierList,s[n].qualifierList,s[n].storageList,[s[n-1],...s[n].fnSpecifierList]);break;case 99:this._$=c.yyMergeLocationInfo(n-2,n),this.$=new o.InitDeclarator(this._$,s[n-2],s[n]);break;case 112:this._$=r[n],this.$="bool";break;case 115:this._$=r[n],this.$=new o.CustomTypeSpecifier(this._$,s[n]);break;case 116:this._$=c.yyMergeLocationInfo(n-4,n),this.$=new o.StructUnionSpecifier(this._$,s[n-4],s[n-3],s[n-1]);break;case 117:this._$=c.yyMergeLocationInfo(n-3,n),this.$=new o.StructUnionSpecifier(this._$,s[n-3],void 0,s[n-1]);break;case 118:this._$=c.yyMergeLocationInfo(n-1,n),this.$=new o.StructUnionSpecifier(this._$,s[n-1],s[n]);break;case 119:this._$=r[n],this.$="struct";break;case 120:this._$=r[n],this.$="union";break;case 122:case 156:case 195:case 215:this._$=c.yyMergeLocationInfo(n-1,n),this.$=(s[n-1].push(s[n]),s[n-1]);break;case 123:this._$=c.yyMergeLocationInfo(n-2,n),this.$=new o.StructDeclaration(this._$,s[n-2],s[n-1]);break;case 124:this._$=c.yyMergeLocationInfo(n-1,n),this.$=new o.SpecifierQualifiers(this._$,[s[n-1],...s[n].specifierList],s[n].qualifierList);break;case 125:this._$=r[n],this.$=new o.SpecifierQualifiers(this._$,[s[n]],[]);break;case 126:this._$=c.yyMergeLocationInfo(n-1,n),this.$=new o.SpecifierQualifiers(this._$,s[n].specifierList,[s[n-1],...s[n].qualifierList]);break;case 127:this._$=r[n],this.$=new o.SpecifierQualifiers(this._$,[],[s[n]]);break;case 131:this._$=c.yyMergeLocationInfo(n-3,n),this.$=new o.EnumSpecifier(this._$,void 0,s[n-1]);break;case 132:this._$=c.yyMergeLocationInfo(n-4,n),this.$=new o.EnumSpecifier(this._$,s[n-3],s[n-1]);break;case 133:this._$=c.yyMergeLocationInfo(n-4,n),this.$=new o.EnumSpecifier(this._$,void 0,s[n-2]);break;case 134:this._$=c.yyMergeLocationInfo(n-5,n),this.$=new o.EnumSpecifier(this._$,s[n-4],s[n-2]);break;case 135:this._$=c.yyMergeLocationInfo(n-1,n),this.$=new o.EnumSpecifier(this._$,s[n]);break;case 138:this._$=r[n],this.$=new o.Enumerator(this._$,s[n]);break;case 139:this._$=c.yyMergeLocationInfo(n-2,n),this.$=new o.Enumerator(this._$,s[n-2],s[n]);break;case 140:this._$=r[n],this.$="const";break;case 141:this._$=r[n],this.$="inline";break;case 143:this._$=c.yyMergeLocationInfo(n-1,n),this.$=new o.PointerDeclarator(this._$,s[n-1],s[n]);break;case 145:this._$=r[n],this.$=new o.IdentifierDeclarator(this._$,s[n]);break;case 147:this._$=c.yyMergeLocationInfo(n-3,n),this.$=new o.ArrayDeclarator(this._$,s[n-3],s[n-1]);break;case 148:this._$=c.yyMergeLocationInfo(n-2,n),this.$=new o.ArrayDeclarator(this._$,s[n-2]);break;case 149:this._$=c.yyMergeLocationInfo(n-3,n),this.$=new o.FunctionDeclarator(this._$,s[n-3],s[n-1],s[n-1].variadic);break;case 150:this._$=c.yyMergeLocationInfo(n-2,n),this.$=new o.FunctionDeclarator(this._$,s[n-2]);break;case 151:this._$=r[n],this.$=new o.Pointer(this._$);break;case 152:this._$=c.yyMergeLocationInfo(n-1,n),this.$=new o.Pointer(this._$,s[n]);break;case 153:this._$=c.yyMergeLocationInfo(n-1,n),this.$=new o.Pointer(this._$,void 0,s[n]);break;case 154:this._$=c.yyMergeLocationInfo(n-2,n),this.$=new o.Pointer(this._$,s[n-1],s[n]);break;case 157:this._$=r[n],this.$=(s[n].variadic=!1,s[n]);break;case 158:this._$=c.yyMergeLocationInfo(n-2,n),this.$=(s[n-2].variadic=!0,s[n-2]);break;case 161:case 162:this._$=c.yyMergeLocationInfo(n-1,n),this.$=new o.ParameterDeclaration(this._$,s[n-1],s[n]);break;case 163:this._$=r[n],this.$=new o.ParameterDeclaration(this._$,s[n]);break;case 164:this._$=r[n],this.$=new o.TypeName(this._$,s[n]);break;case 165:this._$=c.yyMergeLocationInfo(n-1,n),this.$=new o.TypeName(this._$,s[n-1],s[n]);break;case 166:this._$=r[n],this.$=new o.AbstractPointerDeclarator(this._$,s[n]);break;case 168:this._$=c.yyMergeLocationInfo(n-1,n),this.$=new o.AbstractPointerDeclarator(this._$,s[n-1],s[n]);break;case 170:this._$=c.yyMergeLocationInfo(n-1,n),this.$=new o.AbstractArrayDeclarator(this._$);break;case 171:this._$=c.yyMergeLocationInfo(n-2,n),this.$=new o.AbstractArrayDeclarator(this._$,void 0,s[n-1]);break;case 172:this._$=c.yyMergeLocationInfo(n-2,n),this.$=new o.AbstractArrayDeclarator(this._$,s[n-2]);break;case 173:this._$=c.yyMergeLocationInfo(n-3,n),this.$=new o.AbstractArrayDeclarator(this._$,s[n-3],s[n-1]);break;case 174:this._$=c.yyMergeLocationInfo(n-1,n),this.$=new o.AbstractFunctionDeclarator(this._$);break;case 175:this._$=c.yyMergeLocationInfo(n-2,n),this.$=new o.AbstractFunctionDeclarator(this._$,void 0,s[n-1],s[n-1].variadic);break;case 176:this._$=c.yyMergeLocationInfo(n-2,n),this.$=new o.AbstractFunctionDeclarator(this._$,s[n-2]);break;case 177:this._$=c.yyMergeLocationInfo(n-3,n),this.$=new o.AbstractFunctionDeclarator(this._$,s[n-3],s[n-1],s[n-1].variadic);break;case 180:this._$=c.yyMergeLocationInfo(n-3,n),this.$=s[n-2];break;case 189:this._$=c.yyMergeLocationInfo(n-2,n),this.$=s[n].setLabel(s[n-2]);break;case 190:this._$=c.yyMergeLocationInfo(n-3,n),this.$=new o.CaseStatement(this._$,s[n-2],s[n]);break;case 191:this._$=c.yyMergeLocationInfo(n-2,n),this.$=new o.DefaultStatement(this._$,s[n]);break;case 192:this._$=c.yyMergeLocationInfo(n-1,n),this.$=new o.CompoundStatement(this._$,[]);break;case 193:this._$=c.yyMergeLocationInfo(n-2,n),this.$=new o.CompoundStatement(this._$,s[n-1]);break;case 198:this._$=r[n],this.$=new o.NoOp(this._$);break;case 199:this._$=c.yyMergeLocationInfo(n-1,n),this.$=new o.ExpressionStatement(this._$,s[n-1]);break;case 200:this._$=c.yyMergeLocationInfo(n-4,n),this.$=new o.IfStatement(this._$,s[n-2],s[n]);break;case 201:this._$=c.yyMergeLocationInfo(n-6,n),this.$=new o.IfStatement(this._$,s[n-4],s[n-2],s[n]);break;case 202:this._$=c.yyMergeLocationInfo(n-4,n),this.$=new o.SwitchStatement(this._$,s[n-2],s[n]);break;case 203:this._$=c.yyMergeLocationInfo(n-4,n),this.$=new o.WhileLoop(this._$,s[n-2],s[n]);break;case 204:this._$=c.yyMergeLocationInfo(n-6,n),this.$=new o.DoWhileLoop(this._$,s[n-5],s[n-2]);break;case 205:case 207:this._$=c.yyMergeLocationInfo(n-5,n),this.$=new o.ForLoop(this._$,s[n-3],s[n-2],void 0,s[n]);break;case 206:case 208:this._$=c.yyMergeLocationInfo(n-6,n),this.$=new o.ForLoop(this._$,s[n-4],s[n-3],s[n-2],s[n]);break;case 209:this._$=c.yyMergeLocationInfo(n-2,n),this.$=new o.GotoStatement(this._$,s[n-1]);break;case 210:this._$=c.yyMergeLocationInfo(n-1,n),this.$=new o.ContinueStatement(this._$);break;case 211:this._$=c.yyMergeLocationInfo(n-1,n),this.$=new o.BreakStatement(this._$);break;case 212:this._$=c.yyMergeLocationInfo(n-1,n),this.$=new o.ReturnStatement(this._$);break;case 213:this._$=c.yyMergeLocationInfo(n-2,n),this.$=new o.ReturnStatement(this._$,s[n-1]);break;case 217:this._$=r[n],this.$=(h.externalDeclaration(s[n]),s[n]);break;case 218:this._$=c.yyMergeLocationInfo(n-2,n),this.$=new o.FunctionDefinition(this._$,s[n-2],s[n-1],s[n])}},table:function(e){for(var t=[],i=e.len,n=e.symbol,s=e.type,r=e.state,o=e.mode,a=e.goto,c=0,h=i.length;c<h;c++){for(var l=i[c],p={},y=0;y<l;y++){var u=n.shift();switch(s.shift()){case 2:p[u]=[o.shift(),a.shift()];break;case 0:p[u]=r.shift();break;default:p[u]=[3]}}t.push(p)}return t}({len:s([34,1,32,t,[0,4],10,t,[35,4],t,[0,19],3,3,t,[0,4],5,0,2,4,7,0,10,0,7,t,[0,5],28,23,4,28,0,40,91,0,8,7,39,32,9,0,0,1,23,23,0,9,26,26,2,0,3,4,0,0,41,0,37,8,42,25,25,26,25,n,[25,3],t,[0,5],10,0,0,44,61,11,t,[0,6],12,0,14,18,20,22,25,0,0,90,n,[25,6],t,[0,4],39,38,1,0,2,t,[1,3],59,1,n,[6,3],40,n,[113,3],1,t,[0,3],n,[19,3],n,[45,3],0,0,23,0,n,[9,3],t,[0,4],4,38,2,2,0,38,t,[0,11],39,35,39,40,n,[19,3],n,[9,3],t,[0,3],61,34,33,n,[68,3],7,32,31,30,30,t,[29,4],28,28,27,27,t,[26,3],0,0,59,1,59,0,38,t,[39,3],1,70,n,[85,4],n,[46,3],30,0,0,8,4,42,n,[51,3],8,n,[85,5],n,[174,3],2,9,2,n,[99,5],1,10,11,0,26,n,[103,3],12,14,18,18,t,[20,4],22,22,25,n,[168,3],n,[67,3],n,[56,3],2,2,1,41,41,n,[49,5],39,32,1,n,[156,3],n,[77,4],0,37,0,n,[144,5],t,[59,3],39,40,40,n,[21,8],0,52,n,[47,3],59,2,59,n,[82,3],59,1,n,[60,3],n,[62,3],0,0]),symbol:s([1,t,[56,20,1],89,115,116,t,[119,4,1],128,131,132,154,155,156,1,n,[35,21],n,[34,9],155,156,3,10,24,27,90,117,118,133,134,135,3,4,5,8,n,[13,3],n,[48,20],n,[47,8],n,[35,105],25,27,90,n,[3,3],8,23,24,25,147,8,24,3,27,90,134,n,[52,4],n,[14,3],n,[59,5],27,73,131,135,136,3,10,27,90,n,[181,9],25,n,[77,21],n,[17,15],t,[120,6,1],128,131,27,90,129,130,n,[55,28],3,t,[9,6,1],25,t,[27,7,1],35,36,37,t,[90,6,1],t,[97,15,1],143,n,[40,7],t,[24,10,1],n,[42,3],n,[80,20],77,78,79,t,[81,8,1],n,[73,21],113,n,[398,9],t,[145,9,1],n,[221,4],n,[403,8],n,[246,4],6,n,[107,6],n,[146,30],114,4,n,[338,28],137,138,139,n,[317,9],4,n,[282,23],26,n,[24,18],n,[23,4],n,[142,4],126,127,n,[143,6],10,27,n,[36,18],n,[35,4],n,[26,25],8,26,8,23,26,n,[371,5],n,[343,39],144,4,6,t,[8,5,1],t,[15,10,1],26,t,[38,18,1],112,n,[37,3],21,22,24,26,45,t,[3,10,1],n,[48,11],34,35,36,n,[51,18],n,[128,7],n,[127,18],n,[25,50],99,n,[26,25],n,[151,7],44,45,n,[9,3],n,[140,3],n,[10,4],n,[162,21],t,[33,4,1],n,[163,18],92,n,[88,17],n,[339,15],n,[576,22],n,[361,6],140,n,[115,3],n,[94,4],n,[126,7],9,n,[12,18],n,[109,4],n,[14,4],n,[134,6],24,26,n,[127,6],n,[18,12],n,[147,8],n,[20,4],11,12,n,[22,20],n,[199,11],n,[25,10],n,[778,85],n,[777,7],n,[1182,9],5,n,[325,16],n,[486,46],n,[810,13],22,n,[1109,3],t,[3,3],n,[183,8],n,[46,10],n,[162,33],n,[153,3],n,[152,5],27,90,24,24,n,[64,8],n,[722,31],113,n,[963,3],6,4,4,8,n,[895,6],n,[1205,4],141,142,n,[874,23],8,24,n,[811,3],n,[810,8],n,[196,31],n,[857,3],26,n,[42,37],111,n,[38,38],113,n,[39,35],n,[74,40],4,n,[40,22],t,[96,16,1],27,90,27,90,n,[157,56],n,[794,44],n,[100,34],n,[34,33],4,8,4,n,[1252,4],n,[443,3],n,[43,32],n,[32,31],n,[31,30],n,[30,59],n,[29,115],n,[28,55],n,[27,53],n,[26,59],n,[993,52],22,n,[1053,60],n,[918,111],n,[39,43],82,n,[1204,18],n,[1449,20],n,[1438,31],150,24,8,24,t,[56,21,1],n,[33,8],n,[2155,5],n,[2486,3],142,n,[8,4],n,[2076,5],n,[102,21],n,[47,8],n,[1299,3],n,[2207,3],n,[859,3],n,[2280,38],n,[2192,4],n,[2191,4],n,[1324,11],n,[1658,12],n,[2135,22],8,22,n,[1948,9],6,8,n,[974,3],n,[1953,10],n,[1848,11],n,[587,27],4,5,n,[205,4],10,n,[2403,28],n,[197,6],n,[1916,56],n,[1934,30],n,[20,60],n,[1994,22],n,[2016,43],n,[2041,34],n,[805,50],n,[387,3],n,[391,3],n,[1924,9],n,[697,32],150,n,[41,42],n,[627,4],n,[2865,70],n,[549,3],n,[856,37],n,[1009,45],n,[1106,59],n,[59,118],n,[2030,56],n,[40,56],6,4,n,[2640,43],t,[80,9,1],n,[588,3],n,[653,60],n,[61,120],n,[2629,9],n,[475,110]]),type:s([t,[2,21],t,[0,13],1,n,[35,32],n,[15,10],t,[2,27],n,[45,12],n,[35,103],n,[3,6],n,[5,8],n,[52,15],n,[69,6],n,[76,31],n,[92,25],n,[55,46],n,[338,16],n,[314,13],t,[2,47],t,[0,40],n,[43,8],n,[73,46],n,[491,36],n,[333,19],n,[409,26],n,[142,15],n,[97,21],n,[26,38],n,[35,21],n,[253,26],n,[329,34],t,[2,67],n,[112,25],n,[25,33],n,[51,43],n,[146,46],n,[576,61],t,[2,173],n,[777,42],n,[1182,34],n,[105,50],n,[162,65],n,[428,23],n,[409,35],n,[874,32],n,[927,19],n,[1006,54],n,[42,27],n,[576,39],n,[74,74],n,[40,24],n,[1420,3],n,[1389,71],n,[794,46],n,[34,50],n,[1657,13],n,[43,29],n,[32,31],n,[31,30],n,[30,59],n,[29,115],n,[28,55],n,[27,53],n,[26,69],n,[1357,73],n,[623,63],n,[918,78],n,[922,61],n,[1438,53],n,[56,33],n,[2037,26],n,[902,45],n,[314,25],n,[1413,8],n,[97,20],n,[1822,76],n,[116,13],n,[200,38],t,[2,266],n,[865,54],n,[48,41],n,[89,45],n,[2865,60],n,[73,33],n,[2165,68],n,[1166,59],n,[59,105],n,[2030,63],n,[938,93],n,[2875,93],n,[61,121],n,[475,88]]),state:s([1,t,[6,4,1],25,31,26,10,11,2,t,[4,6,1],n,[12,5],36,5,44,39,42,37,41,40,47,n,[16,7],48,n,[8,7],49,n,[8,7],50,n,[8,7],51,54,55,44,60,65,64,63,44,66,41,40,71,25,31,68,69,70,26,72,75,73,74,97,98,107,99,89,83,81,86,t,[115,6,-1],108,101,96,88,82,80,78,77,128,n,[22,19],142,132,119,121,n,[76,7],120,122,123,117,118,t,[124,4,1],44,143,144,41,40,n,[67,6],148,n,[45,12],147,145,153,n,[43,7],149,151,152,155,154,n,[112,3],157,n,[112,4],n,[8,3],159,n,[7,3],44,160,161,162,n,[133,5],163,n,[19,5],164,n,[137,3],168,n,[137,22],170,169,171,n,[24,6],191,86,n,[8,6],193,n,[8,7],148,86,194,n,[9,6],195,86,199,n,[58,20],142,200,n,[89,3],202,26,72,201,n,[202,34],219,n,[201,5],39,42,n,[202,23],221,n,[66,22],228,t,[122,6,1],230,n,[125,21],234,44,238,41,240,239,241,n,[239,7],75,248,n,[88,20],249,n,[58,20],254,n,[79,21],255,n,[64,17],256,n,[40,21],257,n,[22,6],259,n,[23,14],260,261,262,n,[290,22],n,[312,28],263,n,[115,16],264,n,[17,15],265,269,268,241,n,[19,14],271,n,[15,13],272,n,[14,12],273,n,[13,12],274,n,[13,11],275,n,[12,11],276,n,[12,11],277,n,[12,11],278,n,[12,10],279,n,[11,10],280,n,[11,9],281,n,[10,9],282,n,[10,8],283,n,[9,8],284,n,[9,8],285,n,[454,22],286,t,[122,7,1],n,[29,21],288,n,[29,6],n,[295,20],289,n,[316,21],290,n,[22,21],291,n,[22,21],292,n,[22,21],132,295,n,[665,8],294,n,[833,8],299,44,60,300,44,n,[13,8],66,41,240,305,151,152,303,n,[378,15],n,[593,6],307,44,308,n,[854,3],n,[621,8],n,[841,15],311,n,[50,8],317,300,n,[76,8],269,n,[74,5],n,[251,22],318,n,[251,26],142,132,323,n,[23,22],324,n,[149,20],326,n,[110,8],328,151,152,n,[32,19],332,n,[75,20],333,n,[148,22],334,n,[428,28],335,n,[29,28],336,n,[206,27],337,n,[22,21],339,n,[22,21],341,n,[95,22],346,n,[124,28],348,n,[29,28],350,n,[29,28],352,n,[29,28],353,n,[29,6]]),mode:s([t,[1,46],t,[2,7],n,[27,101],n,[31,5],1,n,[27,7],n,[9,3],n,[43,8],n,[18,5],n,[12,8],t,[2,20],n,[100,22],n,[44,38],t,[1,57],n,[96,6],n,[327,43],n,[218,8],n,[369,35],n,[20,35],n,[299,11],n,[352,20],n,[317,10],n,[250,19],n,[24,7],n,[67,6],n,[289,19],n,[310,86],n,[146,12],n,[412,22],n,[440,60],n,[236,15],n,[65,20],n,[8,22],n,[34,18],n,[30,22],n,[87,7],n,[55,20],n,[271,60],n,[246,30],n,[688,75],n,[561,7],n,[502,7],t,[1,217],n,[219,219],t,[1,232],n,[680,7],n,[458,70],n,[1605,13],n,[1062,14],n,[1676,26],n,[123,26],n,[1116,48],n,[1134,38],n,[20,60],n,[1194,23],n,[1216,42],n,[1241,80],n,[2006,28],n,[690,216],t,[2,42],n,[538,11],t,[1,155]]),goto:s([3,t,[12,13,1],27,33,34,32,28,29,30,35,n,[21,20],45,43,38,46,t,[88,7],n,[31,20],t,[90,7],n,[27,20],t,[92,7],n,[27,20],t,[94,7],n,[27,20],52,46,53,46,98,56,98,57,59,58,45,46,62,144,61,t,[144,4],t,[151,4],43,151,28,45,43,46,t,[118,6],67,t,[118,21],n,[74,15],46,t,[135,6],76,t,[135,21],100,t,[90,6,1],79,46,t,[102,5,1],109,84,85,87,n,[18,7],131,57,116,n,[20,10],n,[159,20],129,130,t,[133,9,1],n,[144,3],62,143,61,t,[143,4],100,146,n,[62,6],n,[59,10],150,n,[60,20],t,[152,4],43,152,28,156,n,[25,15],158,n,[16,15],n,[88,3],t,[125,5],n,[23,15],t,[127,5],n,[20,15],166,165,138,167,138,46,n,[206,18],t,[38,15],172,t,[38,10],t,[173,10,1],t,[68,3],183,t,[68,3],184,186,26,185,26,187,t,[26,16],188,189,190,t,[26,18],192,n,[230,16],n,[17,17],n,[138,7],n,[17,10],196,n,[17,16],t,[66,7],197,66,t,[64,3],198,t,[64,6],t,[14,21],109,t,[14,21],n,[96,17],n,[272,15],t,[62,3],203,t,[62,7],t,[60,3],204,t,[60,8],t,[58,10],205,206,58,58,t,[55,4],207,208,t,[55,6],209,210,t,[55,4],t,[50,12],211,212,t,[50,6],t,[47,4],213,214,t,[47,16],t,[44,4],215,44,44,216,217,t,[44,16],n,[576,9],218,n,[576,43],38,46,t,[12,15],220,t,[12,23],n,[248,17],222,224,223,225,226,227,n,[117,9],n,[25,10],n,[96,11],229,46,231,232,n,[34,7],233,n,[33,10],n,[860,3],235,236,157,237,242,163,243,163,43,46,244,n,[160,15],246,245,247,n,[590,8],n,[50,10],251,250,253,252,n,[21,17],n,[17,52],258,n,[18,16],46,n,[109,18],n,[482,32],n,[49,34],266,224,267,270,164,243,43,n,[178,69],n,[17,193],n,[539,23],287,n,[31,30],n,[129,68],293,n,[99,8],n,[784,30],296,224,297,n,[23,20],298,242,166,243,166,46,302,167,301,167,242,304,243,43,46,n,[35,20],100,306,n,[115,16],n,[1337,3],309,n,[1293,9],310,n,[24,10],224,312,t,[67,7],197,67,313,224,314,315,316,t,[65,3],198,t,[65,6],t,[63,3],203,t,[63,7],n,[193,17],270,166,243,270,n,[124,3],n,[123,20],t,[61,3],204,t,[61,8],t,[59,10],205,206,59,59,t,[56,4],207,208,t,[56,6],209,210,t,[56,4],t,[57,4],207,208,t,[57,6],209,210,t,[57,4],t,[51,12],211,212,t,[51,6],t,[52,12],211,212,t,[52,6],t,[53,12],211,212,t,[53,6],t,[54,12],211,212,t,[54,6],t,[48,4],213,214,t,[48,16],t,[49,4],213,214,t,[49,16],t,[45,4],215,45,45,216,217,t,[45,16],t,[46,4],215,46,46,216,217,t,[46,16],n,[554,30],319,224,320,224,321,224,322,n,[492,18],n,[18,18],302,168,301,168,100,325,n,[358,16],327,n,[352,20],329,330,331,n,[738,64],n,[30,67],n,[107,11],338,n,[18,17],340,n,[18,16],342,343,t,[200,43],344,t,[200,8],345,224,n,[139,30],347,n,[32,31],349,n,[32,31],351,n,[264,60]])}),defaultActions:function(e){for(var t={},i=e.idx,n=e.goto,s=0,r=i.length;s<r;s++){t[i[s]]=n[s]}return t}({idx:s([t,[3,4,1],t,[12,19,1],t,[33,4,1],38,42,44,t,[46,5,1],55,58,64,65,69,74,77,78,80,t,[89,7,1],97,98,t,[102,6,1],109,115,116,118,119,120,t,[122,6,1],131,142,143,146,147,t,[148,4,2],155,156,158,159,t,[161,5,1],170,t,[172,11,1],189,190,191,193,194,195,199,218,219,223,231,232,233,235,236,238,239,244,245,t,[247,4,1],252,254,258,260,261,262,266,268,t,[283,4,1],288,289,t,[296,4,1],304,306,t,[308,4,1],313,314,316,317,318,325,327,t,[329,5,1],335,336,342,343,346,348,t,[350,4,1]]),goto:s([2,214,216,217,t,[100,16,1],140,141,142,119,120,1,215,86,96,145,3,t,[89,4,2],218,87,153,155,121,136,99,178,70,16,t,[32,6,1],12,13,t,[4,5,1],10,9,40,192,194,196,197,t,[183,6,1],198,83,97,148,85,38,150,159,154,156,146,117,122,128,130,124,126,131,181,t,[72,11,1],22,23,t,[27,4,1],11,193,195,199,210,211,212,147,149,161,162,116,123,133,137,139,132,179,71,18,24,20,21,15,165,41,42,43,189,191,84,209,213,158,160,174,170,129,134,180,182,17,19,31,39,190,172,176,169,175,171,69,25,202,203,173,177,205,207,201,204,206,208])}),parseError:function(e,t,i){if(!t.recoverable)throw"function"==typeof this.trace&&this.trace(e),i||(i=this.JisonParserError),new i(e,t);"function"==typeof this.trace&&this.trace(e),t.destroy()},parse:function(e){var t,i,n,s=this,r=new Array(128),o=new Array(128),a=new Array(128),c=new Array(128),h=this.table,l=0,p=0,y=(this.TERROR,this.EOF),u=(this.options.errorRecoveryTokenDiscardCount,[0,354]);n=this.__lexer__?this.__lexer__:this.__lexer__=Object.create(this.lexer);var f={parseError:void 0,quoteName:void 0,lexer:void 0,parser:void 0,pre_parse:void 0,post_parse:void 0,pre_lex:void 0,post_lex:void 0};function d(e){if("object"==typeof e){var t={};for(var i in e)Object.prototype.hasOwnProperty.call(e,i)&&(t[i]=e[i]);return t}return e}function m(e,t){for(var i in t)void 0===e[i]&&Object.prototype.hasOwnProperty.call(t,i)&&(e[i]=t[i])}function _(e){var t=d(e);return t&&t.range&&(t.range=t.range.slice(0)),t}function g(){var e=n.fastLex();return"number"!=typeof e&&(e=s.symbols_[e]||e),e||y}"function"!=typeof assert||assert,this.yyGetSharedState=function(){return f},m(f,this.yy),f.lexer=n,f.parser=this,"function"==typeof f.parseError?this.parseError=function(e,t,i){return i||(i=this.JisonParserError),f.parseError.call(this,e,t,i)}:this.parseError=this.originalParseError,"function"==typeof f.quoteName?this.quoteName=function(e){return f.quoteName.call(this,e)}:this.quoteName=this.originalQuoteName,this.cleanupAfterParse=function(e,t,i){var s,h;t&&((f.post_parse||this.post_parse)&&(h=this.constructParseErrorInfo(null,null,null,!1)),f.post_parse&&void 0!==(s=f.post_parse.call(this,f,e,h))&&(e=s),this.post_parse&&void 0!==(s=this.post_parse.call(this,f,e,h))&&(e=s),h&&h.destroy&&h.destroy());if(this.__reentrant_call_depth>1)return e;if(n.cleanupAfterLex&&n.cleanupAfterLex(i),f&&(f.lexer=void 0,f.parser=void 0,n.yy===f&&(n.yy=void 0)),f=void 0,this.parseError=this.originalParseError,this.quoteName=this.originalQuoteName,r.length=0,o.length=0,c.length=0,a.length=0,l=0,!i){for(var p=this.__error_infos.length-1;p>=0;p--){var y=this.__error_infos[p];y&&"function"==typeof y.destroy&&y.destroy()}this.__error_infos.length=0}return e},this.yyMergeLocationInfo=function(e,t,i,n,s){var r,o=0|e,a=0|t,h=i,p=n;if(!h&&null!=e)for(var y=o;y<=a&&!(h=c[y]);y++);if(!p&&null!=t)for(y=a;y>=o&&!(p=c[y]);y--);if(!h&&null==e){if(!s)for(y=(o||l)-1;y>=0&&!(h=c[y]);y--);return h?((r=d(h)).first_line=r.last_line,r.first_column=r.last_column,r.range&&(r.range=r.range.slice(0),r.range[0]=r.range[1]),p&&(m(r,p),r.last_line=p.last_line,r.last_column=p.last_column,r.range&&p.range&&(r.range[1]=p.range[1])),r):p?((r=d(p)).range&&(r.range=r.range.slice(0)),r):void 0}if(h||(h=p,p=null),h)return(r=d(h)).range&&(r.range=r.range.slice(0)),p&&(m(r,p),r.last_line=p.last_line,r.last_column=p.last_column,r.range&&p.range&&(r.range[1]=p.range[1])),r},this.constructParseErrorInfo=function(e,t,i,s){var h={errStr:e,exception:t,text:n.match,value:n.yytext,token:this.describeSymbol(p)||p,token_id:p,line:n.yylineno,loc:_(n.yylloc),expected:i,recoverable:s,state:b,action:C,new_state:S,symbol_stack:r,state_stack:o,value_stack:a,location_stack:c,stack_pointer:l,yy:f,lexer:n,parser:this,destroy:function(){var e=!!this.recoverable;for(var t in this)this.hasOwnProperty(t)&&"object"==typeof t&&(this[t]=void 0);this.recoverable=e}};return this.__error_infos.push(h),h};var b,C,w,$,v,E,x,S,T=function(){var e=n.lex();return"number"!=typeof e&&(e=s.symbols_[e]||e),e||y},A={$:!0,_$:void 0,yy:f},I=!1;try{if(this.__reentrant_call_depth++,n.setInput(e,f),"function"==typeof n.canIUse)n.canIUse().fastLex&&(T=g);for(t=n.yylloc,c[l]=t,a[l]=null,o[l]=0,r[l]=0,++l,i=n.yytext,this.pre_parse&&this.pre_parse.call(this,f),f.pre_parse&&f.pre_parse.call(this,f),S=o[l-1];;){if(b=S,this.defaultActions[b])C=2,S=this.defaultActions[b];else if(p||(p=T()),$=h[b]&&h[b][p]||u,S=$[1],!(C=$[0])){var L,k=this.describeSymbol(p)||p,N=this.collect_expected_token_set(b);L="number"==typeof n.yylineno?"Parse error on line "+(n.yylineno+1)+": ":"Parse error: ","function"==typeof n.showPosition&&(L+="\n"+n.showPosition(69,10)+"\n"),N.length?L+="Expecting "+N.join(", ")+", got unexpected "+k:L+="Unexpected "+k,v=this.constructParseErrorInfo(L,null,N,!1),void 0!==(w=this.parseError(v.errStr,v,this.JisonParserError))&&(I=w);break}switch(C){default:if(C instanceof Array){v=this.constructParseErrorInfo("Parse Error: multiple actions possible at state: "+b+", token: "+p,null,null,!1),void 0!==(w=this.parseError(v.errStr,v,this.JisonParserError))&&(I=w);break}v=this.constructParseErrorInfo("Parsing halted. No viable error recovery approach available due to internal system failure.",null,null,!1),void 0!==(w=this.parseError(v.errStr,v,this.JisonParserError))&&(I=w);break;case 1:r[l]=p,a[l]=n.yytext,c[l]=_(n.yylloc),o[l]=S,++l,p=0,i=n.yytext,t=n.yylloc;continue;case 2:if(E=(x=this.productions_[S-1])[1],void 0!==(w=this.performAction.call(A,i,t,S,l-1,a,c))){I=w;break}l-=E;var P=x[0];r[l]=P,a[l]=A.$,c[l]=A._$,S=h[o[l-1]][P],o[l]=S,++l;continue;case 3:-2!==l&&(I=!0,l--,void 0!==a[l]&&(I=a[l]))}break}}catch(e){if(e instanceof this.JisonParserError)throw e;if(n&&"function"==typeof n.JisonLexerError&&e instanceof n.JisonLexerError)throw e;v=this.constructParseErrorInfo("Parsing aborted due to exception.",e,null,!1),I=!1,void 0!==(w=this.parseError(v.errStr,v,this.JisonParserError))&&(I=w)}finally{I=this.cleanupAfterParse(I,!0,!0),this.__reentrant_call_depth--}return I}};r.originalParseError=r.parseError,r.originalQuoteName=r.quoteName;const o=i(428);function a(){this.yy={}}return a.prototype=r,r.Parser=a,new a}();t.parser=n,t.Parser=n.Parser,t.parse=function(){return n.parse.apply(n,arguments)}}},t={};function i(n){var s=t[n];if(void 0!==s)return s.exports;var r=t[n]={exports:{}};return e[n](r,r.exports,i),r.exports}i.d=(e,t)=>{for(var n in t)i.o(t,n)&&!i.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},i.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),i.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},(()=>{"use strict";var e=i(428);class CError extends Error{constructor(e,i,n){super(e),this.node=i,this.node2=n,this.name="CError",i?.loc&&(this.message+="\n\n"+t(i.loc),n?.loc&&(this.message+="\n\n"+t(n.loc,"Secondary location")))}}function t(e,t="Location"){const i=e.source.split("\n");if(e.first_line>=i.length)return`${t}: [UNKNOWN]`;let n=`${t}:\n`;const s=Math.ceil(Math.log10(e.last_line+4));function r(e){n+=`L${(e+1).toString().padStart(s,"0")}: ${i[e]}\n`}return e.first_line>1&&r(e.first_line-2),e.first_line>0&&r(e.first_line-1),r(e.first_line),n+=new Array(3+s+e.first_column).join(" "),e.first_line===e.last_line?n+=new Array(1+e.last_column-e.first_column).join("^"):n+="^",n+="\n",e.first_line+1<i.length&&r(e.first_line+1),e.first_line+2<i.length&&r(e.first_line+2),n}class CFuncType{constructor(e,t,i,n,s=!1){this.node=e,this.returnType=t,this.parameterTypes=i,this.parameterNames=n,this.variadic=s,this.typeName="function",this.bytes=0,this.alignment=1,this.incomplete=!1,t instanceof CVoid||l(t),i.forEach((e=>l(e)))}equals(e){return e instanceof CFuncType&&e.returnType.equals(this.returnType)&&e.parameterTypes.length===this.parameterTypes.length&&e.parameterTypes.every(((e,t)=>this.parameterTypes[t].equals(e)))&&e.variadic===this.variadic}get pointerGeneration(){return r(new CPointer(this.node,this,!1,this),o(this))}}class CPointer{constructor(e,t,i=!1,n){this.node=e,this.type=t,this.original=n,this.bytes=4,this.alignment=4,this.incomplete=!1,i&&(this.qualifier="const")}equals(e){return e instanceof CPointer&&e.qualifier===this.qualifier&&this.type.equals(e.type)}get pointerGeneration(){return this}get typeName(){return this.type.typeName+"*"+(this.qualifier?" "+this.qualifier:"")}}class CArray{constructor(e,t,i){this.node=e,this.type=t,this.length=i,l(t),this.alignment=t.alignment}get bytes(){if(void 0===this.length)throw new Error("Tried to get size of incomplete type");return this.type.bytes*this.length}get incomplete(){return void 0===this.length}equals(e){return e instanceof CArray&&e.length===this.length&&this.type.equals(e.type)}get pointerGeneration(){return r(new CPointer(this.node,this.type,!1,this),o(this))}get typeName(){return this.length?this.type.typeName+"["+this.length+"]":this.type.typeName+"[]"}}class CCompoundMember{constructor(e,t,i){this.node=e,this.name=t,this.type=i}}class CStruct{constructor(e,t){this.node=e,this.name=t}get members(){if(void 0===this._members)throw new Error("Can't get members of an incomplete struct");return this._members}set members(e){if(void 0!==this._members)throw new Error("Can't redefine a struct's members");if(0===e.length)throw new Error("Struct must have one or more member");this._members=e}get bytes(){if(this.incomplete)throw new Error("Tried to get size of incomplete type");return this.members.reduce(((e,t)=>(e=Math.ceil(e/t.type.alignment)*t.type.alignment)+t.type.bytes),0)}get alignment(){return Math.max(...this.members.map((e=>e.type.alignment)))}get incomplete(){return void 0===this._members}equals(e){return e instanceof CStruct&&(void 0===this.name&&void 0===e.name?this.members.length===e.members.length&&this.members.every(((t,i)=>e.members[i].name===t.name&&e.members[i].type.equals(t.type))):e.name===this.name)}memberType(e){const t=this.members.find((t=>t.name===e));if(t)return t.type;throw new Error(`Struct does not contain member "${e}"`)}hasConstMember(){return void 0!==this.members.find((e=>o(e.type)||(e.type instanceof CUnion||e.type instanceof CStruct)&&e.type.hasConstMember()))}get pointerGeneration(){return this}get typeName(){return this.name?"struct "+this.name:"struct {"+this.members.map((e=>e.type.typeName+" "+e.name+";")).join(" ")+"}"}}class CUnion{constructor(e,t){this.node=e,this.name=t}get members(){if(void 0===this._members)throw new Error("Can't get members of an incomplete union");return this._members}set members(e){if(void 0!==this._members)throw new Error("Can't redefine a union's members");if(0===e.length)throw new Error("Struct must have one or more member");this._members=e}get bytes(){if(this.incomplete)throw new Error("Tried to get size of incomplete type");return this.members.reduce(((e,t)=>Math.max(e,t.type.bytes)),0)}get alignment(){return Math.max(...this.members.map((e=>e.type.alignment)))}get incomplete(){return void 0===this._members}equals(e){return e instanceof CUnion&&(void 0===this.name&&void 0===e.name?this.members.length===e.members.length&&this.members.every(((t,i)=>e.members[i].name===t.name&&e.members[i].type.equals(t.type))):e.name===this.name)}memberType(e){const t=this.members.find((t=>t.name===e));if(t)return t.type;throw new Error(`Union does not contain member "${e}"`)}hasConstMember(){return void 0!==this.members.find((e=>o(e.type)||(e.type instanceof CUnion||e.type instanceof CStruct)&&e.type.hasConstMember()))}get pointerGeneration(){return this}get typeName(){return this.name?"union "+this.name:"union {"+this.members.map((e=>e.type.typeName+" "+e.name+";")).join(" ")+"}"}}class CEnum{constructor(e,t){this.node=e,this.name=t,this.typeName="enum"}get values(){if(void 0===this._values)throw new Error("Can't get values of an incomplete enum");return this._values}set values(e){if(void 0!==this._values)throw new Error("Can't redefine an enum's values");if(0===e.length)throw new Error("Enum must have one or more value");this._values=e}get incomplete(){return void 0===this._values}equals(e){return void 0===this.name?this===e:e instanceof CEnum&&e.name===this.name}}class CVoid{constructor(){this.typeName="void",this.bytes=0,this.alignment=1,this.incomplete=!0,this.node=void 0}equals(e){return e instanceof CVoid}get pointerGeneration(){return this}}class CArithmetic{constructor(e,t,i){this.typeName=e,this.bytes=t,this.type=i,this.incomplete=!1,this.node=void 0,this.alignment=t}equals(e){return e instanceof CArithmetic&&e.typeName===this.typeName&&e.type===this.type&&e.bytes===this.bytes}get minValue(){if(CArithmetic.BOOL.equals(this))return 0;switch(this.type){case"float":return-1/0;case"unsigned":return 0;case"signed":return-(2n**(BigInt(8*this.bytes)-1n))}}get maxValue(){if(CArithmetic.BOOL.equals(this))return 1;switch(this.type){case"float":return 1/0;case"unsigned":return 2n**BigInt(8*this.bytes)-1n;case"signed":return 2n**(BigInt(8*this.bytes)-1n)-1n}}get pointerGeneration(){return this}}CArithmetic.Fp32=new CArithmetic("float",4,"float"),CArithmetic.Fp64=new CArithmetic("double",8,"float"),CArithmetic.U8=new CArithmetic("char",1,"unsigned"),CArithmetic.S8=new CArithmetic("signed char",1,"signed"),CArithmetic.U16=new CArithmetic("unsigned short",2,"unsigned"),CArithmetic.S16=new CArithmetic("short",2,"signed"),CArithmetic.U32=new CArithmetic("unsigned int",4,"unsigned"),CArithmetic.S32=new CArithmetic("int",4,"signed"),CArithmetic.U64=new CArithmetic("unsigned long",8,"unsigned"),CArithmetic.S64=new CArithmetic("long",8,"signed"),CArithmetic.BOOL=new CArithmetic("bool",4,"signed");const n=CArithmetic.U32,s=Symbol("const");function r(e,t){if(void 0===t)return e;if(Object.prototype.hasOwnProperty.call(e,"qualifier"))throw new Error("Type already has a qualifier");const i=e;if(i[s])return i[s];const n=Object.setPrototypeOf({qualifier:t,_base:e},e);return i[s]=n,n}function o(e){return e?.qualifier}function a(e){return"float"===e.type?e:e.bytes<CArithmetic.S32.bytes||e===CArithmetic.BOOL?CArithmetic.S32:e}function c(e,t){return e===CArithmetic.Fp64||t===CArithmetic.Fp64?CArithmetic.Fp64:e===CArithmetic.Fp32||t===CArithmetic.Fp32?CArithmetic.Fp32:(e=a(e),t=a(t),e===CArithmetic.U64||t===CArithmetic.U64?CArithmetic.U64:e===CArithmetic.S64||t===CArithmetic.S64?CArithmetic.S64:e===CArithmetic.U32||t===CArithmetic.U32?CArithmetic.U32:CArithmetic.S32)}function h(e){const t=e.slice();function i(e){const i=t.indexOf(e);return i>-1&&(t.splice(i,1),!0)}function n(e){if(!(t.length>0))return e}return i("void")?n(new CVoid):i("double")?(i("long"),n(CArithmetic.Fp64)):i("float")?n(CArithmetic.Fp32):i("char")?i("signed")?n(CArithmetic.S8):(i("unsigned"),n(CArithmetic.U8)):i("short")?(i("int"),i("unsigned")?n(CArithmetic.U16):(i("signed"),n(CArithmetic.S16))):i("long")?(i("long"),i("int"),i("unsigned")?n(CArithmetic.U64):(i("signed"),n(CArithmetic.S64))):i("int")?i("unsigned")?n(CArithmetic.U32):(i("signed"),n(CArithmetic.S32)):i("unsigned")?n(CArithmetic.U32):i("signed")?n(CArithmetic.S32):i("bool")?n(CArithmetic.BOOL):void 0}function l(e,t=e.node){if(e.incomplete)throw new class extends CError{constructor(){super(...arguments),this.name="IncompleteTypeError"}}("Invalid use of an incomplete type",t);return e}const p=new Map;function y(e,t=[]){for(const i of e){t.push(i),y(i.children(),t),t.pop();for(const e of p.get(Object.getPrototypeOf(i).constructor)??[])e(i,t)}return e}class ParseTreeValidationError extends CError{constructor(e,t,i){super(e&&e.loc?`Line ${e.loc.first_line+1}: ${t}`:t,e,i),this.name="TreeValidationError"}}function u(e,t){const i=p.get(e);i?i.push(t):p.set(e,[t])}const f=e=>{if(e.qualifierList.length>1)throw new ParseTreeValidationError(e,"Invalid qualifiers.");!function(e,t){if(e.every((e=>"string"==typeof e))&&!h(e))throw new ParseTreeValidationError(t,"Invalid specifiers - "+e.join(", "))}(e.specifierList,e)};function d(t,i){for(let n=i.length-1;n>=0;n--){if(!(i[n]instanceof e.Expression)||"sizeof"===i[n].type)return;if("constantExpr"===i[n].type)throw new ParseTreeValidationError(t,"Invalid constant expr.")}}u(e.SpecifierQualifiers,f),u(e.DeclarationSpecifiers,f),u(e.DeclarationSpecifiers,((e,t)=>{if(e.storageList.length>1)throw new ParseTreeValidationError(e,"Invalid storage class list.");if(e.fnSpecifierList.length>1)throw new ParseTreeValidationError(e,"Invalid fn specifier list.");if("typedef"===e.storageList[0]&&1!==t.length)throw new ParseTreeValidationError(e,"Nested typedefs are not allowed")})),u(e.UnaryExpression,((e,t)=>{switch(e.type){case"postfixIncrement":case"postfixDecrement":case"prefixIncrement":case"prefixDecrement":case"addressOf":case"dereference":d(e,t)}})),u(e.BinaryExpression,((e,t)=>{switch(e.type){case"comma":case"arraySubscript":d(e,t)}})),u(e.FunctionCallExpression,d),u(e.MemberAccessExpression,d);var m=i(347);const _=Object.fromEntries(["if","break","case","char","const","continue","default","do","double","else","enum","extern","float","for","inline","int","long","return","short","signed","sizeof","static","struct","switch","typedef","union","unsigned","void","while","_Bool","goto","auto","register","volatile","import"].map((e=>[e,e.toUpperCase()]))),g=[{type:e=>_[e]??"IDENTIFIER",regex:/[a-zA-Z_][a-zA-Z0-9_]*/},{type:e=>e,regex:new RegExp(["...","<<=",">>=","!=","%=","&&","&=","*=","++","+=","--","-=","->","/=","<<","<=","==",">=",">>","^=","|=","||","!","%","&","(",")","*","+",",","-",".","/",":",";","<","=",">","?","[","]","^","{","|","}","~"].map((e=>e.replace(/[.*+?^${}()|[\]\\]/g,"\\$&"))).join("|"))},{type:"CONSTANT_FLOAT",regex:/(?:[0-9]+[Ee][+-]?[0-9]+|(?:[0-9]*\.[0-9]+|[0-9]+\.[0-9]*)(?:[Ee][+-]?[0-9]+)?)[fFlL]?|(?:[1-9][0-9]*|0)[fF]/},{type:"CONSTANT_HEX",regex:/0[xX][a-fA-F0-9]+(?:[uU][lL]{0,2}|[lL]{1,2}[uU]?|)/},{type:"CONSTANT_OCTAL",regex:/0[0-7]+(?:[uU][lL]{0,2}|[lL]{1,2}[uU]?|)/},{type:"CONSTANT_INT",regex:/(?:[1-9][0-9]*|0)(?:[uU][lL]{0,2}|[lL]{1,2}[uU]?|)/},{type:"CONSTANT_CHAR",regex:/'(?:[^\\\n']|\\(?:.|x[0-9a-fA-F]{1,2}|[0-7]{1,3}))'/,value:e=>e.slice(1,-1)},{type:"STRING_LITERAL",regex:/"(?:[^\\\n"]|\\(?:[^x0-7\n]|x[0-9a-fA-F]{1,2}|[0-7]{1,3}))*"/,value:e=>e.slice(1,-1)}];class Lexer{constructor(){this.source="",this.index=0,this.line=0,this.col=0}next(){for(;this.index<this.source.length&&(" "===this.source[this.index]||"\t"===this.source[this.index]||"\v"===this.source[this.index]||"\f"===this.source[this.index]||"\n"===this.source[this.index]);)"\n"===this.source[this.index]?(this.line++,this.col=1):this.col++,this.index++;const e={first_line:this.line,first_column:this.col,last_line:this.line,last_column:this.col+1,source:this.source};if(this.index===this.source.length)return{type:"EOF",value:"",text:"",loc:e};Lexer.regex.lastIndex=this.index;const t=Lexer.regex.exec(this.source);if(!t)throw new LexerError(e);const i=t[0];this.index+=i.length,this.col+=i.length,e.last_column=this.col;let n=0;for(;void 0===t[n+1];)n++;const s=g[n];return{type:"function"==typeof s.type?s.type(i):s.type,value:s.value?.(i)??i,text:i,loc:e}}reset(e){this.source=e,this.index=0,this.line=0,this.col=1}}Lexer.regex=new RegExp(g.map((e=>"("+e.regex.source+")")).join("|"),"ym");class LexerError extends CError{constructor(t){super("Unknown token",new class extends e.ParseNode{constructor(){super(...arguments),this.type="Unknown"}}(t)),this.name="LexerError"}}const b=new Lexer;const C=m;function w(e){try{return y(C.parse(e))}catch(e){throw e?.hash?.loc&&(e.message+="\n\n"+t(e.hash?.loc)),e}}C.parser.lexer=new class WrappedLexer{constructor(){this.types=new Map}lex(){const e=b.next();return this.yytext=e.value,this.yylloc=e.loc,this.yylineno=e.loc.first_line,"IDENTIFIER"===e.type&&this.types.get(e.text)?"TYPE_NAME":e.type}setInput(e){this.yytext=void 0,this.yylloc=void 0,this.yylineno=void 0,this.types.clear(),b.reset(e)}externalDeclaration(t){if("typedef"===t.typeInfo.storageList[0])for(let i of t.list){for(;!(i instanceof e.IdentifierDeclarator);)i=i.body;this.types.set(i.id,!0)}}};class type_checking_ExpressionTypeError extends CError{constructor(e,t,i){super(i?`Expected ${t} but got ${i} instead!`:`Expected ${t}`,e),this.wantedType=t,this.actualType=i,this.name="ExpressionTypeError"}}function $(e,t){if(t instanceof CArithmetic)return t;throw new type_checking_ExpressionTypeError(e,"arithmetic",t.typeName)}function v(e,t){const i=$(e,t);switch(i.type){case"signed":case"unsigned":return i;default:throw new type_checking_ExpressionTypeError(e,"integer",t.typeName)}}function E(e,t){if(t instanceof CPointer)return t;throw new type_checking_ExpressionTypeError(e,"pointer",t.typeName)}function x(e,t){if(t instanceof CArithmetic)return t;if(t instanceof CPointer)return t;throw new type_checking_ExpressionTypeError(e,"arithmetic or pointer",t.typeName)}function S(e,t){if(t instanceof CPointer&&t.type instanceof CFuncType)throw new type_checking_ExpressionTypeError(e,"non-function pointer","function pointer");return t}function T(e,t){if(e.lvalue===t)return e;throw new type_checking_ExpressionTypeError(e.node,`lvalue=${t}`,`lvalue=${e.lvalue}`)}class CConstant{constructor(e,t,i){this.node=e,this.type=t,this.value=i,this.lvalue=!1}changeType(e){if(this.type.equals(e))return this;let t;if(e.equals(CArithmetic.BOOL))t=0==this.value?0:1;else if("float"===e.type)t=Number(this.value);else{if(this.value>e.maxValue||this.value<e.minValue)throw new type_checking_ExpressionTypeError(this.node,`value which fits in ${e.typeName}`,this.value.toString());t=BigInt(this.value)}return new CConstant(this.node,e,t)}*identifiers(){}}class CIdentifier{constructor(e,t){this.node=e,this.value=t,this.lvalue=!(t.type instanceof CFuncType)}get type(){return this.value.type.pointerGeneration}*identifiers(){yield this}}class CStringLiteral{constructor(e,t){if(this.node=e,this.value=t,this.lvalue=!1,0===t.length||0n!==t[t.length-1])throw new type_checking_ExpressionTypeError(e,"null terminated char[]","char[]");this.type=new CArray(e,CArithmetic.U8,t.length).pointerGeneration}*identifiers(){}}class CFunctionCall{constructor(e,t,i){if(this.node=e,this.body=t,this.args=i,this.lvalue=!1,this.fnType=function(e,t){if(t instanceof CFuncType)return t;if(t instanceof CPointer&&t.type instanceof CFuncType)return t.type;throw new type_checking_ExpressionTypeError(e,"function",t.typeName)}(t.node,t.type),this.type=this.fnType.returnType.pointerGeneration,this.fnType.variadic&&this.fnType.parameterTypes.length>i.length)throw new type_checking_ExpressionTypeError(e,`at least ${this.fnType.parameterTypes.length} argument(s) to variadic function`);if(!this.fnType.variadic&&this.fnType.parameterTypes.length!==i.length)throw new type_checking_ExpressionTypeError(e,`${this.fnType.parameterTypes.length} argument(s)`,`${i.length}`);for(let e=0;e<this.fnType.parameterTypes.length;e++)CAssignment.checkAssignmentValid(i[e].node,this.fnType.parameterTypes[e],i[e])}*identifiers(){yield*this.body.identifiers();for(const e of this.args)yield*e.identifiers()}}class CMemberAccess{constructor(e,t,i){this.node=e,this.body=t,this.member=i;const n=t.type instanceof CPointer?t.type.original??t.type:t.type,s=E(t.node,n);this.structUnion=function(e,t){if(l(t),t instanceof CStruct)return t;if(t instanceof CUnion)return t;throw new type_checking_ExpressionTypeError(e,"struct or union",t.typeName)}(t.node,s.type);const r=this.structUnion.memberType(i);this.type=r.pointerGeneration,this.lvalue=!(this.type instanceof CArray)}*identifiers(){yield*this.body.identifiers()}}class CIncrDecr{constructor(e,t,i,n){this.node=e,this.body=t,this.op=i,this.pos=n,this.lvalue=!1,T(t,!0);const s=t.type instanceof CPointer?t.type.original??t.type:t.type;this.type=S(t.node,x(t.node,s)),this.type instanceof CPointer&&l(this.type.type)}*identifiers(){yield*this.body.identifiers()}}class CSizeof{constructor(e,t){if(this.node=e,this.lvalue=!1,this.type=n,this.body=t instanceof CPointer?t.original??t:t,this.body.incomplete||0===this.body.bytes||this.body instanceof CFuncType)throw new type_checking_ExpressionTypeError(e,"Complete non-function type",t.typeName)}*identifiers(){}}class CAddressOf{constructor(e,t){this.node=e,this.lvalue=!1;const i=t.type instanceof CPointer?t.type.original??t.type:t.type;t instanceof CIdentifier&&i instanceof CFuncType||T(t,!0),this.type=new CPointer(e,i),t instanceof CIdentifier&&(t.value.addressUsed=!0),this.body=t}*identifiers(){yield*this.body.identifiers()}}class CDereference{constructor(e,t){this.node=e,this.body=t,this.lvalue=!0,this.type=E(e,t.type).type.pointerGeneration}*identifiers(){yield*this.body.identifiers()}}class CUnaryPlusMinus{constructor(e,t,i){this.node=e,this.body=t,this.op=i,this.lvalue=!1,this.bodyType=$(t.node,t.type),this.type=a(this.bodyType)}*identifiers(){yield*this.body.identifiers()}}class CBitwiseNot{constructor(e,t){this.node=e,this.body=t,this.lvalue=!1,this.bodyType=v(t.node,t.type),this.type=this.bodyType.bytes<CArithmetic.S32.bytes?CArithmetic.S32:this.bodyType}*identifiers(){yield*this.body.identifiers()}}class CLogicalNot{constructor(e,t){this.node=e,this.body=t,this.lvalue=!1,this.type=CArithmetic.S32,x(t.node,t.type)}*identifiers(){yield*this.body.identifiers()}}class CCast{constructor(e,t,i){this.node=e,this.body=i,this.lvalue=!1,this.type=t.pointerGeneration}*identifiers(){yield*this.body.identifiers()}}class CMulDiv{constructor(e,t,i,n){this.node=e,this.lhs=t,this.rhs=i,this.op=n,this.lvalue=!1,this.type=c($(t.node,t.type),$(i.node,i.type))}*identifiers(){yield*this.lhs.identifiers(),yield*this.rhs.identifiers()}}class CMod{constructor(e,t,i){this.node=e,this.lhs=t,this.rhs=i,this.lvalue=!1,this.type=c(v(t.node,t.type),v(i.node,i.type))}*identifiers(){yield*this.lhs.identifiers(),yield*this.rhs.identifiers()}}class CAddSub{constructor(e,t,i,n){if(this.node=e,this.lhs=t,this.rhs=i,this.op=n,this.lvalue=!1,t.type instanceof CPointer&&i.type instanceof CPointer){if(!t.type.equals(i.type))throw new type_checking_ExpressionTypeError(e,"both pointers to have the same type");l(t.type.type),this.type=S(t.node,t.type),S(i.node,i.type)}else t.type instanceof CPointer?(v(i.node,i.type),l(t.type.type),this.type=S(t.node,t.type)):i.type instanceof CPointer?(v(t.node,t.type),l(i.type.type),this.type=S(i.node,i.type)):this.type=c($(t.node,t.type),$(i.node,i.type))}*identifiers(){yield*this.lhs.identifiers(),yield*this.rhs.identifiers()}}class CShift{constructor(e,t,i,n){this.node=e,this.lhs=t,this.rhs=i,this.dir=n,this.lvalue=!1,this.type=a(v(t.node,t.type)),v(i.node,i.type)}*identifiers(){yield*this.lhs.identifiers(),yield*this.rhs.identifiers()}}class CRelational{constructor(e,t,i,s){this.node=e,this.lhs=t,this.rhs=i,this.op=s,this.lvalue=!1,this.type=CArithmetic.BOOL,x(t.node,t.type),x(i.node,i.type),this.commonType=c(t.type instanceof CArithmetic?t.type:n,i.type instanceof CArithmetic?i.type:n)}*identifiers(){yield*this.lhs.identifiers(),yield*this.rhs.identifiers()}}class CEquality{constructor(e,t,i,s){this.node=e,this.lhs=t,this.rhs=i,this.op=s,this.lvalue=!1,this.type=CArithmetic.BOOL,x(t.node,t.type),x(i.node,i.type),this.commonType=c(t.type instanceof CArithmetic?t.type:n,i.type instanceof CArithmetic?i.type:n)}*identifiers(){yield*this.lhs.identifiers(),yield*this.rhs.identifiers()}}class CBitwiseAndOr{constructor(e,t,i,n){this.node=e,this.lhs=t,this.rhs=i,this.op=n,this.lvalue=!1,this.type=c(v(t.node,t.type),v(i.node,i.type))}*identifiers(){yield*this.lhs.identifiers(),yield*this.rhs.identifiers()}}class CLogicalAndOr{constructor(e,t,i,n){this.node=e,this.lhs=t,this.rhs=i,this.op=n,this.lvalue=!1,this.type=CArithmetic.BOOL,x(t.node,t.type),x(i.node,i.type)}*identifiers(){yield*this.lhs.identifiers(),yield*this.rhs.identifiers()}}class CConditional{constructor(e,t,i,n){if(this.node=e,this.test=t,this.trueValue=i,this.falseValue=n,this.lvalue=!1,x(t.node,t.type),i.type instanceof CArithmetic&&n.type instanceof CArithmetic)this.type=c(i.type,n.type);else{if(!i.type.equals(n.type)){if(i.type instanceof CPointer&&n.type instanceof CPointer){if(i.type.type instanceof CVoid)return void(this.type=n.type);if(n.type.type instanceof CVoid)return void(this.type=i.type)}else if(i.type instanceof CPointer||n.type instanceof CPointer){const e=i.type instanceof CPointer?n:i;if(e instanceof CConstant&&0==e.value)return void(this.type=i.type instanceof CPointer?i.type:n.type)}throw new type_checking_ExpressionTypeError(e,"both conditional branches to have the same type","different types")}this.type=i.type}}*identifiers(){yield*this.test.identifiers(),yield*this.trueValue.identifiers(),yield*this.falseValue.identifiers()}}class CAssignment{constructor(e,t,i,n,s=!1){this.node=e,this.lhs=t,this.rhs=i,this.assignmentType=n,this.initialAssignment=s,this.lvalue=!1;const r=t.type instanceof CPointer?t.type.original??t.type:t.type;if(T(t,!0),r instanceof CArray&&!s||r instanceof CFuncType||t.type.incomplete)throw new type_checking_ExpressionTypeError(t.node,"assignable type");if("const"===o(r)&&!s)throw new type_checking_ExpressionTypeError(t.node,"non-const location");if((r instanceof CStruct||r instanceof CUnion)&&r.hasConstMember()&&!s)throw new type_checking_ExpressionTypeError(t.node,"structure without a const member");if(this.type=r.pointerGeneration,n){if(i instanceof CInitializer)throw new type_checking_ExpressionTypeError(e,"simple assignments with structure initializers");let s=i.type;switch(n){case"mul":s=new CMulDiv(e,t,i,"*").type;break;case"div":s=new CMulDiv(e,t,i,"/").type;break;case"mod":s=new CMod(e,t,i).type;break;case"add":s=new CAddSub(e,t,i,"+").type;break;case"sub":s=new CAddSub(e,t,i,"-").type;break;case"leftShift":s=new CShift(e,t,i,"left").type;break;case"rightShift":s=new CShift(e,t,i,"right").type;break;case"bitwiseAnd":s=new CBitwiseAndOr(e,t,i,"and").type;break;case"bitwiseOr":s=new CBitwiseAndOr(e,t,i,"or").type;break;case"bitwiseXor":s=new CBitwiseAndOr(e,t,i,"xor").type;break;default:throw new type_checking_ExpressionTypeError(e,"valid assignment type")}CAssignment._checkAssignmentTypeValid(e,r,s)}else CAssignment.checkAssignmentValid(e,r,i)}*identifiers(){yield*this.lhs.identifiers(),yield*this.rhs.identifiers()}static checkAssignmentValid(e,t,i){t instanceof CPointer&&i instanceof CConstant&&0n===i.value||this._checkAssignmentTypeValid(e,t,i.type)}static _checkAssignmentTypeValid(e,t,i){if(!(t.equals(i)||t instanceof CArithmetic&&i instanceof CArithmetic)){if(t instanceof CPointer&&i instanceof CPointer){if(t.type instanceof CVoid||i.type instanceof CVoid)return;if(t.type.equals(i.type))return}if(!(t instanceof CPointer&&i instanceof CFuncType&&t.type.equals(i))){if(i instanceof CPointer&&i.original){if(t.equals(i.original))return;if(t instanceof CArray&&i.original instanceof CArray&&t.type.equals(i.type)&&(i.original.length??0)<(t.length??0))return}throw new type_checking_ExpressionTypeError(e,t.typeName,i.typeName)}}}}class CComma{constructor(e,t,i){this.node=e,this.lhs=t,this.rhs=i,this.lvalue=!1,this.type=i.type}*identifiers(){yield*this.lhs.identifiers(),yield*this.rhs.identifiers()}}class CInitializer{constructor(e,t,i){this.node=e,this.body=t,this._memberTypes=[],this._type=i??new CArray(void 0,new CPointer(void 0,new CVoid),t.length)}get memberTypes(){return this._memberTypes}get type(){return this._type}set type(e){if(this._memberTypes=[],e instanceof CArray){if(this.body.length>(e.length??1/0))throw new type_checking_ExpressionTypeError(this.node,`at most ${e.length} elements`,`${this.body.length} elements`);for(let t=0;t<this.body.length;t++)this.body[t]=CInitializer.typeCheck(e.type,this.body[t]),this._memberTypes.push(e.type)}else if(e instanceof CStruct){if(this.body.length>e.members.length)throw new type_checking_ExpressionTypeError(this.node,`at most ${e.members.length} elements`,`${this.body.length} elements`);for(let t=0;t<this.body.length;t++)this.body[t]=CInitializer.typeCheck(e.members[t].type,this.body[t]),this._memberTypes.push(e.members[t].type)}else{if(!(e instanceof CUnion))throw new type_checking_ExpressionTypeError(this.node,"Invalid type for initializer");if(this.body.length>1)throw new type_checking_ExpressionTypeError(this.node,"one element matching first member in union",`${this.body.length} elements`);1===this.body.length&&(this.body[0]=CInitializer.typeCheck(e.members[0].type,this.body[0]),this._memberTypes.push(e.members[0].type))}this._type=e}*identifiers(){for(const e of this.body)yield*e.identifiers()}static typeCheck(e,t){return t instanceof CInitializer?t.type=e:(CAssignment.checkAssignmentValid(t.node,e,t),t instanceof CConstant&&e instanceof CArithmetic&&t.type!==e&&(t=t.changeType(e))),t}}class Scope{constructor(e,t,i=t?.func){this.node=e,this.parent=t,this.func=i,this.tags=new Map,this.identifiers=new Map,this.typedefs=new Map}_getTag(e){return this.tags.get(e)??this.parent?._getTag(e)}lookupTag(e,t,i){const n=this._getTag(e);if(t&&n&&t.prototype!==Object.getPrototypeOf(n))throw new ScopeError("`"+e+"` was already declared as a "+n.typeName,n.node,i);return n}addTag(e){if(!e.name)throw new Error("Cannot add nameless compound type to scope");if(this._getTag(e.name))throw new ScopeError("Compound type `"+e.name+"` is already defined!",e.node);this.tags.set(e.name,e)}_getId(e){return this.identifiers.get(e)??this.parent?._getId(e)}lookupIdentifier(e,t){const i=this._getId(e);if(!i)throw new ScopeError("Failed to find `"+e+"`",t);return i}addIdentifier(e){const t=this.identifiers.get(e.name);if(t)if(t.type.equals(e.type)&&t instanceof CFuncDeclaration&&e instanceof CFuncDefinition)"external"!==t.linkage&&"external"===e.linkage&&(e.linkage=t.linkage),t.definition=e;else{if(t.type.equals(e.type)&&e instanceof CFuncDeclaration)return void(t instanceof CFuncDeclaration&&(t.fnImport||(t.fnImport=e.fnImport)));if(!(t.type.equals(e.type)&&t instanceof CVarDeclaration&&e instanceof CVarDefinition)){if(t.type.equals(e.type)&&e instanceof CVarDeclaration){if("external"!==t.linkage&&t.linkage!==e.linkage)throw new ScopeError("Variable `"+e.name+"` is already defined with "+t.linkage+" linkage",t.node,e.node);return}throw new ScopeError("Identifier `"+e.name+"` is already defined in this scope!",t.node,e.node)}if("external"!==t.linkage&&t.linkage!==e.linkage)throw new ScopeError("Variable `"+e.name+"` is already defined with "+t.linkage+" linkage",t.node,e.node);t.definition=e}this.identifiers.set(e.name,e)}get declarations(){return[...this.identifiers.values()]}_getTypedef(e){return this.typedefs.get(e)??this.parent?._getTypedef(e)}lookupTypedef(e,t){const i=this._getTypedef(e);if(void 0===i)throw new ScopeError("typedef `"+e+"` not found in scope",t);return i}addTypedef(e,t,i){const n=this._getTypedef(e);if(n){if(n.equals(t))return;throw new ScopeError("typedef already defined with a different type",i)}this.typedefs.set(e,t)}}class ScopeError extends CError{constructor(){super(...arguments),this.name="ScopeError"}}class CCompoundStatement{constructor(e,t){this.node=e,this.parent=t,this.statements=[],this.scope=new Scope(e,t.scope,t instanceof CFuncDefinition?t:void 0)}}class CExpressionStatement{constructor(e,t,i){this.node=e,this.expression=t,this.parent=i}get scope(){return this.parent.scope}}class CNop{constructor(e,t){this.node=e,this.parent=t}get scope(){return this.parent.scope}}class CIf{constructor(e,t,i){this.node=e,this.test=t,this.parent=i,x(t.node,t.type)}get scope(){return this.parent.scope}}class CForLoop{constructor(e,t){this.node=e,this.parent=t,this.scope=new Scope(e,t.scope)}}class CWhileLoop{constructor(e,t,i){this.node=e,this.test=t,this.parent=i,x(t.node,t.type)}get scope(){return this.parent.scope}}class CDoLoop{constructor(e,t,i){this.node=e,this.test=t,this.parent=i,x(t.node,t.type)}get scope(){return this.parent.scope}}class CGoto{constructor(e,t,i){this.node=e,this.target=t,this.parent=i}get scope(){return this.parent.scope}}class CSwitch{constructor(e,t,i){this.node=e,this.expression=t,this.parent=i,this.children=[]}get scope(){return this.parent.scope}}class CContinue{constructor(e,t,i){this.node=e,this.loop=t,this.parent=i}get scope(){return this.parent.scope}}class CBreak{constructor(e,t,i){this.node=e,this.target=t,this.parent=i}get scope(){return this.parent.scope}}class CReturn{constructor(e,t,i,n){if(this.node=e,this.func=t,this.value=i,this.parent=n,void 0===i){if(t.type.returnType.bytes>0)throw new type_checking_ExpressionTypeError(e,"`return [expression]`","`return;`")}else t.type.returnType.equals(i.type)||CAssignment.checkAssignmentValid(e,t.type.returnType,i)}get scope(){return this.parent.scope}}class CLabelledStatement{constructor(e,t){this.node=e,this.label=t}}class CVarDeclaration{constructor(e,t,i,n,s){this.node=e,this.name=t,this.type=i,this.storage=n,this.linkage=s,this.declType="variable",this._addressUsed=!1}set addressUsed(e){var t;this._definition?(t=this._definition).addressUsed||(t.addressUsed=e):this._addressUsed||(this._addressUsed=e)}get addressUsed(){return this._definition?this._definition.addressUsed:this._addressUsed}set definition(e){if(void 0===e)throw new Error("Cannot set definition to undefined");e.addressUsed||(e.addressUsed=this._addressUsed),this._definition=e}get definition(){return this._definition}}class CVarDefinition{constructor(e,t,i,n,s){this.node=e,this.name=t,this.type=i,this.storage=n,this.linkage=s,this.declType="variable",this.addressUsed=!1,this.dependencies=new Map}}class CArgument{constructor(e,t,i,n){this.node=e,this.name=t,this.type=i,this.index=n,this.declType="variable",this.storage="argument",this.linkage="none",this.addressUsed=!1}}class CFuncDeclaration{constructor(e,t,i,n,s=!1){this.node=e,this.name=t,this.type=i,this.linkage=n,this.fnImport=s,this.declType="function"}}class CFuncDefinition{constructor(e,t,i,n,s){this.node=e,this.name=t,this.type=i,this.linkage=n,this.translationUnit=s,this.declType="function",this.dependencies=new Map,this.hints={inline:!1},this.body=new CCompoundStatement(e.body,this)}get scope(){return this.translationUnit}equals(e){return e===this}getFunction(){return this}}const A=new class extends e.ParseNode{constructor(){super({first_line:0,first_column:0,last_line:0,last_column:0,source:""}),this.type="__internal__"}},I={wasm:new CFuncDeclaration(A,"__wasm__",new CFuncType(A,new CVoid,[CArithmetic.U32],void 0,!0),"internal"),wasm_i32:new CFuncDeclaration(A,"__wasm_i32__",new CFuncType(A,CArithmetic.U32,[CArithmetic.U32],void 0,!0),"internal"),wasm_i64:new CFuncDeclaration(A,"__wasm_i64__",new CFuncType(A,CArithmetic.U64,[CArithmetic.U32],void 0,!0),"internal"),wasm_f32:new CFuncDeclaration(A,"__wasm_f32__",new CFuncType(A,CArithmetic.Fp32,[CArithmetic.U32],void 0,!0),"internal"),wasm_f64:new CFuncDeclaration(A,"__wasm_f64__",new CFuncType(A,CArithmetic.Fp64,[CArithmetic.U32],void 0,!0),"internal"),wasm_ssp:new CFuncDeclaration(A,"__wasm_ssp__",new CFuncType(A,new CPointer(A,new CVoid,!0),[]),"internal"),wasm_rload:new CFuncDeclaration(A,"__wasm_rload__",new CFuncType(A,new CPointer(A,new CVoid,!0),[new CPointer(A,new CVoid,!0)]),"internal")},L=new Scope;Object.values(I).forEach((e=>L.addIdentifier(e)));const k=Symbol("constant");function N(e){e[k]=!1}function P(e,t){if(e[k]??1){if(e instanceof CConstant)return{value:e.value,type:e.type};if(e instanceof CIdentifier&&e.value instanceof CVarDefinition&&"const"===e.value.type.qualifier&&e.value.staticValue instanceof CConstant)return P(e.value.staticValue,t);if(e instanceof CSizeof)return M({value:e.body.bytes,type:n});if(e instanceof CUnaryPlusMinus){const i=P(e.body,t);return i?"+"===e.op?i:{value:-i.value,type:e.type}:N(e)}if(e instanceof CBitwiseNot){const i=D(e.body,t);return i?M({value:~i.value,type:i.type}):N(e)}if(e instanceof CLogicalNot){const i=P(e.body,t);return i?{value:0==i.value?1n:0n,type:CArithmetic.S32}:N(e)}if(e instanceof CCast&&(e.type instanceof CArithmetic||e.type instanceof CPointer)){const i=P(e.body,t);return i?M({value:i.value,type:e.type}):N(e)}if(e instanceof CMulDiv){const i=P(e.lhs,t),n=P(e.rhs,t);if(!i||!n)return N(e);if("*"===e.op)return"float"===e.type.type?{value:Number(i.value)*Number(n.value),type:e.type}:M({value:BigInt(i.value)*BigInt(n.value),type:e.type});if(0!=n.value)return"float"===e.type.type?{value:Number(i.value)/Number(n.value),type:e.type}:M({value:BigInt(i.value)/BigInt(n.value),type:e.type})}else{if(e instanceof CMod){const i=D(e.lhs,t),n=D(e.rhs,t);return i&&n&&0n!==n.value?M({value:i.value%n.value,type:e.type}):N(e)}if(e instanceof CAddSub&&e.type instanceof CArithmetic){const i=P(e.lhs,t),n=P(e.rhs,t);return i&&n?"+"===e.op?"float"===e.type.type?{value:Number(i.value)+Number(n.value),type:e.type}:M({value:BigInt(i.value)+BigInt(n.value),type:e.type}):"float"===e.type.type?{value:Number(i.value)-Number(n.value),type:e.type}:M({value:BigInt(i.value)-BigInt(n.value),type:e.type}):N(e)}if(e instanceof CShift){const i=D(e.lhs,t),n=D(e.rhs,t);return i&&n?"left"===e.dir?M({value:i.value<<n.value,type:e.type}):M({value:i.value>>n.value,type:e.type}):N(e)}if(e instanceof CRelational){const i=P(e.lhs,t),n=P(e.rhs,t);return i&&n?"LT"===e.op?{value:i.value<n.value?1n:0n,type:CArithmetic.S32}:"GT"===e.op?{value:i.value>n.value?1n:0n,type:CArithmetic.S32}:"LEq"===e.op?{value:i.value<=n.value?1n:0n,type:CArithmetic.S32}:{value:i.value>=n.value?1n:0n,type:CArithmetic.S32}:N(e)}if(e instanceof CEquality){const i=P(e.lhs,t),n=P(e.rhs,t);return i&&n?"=="===e.op?{value:i.value==n.value?1n:0n,type:CArithmetic.S32}:{value:i.value!=n.value?1n:0n,type:CArithmetic.S32}:N(e)}if(e instanceof CBitwiseAndOr){const i=D(e.lhs,t),n=D(e.rhs,t);return i&&n?"and"===e.op?M({value:i.value&n.value,type:e.type}):"or"===e.op?M({value:i.value|n.value,type:e.type}):M({value:i.value^n.value,type:e.type}):N(e)}if(e instanceof CLogicalAndOr){const i=P(e.lhs,t);if(!i)return N(e);if("and"===e.op){if(0!=i.value){const i=P(e.rhs,t);if(!i)return N(e);if(0!=i.value)return{value:1n,type:CArithmetic.S32}}return{value:0n,type:CArithmetic.S32}}{if(0!=i.value)return{value:1n,type:CArithmetic.S32};const n=P(e.rhs,t);return n?0!=n.value?{value:1n,type:CArithmetic.S32}:{value:0n,type:CArithmetic.S32}:N(e)}}if(e instanceof CConditional&&(e.type instanceof CArithmetic||e.type instanceof CPointer)){const i=P(e.test,t);if(!i)return N(e);let n;return n=0!=i.value?P(e.trueValue,t):P(e.falseValue,t),n?M({value:n.value,type:e.type}):N(e)}}if(void 0!==t){const i=t(e,(e=>P(e,t)),N);if(i)return i}N(e)}}function D(e,t){const i=P(e,t);if(i?.type instanceof CArithmetic&&"float"!==i.type.type)return{value:BigInt(i.value),type:i.type}}function M(e){if(e.type instanceof CArithmetic){if(CArithmetic.BOOL.equals(e.type))return{value:0==e.value?0n:1n,type:CArithmetic.BOOL};if("float"===e.type.type)return{value:"number"==typeof e.value?e.value:Number(e.value),type:e.type};{let t;t="number"==typeof e.value?isNaN(e.value)?0n:e.value>e.type.maxValue?BigInt(e.type.maxValue):e.value<e.type.minValue?BigInt(e.type.minValue):BigInt(Math.trunc(e.value)):e.value;const i=2n**BigInt(8*e.type.bytes)-1n;if("unsigned"===e.type.type)t&=i;else{const n=BigInt(e.type.minValue);t=(t-n&i)+n}return{value:t,type:e.type}}}return{value:M({value:e.value,type:CArithmetic.U32}).value,type:e.type}}function O(t,i){let n=function(t,i){const n=t.specifierList,s=1===n.length?n[0]:void 0;if(s instanceof e.StructUnionSpecifier){const e="struct"===s.structure?CStruct:CUnion;let t=new e(s,s.id);if(s.id){const n=i.lookupTag(s.id,e,s);n?t=n:i.addTag(t)}if(!s.declarations)return t;const n=[];for(const e of s.declarations){const t=O(e,i);for(const s of e.list){const r=F(t,s,i),o=U(s);if(r.incomplete||0===r.bytes||r instanceof CFuncType)throw new ParseTreeValidationError(s,"Type must be complete");n.push(new CCompoundMember(e,o,r))}}return t.members=n,t.node=s,t}if(s instanceof e.EnumSpecifier){let e=new CEnum(s,s.id);if(s.id){const t=i.lookupTag(s.id,CEnum,s);t?e=t:i.addTag(e)}if(!s.body)return CArithmetic.S32;let t=0n;const n=[];for(const e of s.body){e.value&&(t=V(e.value,i).value);const s=new CVarDefinition(e,e.id,r(CArithmetic.S32,"const"),"static","internal");s.staticValue=new CConstant(e,CArithmetic.S32,t),i.addIdentifier(s),n.push({name:e.id,value:t++})}return e.values=n,e.node=s,CArithmetic.S32}if(n.every((e=>"string"==typeof e))){const e=h(n);if(e)return e}else if(1===n.length&&n[0]instanceof e.CustomTypeSpecifier)return i.lookupTypedef(n[0].name);throw new ParseTreeValidationError(t,"Invalid specifier")}(t.typeInfo,i);return t.typeInfo.qualifierList.length&&(n=r(n,t.typeInfo.qualifierList[0])),t.declarator&&(n=F(n,t.declarator,i)),n}function F(t,i,n){let s=i;for(;s&&!(s instanceof e.IdentifierDeclarator);)if(s instanceof e.PointerDeclarator||s instanceof e.AbstractPointerDeclarator){let e=s.pointer;for(;e;)t=new CPointer(e,t,e.qualifierList?.includes("const")),e=e.body;s=s.body}else if(s instanceof e.ArrayDeclarator||s instanceof e.AbstractArrayDeclarator){if(t=new CArray(s,t),s.length&&(t.length=Number(V(s.length,n).value),t.length<=0))throw new ParseTreeValidationError(s.length,"Invalid array length");s=s.body}else{const e=[];let i;for(const t of s.args??[]){let s=O(t,n);if(s instanceof CArray)s=new CPointer(s.node,s.type);else if(s instanceof CFuncType)throw new ParseTreeValidationError(t,"Functions cannot be parameters");if(e.push(s),t.declarator&&!t.declarator.abstractDeclarator&&(i??(i=[]),i.push(U(t.declarator))),i&&i.length!==e.length)throw new ParseTreeValidationError(t,"Unexpected mix of abstract & non-abstract declarators")}1===e.length&&e[0]instanceof CVoid&&e.shift(),0===e.length&&(i=[]),t=new CFuncType(s,t,e,i,s.variadic),s=s.body}return t}function U(t){for(;!(t instanceof e.IdentifierDeclarator);)t=t.body;return t.id}function B(t,i){if(t instanceof e.ConstantExpression)return B(t.expr,i);if(t instanceof e.Constant)return function(e){let t,i=e.value;if("int"===e.valueType||"oct"===e.valueType||"hex"===e.valueType){let t,n,s=!1,r=!1;if(i=i.toLowerCase(),i.endsWith("u")&&(i=i.slice(0,-1),s=!0),i.endsWith("l")&&(i=i.slice(0,-1),r=!0,i.endsWith("l")&&(i=i.slice(0,-1))),!s&&i.endsWith("u")&&(i=i.slice(0,-1),s=!0),"oct"!==e.valueType)t=BigInt(i);else{t=0n;for(let e=0;e<i.length-1;e++)t+=BigInt(i[i.length-1-e])*8n**BigInt(e)}n="int"!==e.valueType||s||r?"int"===e.valueType||s||r?s&&r?[CArithmetic.U64]:r?[CArithmetic.S64,CArithmetic.U64]:[CArithmetic.U32,CArithmetic.U64]:[CArithmetic.S32,CArithmetic.U32,CArithmetic.S64,CArithmetic.U64]:[CArithmetic.S32,CArithmetic.S64,CArithmetic.U64];for(const i of n)if(t>=i.minValue&&t<=i.maxValue)return new CConstant(e,i,t);throw new ParseTreeValidationError(e,"Integer constant too large for its type")}if("float"===e.valueType)return i.endsWith("f")?(i=i.slice(0,-1),t=CArithmetic.Fp32):t=CArithmetic.Fp64,new CConstant(e,t,parseFloat(i));if("char"===e.valueType)return i=q(i,e),new CConstant(e,CArithmetic.U8,BigInt(i.codePointAt(0)));throw new ParseTreeValidationError(e,"Invalid constant type?")}(t);if(t instanceof e.Identifier){const e=new CIdentifier(t,i.lookupIdentifier(t.name,t));return i.func&&i.func.dependencies.set(e.value,!0),e}if(t instanceof e.StringLiteral){const e=[],i=/[^\\\n"]|\\(?:[^x0-7\n]|x[0-9a-fA-F]{1,2}|[0-7]{1,3})/y;for(;i.lastIndex<t.value.length;){const n=i.exec(t.value);if(!n||0===i.lastIndex)throw new ParseTreeValidationError(t,"Invalid string literal");e.push(BigInt(q(n[0],t).codePointAt(0)??0))}return e.push(0n),new CStringLiteral(t,e)}if(t instanceof e.UnaryExpression)return function(e,t){const i=B(e.body,t);if("prefixIncrement"===e.type)return new CIncrDecr(e,i,"++","pre");if("prefixDecrement"===e.type)return new CIncrDecr(e,i,"--","pre");if("postfixIncrement"===e.type)return new CIncrDecr(e,i,"++","post");if("postfixDecrement"===e.type)return new CIncrDecr(e,i,"--","post");if("addressOf"===e.type)return new CAddressOf(e,i);if("dereference"===e.type)return new CDereference(e,i);if("unaryPlus"===e.type)return new CUnaryPlusMinus(e,i,"+");if("unaryMinus"===e.type)return new CUnaryPlusMinus(e,i,"-");if("bitwiseNot"===e.type)return new CBitwiseNot(e,i);if("logicalNot"===e.type)return new CLogicalNot(e,i);throw new ParseTreeValidationError(e,"Invalid unary expression")}(t,i);if(t instanceof e.BinaryExpression)return function(e,t){const i=B(e.lhs,t),n=B(e.rhs,t);if("mul"===e.type)return new CMulDiv(e,i,n,"*");if("div"===e.type)return new CMulDiv(e,i,n,"/");if("mod"===e.type)return new CMod(e,i,n);if("add"===e.type)return new CAddSub(e,i,n,"+");if("sub"===e.type)return new CAddSub(e,i,n,"-");if("bitwiseShiftLeft"===e.type)return new CShift(e,i,n,"left");if("bitwiseShiftRight"===e.type)return new CShift(e,i,n,"right");if("relationalLT"===e.type)return new CRelational(e,i,n,"LT");if("relationalGT"===e.type)return new CRelational(e,i,n,"GT");if("relationalLEq"===e.type)return new CRelational(e,i,n,"LEq");if("relationalGEq"===e.type)return new CRelational(e,i,n,"GEq");if("relationalEq"===e.type)return new CEquality(e,i,n,"==");if("relationalNEq"===e.type)return new CEquality(e,i,n,"!=");if("bitwiseAnd"===e.type)return new CBitwiseAndOr(e,i,n,"and");if("bitwiseXor"===e.type)return new CBitwiseAndOr(e,i,n,"xor");if("bitwiseOr"===e.type)return new CBitwiseAndOr(e,i,n,"or");if("logicalAnd"===e.type)return new CLogicalAndOr(e,i,n,"and");if("logicalOr"===e.type)return new CLogicalAndOr(e,i,n,"or");if("comma"===e.type)return new CComma(e,i,n);if("arraySubscript"===e.type)return new CDereference(e,new CAddSub(e,B(e.lhs,t),B(e.rhs,t),"+"));throw new ParseTreeValidationError(e,"Invalid binary expression")}(t,i);if(t instanceof e.SizeofExpression)return t.body instanceof e.Expression?new CSizeof(t,B(t.body,i).type):new CSizeof(t,O(t.body,i));if(t instanceof e.CastExpression)return new CCast(t,O(t.targetType,i),B(t.body,i));if(t instanceof e.FunctionCallExpression)return new CFunctionCall(t,B(t.fn,i),(t.args??[]).map((e=>B(e,i))));if(t instanceof e.MemberAccessExpression){let e=B(t.lhs,i);return t.pointer||(e=new CAddressOf(t,e)),new CMemberAccess(t,e,t.rhs)}if(t instanceof e.ConditionalExpression)return new CConditional(t,B(t.condition,i),B(t.trueValue,i),B(t.falseValue,i));if(t instanceof e.AssignmentExpression)return new CAssignment(t,B(t.lhs,i),B(t.rhs,i),t.assignType);throw new ParseTreeValidationError(t,"Invalid expression")}function V(e,t){return function(e,t){const i=D(e,t);if(i)return i;throw new type_checking_ExpressionTypeError(e.node,"constant integer expression")}(B(e.expr,t))}function q(e,t){if(e.startsWith("\\")){if("\\n"===e)return"\n";if("\\t"===e)return"\t";if("\\v"===e)return"\v";if("\\b"===e)return"\b";if("\\r"===e)return"\r";if("\\f"===e)return"\f";if("\\a"===e)return"";if("\\\\"===e)return"\\";if("\\?"===e)return"?";if("\\'"===e)return"'";if('\\"'===e)return'"';let i;if(i=e.startsWith("\\x")?parseInt(e.slice(2),16):parseInt(e.slice(1),8),!isNaN(i)&&i>=0&&i<=255)return String.fromCharCode(i);throw new ParseTreeValidationError(t,"Invalid character escape")}const i=e.codePointAt(0);if(1!==e.length||void 0===i||i>255)throw new ParseTreeValidationError(t,"Invalid character");return e}function R(t,i,n){if("typedef"===t.typeInfo.storageList[0])return function(t,i){if(0===t.list.length)throw new ParseTreeValidationError(t,"typedef must define at least one identifier");const n=O(t,i);for(const s of t.list){if(s instanceof e.InitDeclarator)throw new ParseTreeValidationError(t,"cannot initialize a typedef");const r=F(n,s,i),o=U(s);i.addTypedef(o,r,s)}}(t,i),[];const s=O(t,i),r=[];for(let o of t.list){const a=U(o);let c;o instanceof e.InitDeclarator&&(c=G(o,o.initializer,i),o=o.body);const h=F(s,o,i),l=c?.type instanceof CPointer?c.type.original??c.type:c?.type;if(l instanceof CArray&&h instanceof CArray&&h.incomplete&&(h.length=l.length),h.incomplete)throw new type_checking_ExpressionTypeError(h.node??o,"complete type","incomplete type");if(h instanceof CFuncType){const e="static"===t.typeInfo.storageList[0]?"internal":"external",n="import"===t.typeInfo.fnSpecifierList[0];i.addIdentifier(new CFuncDeclaration(o,a,h,e,n))}else{if(t.typeInfo.fnSpecifierList.length>0)throw new type_checking_ExpressionTypeError(o,"variable declaration with function specifier");let e,s,l;"static"===t.typeInfo.storageList[0]?(e="static",s=n?"none":"internal",l=n||void 0!==c?CVarDefinition:CVarDeclaration):"extern"===t.typeInfo.storageList[0]?(e="static",s="external",l=CVarDeclaration):(e=n?"local":"static",s=n?"none":"external",l=n||void 0!==c?CVarDefinition:CVarDeclaration);const p=new l(o,a,h,e,s);if(i.addIdentifier(p),c){if(p instanceof CVarDeclaration)throw new type_checking_ExpressionTypeError(o,"declaration","declaration with initializer");if(c instanceof CInitializer&&(c.type=h),c instanceof CConstant&&h instanceof CArithmetic&&h!==c.type&&(c=c.changeType(h)),n&&"static"!==p.storage){const e=new CIdentifier(o,p);r.push(new CAssignment(o,e,c,void 0,!0))}else{p.staticValue=c,CAssignment.checkAssignmentValid(o,h,p.staticValue);for(const e of c.identifiers())p.dependencies.set(e.value,!0)}}}}return r}function G(e,t,i){return Array.isArray(t)?new CInitializer(e,t.map((t=>G(e,t,i)))):B(t,i)}function z(e,t){if("import"===e.typeInfo.fnSpecifierList[0])throw new type_checking_ExpressionTypeError(e,"function definition to not be marked `import`");const i=O(e,t);if(!(i instanceof CFuncType))throw new ParseTreeValidationError(e,"Unexpected declarator");const n=U(e.declarator);let s;if("static"===e.typeInfo.storageList[0])s="internal";else{if("typedef"===e.typeInfo.storageList[0])throw new ParseTreeValidationError(e,"Invalid typedef");s="external"}const r=new CFuncDefinition(e,n,i,s,t);if(r.hints.inline="inline"===e.typeInfo.fnSpecifierList[0],t.addIdentifier(r),!i.parameterNames)throw new ParseTreeValidationError(e,"Expected parameter names");for(let t=0;t<i.parameterTypes.length;t++)r.body.scope.addIdentifier(new CArgument(e,i.parameterNames[t],i.parameterTypes[t],t));if(H(e.body,r),!(i.returnType instanceof CVoid||j(r.body)))throw new ParseTreeValidationError(e.body,"Non-void function may not return")}function j(e){if(e instanceof CReturn)return!0;if(e instanceof CCompoundStatement){for(let t=0;t<e.statements.length;t++)if(j(e.statements[t])){if(t+1<e.statements.length){if(e.statements[t+1]===e.scope.labelledStatement?.body)continue;throw new ParseTreeValidationError(e.statements[t+1].node,"Statement after return")}return!0}}else{if(e instanceof CIf)return j(e.ifBody)&&j(e.elseBody);if(e instanceof CDoLoop)return j(e.body);if(e instanceof CSwitch)return e.children.every((e=>j(e.body)))&&void 0!==e.children.find((e=>e.default))}return!1}function W(t,i){if(t instanceof e.CompoundStatement)return H(t,i);if(t instanceof e.ExpressionStatement)return new CExpressionStatement(t,B(t.expression,i.scope),i);if(t instanceof e.IfStatement){const e=new CIf(t,B(t.expression,i.scope),i);return e.ifBody=W(t.ifBody,e),t.elseBody&&(e.elseBody=W(t.elseBody,e)),e}if(t instanceof e.ForLoop){const n=new CForLoop(t,i);return t.init instanceof e.ExpressionStatement||t.init instanceof e.NoOp?n.init=W(t.init,n):n.init=R(t.init,n.scope,!0).map((e=>new CExpressionStatement(e.node,e,n))),n.test=W(t.test,n),t.update&&(n.update=B(t.update,n.scope)),n.body=W(t.body,n),n}if(t instanceof e.WhileLoop){const e=new CWhileLoop(t,B(t.test,i.scope),i);return e.body=W(t.body,e),e}if(t instanceof e.DoWhileLoop){const e=new CDoLoop(t,B(t.test,i.scope),i);return e.body=W(t.body,e),e}if(t instanceof e.GotoStatement){let e=i;for(;e.scope.labelledStatement?.label!==t.target;){if(e.parent instanceof CFuncDefinition)throw new ParseTreeValidationError(t,"No properly structured control flow target for goto statement");e=e.parent}return new CGoto(t,e.scope.labelledStatement,i)}if(t instanceof e.ContinueStatement){let e=i;for(;!(e instanceof CForLoop||e instanceof CWhileLoop||e instanceof CDoLoop);){if(e.parent instanceof CFuncDefinition)throw new ParseTreeValidationError(t,"No target for continue statement");e=e.parent}return new CContinue(t,e,i)}if(t instanceof e.BreakStatement){let e=i;for(;!(e instanceof CForLoop||e instanceof CWhileLoop||e instanceof CDoLoop||e instanceof CSwitch);){if(e.parent instanceof CFuncDefinition)throw new ParseTreeValidationError(t,"No target for break statement");e=e.parent}return new CBreak(t,e,i)}if(t instanceof e.SwitchStatement){const n=new CSwitch(t,B(t.expression,i.scope),i);return function(t,i,n){if(!(i.body instanceof e.CompoundStatement))throw new ParseTreeValidationError(i,"Expected switch statement to have a compound statement body");const s=i.body.body.slice();for(;s.length>0;){const r=s.shift();if(r instanceof e.CaseStatement||r instanceof e.DefaultStatement){let o;t.children.length>0&&0===t.children[t.children.length-1].body.statements.length?o=t.children[t.children.length-1]:(o={cases:[],default:!1,body:new CCompoundStatement(i,t)},t.children.push(o)),r instanceof e.CaseStatement?o.cases.push(V(r.value,n)):o.default=!0,s.unshift(r.body)}else if(r){if(0===t.children.length)throw new ParseTreeValidationError(r,"Unexpected first statement inside a switch statement");Q(r,t.children[t.children.length-1].body)}}}(n,t,i.scope),n}if(t instanceof e.ReturnStatement){let e=i;for(;!(e instanceof CFuncDefinition);)e=e.parent;const n=t.value?B(t.value,i.scope):void 0;return new CReturn(t,e,n,i)}if(t instanceof e.NoOp)return new CNop(t,i);if(t instanceof e.CaseStatement)throw new ParseTreeValidationError(t,"Unexpected case statement");if(t instanceof e.DefaultStatement)throw new ParseTreeValidationError(t,"Unexpected default statement");throw new ParseTreeValidationError(t,"Unknown statement type")}function H(t,i){const n=i instanceof CFuncDefinition?i.body:new CCompoundStatement(t,i),s=t.body.filter((t=>t instanceof e.Statement&&void 0!==t.label));if(s.length>1)throw new ParseTreeValidationError(s[0],"Only one labelled statement is supported per block",s[1]);1===s.length&&(n.scope.labelledStatement=new CLabelledStatement(s[0],s[0].label));for(const e of t.body)Q(e,n);return n}function Q(t,i){if(t instanceof e.Declaration)for(const e of R(t,i.scope,!0))i.statements.push(new CExpressionStatement(e.node,e,i));else{const e=W(t,i);i.statements.push(e),void 0!==t.label&&i.scope.labelledStatement?.node===t&&(i.scope.labelledStatement.body=e)}}function J(t){return function(t){const i=new Scope(void 0,L);for(const n of t)n instanceof e.FunctionDefinition?z(n,i):R(n,i,!1);return i}(w(t))}const X='\nstatic const struct Node {\n  enum NodeType {TYPE_A = 3, TYPE_B} type;\n  char tag[8];\n  struct Node* child;\n} myPair = {TYPE_B, "testing"};\n\nint getTag(struct Node *node) {\n  return node->type;\n}\n'.trimStart();let Y=0,Z=new WeakMap;function K(e){let t=Z.get(e);return void 0===t?(t=Y++,Z.set(e,t),[t,!0]):[t,!1]}function ee(e,t,i){const n=document.createElement("li");if(e.appendChild(n),"object"!=typeof i)return void(n.innerHTML=`<span class="key">${t}:</span> ${i}`);const[s,r]=K(i);if(n.classList.add(`objID${s}`),r&&(n.id=`objID${s}`),n.innerHTML=`<span class="key">${t}:</span> <code>${i instanceof CArithmetic?i.typeName:Object.getPrototypeOf(i).constructor.name}</code>`,(!(i instanceof CArithmetic)||i.qualifier)&&(n.innerHTML+=r?` <span class="id">[${s}]</span>`:` <a class="id" href="#objID${s}">${s}</a>`,r)){n.classList.add("expandable"),n.addEventListener("click",(e=>{e.stopPropagation();const t=n.getBoundingClientRect();e.clientX<t.left+20&&e.clientY<t.top+20&&n.classList.toggle("hidden")}));const e=document.createElement("ul");if(n.appendChild(e),i instanceof Map)for(const[t,n]of i.entries())ee(e,t,n);else for(const[t,n]of Object.entries(i))"node"!==t&&ee(e,t,n);0===e.children.length&&(e.remove(),n.classList.remove("expandable"))}}function te(e){const t=window.document.getElementById("identifiers"),i=window.document.getElementById("tags"),n=window.document.getElementById("typedefs"),s=window.document.getElementById("errors");if(!(t&&i&&s&&n))throw new Error("Element not found");let r;t.innerHTML=i.innerText=n.innerText="",Y=0,Z=new WeakMap;try{r=J(e)}catch(e){throw s.innerText=e.toString(),e}s.innerHTML="",K(r);for(const[e,i]of r.identifiers)ee(t,e,i);for(const[e,t]of r.tags)ee(i,e,t);for(const[e,t]of r.typedefs)ee(n,e,t)}if("undefined"!=typeof window&&window.document){window.document.write(`\n        <h1>c2wasm ctree</h1>\n        <div>\n            <textarea id="textInput" rows="20" style="width: 100%; resize: vertical">${X}</textarea>\n\n            <pre id="errors"></pre>\n            <div id="objID0"></div>\n            <h3>Identifiers:</h3>\n            <ul id="identifiers" class="treelist"></ul>\n            <h3>Tags:</h3>\n            <ul id="tags" class="treelist"></ul>\n            <h3>Typedefs:</h3>\n            <ul id="typedefs" class="treelist"></ul>\n        </div>\n\n        <style>\n            ul.treelist {\n                padding: 0;\n            }\n\n            ul.treelist ul {\n              padding-inline-start: 18px;\n              border-left: 1px dashed black;\n              margin-left: 6px;\n            }\n\n            ul.treelist li {\n              list-style-type: none;\n              position: relative;\n            }\n\n            ul.treelist li::before {\n              content: "\\25BB";\n              font-size: 0.8em;\n              color: black;\n              user-select: none;\n              pointer-events: auto;\n              display: inline-block;\n              width: 20px;\n            }\n\n            ul.treelist li.expandable::before {\n              content: "\\25BC";\n              cursor: pointer;\n            }\n\n            ul.treelist li.expandable.hidden::before {\n              content: "\\25B6";\n              transform: none;\n            }\n\n            ul.treelist li.expandable.hidden ul {\n              display: none;\n            }\n        </style>\n    `);const e=window.document.getElementById("textInput");e.addEventListener("input",(()=>te(e.value))),te(e.value)}else console.log(J(X))})()})();
//# sourceMappingURL=ir.js.map